{
  "rules": [
    {
      "id": "bash.curl.security.curl-eval.curl-eval",
      "severity": "WARNING",
      "languages": [
        "bash"
      ],
      "message": "Data is being evaluated from a 'curl' command, creating risk of code injection. If an attacker controls the URL or response, they could execute arbitrary commands on your system. This vulnerability bypasses network boundaries and allows remote code execution through seemingly innocent web requests.",
      "metadata": {
        "owasp": [
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"
        ],
        "category": "security",
        "technology": [
          "bash",
          "curl"
        ],
        "confidence": "MEDIUM",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Code injection via curl command evaluation",
        "fix-suggestion": "Avoid piping `curl` output directly to interpreters like `bash`, `sh`, or `eval`. Instead, download the content to a file first, review it, then execute it separately if needed. Consider using package managers or verified installation methods from trusted sources."
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern": "$(curl ...)\n"
        },
        {
          "pattern": "`curl ...`\n"
        }
      ],
      "pattern-sinks": [
        {
          "pattern": "eval ..."
        }
      ]
    },
    {
      "id": "bash.curl.security.curl-pipe-bash.curl-pipe-bash",
      "languages": [
        "bash"
      ],
      "severity": "WARNING",
      "message": "Data from a 'curl' command is being piped directly to a shell. If an attacker controls the URL or can modify the response, they could execute arbitrary commands on your system. This practice bypasses security checks and allows remote code execution through web requests.",
      "metadata": {
        "owasp": [
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"
        ],
        "category": "security",
        "technology": [
          "bash",
          "curl"
        ],
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Insecure pipe from curl to shell",
        "fix-suggestion": "Avoid piping `curl` output directly to `bash` or other shells. Download scripts to a file first, verify their contents, then execute them separately. Use package managers or other secure installation methods from trusted sources when possible."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "curl ... | ... bash ..."
            },
            {
              "pattern": "curl ... | ... /bin/bash ..."
            },
            {
              "pattern": "... bash <(curl ...)"
            },
            {
              "pattern": "... /bin/bash <(curl ...)"
            },
            {
              "pattern": "... bash -c \"$(curl ...)\""
            },
            {
              "pattern": "... /bin/bash -c \"$(curl ...)\""
            }
          ]
        }
      ]
    },
    {
      "id": "bash.lang.security.ifs-tampering.ifs-tampering",
      "languages": [
        "bash"
      ],
      "severity": "WARNING",
      "message": "Changing the IFS (Internal Field Separator) variable globally alters how string splitting works throughout your script, potentially causing unexpected behavior in commands that rely on default field separation. This can lead to command injection vulnerabilities as arguments may not be properly separated. Limit IFS changes to specific command scope using local assignment to prevent widespread impact.",
      "pattern": "IFS=...",
      "metadata": {
        "cwe": [
          "CWE-20: Improper Input Validation"
        ],
        "category": "security",
        "technology": [
          "bash"
        ],
        "confidence": "LOW",
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "Insecure IFS manipulation can break shell command parsing",
        "fix-suggestion": "Protect against IFS tampering by restricting changes to the smallest scope. Use `local IFS=\",\"` inside functions or temporary storage with `OLD_IFS=\"$IFS\"; IFS=\",\"; command; IFS=\"$OLD_IFS\"`. Consider safer alternatives like `cut`, `awk`, or `sed` for field separation instead of relying on `IFS`."
      }
    },
    {
      "id": "c.lang.security.insecure-use-gets-fn.insecure-use-gets-fn",
      "pattern": "gets(...)",
      "message": "The 'gets()' function is being used without checking buffer boundaries, which can lead to buffer overflows. This vulnerability allows attackers to write beyond allocated memory, potentially executing arbitrary code. Buffer overflows are a common source of security vulnerabilities in C programs.",
      "metadata": {
        "cwe": [
          "CWE-676: Use of Potentially Dangerous Function"
        ],
        "references": [
          "https://us-cert.cisa.gov/bsi/articles/knowledge/coding-practices/fgets-and-gets_s"
        ],
        "category": "security",
        "technology": [
          "c"
        ],
        "confidence": "MEDIUM",
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Dangerous Method or Function"
        ],
        "short-description": "Buffer overflow risk from using gets()",
        "fix-suggestion": "Replace `gets()` with `fgets()` or `gets_s()` which perform boundary checks. When using `fgets()`, provide a size limit parameter: `fgets(buffer, sizeof(buffer), stdin)`. This ensures input cannot exceed buffer size and prevents buffer overflow attacks."
      },
      "languages": [
        "c"
      ],
      "severity": "ERROR"
    },
    {
      "id": "c.lang.security.insecure-use-scanf-fn.insecure-use-scanf-fn",
      "pattern": "scanf(...)",
      "message": "The 'scanf()' function is being used improperly, which doesn't consider buffer boundaries and can lead to buffer overflows. This can allow attackers to write beyond allocated memory, potentially executing arbitrary code. Improper use of scanf() is a common source of vulnerabilities.",
      "metadata": {
        "cwe": [
          "CWE-676: Use of Potentially Dangerous Function"
        ],
        "references": [
          "http://sekrit.de/webdocs/c/beginners-guide-away-from-scanf.html"
        ],
        "category": "security",
        "technology": [
          "c"
        ],
        "confidence": "LOW",
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Dangerous Method or Function"
        ],
        "short-description": "Buffer overflow risk from improper scanf() use",
        "fix-suggestion": "Replace `scanf()` with `fgets()` for reading input, then parse the string safely. Use format specifiers with field width limits like `scanf(\"%99s\", buffer)` if you must use `scanf()`. Always ensure buffer sizes are respected to prevent overflow attacks."
      },
      "languages": [
        "c"
      ],
      "severity": "WARNING"
    },
    {
      "id": "c.lang.security.insecure-use-strtok-fn.insecure-use-strtok-fn",
      "pattern": "strtok(...)",
      "message": "The 'strtok()' function is being used, which directly modifies the first argument buffer and permanently erases delimiter characters. This function is not thread-safe and can cause unexpected behavior in multithreaded applications. It can also lead to potential buffer overflows if not used correctly.",
      "metadata": {
        "cwe": [
          "CWE-676: Use of Potentially Dangerous Function"
        ],
        "references": [
          "https://wiki.sei.cmu.edu/confluence/display/c/STR06-C.+Do+not+assume+that+strtok%28%29+leaves+the+parse+string+unchanged",
          "https://man7.org/linux/man-pages/man3/strtok.3.html#BUGS",
          "https://stackoverflow.com/a/40335556"
        ],
        "category": "security",
        "technology": [
          "c"
        ],
        "confidence": "LOW",
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Dangerous Method or Function"
        ],
        "short-description": "Thread safety issue with strtok() function",
        "fix-suggestion": "Replace `strtok()` with the thread-safe `strtok_r()` function. Use `strtok_r(str, delim, &saveptr)` which requires an additional state parameter to maintain position context. This prevents race conditions in multithreaded environments and improves code reliability."
      },
      "languages": [
        "c"
      ],
      "severity": "WARNING"
    },
    {
      "id": "c.lang.security.random-fd-exhaustion.random-fd-exhaustion",
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern": "$FD = open(\"/dev/urandom\", ...);\n...\nread($FD, ...);\n"
            },
            {
              "pattern-not": "$FD = open(\"/dev/urandom\", ...);\n...\n$BYTES_READ = read($FD, ...);\n"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern": "$FD = open(\"/dev/random\", ...);\n...\nread($FD, ...);\n"
            },
            {
              "pattern-not": "$FD = open(\"/dev/random\", ...);\n...\n$BYTES_READ = read($FD, ...);\n"
            }
          ]
        }
      ],
      "message": "The code calls 'read()' without error checking, making it susceptible to file descriptor exhaustion. If attackers can cause this function to fail, it may result in unpredictable behavior or denial of service. This vulnerability affects application reliability and security.",
      "metadata": {
        "cwe": [
          "CWE-774: Allocation of File Descriptors or Handles Without Limits or Throttling"
        ],
        "references": [
          "https://lwn.net/Articles/606141/"
        ],
        "category": "security",
        "technology": [
          "c"
        ],
        "confidence": "MEDIUM",
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Denial-of-Service (DoS)"
        ],
        "short-description": "Missing error checking in read() call",
        "fix-suggestion": "Add error checking when calling `read()` to handle file descriptor exhaustion. Consider using the `getrandom()` function instead, which is designed for secure random number generation. Always verify return values to ensure proper error handling and system resilience."
      },
      "languages": [
        "c"
      ],
      "severity": "WARNING"
    },
    {
      "id": "clojure.lang.security.documentbuilderfactory-xxe.documentbuilderfactory-xxe",
      "languages": [
        "clojure"
      ],
      "severity": "ERROR",
      "metadata": {
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "asvs": {
          "section": "V5 Validation, Sanitization and Encoding",
          "control_id": "5.5.2 Insecue XML Deserialization",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention",
          "version": "4"
        },
        "references": [
          "https://semgrep.dev/blog/2022/xml-security-in-java",
          "https://semgrep.dev/docs/cheat-sheets/java-xxe/",
          "https://xerces.apache.org/xerces2-j/features.html"
        ],
        "source-rule-url": "https://github.com/clj-holmes/clj-holmes-rules/blob/main/security/xxe-clojure-xml/xxe-clojure-xml.yml",
        "category": "security",
        "technology": [
          "clojure",
          "xml"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "Unprotected XML parser susceptible to XXE attacks",
        "fix-suggestion": "Prevent XXE attacks by configuring `DocumentBuilderFactory` to disable DOCTYPE processing. Set security features like `.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true)` or disable external entities with `.setFeature(\"http://xml.org/sax/features/external-general-entities\", false)`. Add further protection with `.setXIncludeAware(false)` and `.setExpandEntityReferences(false)`."
      },
      "message": "When XML parsers allow DOCTYPE declarations, attackers can craft malicious XML files that access local files or external resources through XXE (XML External Entity) attacks. These attacks can lead to sensitive data disclosure, server-side request forgery, or denial of service. Protect your application by disabling DOCTYPE processing or external entity resolution in your XML parser configuration.",
      "patterns": [
        {
          "pattern-inside": "(ns ... (:require [clojure.xml :as ...]))\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "(def ... ... ( ... ))\n"
            },
            {
              "pattern-inside": "(defn ... ... ( ... ))\n"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern": "(clojure.xml/parse $INPUT)"
            },
            {
              "patterns": [
                {
                  "pattern-inside": "(doto (javax.xml.parsers.SAXParserFactory/newInstance) ...)\n"
                },
                {
                  "pattern": "(.setFeature \"http://apache.org/xml/features/disallow-doctype-decl\" false)"
                },
                {
                  "pattern-not-inside": "(doto (javax.xml.parsers.SAXParserFactory/newInstance)\n  ...\n  (.setFeature \"http://xml.org/sax/features/external-general-entities\" false)\n  ...\n  (.setFeature \"http://xml.org/sax/features/external-parameter-entities\" false)\n  ...)\n"
                },
                {
                  "pattern-not-inside": "(doto (javax.xml.parsers.SAXParserFactory/newInstance)\n  ...\n  (.setFeature \"http://xml.org/sax/features/external-parameter-entities\" false)\n  ...\n  (.setFeature \"http://xml.org/sax/features/external-general-entities\" false)\n  ...)\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "clojure.lang.security.use-of-md5.use-of-md5",
      "languages": [
        "clojure"
      ],
      "severity": "WARNING",
      "message": "MD5 hash algorithm is being used, which is not collision resistant. Attackers can create different inputs that produce the same hash, undermining verification systems. MD5 should never be used for password storage or security-critical applications.",
      "metadata": {
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html",
          "https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html"
        ],
        "technology": [
          "clojure"
        ],
        "source-rule-url": "https://github.com/clj-holmes/clj-holmes-rules/blob/main/security/weak-hash-function-md5.yml",
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-328: Use of Weak Hash"
        ],
        "author": "Gabriel Marquet <gab.marquet@gmail.com>",
        "category": "security",
        "subcategory": [
          "vuln"
        ],
        "confidence": "HIGH",
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Hashing Algorithm"
        ],
        "short-description": "Weak MD5 hashing algorithm detected",
        "fix-suggestion": "Replace MD5 with a modern, secure hashing algorithm. Use current recommended algorithms like `SHA-256`, `SHA-512`, or `PBKDF2` with proper salting for password hashing. For password storage specifically, use specialized password hashing functions like `bcrypt` or `Argon2`."
      },
      "pattern-either": [
        {
          "pattern": "(MessageDigest/getInstance \"MD5\")"
        },
        {
          "pattern": "(MessageDigest/getInstance MessageDigestAlgorithms/MD5)"
        },
        {
          "pattern": "(MessageDigest/getInstance org.apache.commons.codec.digest.MessageDigestAlgorithms/MD5)"
        },
        {
          "pattern": "(java.security.MessageDigest/getInstance \"MD5\")"
        },
        {
          "pattern": "(java.security.MessageDigest/getInstance MessageDigestAlgorithms/MD5)"
        },
        {
          "pattern": "(java.security.MessageDigest/getInstance org.apache.commons.codec.digest.MessageDigestAlgorithms/MD5)"
        }
      ]
    },
    {
      "id": "clojure.lang.security.use-of-sha1.use-of-sha1",
      "languages": [
        "clojure"
      ],
      "severity": "WARNING",
      "message": "SHA1 hash algorithm is being used, which is no longer considered secure. SHA1 is not collision resistant, making it unsuitable for cryptographic signatures or other security applications. Attackers can potentially create colliding documents to bypass verification systems.",
      "metadata": {
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html",
          "https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html"
        ],
        "technology": [
          "clojure"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm",
          "CWE-328: Use of Weak Hash"
        ],
        "category": "security",
        "subcategory": [
          "vuln"
        ],
        "confidence": "HIGH",
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues",
          "Insecure Hashing Algorithm"
        ],
        "short-description": "Insecure SHA1 hash algorithm detected",
        "fix-suggestion": "Replace SHA1 with more secure hash algorithms like `SHA-256` or `SHA-512`. For password hashing specifically, use specialized functions like `PBKDF2`, `bcrypt`, or `Argon2` that provide better protection against brute force attacks."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "(MessageDigest/getInstance $ALGO)"
            },
            {
              "pattern": "(java.security.MessageDigest/getInstance $ALGO)"
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$ALGO",
            "regex": "(((org\\.apache\\.commons\\.codec\\.digest\\.)?MessageDigestAlgorithms/)?\"?(SHA-1|SHA1)\"?)"
          }
        }
      ]
    },
    {
      "id": "csharp.dotnet.security.mvc-missing-antiforgery.mvc-missing-antiforgery",
      "message": "State-changing MVC methods without proper security measures like antiforgery tokens are vulnerable to Cross-Site Request Forgery (CSRF) attacks. Attackers can craft malicious websites that trick authenticated users into submitting unwanted requests to your application. Implement antiforgery tokens or strict content type validation to ensure requests originate from legitimate sources.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "category": "security",
        "cwe": [
          "CWE-352: Cross-Site Request Forgery (CSRF)"
        ],
        "cwe2021-top25": true,
        "cwe2022-top25": true,
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html#cross-site-request-forgery",
          "https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests"
        ],
        "subcategory": [
          "audit"
        ],
        "technology": [
          ".net",
          "mvc"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site Request Forgery (CSRF)"
        ],
        "short-description": "Lack of CSRF tokens on modifying MVC requests",
        "fix-suggestion": "Secure your MVC application by adding the `[ValidateAntiForgeryToken]` attribute to all state-changing action methods. Include `@Html.AntiForgeryToken()` helper in your Razor views to generate the required token. For API endpoints, consider implementing `[Consumes(\"application/json\")]` with token validation or create a custom authorization filter for AJAX requests."
      },
      "languages": [
        "csharp"
      ],
      "patterns": [
        {
          "pattern": "[$HTTPMETHOD]\npublic IActionResult $METHOD(...){\n    ...\n}\n"
        },
        {
          "pattern-inside": "using Microsoft.AspNetCore.Mvc;\n...\n"
        },
        {
          "pattern-not": "[ValidateAntiForgeryToken]\npublic IActionResult $METHOD(...){\n    ...\n}\n"
        },
        {
          "pattern-not": "[Consumes(...)]\npublic IActionResult $METHOD(...){\n  ...\n}\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$HTTPMETHOD",
            "regex": "Http(Post|Put|Delete|Patch)"
          }
        }
      ]
    },
    {
      "id": "csharp.dotnet.security.net-webconfig-debug.net-webconfig-debug",
      "message": "ASP.NET applications with 'debug' set to true in production can leak sensitive debugging information to attackers. Debug mode also negatively impacts performance and reliability. Exposing debug information can reveal implementation details that help attackers exploit other vulnerabilities.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "category": "security",
        "cwe": [
          "CWE-11: ASP.NET Misconfiguration: Creating Debug Binary"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "references": [
          "https://web.archive.org/web/20190919105353/https://blogs.msdn.microsoft.com/prashant_upadhyay/2011/07/14/why-debugfalse-in-asp-net-applications-in-production-environment/",
          "https://msdn.microsoft.com/en-us/library/e8z01xdh.aspx"
        ],
        "subcategory": [
          "audit"
        ],
        "technology": [
          ".net"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Active Debug Code"
        ],
        "short-description": "ASP.NET debug mode enabled in production",
        "fix-suggestion": "Set `debug` to `false` or remove it from the `<compilation ... />` element in your web.config file for production environments. Use configuration transforms to maintain different settings between development and production. Never deploy applications with debug mode enabled."
      },
      "languages": [
        "generic"
      ],
      "paths": {
        "include": [
          "*web.config*"
        ]
      },
      "patterns": [
        {
          "pattern": "<compilation ... debug = \"true\" ... />\n"
        },
        {
          "pattern-inside": "<system.web>\n  ...\n</system.web>\n"
        }
      ]
    },
    {
      "id": "csharp.dotnet.security.net-webconfig-trace-enabled.net-webconfig-trace-enabled",
      "message": "Tracing is enabled in this ASP.NET application, which can leak sensitive application information to attackers. According to OWASP guidelines, tracing should be disabled in production applications. Exposed trace information can reveal implementation details that help attackers exploit other vulnerabilities.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "category": "security",
        "cwe": [
          "CWE-1323: Improper Management of Sensitive Trace Data"
        ],
        "owasp": "A05:2021 - Security Misconfiguration",
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/DotNet_Security_Cheat_Sheet.html#asp-net-web-forms-guidance",
          "https://msdn.microsoft.com/en-us/library/e8z01xdh.aspx"
        ],
        "subcategory": [
          "audit"
        ],
        "technology": [
          ".net"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Insecure tracing enabled in ASP.NET application",
        "fix-suggestion": "Disable tracing for production applications by setting `<trace enabled=\"false\"/>` in your web.config file. Use configuration transforms to maintain different settings between development and production environments. Remove or disable any custom trace implementations in production code."
      },
      "languages": [
        "generic"
      ],
      "paths": {
        "include": [
          "*web.config*"
        ]
      },
      "patterns": [
        {
          "pattern": "<trace ... enabled = \"true\" ... />\n"
        },
        {
          "pattern-inside": "<system.web>\n  ...\n</system.web>\n"
        }
      ]
    },
    {
      "id": "csharp.dotnet.security.razor-template-injection.razor-template-injection",
      "message": "When user-controlled text is passed directly into Razor.Parse, attackers can inject malicious code that will be executed during template rendering. This server-side template injection can lead to remote code execution with the same privileges as the application server. Always sanitize and validate user input before incorporating it into template parsing operations.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "cwe2022-top25": true,
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://clement.notin.org/blog/2020/04/15/Server-Side-Template-Injection-(SSTI)-in-ASP.NET-Razor/"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          ".net",
          "razor",
          "asp"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Template injection risk with user input in Razor",
        "fix-suggestion": "Avoid passing user-supplied input directly to `Razor.Parse` or `RazorEngine` to prevent template injection. Create a template model approach where user input is passed as model properties consumed in predefined templates. If dynamic templates are necessary, validate template content against an allowlist before parsing."
      },
      "languages": [
        "csharp"
      ],
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "focus-metavariable": "$ARG"
            },
            {
              "pattern-inside": "public ActionResult $METHOD(..., string $ARG,...){...}\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "pattern": "Razor.Parse(...)\n"
        }
      ],
      "pattern-sanitizers": [
        {
          "not_conflicting": true,
          "pattern": "$F(...)"
        }
      ]
    },
    {
      "id": "csharp.dotnet.security.use_ecb_mode.use_ecb_mode",
      "message": "The insecure ECB (Electronic Code Book) encryption mode is being used. ECB mode encrypts identical plaintext blocks into identical ciphertext blocks, which reveals patterns in the data. This vulnerability can allow attackers to infer information about the encrypted content.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "category": "security",
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A02:2021 - Cryptographic Failures"
        ],
        "references": [
          "https://learn.microsoft.com/en-gb/dotnet/api/system.security.cryptography.chacha20poly1305?view=net-6.0",
          "https://learn.microsoft.com/en-gb/dotnet/api/system.security.cryptography.aesgcm?view=net-6.0",
          "https://learn.microsoft.com/en-gb/dotnet/api/system.security.cryptography.ciphermode?view=net-6.0",
          "https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#cipher-modes"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          ".net"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Insecure ECB encryption mode detected",
        "fix-suggestion": "Replace ECB mode with an authenticated encryption mode. Use the `AesGcm` or `ChaCha20Poly1305` classes which provide both confidentiality and integrity. If you need compatibility with older frameworks, use CBC mode with proper initialization vectors and add separate message authentication."
      },
      "languages": [
        "csharp"
      ],
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "($KEYTYPE $KEY).EncryptEcb(...);"
            },
            {
              "pattern": "($KEYTYPE $KEY).DecryptEcb(...);"
            },
            {
              "pattern": "($KEYTYPE $KEY).Mode = CipherMode.ECB;"
            }
          ]
        },
        {
          "metavariable-pattern": {
            "metavariable": "$KEYTYPE",
            "pattern-either": [
              {
                "pattern": "SymmetricAlgorithm"
              },
              {
                "pattern": "Aes"
              },
              {
                "pattern": "Rijndael"
              },
              {
                "pattern": "DES"
              },
              {
                "pattern": "TripleDES"
              },
              {
                "pattern": "RC2"
              }
            ]
          }
        }
      ]
    },
    {
      "id": "csharp.dotnet.security.use_weak_rng_for_keygeneration.use_weak_rng_for_keygeneration",
      "message": "An insecure random number generator (System.Random) is being used to create cryptographic keys. This predictable RNG makes keys potentially guessable by attackers. Cryptographic operations require cryptographically strong random numbers to ensure security.",
      "severity": "ERROR",
      "metadata": {
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "category": "security",
        "cwe": [
          "CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)"
        ],
        "owasp": [
          "A02:2021 - Cryptographic Failures"
        ],
        "references": [
          "https://learn.microsoft.com/en-us/dotnet/api/system.random?view=net-6.0#remarks",
          "https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.randomnumbergenerator?view=net-6.0",
          "https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.aesgcm?view=net-6.0#constructors",
          "https://learn.microsoft.com/en-us/dotnet/api/system.security.cryptography.symmetricalgorithm.key?view=net-6.0#system-security-cryptography-symmetricalgorithm-key"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          ".net"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Weak random generator for cryptographic keys",
        "fix-suggestion": "Replace `System.Random` with `System.Security.Cryptography.RandomNumberGenerator` for all cryptographic purposes. Use `RandomNumberGenerator.GetBytes(byte[] data)` to fill byte arrays with cryptographically strong random values. Never use standard random generators for security-sensitive operations."
      },
      "languages": [
        "csharp"
      ],
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-inside": "(System.Random $RNG).NextBytes($KEY); ..."
            },
            {
              "pattern": "$KEY"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern": "($KEYTYPE $CIPHER).Key = $SINK;"
                },
                {
                  "focus-metavariable": "$SINK"
                },
                {
                  "metavariable-pattern": {
                    "metavariable": "$KEYTYPE",
                    "pattern-either": [
                      {
                        "pattern": "SymmetricAlgorithm"
                      },
                      {
                        "pattern": "Aes"
                      },
                      {
                        "pattern": "Rijndael"
                      },
                      {
                        "pattern": "DES"
                      },
                      {
                        "pattern": "TripleDES"
                      },
                      {
                        "pattern": "RC2"
                      }
                    ]
                  }
                }
              ]
            },
            {
              "pattern": "new AesGcm(...)"
            },
            {
              "pattern": "new AesCcm(...)"
            },
            {
              "pattern": "new ChaCha20Poly1305(...)"
            }
          ]
        }
      ]
    },
    {
      "id": "csharp.dotnet.security.web-config-insecure-cookie-settings.web-config-insecure-cookie-settings",
      "message": "The Secure flag for cookies is explicitly disabled in the configuration. This allows sensitive cookie values to be transmitted over unencrypted HTTP connections. Without the Secure flag, cookies containing authentication tokens or session IDs are vulnerable to interception by attackers.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "category": "security",
        "cwe": [
          "CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "references": [
          "https://docs.microsoft.com/en-us/aspnet/web-api/overview/advanced/http-cookies",
          "https://docs.microsoft.com/en-us/dotnet/api/system.web.security.formsauthentication.requiressl?redirectedfrom=MSDN&view=netframework-4.8#System_Web_Security_FormsAuthentication_RequireSSL",
          "https://docs.microsoft.com/en-us/dotnet/api/system.web.security.roles.cookierequiressl?redirectedfrom=MSDN&view=netframework-4.8#System_Web_Security_Roles_CookieRequireSSL"
        ],
        "subcategory": [
          "audit"
        ],
        "technology": [
          ".net",
          "asp",
          "webforms"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cookie Security"
        ],
        "short-description": "Cookie Secure flag explicitly disabled",
        "fix-suggestion": "Enable the Secure flag for cookies by setting `<httpCookies requireSSL=\"true\" ... />` in your web.config file. This ensures cookies are only transmitted over HTTPS connections. Also consider setting the HttpOnly flag to prevent client-side script access to cookies."
      },
      "languages": [
        "generic"
      ],
      "paths": {
        "include": [
          "*web.config"
        ]
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "requireSSL=\"false\"\n"
            },
            {
              "pattern": "cookieRequireSSL=\"false\"\n"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "<httpCookies ...>\n"
            },
            {
              "pattern-inside": "<forms ...>\n"
            },
            {
              "pattern-inside": "<roleManager ...>\n"
            }
          ]
        }
      ]
    },
    {
      "id": "csharp.dotnet.security.audit.mass-assignment.mass-assignment",
      "message": "Autobinding vulnerability exists where attackers can modify object properties they shouldn't have access to. This mass assignment vulnerability allows attackers to create a request that manipulates properties beyond what's intended in the UI. This can lead to privilege escalation or data manipulation.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": [
          "CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes"
        ],
        "owasp": [
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "references": [
          "https://cwe.mitre.org/data/definitions/915.html",
          "https://github.com/OWASP/API-Security/blob/master/2019/en/src/0xa6-mass-assignment.md"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          ".net"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mass Assignment"
        ],
        "short-description": "Mass assignment vulnerability in model binding",
        "fix-suggestion": "Use explicit binding with the `[Bind]` attribute to whitelist only the properties that should be modifiable: `[Bind(\"Property1,Property2\")]`. Alternatively, create dedicated view models (DTOs) that only contain the properties users should modify. Never bind directly to domain models from user input."
      },
      "languages": [
        "csharp"
      ],
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "public IActionResult $METHOD(..., $TYPE $ARG, ...){\n  ...\n}\n"
                },
                {
                  "pattern": "public ActionResult $METHOD(..., $TYPE $ARG, ...){\n  ...\n}\n"
                }
              ]
            },
            {
              "pattern-inside": "using Microsoft.AspNetCore.Mvc;\n...\n"
            },
            {
              "pattern-not": "public IActionResult $METHOD(..., [Bind(...)] $TYPE $ARG, ...){\n  ...\n}\n"
            },
            {
              "pattern-not": "public ActionResult $METHOD(..., [Bind(...)] $TYPE $ARG, ...){\n  ...\n}\n"
            },
            {
              "focus-metavariable": "$ARG"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "pattern": "View(...)"
        }
      ]
    },
    {
      "id": "csharp.lang.security.stacktrace-disclosure.stacktrace-disclosure",
      "patterns": [
        {
          "pattern": "$APP.UseDeveloperExceptionPage(...);"
        },
        {
          "pattern-not-inside": "if ($ENV.IsDevelopment(...)) {\n  ...\n}\n"
        }
      ],
      "message": "Stack trace information is displayed in a non-development environment. Exposing detailed stack traces helps attackers gather information about your application structure and potential vulnerabilities. This information disclosure aids in reconnaissance and targeting specific attack vectors.",
      "metadata": {
        "category": "security",
        "technology": [
          "csharp"
        ],
        "owasp": [
          "A06:2017 - Security Misconfiguration",
          "A04:2021 - Insecure Design"
        ],
        "cwe": [
          "CWE-209: Generation of Error Message Containing Sensitive Information"
        ],
        "references": [
          "https://cwe.mitre.org/data/definitions/209.html",
          "https://owasp.org/Top10/A04_2021-Insecure_Design/"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Sensitive stack trace exposed in production",
        "fix-suggestion": "Implement custom error handling that logs detailed errors internally but displays generic messages to users in production. Use environment-specific configuration to control error detail level, showing full details only in development. Configure proper exception handling middleware that sanitizes error output in production."
      },
      "languages": [
        "csharp"
      ],
      "severity": "WARNING"
    },
    {
      "id": "csharp.lang.security.ad.jwt-tokenvalidationparameters-no-expiry-validation.jwt-tokenvalidationparameters-no-expiry-validation",
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern": "$LIFETIME = $FALSE"
                },
                {
                  "pattern-inside": "new TokenValidationParameters {...}"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern": "(TokenValidationParameters $OPTS). ... .$LIFETIME = $FALSE\n"
                }
              ]
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$LIFETIME",
            "regex": "(RequireExpirationTime|ValidateLifetime)"
          }
        },
        {
          "metavariable-regex": {
            "metavariable": "$FALSE",
            "regex": "(false)"
          }
        },
        {
          "focus-metavariable": "$FALSE"
        }
      ],
      "fix": "true\n",
      "message": "JWT token lifetime validation is disabled. This allows expired JWT tokens to be used indefinitely, creating a significant security risk. Without proper expiration validation, compromised tokens remain valid, allowing attackers continued access to protected resources.",
      "metadata": {
        "category": "security",
        "technology": [
          "csharp"
        ],
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A07:2021 - Identification and Authentication Failures"
        ],
        "cwe": [
          "CWE-613: Insufficient Session Expiration"
        ],
        "references": [
          "https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/",
          "https://cwe.mitre.org/data/definitions/613.html",
          "https://docs.microsoft.com/en-us/dotnet/api/microsoft.identitymodel.tokens.tokenvalidationparameters?view=azure-dotnet"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "JWT token expiration validation disabled",
        "fix-suggestion": "Enable JWT token lifetime validation by removing `TokenValidationParameters.ValidateLifetime = false` or setting it to `true`. Configure reasonable expiration times using the `exp` claim in your tokens. Implement token refresh mechanisms instead of disabling expiration checks."
      },
      "languages": [
        "csharp"
      ],
      "severity": "WARNING"
    },
    {
      "id": "csharp.lang.security.cryptography.x509-subject-name-validation.X509-subject-name-validation",
      "severity": "WARNING",
      "languages": [
        "csharp"
      ],
      "metadata": {
        "cwe": [
          "CWE-295: Improper Certificate Validation"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A07:2021 - Identification and Authentication Failures"
        ],
        "references": [
          "https://docs.microsoft.com/en-us/dotnet/api/system.identitymodel.tokens.issuernameregistry?view=netframework-4.8"
        ],
        "category": "security",
        "technology": [
          ".net"
        ],
        "confidence": "MEDIUM",
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Insecure certificate validation by subject name",
        "fix-suggestion": "Use the `X509Certificate2.Verify()` method instead of subject name validation. Implement proper certificate chain validation including checking trusted root authorities and revocation status. Consider using modern TLS libraries that handle certificate validation correctly by default."
      },
      "message": "Certificates are being validated based on subject name, which is an insecure practice. This validation method doesn't properly verify the certificate chain or check revocation status. This can allow attackers to use fraudulent certificates for man-in-the-middle attacks.",
      "patterns": [
        {
          "pattern-inside": "using System.IdentityModel.Tokens;\n...\n"
        },
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "X509SecurityToken $TOK = $RHS;\n...\n"
                    },
                    {
                      "pattern-inside": "$T $M(..., X509SecurityToken $TOK, ...) {\n    ...\n}\n"
                    }
                  ]
                },
                {
                  "metavariable-pattern": {
                    "metavariable": "$RHS",
                    "pattern-either": [
                      {
                        "pattern": "$T as X509SecurityToken"
                      },
                      {
                        "pattern": "new X509SecurityToken(...)"
                      }
                    ]
                  }
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "X509Certificate2 $CERT = new X509Certificate2(...);\n...\n"
                    },
                    {
                      "pattern-inside": "$T $M(..., X509Certificate2 $CERT, ...) {\n    ...\n}\n"
                    },
                    {
                      "pattern-inside": "foreach (X509Certificate2 $CERT in $COLLECTION) {\n    ...\n}\n"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "String.Equals($NAME, \"...\")"
                },
                {
                  "pattern": "String.Equals(\"...\", $NAME)"
                },
                {
                  "pattern": "$NAME.Equals(\"...\")"
                },
                {
                  "pattern": "$NAME == \"...\""
                },
                {
                  "pattern": "$NAME != \"...\""
                },
                {
                  "pattern": "\"...\" == $NAME\n"
                },
                {
                  "pattern": "\"...\" != $NAME\n"
                }
              ]
            },
            {
              "metavariable-pattern": {
                "metavariable": "$NAME",
                "pattern-either": [
                  {
                    "pattern": "$TOK.Certificate.SubjectName.Name"
                  },
                  {
                    "pattern": "$CERT.SubjectName.Name"
                  },
                  {
                    "pattern": "$CERT.GetNameInfo(...)"
                  }
                ]
              }
            }
          ]
        }
      ]
    },
    {
      "id": "csharp.lang.security.filesystem.unsafe-path-combine.unsafe-path-combine",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "$A"
            },
            {
              "pattern-inside": "Path.Combine(...,$A,...)\n"
            },
            {
              "pattern-inside": "public $TYPE $M(...,$A,...){...}\n"
            },
            {
              "pattern-not-inside": "<... Path.GetFileName($A) != $A ...>\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$X"
            },
            {
              "pattern": "File.$METHOD($X,...)\n"
            },
            {
              "metavariable-regex": {
                "metavariable": "$METHOD",
                "regex": "(?i)^(read|write)"
              }
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "pattern": "Path.GetFileName(...)\n"
        },
        {
          "patterns": [
            {
              "pattern-inside": "$X = Path.GetFileName(...);\n...\n"
            },
            {
              "pattern": "$X"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern": "$X"
            },
            {
              "pattern-inside": "if(<... Path.GetFileName($X) != $X ...>){\n  ...\n  throw new $EXCEPTION(...);\n}\n...\n"
            }
          ]
        }
      ],
      "message": "When unsanitized user input is provided to Path.Combine, attackers can insert path traversal sequences (like '../') to navigate outside intended directories. This can lead to unauthorized access to sensitive files or directories on the server filesystem. Always validate user-supplied path components or use permission-based file access methods to contain file operations to intended areas.",
      "languages": [
        "csharp"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "confidence": "MEDIUM",
        "references": [
          "https://www.praetorian.com/blog/pathcombine-security-issues-in-aspnet-applications/",
          "https://docs.microsoft.com/en-us/dotnet/api/system.io.path.combine?view=net-6.0#remarks"
        ],
        "technology": [
          ".net"
        ],
        "cwe": [
          "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
        ],
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "short-description": "Unsafe path combination enabling unauthorized file access",
        "fix-suggestion": "Validate input before using `Path.Combine` by checking for path traversal sequences like `\"../\"` or `\"..\\\"`. Use `Path.GetFullPath()` on the result and verify it's within the expected directory using `String.StartsWith()`. For stronger protection, use .NET Core's `Path.GetRelativePath()` method to ensure paths remain relative to a specified base directory."
      }
    },
    {
      "id": "csharp.lang.security.http.http-listener-wildcard-bindings.http-listener-wildcard-bindings",
      "severity": "WARNING",
      "languages": [
        "C#"
      ],
      "metadata": {
        "cwe": [
          "CWE-706: Use of Incorrectly-Resolved Name or Reference"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "references": [
          "https://docs.microsoft.com/en-us/dotnet/api/system.net.httplistener?view=net-6.0"
        ],
        "category": "security",
        "technology": [
          ".net"
        ],
        "confidence": "MEDIUM",
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Overly permissive HttpListener network binding",
        "fix-suggestion": "Replace wildcard bindings with specific IP addresses or hostnames. If wildcard binding is necessary, use subdomain wildcards (e.g., `*.example.com`) rather than top-level wildcards. Always implement proper authentication and authorization to secure exposed endpoints regardless of binding."
      },
      "message": "The top-level wildcard binding in HttpListener exposes your application to security vulnerabilities. Using 0.0.0.0 or empty string bindings opens your service on all network interfaces. This gives attackers more control over where traffic is routed and potentially exposes internal services.",
      "patterns": [
        {
          "pattern-inside": "using System.Net;\n...\n"
        },
        {
          "pattern": "$LISTENER.Prefixes.Add(\"$PREFIX\")"
        },
        {
          "metavariable-regex": {
            "metavariable": "$PREFIX",
            "regex": "(http|https)://(\\*|\\+)(.[a-zA-Z]{2,})?:[0-9]+"
          }
        }
      ]
    },
    {
      "id": "csharp.lang.security.injections.os-command.os-command-injection",
      "severity": "ERROR",
      "languages": [
        "csharp"
      ],
      "metadata": {
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/www-community/attacks/Command_Injection"
        ],
        "category": "security",
        "technology": [
          ".net"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Command injection possible through unsanitized external data",
        "fix-suggestion": "Replace string concatenation with the `ProcessStartInfo` class and its arguments collection to prevent OS command injection. Set `ProcessStartInfo.UseShellExecute` to false and `ProcessStartInfo.CreateNoWindow` to true to prevent shell execution. Pass each parameter as separate entries in the `ProcessStartInfo.ArgumentList` collection rather than building a command string with user input."
      },
      "message": "Building OS commands by concatenating unsanitized external data allows attackers to inject additional commands that will be executed with your application's privileges. These injected commands can lead to data theft, system compromise, or complete takeover of the host machine. Always validate and sanitize inputs used in command construction or use safer alternatives that separate command and arguments.",
      "patterns": [
        {
          "pattern-inside": "using System.Diagnostics;\n...\n"
        },
        {
          "pattern-inside": "public $T $F(..., $ARG, ...)\n{\n  ...\n}\n"
        },
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern": "Process.Start($ARG, ...);\n"
                },
                {
                  "focus-metavariable": "$ARG"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-inside": "Process $PROC = new Process();\n...\n"
                },
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "$PROC.StartInfo.FileName = $ARG;\n...\n"
                    },
                    {
                      "pattern-inside": "$PROC.StartInfo.Arguments = <... $ARG ...>;\n...\n"
                    }
                  ]
                },
                {
                  "pattern": "$PROC.Start();\n"
                }
              ]
            },
            {
              "patterns": [
                {
                  "patterns": [
                    {
                      "pattern-inside": "ProcessStartInfo $PSINFO = new ProcessStartInfo()\n{\n  ...\n};\n...\n"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "FileName = $ARG;\n...\n"
                        },
                        {
                          "pattern-inside": "Arguments = <... $ARG ...>;\n...\n"
                        }
                      ]
                    }
                  ]
                },
                {
                  "pattern": "Process.Start($PSINFO);\n"
                },
                {
                  "focus-metavariable": "$PSINFO"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-inside": "Process $PROC = new Process()\n{\n  StartInfo = new ProcessStartInfo()\n  {\n    ...\n  }\n};\n...\n"
                },
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "FileName = $ARG;\n...\n"
                    },
                    {
                      "pattern-inside": "Arguments = $ARG;\n...\n"
                    }
                  ]
                },
                {
                  "pattern": "$PROC.Start();\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "csharp.lang.security.insecure-deserialization.data-contract-resolver.data-contract-resolver",
      "severity": "WARNING",
      "languages": [
        "C#"
      ],
      "metadata": {
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "references": [
          "https://docs.microsoft.com/en-us/dotnet/standard/serialization/binaryformatter-security-guide"
        ],
        "category": "security",
        "technology": [
          ".net"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "Untrusted DataContractResolver can allow malicious object injection",
        "fix-suggestion": "Enhance security by replacing `DataContractResolver` with a custom `ContractResolver` implementation that explicitly defines allowed types. Create a whitelist-based resolver that checks type names against a predefined list of safe types before deserialization. Set the `MaxItemsInObjectGraph` property to a reasonable value to prevent DoS attacks and wrap operations in try-catch blocks."
      },
      "message": "DataContractResolver allows mapping between types during deserialization without strict verification of what's being deserialized, enabling attackers to inject malicious object graphs. When deserializing data from untrusted sources, this can lead to remote code execution through type confusion or gadget chains. Only use DataContractResolver with fully trusted data sources or implement strict type filtering.",
      "patterns": [
        {
          "pattern": "class $MYDCR : DataContractResolver { ... }\n"
        }
      ]
    },
    {
      "id": "csharp.lang.security.insecure-deserialization.insecure-typefilterlevel-full.insecure-typefilterlevel-full",
      "severity": "WARNING",
      "languages": [
        "C#"
      ],
      "metadata": {
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "references": [
          "https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.typefilterlevel?view=net-6.0",
          "https://www.synacktiv.com/en/publications/izi-izi-pwn2own-ics-miami.html"
        ],
        "category": "security",
        "technology": [
          ".net"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "Insecure .NET remoting type filtering allows remote code execution",
        "fix-suggestion": "Replace .NET Remoting with Windows Communication Foundation (WCF) or ASP.NET Web API for stronger security boundaries. If migration isn't immediately possible, set `TypeFilterLevel` to Low and implement a custom `SerializationBinder` to restrict deserializable types. Plan for complete replacement as .NET Remoting contains fundamental security flaws."
      },
      "message": "Using .NET remoting with TypeFilterLevel set to Full allows deserialization of all types, which attackers can exploit to create malicious object graphs that execute arbitrary code. This vulnerability persists even with type filtering enabled because certain deserialization paths bypass these controls. Migrate to more secure communication frameworks like Windows Communication Foundation (WCF) that provide better protection against deserialization attacks.",
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "new BinaryServerFormatterSinkProvider { TypeFilterLevel = $LEVEL }"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$TYPE $SP = new BinaryServerFormatterSinkProvider(...);\n...\n"
                    },
                    {
                      "pattern": "$SP.TypeFilterLevel = $LEVEL\n"
                    }
                  ]
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$LEVEL",
                "regex": "(.*)TypeFilterLevel\\.(Full|Low)"
              }
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$DICT[\"typeFilterLevel\"] = $VAL;\n...\n"
            },
            {
              "pattern": "new BinaryServerFormatterSinkProvider(..., $DICT, ...)"
            },
            {
              "metavariable-regex": {
                "metavariable": "$VAL",
                "regex": "(\\\"Full\\\"|\\\"Low\\\")"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "csharp.lang.security.insecure-deserialization.binary-formatter.insecure-binaryformatter-deserialization",
      "severity": "WARNING",
      "languages": [
        "C#"
      ],
      "metadata": {
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "references": [
          "https://docs.microsoft.com/en-us/dotnet/standard/serialization/binaryformatter-security-guide"
        ],
        "category": "security",
        "technology": [
          ".net"
        ],
        "confidence": "HIGH",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "BinaryFormatter usage can enable arbitrary code execution",
        "fix-suggestion": "Stop using the insecure `BinaryFormatter` and replace it with safer alternatives like `System.Text.Json` or `Newtonsoft.Json`. For communication between trusted endpoints, consider Protocol Buffers, MessagePack, or similar format-specific serializers. If temporary maintenance is required, implement `SerializationBinder` to restrict deserializable types while planning complete removal."
      },
      "message": "BinaryFormatter deserializes the entire object graph with full type fidelity, allowing attackers to craft serialized data that executes malicious code during deserialization. This fundamental design flaw cannot be mitigated through filtering or validation techniques. Microsoft has deprecated BinaryFormatter as inherently unsafe - transition away from it as quickly as possible toward safer serialization alternatives.",
      "patterns": [
        {
          "pattern-inside": "using System.Runtime.Serialization.Formatters.Binary;\n...\n"
        },
        {
          "pattern": "new BinaryFormatter();\n"
        }
      ]
    },
    {
      "id": "csharp.lang.security.insecure-deserialization.fast-json.insecure-fastjson-deserialization",
      "severity": "WARNING",
      "languages": [
        "C#"
      ],
      "metadata": {
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "references": [
          "https://github.com/mgholam/fastJSON#security-warning-update"
        ],
        "category": "security",
        "technology": [
          ".net"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "Unsafe fast-json $type usage can enable code execution",
        "fix-suggestion": "Secure your JSON.NET configuration by disabling the `$type` extension with `settings.TypeNameHandling = TypeNameHandling.None`. If type specification is required, implement a custom `SerializationBinder` that validates type names against an explicit allowlist of safe types. Set `settings.MaxDepth` to limit object graph complexity and prevent stack overflow attacks."
      },
      "message": "The $type extension in fast-json allows specifying the exact type to deserialize into, which can be exploited to instantiate dangerous types that execute code during initialization. When processing untrusted data, attackers can use this feature to trigger remote code execution through deserialization gadgets. Only use the $type extension with JSON from fully trusted sources where the exact type structure is known and verified.",
      "patterns": [
        {
          "pattern-inside": "using fastJSON;\n...\n"
        },
        {
          "pattern": "new JSONParameters\n{\n  BadListTypeChecking = false\n}\n"
        }
      ]
    },
    {
      "id": "csharp.lang.security.insecure-deserialization.fs-pickler.insecure-fspickler-deserialization",
      "severity": "WARNING",
      "languages": [
        "C#"
      ],
      "metadata": {
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "references": [
          "https://mbraceproject.github.io/FsPickler/tutorial.html#Disabling-Subtype-Resolution"
        ],
        "category": "security",
        "technology": [
          ".net"
        ],
        "confidence": "MEDIUM",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "FsPickler allows potential code execution via untrusted data",
        "fix-suggestion": "Secure `FsPickler` by implementing custom surrogates and type verification to restrict deserializable types. Create a custom `IPicklerResolver` that validates types against an allowlist before deserialization and register it using the `WithResolver` method. Consider switching to format-specific serializers for untrusted data sources that don't support arbitrary type instantiation."
      },
      "message": "FsPickler performs type-preserving serialization that faithfully reconstructs objects with their original type metadata, allowing attackers to craft malicious payloads that execute during deserialization. When consuming external data, this can lead to remote code execution by instantiating harmful types with destructive side effects. Avoid using FsPickler with untrusted input or implement custom surrogates and type verification.",
      "patterns": [
        {
          "pattern-inside": "using MBrace.FsPickler.Json;\n...\n"
        },
        {
          "pattern": "FsPickler.CreateJsonSerializer();\n"
        }
      ]
    },
    {
      "id": "csharp.lang.security.insecure-deserialization.javascript-serializer.insecure-javascriptserializer-deserialization",
      "severity": "ERROR",
      "languages": [
        "C#"
      ],
      "metadata": {
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "references": [
          "https://docs.microsoft.com/en-us/dotnet/api/system.web.script.serialization.simpletyperesolver?view=netframework-4.8#remarks"
        ],
        "category": "security",
        "technology": [
          ".net"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "SimpleTypeResolver usage may enable malicious code injection",
        "fix-suggestion": "Eliminate deserialization vulnerabilities by replacing `SimpleTypeResolver` with a custom type resolver that validates against an allowlist. Better yet, switch to `System.Text.Json` or `Newtonsoft.Json` with `TypeNameHandling` set to None. If dynamic type resolution is necessary, implement a type-mapping dictionary in your code rather than allowing direct type specification in serialized data."
      },
      "message": "SimpleTypeResolver enables JavaScriptSerializer to deserialize any type specified in the JSON payload, allowing attackers to instantiate dangerous types with harmful initialization logic. This capability can be exploited to execute arbitrary code on the server through deserialization gadget chains. Avoid using SimpleTypeResolver with untrusted data or switch to safer JSON processing libraries with strict type controls.",
      "patterns": [
        {
          "pattern-inside": "using System.Web.Script.Serialization;\n...\n"
        },
        {
          "pattern": "new JavaScriptSerializer((SimpleTypeResolver $RESOLVER))\n"
        }
      ]
    },
    {
      "id": "csharp.lang.security.insecure-deserialization.los-formatter.insecure-losformatter-deserialization",
      "severity": "WARNING",
      "languages": [
        "C#"
      ],
      "metadata": {
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "references": [
          "https://docs.microsoft.com/en-us/dotnet/api/system.web.ui.losformatter?view=netframework-4.8"
        ],
        "category": "security",
        "technology": [
          ".net"
        ],
        "confidence": "MEDIUM",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "LosFormatter can lead to code execution from untrusted input",
        "fix-suggestion": "Eliminate insecure deserialization by replacing `LosFormatter` with safer serialization mechanisms. For view state or control state, use ASP.NET's built-in protections with appropriate `machineKey` validation and `ViewStateUserKey` settings. For general data serialization, switch to `System.Text.Json` or `Newtonsoft.Json` with `TypeNameHandling.None`."
      },
      "message": "LosFormatter uses insecure deserialization internally when reconstructing objects from a string representation, making it vulnerable to malicious payloads that execute code during deserialization. Attackers can craft inputs that leverage gadget chains to achieve remote code execution on your server. Avoid using LosFormatter entirely, especially with data from untrusted sources.",
      "patterns": [
        {
          "pattern-inside": "using System.Web.UI;\n...\n"
        },
        {
          "pattern": "new LosFormatter();\n"
        }
      ]
    },
    {
      "id": "csharp.lang.security.insecure-deserialization.net-data-contract.insecure-netdatacontract-deserialization",
      "severity": "WARNING",
      "languages": [
        "C#"
      ],
      "metadata": {
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "references": [
          "https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.netdatacontractserializer?view=netframework-4.8#security"
        ],
        "category": "security",
        "technology": [
          ".net"
        ],
        "confidence": "MEDIUM",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "NetDataContractSerializer can be exploited for remote code execution",
        "fix-suggestion": "Replace unsafe `NetDataContractSerializer` with `DataContractSerializer` which only deserializes explicitly allowed types. Use the constructor overload that accepts a list of known types: `new DataContractSerializer(typeof(RootType), new Type[] { typeof(AllowedType1), typeof(AllowedType2) })`. Set the `MaxItemsInObjectGraph` property to a reasonable value to prevent DoS attacks."
      },
      "message": "NetDataContractSerializer includes full type information during serialization and attempts to recreate exact types during deserialization, which attackers can exploit to instantiate dangerous types. This behavior enables remote code execution through carefully crafted payloads that trigger harmful initialization code or leverage gadget chains. Avoid using NetDataContractSerializer with untrusted data and prefer DataContractSerializer which limits deserialization to explicitly allowed types.",
      "patterns": [
        {
          "pattern-inside": "using System.Runtime.Serialization;\n...\n"
        },
        {
          "pattern": "new NetDataContractSerializer();\n"
        }
      ]
    },
    {
      "id": "csharp.lang.security.insecure-deserialization.newtonsoft.insecure-newtonsoft-deserialization",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "TypeNameHandling = TypeNameHandling.$TYPEHANDLER"
            },
            {
              "pattern": "$SETTINGS.TypeNameHandling = TypeNameHandling.$TYPEHANDLER;\n...\nJsonConvert.DeserializeObject<$TYPE>(...,$SETTINGS);\n"
            },
            {
              "pattern": "$SETTINGS.TypeNameHandling = TypeNameHandling.$TYPEHANDLER;\n...\nJsonConvert.DeserializeObject(...,$SETTINGS);\n"
            }
          ]
        },
        {
          "pattern-inside": "using Newtonsoft.Json;\n...\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$TYPEHANDLER",
            "regex": "(All|Auto|Objects|Arrays)"
          }
        }
      ],
      "message": "Certain TypeNameHandling settings in Newtonsoft.Json include type information in the serialized output and use it during deserialization, allowing attackers to specify arbitrary types. This capability can be exploited to instantiate dangerous types that execute code during initialization or leverage gadget chains. Set TypeNameHandling to None when deserializing untrusted data or implement a custom SerializationBinder to restrict allowable types.",
      "languages": [
        "csharp"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "references": [
          "https://www.newtonsoft.com/json/help/html/T_Newtonsoft_Json_TypeNameHandling.htm#remarks"
        ],
        "technology": [
          ".net",
          "newtonsoft",
          "json"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "Insecure TypeNameHandling in Newtonsoft.Json can allow code injection",
        "fix-suggestion": "Prevent deserialization attacks by setting `TypeNameHandling` to None in your JSON.NET settings: `settings.TypeNameHandling = TypeNameHandling.None`. If type information is required, implement a custom `SerializationBinder` that checks requested types against an explicit allowlist. Set a reasonable `MaxDepth` value to prevent stack overflow attacks."
      }
    },
    {
      "id": "csharp.lang.security.insecure-deserialization.soap-formatter.insecure-soapformatter-deserialization",
      "severity": "WARNING",
      "languages": [
        "C#"
      ],
      "metadata": {
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "references": [
          "https://docs.microsoft.com/en-us/dotnet/api/system.runtime.serialization.formatters.soap.soapformatter?view=netframework-4.8#remarks"
        ],
        "category": "security",
        "technology": [
          ".net"
        ],
        "confidence": "MEDIUM",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "SoapFormatter is unsafe and can facilitate remote code execution",
        "fix-suggestion": "Eliminate serialization vulnerabilities by replacing `SoapFormatter` with safer alternatives like JSON.NET (with `TypeNameHandling` set to None) or `System.Text.Json`. If temporary maintenance is necessary, implement a custom `SerializationBinder` to restrict deserializable types by creating a class that inherits from `SerializationBinder` and validates against an allowlist."
      },
      "message": "SoapFormatter performs deserialization with full type fidelity without restrictions, enabling attackers to craft malicious payloads that instantiate dangerous types. When processing external data, this can lead to remote code execution through initialization logic or known gadget chains. Avoid using SoapFormatter entirely as it lacks security features to make it safe for processing untrusted data.",
      "patterns": [
        {
          "pattern-inside": "using System.Runtime.Serialization.Formatters.Soap;\n...\n"
        },
        {
          "pattern": "new SoapFormatter();\n"
        }
      ]
    },
    {
      "id": "csharp.lang.security.memory.memory-marshal-create-span.memory-marshal-create-span",
      "severity": "WARNING",
      "languages": [
        "C#"
      ],
      "metadata": {
        "cwe": [
          "CWE-125: Out-of-bounds Read"
        ],
        "owasp": [
          "A04:2021 - Insecure Design"
        ],
        "references": [
          "https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.memorymarshal.createspan?view=net-6.0",
          "https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.memorymarshal.createreadonlyspan?view=net-6.0"
        ],
        "category": "security",
        "technology": [
          ".net"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Memory Issues"
        ],
        "short-description": "Unbounded MemoryMarshal.CreateSpan usage can cause memory issues",
        "fix-suggestion": "Prevent buffer overflows by adding explicit bounds checking before calling `MemoryMarshal.CreateSpan`. Validate that the length parameter doesn't exceed available memory by calculating the maximum possible length: `int maxPossibleLength = checked(sourceMemory.Length - startOffset)`. Consider creating a utility wrapper method that encapsulates these safety checks for consistent bounds validation."
      },
      "message": "MemoryMarshal.CreateSpan functions don't validate the provided length parameter, potentially creating spans that extend beyond the allocated memory bounds. This oversight can lead to reading or writing memory that doesn't belong to the span's intended data, causing memory corruption or sensitive data exposure. Use these functions carefully with validated length values to ensure spans stay within proper memory boundaries.",
      "pattern-either": [
        {
          "pattern": "MemoryMarshal.CreateSpan(...)"
        },
        {
          "pattern": "MemoryMarshal.CreateReadOnlySpan(...)"
        }
      ]
    },
    {
      "id": "csharp.lang.security.regular-expression-dos.regular-expression-dos-infinite-timeout.regular-expression-dos-infinite-timeout",
      "severity": "WARNING",
      "languages": [
        "C#"
      ],
      "metadata": {
        "cwe": [
          "CWE-1333: Inefficient Regular Expression Complexity"
        ],
        "owasp": "A01:2017 - Injection",
        "references": [
          "https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS",
          "https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.infinitematchtimeout",
          "https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.-ctor?view=net-6.0"
        ],
        "category": "security",
        "technology": [
          ".net"
        ],
        "confidence": "MEDIUM",
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Denial-of-Service (DoS)"
        ],
        "short-description": "ReDoS vulnerability from infinite regex timeout",
        "fix-suggestion": "Set a reasonable timeout for regex operations instead of using infinite timeouts. Add a timeout parameter like `new Regex(pattern, options, TimeSpan.FromSeconds(2))` to limit execution time. Use simpler regex patterns that avoid catastrophic backtracking, particularly when processing untrusted input."
      },
      "message": "The regular expression is configured with an infinite timeout, making the system vulnerable to ReDoS (Regular Expression Denial of Service) attacks. Malicious input to regex patterns can cause exponential evaluation time, freezing application threads. This vulnerability can lead to system-wide performance degradation.",
      "patterns": [
        {
          "pattern-inside": "using System.Text.RegularExpressions;\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "new Regex(..., TimeSpan.InfiniteMatchTimeout)"
            },
            {
              "patterns": [
                {
                  "pattern": "new Regex(..., TimeSpan.FromSeconds($TIME))"
                },
                {
                  "metavariable-comparison": {
                    "metavariable": "$TIME",
                    "comparison": "$TIME > 5"
                  }
                }
              ]
            },
            {
              "pattern": "new Regex(..., TimeSpan.FromMinutes(...))"
            },
            {
              "pattern": "new Regex(..., TimeSpan.FromHours(...))"
            }
          ]
        }
      ]
    },
    {
      "id": "csharp.lang.security.regular-expression-dos.regular-expression-dos.regular-expression-dos",
      "severity": "WARNING",
      "languages": [
        "C#"
      ],
      "metadata": {
        "cwe": [
          "CWE-1333: Inefficient Regular Expression Complexity"
        ],
        "owasp": "A01:2017 - Injection",
        "references": [
          "https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS",
          "https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expressions#regular-expression-examples"
        ],
        "category": "security",
        "technology": [
          ".net"
        ],
        "confidence": "MEDIUM",
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Denial-of-Service (DoS)"
        ],
        "short-description": "ReDoS vulnerability from missing regex timeout",
        "fix-suggestion": "Pass a timeout when using `System.Text.RegularExpressions` with untrusted input. Use `new Regex(pattern, options, TimeSpan.FromSeconds(2))` to limit execution time. Consider using regex patterns that avoid backtracking or alternative string parsing methods for performance-critical code."
      },
      "message": "Regular expressions are being used without a timeout to process untrusted input. This makes the application vulnerable to ReDoS (Regular Expression Denial of Service) attacks. Malicious input can cause exponential backtracking, freezing thread execution and degrading system performance.",
      "patterns": [
        {
          "pattern-inside": "using System.Text.RegularExpressions;\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "public $T $F($X)\n{\n  Regex $Y = new Regex($P);\n  ...\n  $Y.Match($X);\n}\n"
            },
            {
              "pattern": "public $T $F($X)\n{\n  Regex $Y = new Regex($P, $O);\n  ...\n  $Y.Match($X);\n}\n"
            },
            {
              "pattern": "public $T $F($X)\n{\n  ... Regex.Match($X, $P);\n}\n"
            },
            {
              "pattern": "public $T $F($X)\n{\n  ... Regex.Match($X, $P, $O);\n}\n"
            }
          ]
        }
      ]
    },
    {
      "id": "csharp.lang.security.sqli.csharp-sqli.csharp-sqli",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "(string $X)\n"
            },
            {
              "pattern-not": "\"...\"\n"
            }
          ]
        }
      ],
      "pattern-propagators": [
        {
          "pattern": "(StringBuilder $B).$ANY(...,(string $X),...)",
          "from": "$X",
          "to": "$B"
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern": "new $PATTERN($CMD,...)\n"
                    },
                    {
                      "focus-metavariable": "$CMD"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "$CMD.$PATTERN = $VALUE;\n"
                    },
                    {
                      "focus-metavariable": "$VALUE"
                    }
                  ]
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$PATTERN",
                "regex": "^(SqlCommand|CommandText|OleDbCommand|OdbcCommand|OracleCommand)$"
              }
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "pattern-either": [
            {
              "pattern": "$CMD.Parameters.add(...)\n"
            },
            {
              "pattern": "$CMD.Parameters[$IDX] = ...\n"
            }
          ],
          "by-side-effect": true
        }
      ],
      "message": "Creating SQL queries by concatenating strings with user input allows attackers to modify the query structure through specially crafted input. This SQL injection vulnerability can lead to unauthorized data access, data manipulation, or even complete database compromise. Use parameterized queries or prepared statements to separate SQL code from data and prevent injection attacks.",
      "metadata": {
        "category": "security",
        "technology": [
          "csharp"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "confidence": "MEDIUM",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "SQL injection risk via string-concatenated queries",
        "fix-suggestion": "Prevent SQL injection by replacing string concatenation with parameterized queries. With ADO.NET, use `SqlCommand` with `SqlParameter` objects: `cmd.Parameters.Add(\"@Username\", SqlDbType.VarChar).Value = username`. When using Entity Framework, use LINQ queries with parameters: `context.Users.Where(u => u.Username == username)` or parameterized raw SQL: `context.Database.ExecuteSqlRaw(\"SELECT * FROM Users WHERE Username = @p0\", username)`."
      },
      "languages": [
        "csharp"
      ],
      "severity": "ERROR"
    },
    {
      "id": "csharp.lang.security.ssrf.http-client.ssrf",
      "severity": "ERROR",
      "languages": [
        "csharp"
      ],
      "metadata": {
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html"
        ],
        "category": "security",
        "technology": [
          ".net"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "SSRF possibility by making unvalidated external requests",
        "fix-suggestion": "Defend against SSRF attacks by implementing URL validation before making outgoing HTTP requests. Create a validation method that checks URLs against an allowlist and rejects requests to internal network ranges (127.0.0.0/8, 10.0.0.0/8, etc.). Configure your `HttpClient` with `AllowAutoRedirect` set to false to prevent redirect-based bypasses."
      },
      "message": "When user input controls the URL in outgoing HTTP requests, attackers can manipulate these requests to target internal services or external systems. This Server-Side Request Forgery (SSRF) vulnerability can lead to internal network scanning, accessing sensitive local services, or abusing trusted relationships. Validate and restrict outgoing request destinations to prevent attackers from redirecting your application's requests.",
      "patterns": [
        {
          "pattern-inside": "using System.Net.Http;\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "$T $F(..., $X, ...)\n{\n...\nHttpClient $Y = new HttpClient();\n...\n... $Y.GetAsync(<... $X ...>, ...);\n}\n"
            },
            {
              "pattern": "$T $F(..., $X, ...)\n{\n...\n$A $B = <... $X ...>;\n...\nHttpClient $Y = new HttpClient();\n...\n... $Y.GetAsync($B, ...);\n}\n"
            },
            {
              "pattern": "$T $F(..., $X, ...)\n{\n...\nHttpClient $Y = new HttpClient();\n...\n... $Y.GetStringAsync(<... $X ...>);\n}\n"
            },
            {
              "pattern": "$T $F(..., $X, ...)\n{\n...\n$A $B = <... $X ...>;\n...\nHttpClient $Y = new HttpClient();\n...\n... $Y.GetStringAsync($B);\n}\n"
            }
          ]
        }
      ]
    },
    {
      "id": "csharp.lang.security.ssrf.rest-client.ssrf",
      "severity": "ERROR",
      "languages": [
        "csharp"
      ],
      "metadata": {
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html"
        ],
        "category": "security",
        "technology": [
          ".net"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "Unvalidated REST client requests enable SSRF attacks",
        "fix-suggestion": "Prevent SSRF attacks by implementing strict URL validation for all REST client destinations. Create a validation method that checks each URL against an explicit allowlist of permitted domains and rejects internal networks (127.0.0.0/8, 10.0.0.0/8, etc.). Configure your REST client to disable automatic redirects or implement redirect validation that re-applies the same checks."
      },
      "message": "When REST client endpoints are influenced by user input, attackers can make your application send requests to unintended network destinations. This Server-Side Request Forgery (SSRF) allows probing internal networks, accessing restricted services, or leveraging your server's trust relationships. Implement strict validation and allowlisting of request destinations to contain where your application can send requests.",
      "patterns": [
        {
          "pattern-inside": "using RestSharp;\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "$T $F(..., $X, ...)\n{\n...\n... new RestClient(<... $X ...>);\n}\n"
            },
            {
              "pattern": "$T $F(..., $X, ...)\n{\n...\n$A $B = <... $X ...>;\n...\n... new RestClient($B);\n}\n"
            }
          ]
        }
      ]
    },
    {
      "id": "csharp.lang.security.ssrf.web-client.ssrf",
      "severity": "ERROR",
      "languages": [
        "csharp"
      ],
      "metadata": {
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html"
        ],
        "category": "security",
        "technology": [
          ".net"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "Web client with user input can facilitate SSRF",
        "fix-suggestion": "Secure `WebClient` requests by implementing strict URL validation against an allowlist of permitted domains. Use `Uri.TryCreate()` to parse URLs safely, then examine the Host and Scheme properties against permitted patterns. Consider creating a custom `WebClient` subclass that overrides `OpenRead` and `DownloadString` methods to apply validation automatically."
      },
      "message": "Processing user-supplied URLs in WebClient requests enables attackers to redirect your application's requests to arbitrary destinations. This Server-Side Request Forgery (SSRF) vulnerability can expose internal systems, bypass firewalls, or trigger actions on services that trust your server. Validate URL destinations against an allowlist before making outbound requests to prevent request redirection attacks.",
      "patterns": [
        {
          "pattern-inside": "using System.Net;\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "$T $F(..., $X, ...)\n{\n...\nWebClient $Y = new WebClient();\n...\n... $Y.OpenRead(<... $X ...>);\n}\n"
            },
            {
              "pattern": "$T $F(..., $X, ...)\n{\n...\n$A $B = <... $X ...>;\n...\nWebClient $Y = new WebClient();\n...\n... $Y.OpenRead($B);\n}\n"
            },
            {
              "pattern": "$T $F(..., $X, ...)\n{\n...\nWebClient $Y = new WebClient();\n...\n... $Y.OpenReadAsync(<... $X ...>, ...);\n}\n"
            },
            {
              "pattern": "$T $F(..., $X, ...)\n{\n...\n$A $B = <... $X ...>;\n...\nWebClient $Y = new WebClient();\n...\n... $Y.OpenReadAsync($B, ...);\n}\n"
            },
            {
              "pattern": "$T $F(..., $X, ...)\n{\n...\nWebClient $Y = new WebClient();\n...\n... $Y.DownloadString(<... $X ...>);\n}\n"
            },
            {
              "pattern": "$T $F(..., $X, ...)\n{\n...\n$A $B = <... $X ...>;\n...\nWebClient $Y = new WebClient();\n...\n... $Y.DownloadString($B);\n}\n"
            }
          ]
        }
      ]
    },
    {
      "id": "csharp.lang.security.ssrf.web-request.ssrf",
      "severity": "ERROR",
      "languages": [
        "csharp"
      ],
      "metadata": {
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "references": [
          "https://cwe.mitre.org/data/definitions/918.html",
          "https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html"
        ],
        "category": "security",
        "technology": [
          ".net"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "URL-based SSRF vulnerability from unvalidated user input",
        "fix-suggestion": "Protect against SSRF by implementing URL validation for all `WebRequest` operations. Create a helper method that checks URLs against an allowlist and rejects requests to internal networks (127.0.0.0/8, 10.0.0.0/8, etc.). Consider using the newer `HttpClient` with validation middleware instead, and disable automatic redirects to prevent bypass attacks."
      },
      "message": "When server-side code fetches URLs containing unsanitized user input, attackers can manipulate those URLs to target internal resources or unauthorized external services. This Server-Side Request Forgery (SSRF) vulnerability can lead to internal network scanning, data exfiltration, or exploitation of trust relationships. Implement strict URL validation and limit request destinations to prevent attackers from controlling where your server sends requests.",
      "patterns": [
        {
          "pattern-inside": "using System.Net;\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "$T $F(..., $X, ...)\n{\n...\n... WebRequest.Create(<... $X ...>);\n}\n"
            },
            {
              "pattern": "$T $F($X)\n{\n...\n$A $B = <... $X ...>;\n...\n... WebRequest.Create($B);\n}\n"
            },
            {
              "pattern": "$T $F($X)\n{\n...\n$A $B = <... $X ...>;\n...\n$C $D = <... $B ...>;\n...\n... WebRequest.Create($D);\n}\n"
            }
          ]
        }
      ]
    },
    {
      "id": "csharp.lang.security.xxe.xmldocument-unsafe-parser-override.xmldocument-unsafe-parser-override",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "focus-metavariable": "$ARG"
            },
            {
              "pattern-inside": "public $T $M(...,string $ARG,...){...}\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$XMLDOCUMENT.$METHOD(...)\n"
            },
            {
              "pattern-inside": "XmlDocument $XMLDOCUMENT = new XmlDocument(...);\n...\n$XMLDOCUMENT.XmlResolver = new XmlUrlResolver(...);\n...  \n"
            }
          ]
        }
      ],
      "message": "Using an XmlReader with DTD processing enabled allows attackers to include external entities in XML documents that can access local files or trigger network requests. This XML External Entity (XXE) vulnerability can lead to sensitive data disclosure, server-side request forgery, or denial of service attacks. Disable DTD processing by setting the ProhibitDtd property to true or using the appropriate XmlReaderSettings configuration.",
      "languages": [
        "csharp"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "references": [
          "https://www.jardinesoftware.net/2016/05/26/xxe-and-net/",
          "https://docs.microsoft.com/en-us/dotnet/api/system.xml.xmldocument.xmlresolver?view=net-6.0#remarks"
        ],
        "technology": [
          ".net",
          "xml"
        ],
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "impact": "MEDIUM",
        "likelihood": "LOW",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "XMLDocument DTD parsing enabled can cause XXE attacks",
        "fix-suggestion": "Secure XML parsing by configuring the `XmlReader` with safe settings before using it with `XmlDocument`. Create an `XmlReaderSettings` object with: `settings.DtdProcessing = DtdProcessing.Prohibit; settings.XmlResolver = null;` and use this to create a secure reader. For newer applications, consider using `XDocument` from `System.Xml.Linq` which has safer defaults."
      }
    },
    {
      "id": "csharp.lang.security.xxe.xmlreadersettings-unsafe-parser-override.xmlreadersettings-unsafe-parser-override",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "focus-metavariable": "$ARG"
            },
            {
              "pattern-inside": "public $T $M(...,string $ARG,...){...}\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "XmlReader $READER = XmlReader.Create(...,$RS,...);\n"
            },
            {
              "pattern-inside": "XmlReaderSettings $RS = new XmlReaderSettings();\n...\n$RS.DtdProcessing = DtdProcessing.Parse;\n...        \n"
            }
          ]
        }
      ],
      "message": "Enabling DTD processing in XmlReaderSettings allows attackers to exploit XML External Entity (XXE) vulnerabilities by including references to external entities in XML input. This can lead to unauthorized file access, server-side request forgery, or denial of service through resource exhaustion. Set DtdProcessing to Prohibit to prevent external entity resolution when processing XML from untrusted sources.",
      "languages": [
        "csharp"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "references": [
          "https://www.jardinesoftware.net/2016/05/26/xxe-and-net/",
          "https://docs.microsoft.com/en-us/dotnet/api/system.xml.xmldocument.xmlresolver?view=net-6.0#remarks"
        ],
        "technology": [
          ".net",
          "xml"
        ],
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "impact": "MEDIUM",
        "likelihood": "LOW",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "XmlReaderSettings with external entities allows XXE vulnerabilities",
        "fix-suggestion": "Prevent XXE attacks by configuring `XmlReaderSettings` to prohibit DTD processing and disable external entity resolution. Apply these settings: `settings.DtdProcessing = DtdProcessing.Prohibit; settings.XmlResolver = null; settings.MaxCharactersFromEntities = 1024; settings.MaxCharactersInDocument = 1048576;`. Create the `XmlReader` using these secure settings: `XmlReader reader = XmlReader.Create(inputStream, settings)`."
      }
    },
    {
      "id": "csharp.lang.security.xxe.xmltextreader-unsafe-defaults.xmltextreader-unsafe-defaults",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "focus-metavariable": "$ARG"
            },
            {
              "pattern-inside": "public $T $M(...,string $ARG,...){...}\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$READER.$METHOD(...)\n"
            },
            {
              "pattern-not-inside": "$READER.DtdProcessing = DtdProcessing.Prohibit;\n...\n"
            },
            {
              "pattern-inside": "XmlTextReader $READER = new XmlTextReader(...);\n...\n"
            }
          ]
        }
      ],
      "message": "XmlTextReader enables DTD processing by default, allowing attackers to include external entity references in XML that can access local files or network resources. This XML External Entity (XXE) vulnerability can lead to information disclosure, server-side request forgery, or denial of service attacks. Explicitly disable DTD processing by setting ProhibitDtd to true when working with untrusted XML data.",
      "languages": [
        "csharp"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "references": [
          "https://www.jardinesoftware.net/2016/05/26/xxe-and-net/",
          "https://docs.microsoft.com/en-us/dotnet/api/system.xml.xmldocument.xmlresolver?view=net-6.0#remarks"
        ],
        "technology": [
          ".net",
          "xml"
        ],
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "impact": "MEDIUM",
        "likelihood": "LOW",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "XmlTextReader defaults enable DTD parsing leading to XXE",
        "fix-suggestion": "Enhance XML security by replacing direct `XmlTextReader` usage with `XmlReader.Create()` which allows explicit security settings. Create an `XmlReaderSettings` object with: `settings.DtdProcessing = DtdProcessing.Prohibit; settings.XmlResolver = null;`. If you must use `XmlTextReader`, explicitly disable DTD processing: `reader.DtdProcessing = DtdProcessing.Prohibit; reader.XmlResolver = null`."
      }
    },
    {
      "id": "csharp.razor.security.html-raw-json.html-raw-json",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "@Html.Raw(Json.Encode(...))"
            },
            {
              "pattern": "@Html.Raw(JsonConvert.SerializeObject(...))"
            },
            {
              "pattern": "@Html.Raw(...ToJson(...))"
            }
          ]
        }
      ],
      "message": "Embedding raw JSON directly into HTML pages without proper encoding creates a cross-site scripting (XSS) vulnerability if the JSON contains values that can break out of the data context. Attackers can craft malicious payloads that, when embedded in JSON, execute as JavaScript in the victim's browser. Always encode JSON properly using HTML encoding before inserting it into an HTML context to prevent script injection.",
      "languages": [
        "generic"
      ],
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "category": "security",
        "technology": [
          "razor"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Unescaped JSON in HTML can lead to XSS",
        "fix-suggestion": "Prevent XSS when embedding JSON in HTML by using proper serialization and encoding techniques. First serialize data using `JsonSerializer.Serialize()` or `JsonConvert.SerializeObject()`, then HTML-encode the result: `<script>const data = @Html.Raw(Json.Encode(Model.JsonData));</script>`. In ASP.NET Core, use the built-in tools: `<script>const data = @json(Model.JsonData);</script>`."
      },
      "paths": {
        "include": [
          "*.cshtml"
        ]
      },
      "severity": "ERROR"
    },
    {
      "id": "dockerfile.security.last-user-is-root.last-user-is-root",
      "patterns": [
        {
          "pattern": "USER root"
        },
        {
          "pattern-not-inside": {
            "patterns": [
              {
                "pattern": "USER root\n...\nUSER $X\n"
              },
              {
                "metavariable-pattern": {
                  "metavariable": "$X",
                  "patterns": [
                    {
                      "pattern-not": "root"
                    }
                  ]
                }
              }
            ]
          }
        }
      ],
      "message": "The container is configured to run as the 'root' user. This is a security risk because an attacker who gains control of the container will have root access to the container environment. Root access increases the impact of vulnerabilities and enables container escape techniques.",
      "severity": "ERROR",
      "languages": [
        "dockerfile"
      ],
      "metadata": {
        "cwe": [
          "CWE-269: Improper Privilege Management"
        ],
        "source-rule-url": "https://github.com/hadolint/hadolint/wiki/DL3002",
        "references": [
          "https://github.com/hadolint/hadolint/wiki/DL3002"
        ],
        "category": "security",
        "technology": [
          "dockerfile"
        ],
        "confidence": "MEDIUM",
        "owasp": [
          "A04:2021 - Insecure Design"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Container running as root user",
        "fix-suggestion": "Add a `USER` instruction at the end of your Dockerfile to specify a non-root user. Create a dedicated user with `RUN useradd -r -s /bin/false myappuser` and then use `USER myappuser`. Ensure your application has appropriate permissions to run as this non-privileged user."
      }
    },
    {
      "id": "dockerfile.security.missing-user-entrypoint.missing-user-entrypoint",
      "patterns": [
        {
          "pattern": "ENTRYPOINT $...VARS\n"
        },
        {
          "pattern-not-inside": "USER $USER\n...\n"
        }
      ],
      "fix": "USER non-root\nENTRYPOINT $...VARS\n",
      "message": "No USER directive is specified for the container's ENTRYPOINT, causing processes to run as 'root' by default. This gives container processes excessive privileges and increases the impact of potential vulnerabilities. If an attacker compromises the container, they effectively have root access.",
      "severity": "ERROR",
      "languages": [
        "dockerfile"
      ],
      "metadata": {
        "cwe": [
          "CWE-269: Improper Privilege Management"
        ],
        "category": "security",
        "technology": [
          "dockerfile"
        ],
        "confidence": "MEDIUM",
        "owasp": [
          "A04:2021 - Insecure Design"
        ],
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Missing USER directive for container entrypoint",
        "fix-suggestion": "Add a `USER` instruction before your `ENTRYPOINT` or `CMD` instruction to specify a non-root user. Create a dedicated user with `RUN useradd -r -s /bin/false myappuser` then set `USER myappuser`. Ensure your application has appropriate permissions to run as this non-privileged user."
      }
    },
    {
      "id": "dockerfile.security.missing-user.missing-user",
      "patterns": [
        {
          "pattern": "CMD $...VARS\n"
        },
        {
          "pattern-not-inside": "USER $USER\n...\n"
        }
      ],
      "fix": "USER non-root\nCMD $...VARS\n",
      "message": "No USER directive is specified in the Dockerfile, causing container processes to run as 'root' by default. Running as root gives container processes excessive privileges and increases the impact of security vulnerabilities. If an attacker compromises the container, they effectively have root access.",
      "severity": "ERROR",
      "languages": [
        "dockerfile"
      ],
      "metadata": {
        "cwe": [
          "CWE-269: Improper Privilege Management"
        ],
        "category": "security",
        "technology": [
          "dockerfile"
        ],
        "confidence": "MEDIUM",
        "owasp": [
          "A04:2021 - Insecure Design"
        ],
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Container runs as root by default",
        "fix-suggestion": "Add a `USER` instruction toward the end of your Dockerfile to specify a non-root user. Create a dedicated user with `RUN useradd -r -s /bin/false myappuser` and then use `USER myappuser`. Ensure your application has appropriate permissions to run as this non-privileged user."
      }
    },
    {
      "id": "dockerfile.security.no-sudo-in-dockerfile.no-sudo-in-dockerfile",
      "patterns": [
        {
          "pattern": "RUN sudo ...\n"
        }
      ],
      "message": "The 'sudo' command is being used in the Dockerfile, which is unnecessary and introduces security risks. Container processes should run with the least privilege required, and sudo undermines this principle. Using sudo creates confusion about the security context and can lead to privilege escalation.",
      "metadata": {
        "category": "security",
        "technology": [
          "dockerfile"
        ],
        "cwe": [
          "CWE-250: Execution with Unnecessary Privileges"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "references": [
          "https://cwe.mitre.org/data/definitions/250.html",
          "https://docs.docker.com/develop/develop-images/dockerfile_best-practices/#user"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Unnecessary sudo usage in Dockerfile",
        "fix-suggestion": "Remove `sudo` commands from your Dockerfile. Use multi-stage builds to perform privileged operations during build, then copy results to a minimal runtime image. Run the container process as a non-root user with `USER` directive to limit privileges without needing sudo."
      },
      "languages": [
        "dockerfile"
      ],
      "severity": "WARNING"
    },
    {
      "id": "dockerfile.security.dockerd-socket-mount.dockerfile-dockerd-socket-mount",
      "message": "The Dockerfile mounts the Docker socket (docker.sock) inside the container, giving container processes access to the Docker daemon. This allows a compromised container to escape isolation and execute arbitrary commands on the host machine. Mounting the Docker socket effectively grants root access to the host.",
      "languages": [
        "dockerfile",
        "yaml"
      ],
      "severity": "ERROR",
      "metadata": {
        "cwe": [
          "CWE-862: Missing Authorization",
          "CWE-269: Improper Privilege Management"
        ],
        "confidence": "HIGH",
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "subcategory": [
          "audit"
        ],
        "technology": [
          "dockerfile"
        ],
        "category": "security",
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html",
          "https://redfoxsec.com/blog/insecure-volume-mounts-in-docker/",
          "https://blog.quarkslab.com/why-is-exposing-the-docker-socket-a-really-bad-idea.html"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Docker socket mount enables container escape",
        "fix-suggestion": "Remove the Docker socket mount (`-v /var/run/docker.sock:/var/run/docker.sock`) from your container configuration. Use more secure alternatives like Docker-out-of-Docker, dedicated build containers, or container orchestration platforms with proper isolation. Never mount the Docker socket in production containers."
      },
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern": "VOLUME $X"
            },
            {
              "metavariable-regex": {
                "metavariable": "$X",
                "regex": "/var/run/docker.sock"
              }
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-regex": "- \"/var/run/docker.sock:.*\""
            },
            {
              "pattern-inside": "volumes:\n  ...\n"
            }
          ]
        }
      ]
    },
    {
      "id": "generic.ci.security.bash-reverse-shell.bash_reverse_shell",
      "metadata": {
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "category": "security",
        "technology": [
          "ci"
        ],
        "confidence": "HIGH",
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Potential bash reverse shell enabling unauthorized remote access",
        "fix-suggestion": "Remove any reverse shell commands from your codebase immediately and investigate for possible compromise. Implement code review processes and automated scanning to detect suspicious patterns in commits. Apply least privilege principles and configure network-level egress filtering to block unauthorized outbound connections."
      },
      "message": "A bash reverse shell command establishes a connection from the target system back to an attacker-controlled server, giving the attacker remote command execution capabilities. This technique bypasses firewalls that block incoming connections but allow outgoing ones, potentially leading to full system compromise. Review and remove any unexpected reverse shell code as it indicates a serious security breach or attempted backdoor.",
      "severity": "ERROR",
      "languages": [
        "generic"
      ],
      "pattern-either": [
        {
          "pattern": "sh -i >& /dev/udp/.../... 0>&1\n"
        },
        {
          "pattern": "<...>/dev/tcp/.../...; sh <&... >&... 2>&\n"
        },
        {
          "pattern": "<...>/dev/tcp/.../...; cat <&... | while read line; do $line 2>&... >&...;done\n"
        },
        {
          "pattern": "sh -i ...<...> /dev/tcp/.../... ...<&... 1>&... 2>&\n"
        }
      ]
    },
    {
      "id": "generic.nginx.security.alias-path-traversal.alias-path-traversal",
      "patterns": [
        {
          "pattern": "location $...LOCATION {\n  ...\n  alias .../;\n  ...\n}\n"
        },
        {
          "metavariable-pattern": {
            "metavariable": "$...LOCATION",
            "pattern-regex": "^.*[^/]$"
          }
        }
      ],
      "paths": {
        "include": [
          "*.conf",
          "*.vhost",
          "sites-available/*",
          "sites-enabled/*"
        ]
      },
      "fix-regex": {
        "regex": "location\\s+([A-Za-z0-9/-_\\.]+)",
        "replacement": "location \\1/"
      },
      "languages": [
        "generic"
      ],
      "severity": "WARNING",
      "message": "When an Nginx alias directive doesn't end with a trailing slash, attackers can exploit normalized paths to access files outside the intended directory. This path traversal vulnerability occurs because Nginx handles path normalization after applying the alias, allowing directory traversal via specially crafted URLs. Add a trailing slash to both the location and alias paths to ensure proper directory containment.",
      "metadata": {
        "cwe": [
          "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
        ],
        "source-rule-url": "https://github.com/yandex/gixy/blob/master/docs/en/plugins/aliastraversal.md",
        "category": "security",
        "technology": [
          "nginx"
        ],
        "confidence": "LOW",
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control",
          "https://www.acunetix.com/vulnerabilities/web/path-traversal-via-misconfigured-nginx-alias/",
          "https://www.youtube.com/watch?v=CIhHpkybYsY",
          "https://github.com/orangetw/My-Presentation-Slides/blob/main/data/2018-Breaking-Parser-Logic-Take-Your-Path-Normalization-Off-And-Pop-0days-Out.pdf"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "short-description": "Misconfigured Nginx alias may enable path traversal",
        "fix-suggestion": "Prevent path traversal by ensuring both `location` and `alias` directives end with a trailing slash: `location /path/ { alias /actual/directory/; }`. Consider using the `root` directive when possible: `location /path/ { root /base/directory; }`. For complex path mapping, implement input validation or use restrictive location patterns with regex anchors: `location ~ ^/path/(.*)$ { alias /actual/directory/$1; }`."
      }
    },
    {
      "id": "generic.nginx.security.dynamic-proxy-host.dynamic-proxy-host",
      "paths": {
        "include": [
          "*.conf",
          "*.vhost",
          "sites-available/*",
          "sites-enabled/*"
        ]
      },
      "languages": [
        "generic"
      ],
      "severity": "WARNING",
      "message": "The proxy URL host is dynamically determined from user input, creating a security risk. If an attacker can inject values into the host parameter, they can redirect proxy requests to unintended destinations. This enables server-side request forgery (SSRF) attacks that can bypass network boundaries.",
      "metadata": {
        "source-rule-url": "https://github.com/yandex/gixy/blob/master/docs/en/plugins/ssrf.md",
        "references": [
          "https://nginx.org/en/docs/http/ngx_http_map_module.html"
        ],
        "category": "security",
        "technology": [
          "nginx"
        ],
        "confidence": "MEDIUM",
        "cwe": [
          "CWE-441: Unintended Proxy or Intermediary ('Confused Deputy')"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "SSRF risk from dynamic proxy destination",
        "fix-suggestion": "Hardcode acceptable proxy destinations instead of using dynamic values. Use NGINX's `map` directive to create a whitelist of allowed destinations: `map $some_var $backend { default off; valid_input valid_backend; }`. Validate all user input against explicit allowlists before using it in proxy configurations."
      },
      "pattern-either": [
        {
          "pattern": "proxy_pass $SCHEME://$$HOST ...;"
        },
        {
          "pattern": "proxy_pass $$SCHEME://$$HOST ...;"
        }
      ]
    },
    {
      "id": "generic.nginx.security.dynamic-proxy-scheme.dynamic-proxy-scheme",
      "paths": {
        "include": [
          "*.conf",
          "*.vhost",
          "sites-available/*",
          "sites-enabled/*"
        ]
      },
      "languages": [
        "generic"
      ],
      "severity": "WARNING",
      "message": "The protocol scheme for this proxy is dynamically determined, introducing a security vulnerability. If an attacker can manipulate the scheme value, they can force the proxy to use unexpected protocols. This can lead to server-side request forgery (SSRF) or protocol downgrade attacks.",
      "metadata": {
        "cwe": [
          "CWE-16: CWE CATEGORY: Configuration"
        ],
        "references": [
          "https://github.com/yandex/gixy/blob/master/docs/en/plugins/ssrf.md"
        ],
        "category": "security",
        "technology": [
          "nginx"
        ],
        "confidence": "MEDIUM",
        "owasp": [
          "A06:2017 - Security Misconfiguration",
          "A05:2021 - Security Misconfiguration"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Security risk from dynamic proxy protocol scheme",
        "fix-suggestion": "Hardcode the scheme in your proxy configuration rather than using variables. Replace `proxy_pass $scheme://backend` with `proxy_pass https://backend` to enforce HTTPS. If dynamic behavior is needed, validate scheme values against a whitelist using NGINX's `map` directive."
      },
      "pattern": "proxy_pass $$SCHEME:// ...;"
    },
    {
      "id": "generic.nginx.security.header-injection.header-injection",
      "pattern": "location ... <$VARIABLE> ... {\n  ...\n  add_header ... $$VARIABLE\n  ...\n}\n",
      "paths": {
        "include": [
          "*.conf",
          "*.vhost",
          "sites-available/*",
          "sites-enabled/*"
        ]
      },
      "languages": [
        "generic"
      ],
      "severity": "ERROR",
      "message": "A user-controlled parameter is being added as a response header without proper validation. Attackers can inject newlines into this parameter, enabling HTTP response splitting attacks. This vulnerability can lead to cache poisoning, cross-site scripting (XSS), or cookie manipulation.",
      "metadata": {
        "cwe": [
          "CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')"
        ],
        "references": [
          "https://github.com/yandex/gixy/blob/master/docs/en/plugins/httpsplitting.md",
          "https://owasp.org/www-community/attacks/HTTP_Response_Splitting"
        ],
        "category": "security",
        "technology": [
          "nginx"
        ],
        "confidence": "MEDIUM",
        "owasp": [
          "A03:2021 - Injection"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "HTTP response splitting via header injection",
        "fix-suggestion": "Validate the path parameter with a strict regex pattern like `[^\\s]+` to prevent newline injection. Use NGINX's `map` directive to sanitize user input before using it in headers. Consider using predefined headers instead of dynamically generated ones where possible."
      }
    },
    {
      "id": "generic.nginx.security.header-redefinition.header-redefinition",
      "patterns": [
        {
          "pattern-inside": "server {\n  ...\n  add_header ...;\n  ...\n  ...\n}\n"
        },
        {
          "pattern-inside": "location ... {\n  ...\n  ...\n}\n"
        },
        {
          "pattern": "add_header ...;"
        }
      ],
      "paths": {
        "include": [
          "*.conf",
          "*.vhost",
          "sites-available/*",
          "sites-enabled/*"
        ]
      },
      "languages": [
        "generic"
      ],
      "severity": "WARNING",
      "message": "The 'add_header' directive is called in a location block after headers have been set at the server level. In NGINX, this causes location-level headers to completely override all server-level headers, potentially removing important security headers. This behavior is a common source of security misconfigurations.",
      "metadata": {
        "cwe": [
          "CWE-16: CWE CATEGORY: Configuration"
        ],
        "references": [
          "https://github.com/yandex/gixy/blob/master/docs/en/plugins/addheaderredefinition.md"
        ],
        "category": "security",
        "technology": [
          "nginx"
        ],
        "confidence": "LOW",
        "owasp": [
          "A06:2017 - Security Misconfiguration",
          "A05:2021 - Security Misconfiguration"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Security headers lost due to header redefinition",
        "fix-suggestion": "Either explicitly set all headers in both server and location blocks, or set all headers only in the server block. Use `add_header` with the `always` parameter to ensure headers are set for all response codes. Consider using NGINX's `include` directive to maintain consistent headers across configurations."
      }
    },
    {
      "id": "generic.nginx.security.insecure-redirect.insecure-redirect",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "rewrite ... redirect"
            },
            {
              "pattern": "rewrite ... permanent"
            }
          ]
        },
        {
          "pattern-not-inside": "rewrite ... https ... $host ... redirect"
        },
        {
          "pattern-not-inside": "rewrite ... https ... $host ... permanent"
        },
        {
          "pattern-not-regex": "(?i)https:\\/\\/"
        }
      ],
      "paths": {
        "include": [
          "*.conf",
          "*.vhost",
          "sites-available/*",
          "sites-enabled/*"
        ]
      },
      "message": "An insecure redirect configuration in NGINX doesn't specify the URL scheme. Without an explicit scheme, NGINX forwards requests using the incoming scheme, which could be unencrypted HTTP. This allows sensitive data in redirects to be transmitted without encryption, exposing it to interception.",
      "languages": [
        "generic"
      ],
      "severity": "WARNING",
      "metadata": {
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "category": "security",
        "technology": [
          "nginx"
        ],
        "confidence": "LOW",
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Insecure redirect without HTTPS enforcement",
        "fix-suggestion": "Include the `https` scheme explicitly in redirect URLs: `return 301 https://example.com$request_uri;`. Use `if ($scheme != \"https\") { return 301 https://$host$request_uri; }` to enforce HTTPS for all redirects. Always specify the full URL with scheme for security-critical redirects."
      }
    },
    {
      "id": "generic.nginx.security.insecure-ssl-version.insecure-ssl-version",
      "patterns": [
        {
          "pattern-not": "ssl_protocols TLSv1.2 TLSv1.3;"
        },
        {
          "pattern-not": "ssl_protocols TLSv1.3 TLSv1.2;"
        },
        {
          "pattern-not": "ssl_protocols TLSv1.2;"
        },
        {
          "pattern-not": "ssl_protocols TLSv1.3;"
        },
        {
          "pattern": "ssl_protocols ...;"
        }
      ],
      "paths": {
        "include": [
          "*.conf",
          "*.vhost",
          "sites-available/*",
          "sites-enabled/*"
        ]
      },
      "languages": [
        "generic"
      ],
      "severity": "WARNING",
      "message": "An insecure SSL/TLS version is being used in the NGINX configuration. Older TLS versions (1.0, 1.1) and all SSL versions have known security vulnerabilities that make them susceptible to attacks. Using outdated protocols exposes your communications to interception and manipulation by attackers.",
      "metadata": {
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "references": [
          "https://www.acunetix.com/blog/web-security-zone/hardening-nginx/",
          "https://www.acunetix.com/blog/articles/tls-ssl-cipher-hardening/"
        ],
        "category": "security",
        "technology": [
          "nginx"
        ],
        "confidence": "HIGH",
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Outdated TLS/SSL protocol version configured",
        "fix-suggestion": "Configure NGINX to use only secure TLS versions by setting `ssl_protocols TLSv1.2 TLSv1.3;` in your server block. Remove any references to older versions like SSLv3, TLSv1, or TLSv1.1. Also consider implementing strong cipher suites with `ssl_ciphers` directive."
      }
    },
    {
      "id": "generic.nginx.security.missing-internal.missing-internal",
      "options": {
        "generic_ellipsis_max_span": 0,
        "generic_engine": "aliengrep"
      },
      "patterns": [
        {
          "pattern-inside": "location ... {\n  ....\n  ....\n}\n"
        },
        {
          "pattern-not-inside": "location ... {\n  ....\n  internal;\n  ....\n}\n"
        },
        {
          "pattern": "proxy_pass $...URL;"
        },
        {
          "metavariable-regex": {
            "metavariable": "$...URL",
            "regex": "(.*\\$.*)"
          }
        }
      ],
      "paths": {
        "include": [
          "*.conf",
          "*.vhost",
          "sites-available/*",
          "sites-enabled/*"
        ]
      },
      "languages": [
        "generic"
      ],
      "severity": "WARNING",
      "message": "A location block contains 'proxy_pass' without the 'internal' directive. This exposes the proxy endpoint to external requests, potentially enabling server-side request forgery (SSRF) attacks. Without the 'internal' directive, attackers could use your server to proxy requests to internal resources.",
      "metadata": {
        "cwe": [
          "CWE-16: CWE CATEGORY: Configuration"
        ],
        "references": [
          "https://github.com/yandex/gixy/blob/master/docs/en/plugins/ssrf.md",
          "https://nginx.org/en/docs/http/ngx_http_core_module.html#internal"
        ],
        "category": "security",
        "technology": [
          "nginx"
        ],
        "confidence": "LOW",
        "owasp": [
          "A06:2017 - Security Misconfiguration",
          "A05:2021 - Security Misconfiguration"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Unrestricted proxy endpoint enables SSRF",
        "fix-suggestion": "Add the `internal` directive to location blocks containing `proxy_pass` that should only be accessible internally. This restricts access to redirects from other NGINX locations. For additional security, consider implementing IP-based access restrictions with `allow` and `deny` directives."
      }
    },
    {
      "id": "generic.nginx.security.missing-ssl-version.missing-ssl-version",
      "patterns": [
        {
          "pattern": "server { ... listen $PORT ssl; ... }"
        },
        {
          "pattern-not-inside": "server { ... ssl_protocols ... }"
        }
      ],
      "paths": {
        "include": [
          "*.conf",
          "*.vhost",
          "sites-available/*",
          "sites-enabled/*"
        ]
      },
      "languages": [
        "generic"
      ],
      "severity": "WARNING",
      "message": "The NGINX server configuration is missing the 'ssl_protocols' directive. By default, this allows older TLS versions (1.0 and 1.1) that have known vulnerabilities. Without explicit configuration, connections may use cryptographically weak protocols that can be compromised.",
      "metadata": {
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "references": [
          "https://www.acunetix.com/blog/web-security-zone/hardening-nginx/",
          "https://nginx.org/en/docs/http/configuring_https_servers.html"
        ],
        "category": "security",
        "technology": [
          "nginx"
        ],
        "confidence": "MEDIUM",
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Missing TLS protocol version specification",
        "fix-suggestion": "Add `ssl_protocols TLSv1.2 TLSv1.3;` to your NGINX server configuration to explicitly specify secure TLS versions. Remove support for older versions like SSLv3, TLSv1, and TLSv1.1. Also configure strong cipher suites with the `ssl_ciphers` directive."
      }
    },
    {
      "id": "generic.nginx.security.possible-h2c-smuggling.possible-nginx-h2c-smuggling",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "proxy_http_version 1.1 ...;\n...\nproxy_set_header Upgrade ...;\n...\nproxy_set_header Connection ...;\n"
            },
            {
              "pattern": "proxy_set_header Upgrade ...;\n...\nproxy_set_header Connection ...;\n...\nproxy_http_version 1.1 ...;\n"
            },
            {
              "pattern": "proxy_set_header Upgrade ...;\n...\nproxy_http_version 1.1 ...;\n...\nproxy_set_header Connection ...;\n"
            }
          ]
        },
        {
          "pattern-inside": "location ... {\n  ...\n}\n"
        }
      ],
      "languages": [
        "generic"
      ],
      "severity": "WARNING",
      "message": "The NGINX configuration may be vulnerable to H2C smuggling attacks. This allows upgrading HTTP/1.1 connections to HTTP/2 cleartext (h2c), potentially bypassing access controls on reverse proxies. Attackers can establish long-lived connections directly to backend servers, circumventing intended security boundaries.",
      "paths": {
        "include": [
          "*.conf",
          "*.vhost",
          "sites-available/*",
          "sites-enabled/*"
        ]
      },
      "metadata": {
        "cwe": [
          "CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')"
        ],
        "references": [
          "https://labs.bishopfox.com/tech-blog/h2c-smuggling-request-smuggling-via-http/2-cleartext-h2c"
        ],
        "category": "security",
        "technology": [
          "nginx"
        ],
        "confidence": "MEDIUM",
        "owasp": [
          "A04:2021 - Insecure Design"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "H2C smuggling vulnerability in NGINX config",
        "fix-suggestion": "If WebSocket support is required, modify your configuration to only allow the `websocket` value for HTTP/1.1 upgrade headers. If WebSocket support is not needed, configure NGINX to not forward Upgrade headers at all. Consider implementing additional validation at the application level."
      }
    },
    {
      "id": "generic.visualforce.security.ncino.html.usesriforcdns.use-SRI-for-CDNs",
      "languages": [
        "generic"
      ],
      "severity": "WARNING",
      "message": "Content Delivery Network (CDN) resources are included without Subresource Integrity (SRI) checks. Without SRI, compromised content from CDNs can be executed in your application context. Even a single compromised byte in the resource can be used to inject malicious code into your application.",
      "metadata": {
        "cwe": [
          "CWE-346: Origin Validation Error"
        ],
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "cwe2020-top25'": true,
        "cwe2021-top25'": true,
        "cwe2022-top25'": true,
        "impact": "MEDIUM",
        "likelihood": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "salesforce",
          "visualforce"
        ],
        "references": [
          "https://cwe.mitre.org/data/definitions/352.html",
          "https://developer.mozilla.org/en-US/blog/securing-cdn-using-sri-why-how/"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Missing SRI checks for CDN resources",
        "fix-suggestion": "Add `integrity` and `crossorigin` attributes to `<script>` and `<link>` tags loading CDN content. Generate the integrity hash value using tools like `openssl` or online SRI generators. For example: `<script src=\"https://cdn.example.com/script.js\" integrity=\"sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC\" crossorigin=\"anonymous\"></script>`."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "<link...href=\"$URL...\"...>"
            },
            {
              "pattern": "<script...src=\"$URL...\"...>"
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$URL",
            "regex": "http[A-Za-z0-9\\/\\.\\-\\:]"
          }
        },
        {
          "pattern-not": "<script...integrity=\"...\"...src=\"...\"...>"
        },
        {
          "pattern-not": "<script...src=\"...\"...integrity=\"...\"...>"
        },
        {
          "pattern-not": "<link...integrity=\"...\"...href=\"...\"...>"
        },
        {
          "pattern-not": "<link...href=\"...\"...integrity=\"...\"...>"
        }
      ],
      "paths": {
        "include": [
          "*.component",
          "*.page"
        ]
      }
    },
    {
      "id": "generic.visualforce.security.ncino.vf.xssfromunescapedurlparam.xss-from-unescaped-url-param",
      "languages": [
        "generic"
      ],
      "severity": "ERROR",
      "message": "When URL parameters are used in JavaScript without proper escaping, attackers can inject script code by crafting malicious parameter values. This cross-site scripting (XSS) vulnerability allows execution of arbitrary JavaScript in a victim's browser within your application's context. Always escape URL parameters using appropriate encoding functions before incorporating them into scripts.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://developer.salesforce.com/docs/atlas.en-us.apexcode.meta/apexcode/pages_security_tips_xss.htm"
        ],
        "category": "security",
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "salesforce",
          "visualforce"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Unescaped URL parameter usage can result in XSS",
        "fix-suggestion": "Prevent XSS by using proper encoding functions when incorporating URL parameters into script code. Use `JSENCODE()` for JavaScript contexts: `var param = '{!JSENCODE($CurrentPage.parameters.userInput)}'`. For URL contexts, use `URLENCODE()` and for HTML attributes, use `HTMLENCODE()`."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "<apex:outputText...escape=\"false\"...value=\"{!...CurrentPage.parameters.$URL_PARAM}\".../>"
            },
            {
              "pattern": "<apex:outputText...value=\"{!...CurrentPage.parameters.$URL_PARAM}\"...escape=\"false\".../>"
            },
            {
              "pattern": "<script>...'{!...CurrentPage.parameters.$URL_PARAM}'...</script>"
            }
          ]
        },
        {
          "pattern-not": "<script>...'{!...JSENCODE(...CurrentPage.parameters.$URL_PARAM})'...</script>"
        }
      ],
      "paths": {
        "include": [
          "*.component",
          "*.page"
        ]
      }
    },
    {
      "id": "generic.visualforce.security.ncino.xml.cspheaderattribute.csp-header-attribute",
      "languages": [
        "generic"
      ],
      "severity": "INFO",
      "message": "Without the cspHeader attribute set to true, Visualforce pages lack a strong Content Security Policy that could prevent various injection attacks. This absence allows attackers to execute malicious scripts if they can inject content into the page. Enable the cspHeader attribute (requires API version 55+) to enforce restrictions on what resources can be loaded and executed on your page.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://help.salesforce.com/s/articleView?id=sf.csp_trusted_sites.htm&type=5"
        ],
        "category": "security",
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "salesforce",
          "visualforce"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Missing cspHeader attribute reduces Visualforce page security",
        "fix-suggestion": "Enhance security by adding the `cspHeader=\"true\"` attribute to your Visualforce page tag: `<apex:page cspHeader=\"true\" ...>`. Define a comprehensive Content Security Policy by implementing custom headers with directives like `default-src 'self'`, `script-src 'self' https://trusted-cdn.com`, and `frame-ancestors 'self'`. Test thoroughly after implementation to ensure legitimate resources load properly."
      },
      "patterns": [
        {
          "pattern": "<apex:page...>...</apex:page>"
        },
        {
          "pattern-not": "<apex:page...cspHeader=\"true\"...>...</apex:page>"
        },
        {
          "pattern-not": "<apex:page...>...<!--deprecated-->...</apex:page>"
        },
        {
          "pattern-not": "<apex:page...>...<!-- deprecated -->...</apex:page>"
        }
      ],
      "paths": {
        "include": [
          "*.page"
        ]
      }
    },
    {
      "id": "generic.visualforce.security.ncino.xml.visualforceapiversion.visualforce-page-api-version",
      "languages": [
        "generic"
      ],
      "severity": "WARNING",
      "message": "Visualforce pages using API versions below 55 cannot utilize the cspHeader attribute, leaving them without an important security control. Without Content Security Policy enforcement, these pages are more vulnerable to cross-site scripting (XSS) and other injection attacks. Update your Visualforce pages to API version 55 or higher to enable modern security features like CSP.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_pages.htm"
        ],
        "category": "security",
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "salesforce",
          "visualforce"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Outdated Visualforce API version lacks cspHeader support",
        "fix-suggestion": "Enable Content Security Policy support by updating your Visualforce page API version to 55.0 or higher: `<apex:page version=\"55.0\" ...>`. Add the `cspHeader=\"true\"` attribute to activate CSP protection: `<apex:page version=\"55.0\" cspHeader=\"true\" ...>`. Test thoroughly after updating to ensure compatibility with any deprecated features."
      },
      "patterns": [
        {
          "pattern-inside": "<apiVersion.../apiVersion>"
        },
        {
          "pattern-either": [
            {
              "pattern-regex": "[>][0-9].[0-9][<]"
            },
            {
              "pattern-regex": "[>][1-4][0-9].[0-9][<]"
            },
            {
              "pattern-regex": "[>][5][0-4].[0-9][<]"
            }
          ]
        }
      ],
      "paths": {
        "include": [
          "*.page-meta.xml"
        ]
      }
    },
    {
      "id": "go.aws-lambda.security.database-sqli.database-sqli",
      "languages": [
        "go"
      ],
      "message": "AWS Lambda functions that build SQL queries using unsanitized event data allow attackers to modify query structure through specially crafted inputs. This SQL injection vulnerability can lead to unauthorized data access, data manipulation, or full database compromise. Use parameterized queries or prepared statements to separate SQL code from data and prevent injection attacks.",
      "mode": "taint",
      "metadata": {
        "references": [
          "https://pkg.go.dev/database/sql#DB.Query"
        ],
        "category": "security",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "technology": [
          "aws-lambda",
          "database",
          "sql"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "SQL injection risk from unsanitized AWS Lambda event data",
        "fix-suggestion": "Prevent SQL injection in AWS Lambda functions by replacing string concatenation with parameterized queries. For MySQL use: `db.Query(\"SELECT * FROM users WHERE username=?\", username)`, for PostgreSQL: `db.Query(\"SELECT * FROM users WHERE username=$1\", username)`. Consider using an ORM like GORM that provides additional protection through its query builder interface."
      },
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$QUERY"
            },
            {
              "pattern-either": [
                {
                  "pattern": "$DB.Exec($QUERY,...)"
                },
                {
                  "pattern": "$DB.ExecContent($QUERY,...)"
                },
                {
                  "pattern": "$DB.Query($QUERY,...)"
                },
                {
                  "pattern": "$DB.QueryContext($QUERY,...)"
                },
                {
                  "pattern": "$DB.QueryRow($QUERY,...)"
                },
                {
                  "pattern": "$DB.QueryRowContext($QUERY,...)"
                }
              ]
            },
            {
              "pattern-inside": "import \"database/sql\"\n...\n"
            }
          ]
        }
      ],
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "func $HANDLER($CTX $CTXTYPE, $EVENT $TYPE, ...) {...}\n...\nlambda.Start($HANDLER, ...)\n"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "func $HANDLER($EVENT $TYPE) {...}\n...\nlambda.Start($HANDLER, ...)\n"
                    },
                    {
                      "pattern-not-inside": "func $HANDLER($EVENT context.Context) {...}\n...\nlambda.Start($HANDLER, ...)\n"
                    }
                  ]
                }
              ]
            },
            {
              "focus-metavariable": "$EVENT"
            }
          ]
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "go.aws-lambda.security.tainted-sql-string.tainted-sql-string",
      "languages": [
        "go"
      ],
      "severity": "ERROR",
      "message": "Building SQL queries by concatenating user input from Lambda events allows attackers to inject SQL syntax that alters the intended query logic. This SQL injection vulnerability can lead to unauthorized data access, data manipulation, or privilege escalation within the database. Use parameterized queries or an ORM to properly separate SQL code from user-supplied data.",
      "metadata": {
        "references": [
          "https://owasp.org/www-community/attacks/SQL_Injection"
        ],
        "category": "security",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "technology": [
          "aws-lambda"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "String-concatenated queries in Lambda enable SQL injection",
        "fix-suggestion": "Protect Lambda functions from SQL injection by using parameterized queries instead of string concatenation. For MySQL use: `db.Exec(\"SELECT * FROM users WHERE username=?\", username)`, for PostgreSQL: `db.Exec(\"SELECT * FROM users WHERE username=$1\", username)`. For dynamic query parts like table names, implement a whitelist of allowed values rather than accepting arbitrary input."
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "func $HANDLER($CTX $CTXTYPE, $EVENT $TYPE, ...) {...}\n...\nlambda.Start($HANDLER, ...)\n"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "func $HANDLER($EVENT $TYPE) {...}\n...\nlambda.Start($HANDLER, ...)\n"
                    },
                    {
                      "pattern-not-inside": "func $HANDLER($EVENT context.Context) {...}\n...\nlambda.Start($HANDLER, ...)\n"
                    }
                  ]
                }
              ]
            },
            {
              "focus-metavariable": "$EVENT"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern": "\"$SQLSTR\" + ...\n"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$SQLSTR",
                        "regex": "(?i)(\\s*select|\\s*delete|\\s*insert|\\s*create|\\s*update|\\s*alter|\\s*drop).*"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "fmt.Fprintf($F, \"$SQLSTR\", ...)"
                        },
                        {
                          "pattern": "fmt.Sprintf(\"$SQLSTR\", ...)"
                        },
                        {
                          "pattern": "fmt.Printf(\"$SQLSTR\", ...)"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$SQLSTR",
                        "regex": "\\s*(?i)(select|delete|insert|create|update|alter|drop)\\b.*%(v|s|q).*"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-not-inside": "log.$PRINT(...)\n"
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "pattern": "strconv.Atoi(...)"
        }
      ]
    },
    {
      "id": "go.gorilla.security.audit.session-cookie-missing-httponly.session-cookie-missing-httponly",
      "patterns": [
        {
          "pattern-not-inside": "&sessions.Options{\n  ...,\n  HttpOnly: true,\n  ...,\n}\n"
        },
        {
          "pattern": "&sessions.Options{\n  ...,\n}\n"
        }
      ],
      "message": "A session cookie is created without the 'HttpOnly' flag. This allows client-side scripts to access the cookie, increasing the risk of session hijacking through cross-site scripting (XSS) attacks. Cookies containing sensitive authentication data should always have the HttpOnly flag set.",
      "metadata": {
        "cwe": [
          "CWE-1004: Sensitive Cookie Without 'HttpOnly' Flag"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "references": [
          "https://github.com/0c34/govwa/blob/139693e56406b5684d2a6ae22c0af90717e149b8/user/session/session.go#L69"
        ],
        "category": "security",
        "technology": [
          "gorilla"
        ],
        "confidence": "MEDIUM",
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cookie Security"
        ],
        "short-description": "Session cookie missing HttpOnly flag",
        "fix-suggestion": "Set the `HttpOnly` flag to `true` in the Gorilla session Options struct: `Options{HttpOnly: true, ...}`. This prevents JavaScript from accessing the cookie content, mitigating XSS risks. Always configure both HttpOnly and Secure flags together for session cookies."
      },
      "fix-regex": {
        "regex": "(HttpOnly\\s*:\\s+)false",
        "replacement": "\\1true"
      },
      "severity": "WARNING",
      "languages": [
        "go"
      ]
    },
    {
      "id": "go.gorilla.security.audit.session-cookie-missing-secure.session-cookie-missing-secure",
      "patterns": [
        {
          "pattern-not-inside": "&sessions.Options{\n  ...,\n  Secure: true,\n  ...,\n}\n"
        },
        {
          "pattern": "&sessions.Options{\n  ...,\n}\n"
        }
      ],
      "message": "A session cookie is created without the 'Secure' flag. This allows the cookie to be transmitted over unencrypted HTTP connections, exposing it to network eavesdropping. Session cookies containing authentication tokens should only be sent over HTTPS connections.",
      "metadata": {
        "cwe": [
          "CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "references": [
          "https://github.com/0c34/govwa/blob/139693e56406b5684d2a6ae22c0af90717e149b8/user/session/session.go#L69"
        ],
        "category": "security",
        "technology": [
          "gorilla"
        ],
        "confidence": "MEDIUM",
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cookie Security"
        ],
        "short-description": "Session cookie missing Secure flag",
        "fix-suggestion": "Set the `Secure` flag to `true` in the Gorilla session Options struct: `Options{Secure: true, ...}`. This ensures cookies are only transmitted over HTTPS connections. Configure both Secure and HttpOnly flags together for comprehensive session cookie protection."
      },
      "fix-regex": {
        "regex": "(Secure\\s*:\\s+)false",
        "replacement": "\\1true"
      },
      "severity": "WARNING",
      "languages": [
        "go"
      ]
    },
    {
      "id": "go.gorilla.security.audit.session-cookie-samesitenone.session-cookie-samesitenone",
      "patterns": [
        {
          "pattern-inside": "&sessions.Options{\n  ...,\n  SameSite: http.SameSiteNoneMode,\n  ...,\n}\n"
        },
        {
          "pattern": "&sessions.Options{\n  ...,\n}\n"
        }
      ],
      "message": "Gorilla session is configured with SameSiteNoneMode, which doesn't provide protection against cross-site request forgery (CSRF) attacks. This setting allows cookies to be sent in cross-site requests, making your application vulnerable to CSRF and various cookie-based attacks.",
      "metadata": {
        "cwe": [
          "CWE-1275: Sensitive Cookie with Improper SameSite Attribute"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "references": [
          "https://pkg.go.dev/github.com/gorilla/sessions#Options"
        ],
        "category": "security",
        "technology": [
          "gorilla"
        ],
        "confidence": "MEDIUM",
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cookie Security"
        ],
        "short-description": "Vulnerable cookie SameSite setting",
        "fix-suggestion": "Change the SameSite setting from `SameSiteNoneMode` to `SameSiteLaxMode` or `SameSiteStrictMode` in the Options struct. `SameSiteLaxMode` offers a good balance between security and usability for most applications. Ensure you're using the latest Gorilla sessions version."
      },
      "fix-regex": {
        "regex": "(SameSite\\s*:\\s+)http.SameSiteNoneMode",
        "replacement": "\\1http.SameSiteDefaultMode"
      },
      "severity": "WARNING",
      "languages": [
        "go"
      ]
    },
    {
      "id": "go.gorilla.security.audit.websocket-missing-origin-check.websocket-missing-origin-check",
      "patterns": [
        {
          "pattern-inside": "import (\"github.com/gorilla/websocket\")\n...\n"
        },
        {
          "patterns": [
            {
              "pattern-not-inside": "$UPGRADER = websocket.Upgrader{..., CheckOrigin: $FN ,...}\n...\n"
            },
            {
              "pattern-not-inside": "$UPGRADER.CheckOrigin = $FN2\n...\n"
            },
            {
              "pattern": "$UPGRADER.Upgrade(...)\n"
            }
          ]
        }
      ],
      "message": "WebSocket connections without Origin header validation allow cross-site requests to initiate connections, potentially leading to Cross-Site Request Forgery (CSRF) attacks. Attackers can create malicious websites that establish WebSocket connections to your application using the victim's credentials. Implement Origin header validation to verify that WebSocket connection attempts come only from trusted sources.",
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-352: Cross-Site Request Forgery (CSRF)"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "references": [
          "https://pkg.go.dev/github.com/gorilla/websocket#Upgrader"
        ],
        "technology": [
          "gorilla"
        ],
        "confidence": "MEDIUM",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site Request Forgery (CSRF)"
        ],
        "short-description": "No Origin header check on WebSocket can allow CSRF",
        "fix-suggestion": "Secure WebSocket connections by adding Origin header validation to your Upgrader configuration. Create a custom `CheckOrigin` function that verifies requests against trusted domains: `upgrader := websocket.Upgrader{CheckOrigin: func(r *http.Request) bool { origin := r.Header.Get(\"Origin\"); return isAllowedOrigin(origin) }}`. Implement the validation function to check against your allowlist of trusted origins."
      }
    },
    {
      "id": "go.grpc.security.grpc-client-insecure-connection.grpc-client-insecure-connection",
      "metadata": {
        "cwe": [
          "CWE-300: Channel Accessible by Non-Endpoint"
        ],
        "references": [
          "https://blog.gopheracademy.com/advent-2019/go-grps-and-tls/#connection-without-encryption"
        ],
        "category": "security",
        "technology": [
          "grpc"
        ],
        "confidence": "HIGH",
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Unencrypted gRPC client connection",
        "fix-suggestion": "Replace `grpc.WithInsecure()` with `grpc.WithTransportCredentials(credentials.NewTLS(config))`. Create secure TLS credentials using `credentials.NewTLS(tlsConfig)` where `tlsConfig` is a properly configured `tls.Config{}` struct. Always use encrypted connections for transporting sensitive data."
      },
      "message": "An insecure gRPC connection is established using 'grpc.WithInsecure()'. This creates unencrypted connections that can be intercepted, allowing attackers to view or modify data in transit. Unencrypted connections expose sensitive data and can lead to security breaches.",
      "languages": [
        "go"
      ],
      "severity": "ERROR",
      "pattern": "$GRPC.Dial($ADDR, ..., $GRPC.WithInsecure(...), ...)",
      "fix-regex": {
        "regex": "(.*)WithInsecure\\(.*?\\)",
        "replacement": "\\1WithTransportCredentials(credentials.NewTLS(<your_tls_config_here>))"
      }
    },
    {
      "id": "go.grpc.security.grpc-server-insecure-connection.grpc-server-insecure-connection",
      "metadata": {
        "cwe": [
          "CWE-300: Channel Accessible by Non-Endpoint"
        ],
        "references": [
          "https://blog.gopheracademy.com/advent-2019/go-grps-and-tls/#connection-without-encryption"
        ],
        "category": "security",
        "technology": [
          "grpc"
        ],
        "confidence": "HIGH",
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Unencrypted gRPC server connection",
        "fix-suggestion": "Add TLS credentials to your gRPC server using `grpc.Creds(credentials.NewServerTLSFromFile(\"cert.pem\", \"key.pem\"))`. Generate proper TLS certificates for your server and ensure they're properly maintained. Include secure credential options when creating the gRPC server."
      },
      "message": "The gRPC server is configured without TLS credentials. This creates unencrypted connections that can be intercepted, allowing attackers to view or modify data in transit. Servers handling sensitive data should always use encrypted connections.",
      "languages": [
        "go"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sinks": [
        {
          "requires": "OPTIONS and not CREDS",
          "pattern": "grpc.NewServer($OPT, ...)"
        },
        {
          "requires": "EMPTY_CONSTRUCTOR",
          "pattern": "grpc.NewServer()"
        }
      ],
      "pattern-sources": [
        {
          "label": "OPTIONS",
          "pattern": "grpc.ServerOption{ ... }"
        },
        {
          "label": "CREDS",
          "pattern": "grpc.Creds(...)"
        },
        {
          "label": "EMPTY_CONSTRUCTOR",
          "pattern": "grpc.NewServer()"
        }
      ]
    },
    {
      "id": "go.jwt-go.security.audit.jwt-parse-unverified.jwt-go-parse-unverified",
      "message": "JWT tokens are decoded without verification using 'ParseUnverified'. This bypasses signature validation, allowing potentially tampered tokens to be accepted. Unverified tokens cannot be trusted for authentication or authorization decisions.",
      "metadata": {
        "cwe": [
          "CWE-345: Insufficient Verification of Data Authenticity"
        ],
        "owasp": [
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "source-rule-url": "https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/",
        "category": "security",
        "technology": [
          "jwt"
        ],
        "confidence": "MEDIUM",
        "references": [
          "https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "JWT tokens decoded without verification",
        "fix-suggestion": "Avoid using `ParseUnverified` and use `Parse` or `ParseWithClaims` instead with proper verification. Only use `ParseUnverified` when you've previously verified the signature elsewhere in your code. Implement a complete JWT validation process including signature, expiration, and issuer validation."
      },
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "import \"github.com/dgrijalva/jwt-go\"\n...\n"
        },
        {
          "pattern": "$JWT.ParseUnverified(...)\n"
        }
      ]
    },
    {
      "id": "go.jwt-go.security.jwt.hardcoded-jwt-key",
      "message": "Embedding JWT secrets directly in source code makes them accessible to anyone with access to the codebase, including potential attackers. Compromised JWT signing keys allow attackers to forge valid authentication tokens and impersonate any user in the system. Store JWT secrets securely in environment variables or dedicated secret management systems, keeping them separate from the application code.",
      "options": {
        "interfile": true
      },
      "metadata": {
        "cwe": [
          "CWE-798: Use of Hard-coded Credentials"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html"
        ],
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "category": "security",
        "technology": [
          "jwt",
          "secrets"
        ],
        "confidence": "MEDIUM",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "interfile": true,
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Hard-coded Secrets"
        ],
        "short-description": "Hardcoded JWT secret vulnerable to key exposure",
        "fix-suggestion": "Remove hardcoded JWT secrets from source code and store them securely using environment variables or a secrets management system. Replace `var jwtKey = []byte(\"hardcoded-secret\")` with code that loads the key from environment: `var jwtKey = []byte(os.Getenv(\"JWT_SECRET\"))`. For production, use a dedicated secrets manager like AWS Secrets Manager, HashiCorp Vault, or Google Secret Manager."
      },
      "severity": "WARNING",
      "languages": [
        "go"
      ],
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-inside": "[]byte(\"$F\")\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$TOKEN.SignedString($F)\n"
                }
              ]
            },
            {
              "focus-metavariable": "$F"
            }
          ]
        }
      ]
    },
    {
      "id": "go.jwt-go.security.jwt-none-alg.jwt-go-none-algorithm",
      "message": "The 'none' algorithm is being used for JWT token verification. This completely bypasses signature validation, assuming the token's integrity has already been verified. Attackers can forge tokens with the 'none' algorithm to gain unauthorized access.",
      "metadata": {
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/",
        "category": "security",
        "technology": [
          "jwt"
        ],
        "confidence": "HIGH",
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Insecure JWT 'none' algorithm accepted",
        "fix-suggestion": "Explicitly specify secure algorithms when verifying tokens. Use `jwt.Parse(token, func(token *jwt.Token) (interface{}, error) { if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok { return nil, errors.New(\"unexpected signing method\") } return signingKey, nil })`. Never accept the 'none' algorithm for JWT validation."
      },
      "languages": [
        "go"
      ],
      "severity": "ERROR",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "import \"github.com/golang-jwt/jwt\"\n...\n"
            },
            {
              "pattern-inside": "import \"github.com/dgrijalva/jwt-go\"\n...\n"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern": "jwt.SigningMethodNone\n"
            },
            {
              "pattern": "jwt.UnsafeAllowNoneSignatureType"
            }
          ]
        }
      ]
    },
    {
      "id": "go.lang.security.filepath-clean-misuse.filepath-clean-misuse",
      "message": "The filepath.Clean function only normalizes paths but doesn't prevent directory traversal attacks as it preserves '../' sequences at the beginning of a path. Attackers can bypass inadequate path validation by using these sequences to access files outside intended directories. Use additional validation or more secure functions like filepath.Join with an absolute base path to properly contain file system access.",
      "severity": "ERROR",
      "languages": [
        "go"
      ],
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "($REQUEST : *http.Request).$ANYTHING\n"
                },
                {
                  "pattern": "($REQUEST : http.Request).$ANYTHING\n"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$ANYTHING",
                "regex": "^(BasicAuth|Body|Cookie|Cookies|Form|FormValue|GetBody|Host|MultipartReader|ParseForm|ParseMultipartForm|PostForm|PostFormValue|Referer|RequestURI|Trailer|TransferEncoding|UserAgent|URL)$"
              }
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "filepath.Clean($...INNER)"
                },
                {
                  "pattern": "path.Clean($...INNER)"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "pattern-either": [
            {
              "pattern": "\"/\" + ...\n"
            }
          ]
        }
      ],
      "fix": "filepath.FromSlash(filepath.Clean(\"/\"+strings.Trim($...INNER, \"/\")))",
      "options": {
        "interfile": true
      },
      "metadata": {
        "references": [
          "https://pkg.go.dev/path#Clean",
          "http://technosophos.com/2016/03/31/go-quickly-cleaning-filepaths.html",
          "https://labs.detectify.com/2021/12/15/zero-day-path-traversal-grafana/",
          "https://dzx.cz/2021/04/02/go_path_traversal/",
          "https://pkg.go.dev/github.com/cyphar/filepath-securejoin#section-readme"
        ],
        "cwe": [
          "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
        ],
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "interfile": true,
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "short-description": "filepath.Clean alone doesn't prevent path traversal",
        "fix-suggestion": "Replace `filepath.Clean()` with a more secure path validation approach. Convert paths to absolute using `filepath.Abs()`, then validate they remain within the intended directory: `absBase, _ := filepath.Abs(baseDir); absPath, _ := filepath.Abs(filePath); if !strings.HasPrefix(absPath, absBase+\"/\") { return errors.New(\"path traversal detected\") }`. Consider implementing a virtual file system with explicit mappings for web applications."
      }
    },
    {
      "id": "go.lang.security.reverseproxy-director.reverseproxy-director",
      "message": "ReverseProxy's Director function can remove headers that were added within the Director. This behavior can lead to unexpected header handling and potential security issues. Relying on Director to add security headers might result in these headers being lost.",
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "import \"net/http/httputil\"\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "$PROXY.Director = $FUNC"
            },
            {
              "patterns": [
                {
                  "pattern-inside": "httputil.ReverseProxy{\n    ...\n}\n"
                },
                {
                  "pattern": "Director: $FUNC\n"
                }
              ]
            }
          ]
        }
      ],
      "metadata": {
        "cwe": [
          "CWE-115: Misinterpretation of Input"
        ],
        "category": "security",
        "subcategory": [
          "audit"
        ],
        "technology": [
          "go"
        ],
        "confidence": "MEDIUM",
        "likelihood": "LOW",
        "impact": "LOW",
        "references": [
          "https://github.com/golang/go/issues/50580"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Unreliable header handling in ReverseProxy",
        "fix-suggestion": "Use `ReverseProxy.Rewrite` instead of `ReverseProxy.Director` for more reliable header manipulation. The Rewrite function provides better control over request transformation with distinct hooks for different stages. Ensure critical security headers are set in the appropriate handlers."
      }
    },
    {
      "id": "go.lang.security.audit.dangerous-command-write.dangerous-command-write",
      "patterns": [
        {
          "pattern": "$CW.Write($BYTE)\n"
        },
        {
          "pattern-inside": "$CW,$ERR := $CMD.StdinPipe()\n...\n"
        },
        {
          "pattern-not": "$CW.Write(\"...\")\n"
        },
        {
          "pattern-not": "$CW.Write([]byte(\"...\"))\n"
        },
        {
          "pattern-not": "$CW.Write([]byte(\"...\"+\"...\"))\n"
        },
        {
          "pattern-not-inside": "$BYTE = []byte(\"...\");\n...\n"
        },
        {
          "pattern-not-inside": "$BYTE = []byte(\"...\"+\"...\");\n...\n"
        },
        {
          "pattern-inside": "import \"os/exec\"\n...\n"
        }
      ],
      "message": "When user input is incorporated into commands that will be executed, attackers can inject additional shell commands through specially crafted inputs. This command injection vulnerability could lead to remote code execution with the privileges of the application process. Validate and sanitize any user-supplied data used to build commands, or preferably use fixed command strings with separate arguments.",
      "severity": "ERROR",
      "languages": [
        "go"
      ],
      "metadata": {
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "LOW",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Building system commands from user input allows injection",
        "fix-suggestion": "Avoid command injection by replacing shell command strings with Go's `exec.Command` using separate arguments. Instead of `cmd := exec.Command(\"sh\", \"-c\", \"echo \" + userInput)`, use `cmd := exec.Command(\"echo\", userInput)` to treat input as a literal argument. For complex commands, build an arguments slice programmatically and pass it with `cmd := exec.Command(\"program\", args...)`."
      }
    },
    {
      "id": "go.lang.security.audit.dangerous-exec-cmd.dangerous-exec-cmd",
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern": "exec.Cmd {...,Path: $CMD,...}\n"
                },
                {
                  "pattern-not": "exec.Cmd {...,Path: \"...\",...}\n"
                },
                {
                  "pattern-not-inside": "$CMD,$ERR := exec.LookPath(\"...\");\n...\n"
                },
                {
                  "pattern-not-inside": "$CMD = \"...\";\n...\n"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern": "exec.Cmd {...,Args: $ARGS,...}\n"
                },
                {
                  "pattern-not": "exec.Cmd {...,Args: []string{...},...}\n"
                },
                {
                  "pattern-not-inside": "$ARGS = []string{\"...\",...};\n...\n"
                },
                {
                  "pattern-not-inside": "$CMD = \"...\";\n...\n$ARGS = []string{$CMD,...};\n...\n"
                },
                {
                  "pattern-not-inside": "$CMD = exec.LookPath(\"...\");\n...\n$ARGS = []string{$CMD,...};\n...\n"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern": "exec.Cmd {...,Args: []string{$CMD,...},...}\n"
                },
                {
                  "pattern-not": "exec.Cmd {...,Args: []string{\"...\",...},...}\n"
                },
                {
                  "pattern-not-inside": "$CMD,$ERR := exec.LookPath(\"...\");\n...\n"
                },
                {
                  "pattern-not-inside": "$CMD = \"...\";\n...\n"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "exec.Cmd {...,Args: []string{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$EXE,...},...}\n"
                    },
                    {
                      "patterns": [
                        {
                          "pattern": "exec.Cmd {...,Args: []string{$CMD,\"-c\",$EXE,...},...}\n"
                        },
                        {
                          "pattern-inside": "$CMD,$ERR := exec.LookPath(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\");\n...\n"
                        }
                      ]
                    }
                  ]
                },
                {
                  "pattern-not": "exec.Cmd {...,Args: []string{\"...\",\"...\",\"...\",...},...}\n"
                },
                {
                  "pattern-not-inside": "$EXE = \"...\";\n...\n"
                }
              ]
            }
          ]
        },
        {
          "pattern-inside": "import \"os/exec\"\n...\n"
        }
      ],
      "message": "Using exec.Cmd with commands partially constructed from user input allows attackers to inject additional commands through carefully crafted inputs. This command injection vulnerability could result in unauthorized command execution with the application's privileges. Validate and sanitize user inputs or use exec.Command with a fixed binary path and separate argument list to prevent injection.",
      "metadata": {
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "MEDIUM",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "exec.Cmd with untrusted data can cause command injection",
        "fix-suggestion": "Prevent command injection by separating the command from its arguments when using `exec.Cmd`. Replace `cmd := exec.Command(\"sh\", \"-c\", \"grep \"+userPattern+\" file\")` with the safer form `cmd := exec.Command(\"grep\", userPattern, \"file\")`. This ensures user input is treated as literal arguments rather than potentially containing shell metacharacters."
      },
      "severity": "ERROR",
      "languages": [
        "go"
      ]
    },
    {
      "id": "go.lang.security.audit.dangerous-exec-command.dangerous-exec-command",
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "exec.Command($CMD,...)\n"
                    },
                    {
                      "pattern": "exec.CommandContext($CTX,$CMD,...)\n"
                    }
                  ]
                },
                {
                  "pattern-not": "exec.Command(\"...\",...)\n"
                },
                {
                  "pattern-not": "exec.CommandContext($CTX,\"...\",...)\n"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "exec.Command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$CMD,...)\n"
                    },
                    {
                      "pattern": "exec.CommandContext($CTX,\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$CMD,...)\n"
                    }
                  ]
                },
                {
                  "pattern-not": "exec.Command(\"...\",\"...\",\"...\",...)\n"
                },
                {
                  "pattern-not": "exec.CommandContext($CTX,\"...\",\"...\",\"...\",...)\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "exec.Command(\"=~/\\/bin\\/env/\",\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$CMD,...)\n"
                },
                {
                  "pattern": "exec.CommandContext($CTX,\"=~/\\/bin\\/env/\",\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$CMD,...)\n"
                }
              ]
            }
          ]
        },
        {
          "pattern-inside": "import \"os/exec\"\n...\n"
        },
        {
          "pattern-not-inside": "$CMD,$ERR := exec.LookPath(\"...\");\n...\n"
        },
        {
          "pattern-not-inside": "$CMD = \"...\";\n...\n"
        }
      ],
      "message": "Creating exec.Command instances with user-controlled input allows attackers to inject shell commands through maliciously crafted data. This command injection vulnerability can lead to unauthorized command execution with the application's permissions. Use fixed command strings and pass user data as separate arguments, or thoroughly validate and sanitize any user input used in command construction.",
      "metadata": {
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Constructing commands from unsanitized input leads to RCE",
        "fix-suggestion": "Secure command execution by replacing string concatenation with the variadic argument form of `exec.Command`. Instead of `exec.Command(\"sh\", \"-c\", \"grep \"+userPattern+\" file\")`, use `exec.Command(\"grep\", userPattern, \"file\")` to prevent shell interpretation of special characters. For complex argument lists, validate each component with regex before including it in your command."
      },
      "severity": "ERROR",
      "languages": [
        "go"
      ]
    },
    {
      "id": "go.lang.security.audit.dangerous-syscall-exec.dangerous-syscall-exec",
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern": "syscall.$METHOD($BIN,...)\n"
                },
                {
                  "pattern-not": "syscall.$METHOD(\"...\",...)\n"
                },
                {
                  "pattern-not-inside": "$BIN,$ERR := exec.LookPath(\"...\");\n...\n"
                },
                {
                  "pattern-not-inside": "$BIN = \"...\";\n...\n"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern": "syscall.$METHOD($BIN,$ARGS,...)\n"
                },
                {
                  "pattern-not": "syscall.$METHOD($BIN,[]string{\"...\",...},...)\n"
                },
                {
                  "pattern-not-inside": "$ARGS := []string{\"...\",...};\n...\n"
                },
                {
                  "pattern-not-inside": "$CMD = \"...\";\n...\n$ARGS = []string{$CMD,...};\n...\n"
                },
                {
                  "pattern-not-inside": "$CMD,$ERR := exec.LookPath(\"...\");\n...\n$ARGS = []string{$CMD,...};\n...\n"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern": "syscall.$METHOD($BIN,[]string{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$EXE,...},...)\n"
                },
                {
                  "pattern-not": "syscall.$METHOD($BIN,[]string{\"...\",\"...\",\"...\",...},...)\n"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern": "syscall.$METHOD($BIN,$ARGS,...)\n"
                },
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "$ARGS := []string{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$EXE,...};\n...\n"
                    },
                    {
                      "pattern-inside": "$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n...\n$ARGS = []string{$CMD,\"-c\",$EXE,...};\n...\n"
                    },
                    {
                      "pattern-inside": "$CMD,$ERR := exec.LookPath(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\");\n...\n$ARGS = []string{$CMD,\"-c\",$EXE,...};\n...\n"
                    }
                  ]
                },
                {
                  "pattern-not-inside": "$ARGS := []string{\"...\",\"...\",\"...\",...};\n...\n"
                },
                {
                  "pattern-not-inside": "$CMD = \"...\";\n...\n$ARGS = []string{$CMD,\"...\",\"...\",...};\n...\n"
                },
                {
                  "pattern-not-inside": "$CMD,$ERR := exec.LookPath(\"...\");\n...\n$ARGS = []string{$CMD,\"...\",\"...\",...};\n...\n"
                }
              ]
            }
          ]
        },
        {
          "pattern-inside": "import \"syscall\"\n...\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$METHOD",
            "regex": "(Exec|ForkExec)"
          }
        }
      ],
      "message": "Using unsanitized user input with syscall.Exec allows attackers to control which commands are executed on the system. This direct command injection vulnerability can lead to complete system compromise as the commands run with the application's privileges. Validate all inputs used in system calls and consider using safer alternatives with proper argument separation.",
      "metadata": {
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "syscall.Exec with user input can run arbitrary commands",
        "fix-suggestion": "Avoid command injection by replacing `syscall.Exec` with the safer `os/exec` package when possible. If `syscall.Exec` is required, implement strict input validation against an allowlist before including user input. Create separate slices for the command and arguments, and validate path components to prevent directory traversal."
      },
      "severity": "ERROR",
      "languages": [
        "go"
      ]
    },
    {
      "id": "go.lang.security.audit.md5-used-as-password.md5-used-as-password",
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "message": "MD5 is being used for password hashing. MD5 is cryptographically broken and can be cracked very quickly using modern hardware. Password hashes must be computationally expensive to defend against brute force attacks.",
      "options": {
        "interfile": true
      },
      "metadata": {
        "category": "security",
        "technology": [
          "md5"
        ],
        "references": [
          "https://tools.ietf.org/id/draft-lvelvindron-tls-md5-sha1-deprecate-01.html",
          "https://security.stackexchange.com/questions/211/how-to-securely-hash-passwords",
          "https://github.com/returntocorp/semgrep-rules/issues/1609",
          "https://pkg.go.dev/golang.org/x/crypto/bcrypt"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "confidence": "MEDIUM",
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "interfile": true,
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Weak MD5 algorithm for password hashing",
        "fix-suggestion": "Replace MD5 with a secure password hashing function like bcrypt. Use the `golang.org/x/crypto/bcrypt` package with `bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)` for hashing and `bcrypt.CompareHashAndPassword(hashedPassword, password)` for verification. Consider increasing cost factor for stronger security."
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "md5.New"
                },
                {
                  "pattern": "md5.Sum"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$FUNCTION(...)"
            },
            {
              "metavariable-regex": {
                "metavariable": "$FUNCTION",
                "regex": "(?i)(.*password.*)"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "go.lang.security.audit.reflect-makefunc.reflect-makefunc",
      "message": "The 'reflect.MakeFunc' function is being used, which bypasses Go's type system protections. This function executes dynamically generated code, which can lead to security vulnerabilities if user input can influence the generated code. Dynamic code execution increases attack surface.",
      "metadata": {
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-913: Improper Control of Dynamically-Managed Code Resources"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Type system bypass with dynamic code execution",
        "fix-suggestion": "Avoid using `reflect.MakeFunc` where possible, especially with user-controlled input. If dynamic function creation is necessary, implement strict validation on all inputs that influence the behavior. Consider redesigning to use interfaces and static typing instead of reflection."
      },
      "severity": "ERROR",
      "pattern": "reflect.MakeFunc(...)",
      "languages": [
        "go"
      ]
    },
    {
      "id": "go.lang.security.audit.unsafe-reflect-by-name.unsafe-reflect-by-name",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$SMTH.MethodByName($NAME,...)\n"
            },
            {
              "pattern": "$SMTH.FieldByName($NAME,...)\n"
            }
          ]
        },
        {
          "pattern-not": "$SMTH.MethodByName(\"...\",...)\n"
        },
        {
          "pattern-not": "$SMTH.FieldByName(\"...\",...)\n"
        },
        {
          "pattern-inside": "import \"reflect\"\n...\n"
        }
      ],
      "message": "Reflection is used to dynamically access methods or fields based on user-controllable input. This can lead to unauthorized control flow paths if attackers can manipulate which methods are called. Such dynamic invocation bypasses normal access control and type safety checks.",
      "metadata": {
        "cwe": [
          "CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Reflection enables unauthorized method access",
        "fix-suggestion": "Avoid using reflection with user-supplied input. Instead, create a map of allowed operations to handler functions, and validate user input against this whitelist. Replace dynamic reflection with type-safe interfaces and explicit handler mappings to maintain control over execution paths."
      },
      "severity": "WARNING",
      "languages": [
        "go"
      ]
    },
    {
      "id": "go.lang.security.audit.crypto.missing-ssl-minversion.missing-ssl-minversion",
      "message": "The TLS configuration is missing the 'MinVersion' setting. This allows potentially insecure protocol versions by default (TLS 1.0 for servers). Older TLS versions have known vulnerabilities and should be disabled in security-sensitive applications.",
      "metadata": {
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://github.com/securego/gosec/blob/master/rules/tls_config.go",
        "references": [
          "https://golang.org/doc/go1.14#crypto/tls",
          "https://golang.org/pkg/crypto/tls/#:~:text=MinVersion",
          "https://www.us-cert.gov/ncas/alerts/TA14-290A"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "HIGH",
        "subcategory": [
          "audit"
        ],
        "likelihood": "MEDIUM",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Missing minimum TLS version configuration",
        "fix-suggestion": "Add `MinVersion: tls.VersionTLS13` to your TLS configuration to enforce TLS 1.3. For applications requiring broader compatibility, use at least TLS 1.2: `MinVersion: tls.VersionTLS12`. Never allow TLS 1.0 or 1.1 in security-sensitive applications."
      },
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern": "tls.Config{ $...CONF }\n"
        },
        {
          "pattern-not": "tls.Config{..., MinVersion: ..., ...}\n"
        }
      ],
      "fix": "tls.Config{ $...CONF, MinVersion: tls.VersionTLS13 }\n"
    },
    {
      "id": "go.lang.security.audit.crypto.sha224-hash.sha224-hash",
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern-inside": "import \"crypto/sha256\"\n...\n"
            },
            {
              "pattern-either": [
                {
                  "pattern": "sha256.New224()\n"
                },
                {
                  "pattern": "sha256.Sum224(...)\n"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "import \"golang.org/x/crypto/sha3\"\n...\n"
            },
            {
              "pattern-either": [
                {
                  "pattern": "sha3.New224()\n"
                },
                {
                  "pattern": "sha3.Sum224(...)\n"
                }
              ]
            }
          ]
        }
      ],
      "message": "A 224-bit hash function is being used, which is deprecated or disallowed by some security policies. While SHA-224 isn't broken, it offers lower security margins than stronger alternatives. Some compliance frameworks require stronger hash functions.",
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-328: Use of Weak Hash"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "references": [
          "https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar3.ipd.pdf",
          "https://www.cyber.gov.au/resources-business-and-government/essential-cyber-security/ism/cyber-security-guidelines/guidelines-cryptography"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Hashing Algorithm"
        ],
        "short-description": "Policy-noncompliant 224-bit hash function",
        "fix-suggestion": "Replace SHA-224 with stronger hash functions like SHA-384 or higher. Update your code to use `crypto/sha512.New384()` instead of the 224-bit variant. This ensures compliance with security policies while providing better resistance against future attacks."
      }
    },
    {
      "id": "go.lang.security.audit.crypto.bad_imports.insecure-module-used",
      "message": "The 'net/http/cgi' package is being imported, which is vulnerable to httpoxy attacks (CVE-2015-5386). This vulnerability allows attackers to redirect requests by setting HTTP_PROXY headers. The package has known security issues that could compromise your application.",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "source-rule-url": "https://github.com/securego/gosec",
        "references": [
          "https://godoc.org/golang.org/x/crypto/sha3"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "MEDIUM",
        "subcategory": [
          "audit"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Vulnerable CGI package with httpoxy risk",
        "fix-suggestion": "Replace `net/http/cgi` with standard `net/http` or a modern web framework. If you need to handle CGI operations, implement proper header filtering to prevent httpoxy attacks. Consider using environment filtering to remove potentially dangerous proxy configurations from incoming requests."
      },
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern-inside": "import \"net/http/cgi\"\n...\n"
            },
            {
              "pattern": "cgi.$FUNC(...)\n"
            }
          ]
        }
      ]
    },
    {
      "id": "go.lang.security.audit.crypto.insecure_ssh.avoid-ssh-insecure-ignore-host-key",
      "message": "SSH host key verification is disabled, allowing potential man-in-the-middle attacks. Without host key verification, connections can be intercepted by attackers who present fraudulent host keys. This undermines the security guarantees of SSH encryption.",
      "metadata": {
        "cwe": [
          "CWE-322: Key Exchange without Entity Authentication"
        ],
        "owasp": [
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://github.com/securego/gosec",
        "references": [
          "https://skarlso.github.io/2019/02/17/go-ssh-with-host-key-verification/",
          "https://gist.github.com/Skarlso/34321a230cf0245018288686c9e70b2d"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "MEDIUM",
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Disabled SSH host key verification",
        "fix-suggestion": "Use the `golang.org/x/crypto/ssh/knownhosts` package to implement proper host key verification. Replace custom `HostKeyCallback` implementations with `ssh.HostKeyCallback(knownhosts.New(knownhostsFile))`. Always verify host keys against a known_hosts file or other trusted source."
      },
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "pattern": "ssh.InsecureIgnoreHostKey()"
    },
    {
      "id": "go.lang.security.audit.crypto.math_random.math-random-used",
      "metadata": {
        "cwe": [
          "CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)"
        ],
        "owasp": [
          "A02:2021 - Cryptographic Failures"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#secure-random-number-generation"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "MEDIUM",
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Non-cryptographic random number generator",
        "fix-suggestion": "Replace `math/rand` with `crypto/rand` for all security-sensitive operations. Use `crypto/rand.Read()` to generate random bytes or `crypto/rand.Int()` for random integers. Never use standard random generators for authentication tokens, encryption keys, or other security purposes."
      },
      "message": "The 'math/rand' package is being used instead of the cryptographically secure 'crypto/rand'. Standard random number generators are predictable and should never be used for security-related functionality. Predictable randomness can lead to various cryptographic attacks.",
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "import $RAND \"$MATH\"\n"
            },
            {
              "pattern": "import \"$MATH\"\n"
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$MATH",
            "regex": "^(math/rand(\\/v[0-9]+)*)$"
          }
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "...\nrand.$FUNC(...)\n"
            },
            {
              "pattern-inside": "...\n$RAND.$FUNC(...)\n"
            }
          ]
        },
        {
          "focus-metavariable": [
            "$MATH"
          ]
        }
      ],
      "fix": "crypto/rand\n"
    },
    {
      "id": "go.lang.security.audit.crypto.ssl.ssl-v3-is-insecure",
      "message": "SSLv3 is configured, which is known to be insecure due to vulnerabilities like POODLE. Using deprecated SSL protocols exposes communications to potential interception and decryption. Starting with Go 1.14, SSLv3 is completely removed.",
      "metadata": {
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://github.com/securego/gosec/blob/master/rules/tls_config.go",
        "references": [
          "https://golang.org/doc/go1.14#crypto/tls",
          "https://www.us-cert.gov/ncas/alerts/TA14-290A"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "HIGH",
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Insecure SSLv3 protocol enabled",
        "fix-suggestion": "Replace SSLv3 with TLS 1.3 by using `tls.VersionTLS13` in your TLS configuration. Remove any explicit enabling of SSLv3 and older protocols. Ensure your TLS configuration includes `MinVersion: tls.VersionTLS12` at minimum for secure communications."
      },
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "fix-regex": {
        "regex": "VersionSSL30",
        "replacement": "VersionTLS13"
      },
      "pattern": "tls.Config{..., MinVersion: $TLS.VersionSSL30, ...}"
    },
    {
      "id": "go.lang.security.audit.crypto.tls.tls-with-insecure-cipher",
      "message": "An insecure cipher suite is specified in the TLS configuration. Weak cipher suites can be broken by attackers, compromising the confidentiality and integrity of encrypted communications. Using deprecated cipher suites undermines TLS security.",
      "metadata": {
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://github.com/securego/gosec/blob/master/rules/tls.go",
        "references": [
          "https://golang.org/pkg/crypto/tls/#InsecureCipherSuites"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "HIGH",
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Weak cipher suite in TLS configuration",
        "fix-suggestion": "Replace insecure cipher suites with those returned by `tls.CipherSuites()`, which provides a list of secure options. Avoid manually specifying ciphers unless absolutely necessary. If custom configuration is required, check `crypto/tls` documentation for current secure recommendations."
      },
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_RSA_WITH_RC4_128_SHA, ...}}\n"
        },
        {
          "pattern": "tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_RSA_WITH_3DES_EDE_CBC_SHA, ...}}\n"
        },
        {
          "pattern": "tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_RSA_WITH_AES_128_CBC_SHA256, ...}}\n"
        },
        {
          "pattern": "tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, ...}}\n"
        },
        {
          "pattern": "tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_RSA_WITH_RC4_128_SHA, ...}}\n"
        },
        {
          "pattern": "tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, ...}}\n"
        },
        {
          "pattern": "tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, ...}}\n"
        },
        {
          "pattern": "tls.Config{..., CipherSuites: []$TYPE{..., tls.TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, ...}}\n"
        },
        {
          "pattern": "tls.CipherSuite{..., TLS_RSA_WITH_RC4_128_SHA, ...}\n"
        },
        {
          "pattern": "tls.CipherSuite{..., TLS_RSA_WITH_3DES_EDE_CBC_SHA, ...}\n"
        },
        {
          "pattern": "tls.CipherSuite{..., TLS_RSA_WITH_AES_128_CBC_SHA256, ...}\n"
        },
        {
          "pattern": "tls.CipherSuite{..., TLS_ECDHE_ECDSA_WITH_RC4_128_SHA, ...}\n"
        },
        {
          "pattern": "tls.CipherSuite{..., TLS_ECDHE_RSA_WITH_RC4_128_SHA, ...}\n"
        },
        {
          "pattern": "tls.CipherSuite{..., TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, ...}\n"
        },
        {
          "pattern": "tls.CipherSuite{..., TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256, ...}\n"
        },
        {
          "pattern": "tls.CipherSuite{..., TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256, ...}\n"
        }
      ]
    },
    {
      "id": "go.lang.security.audit.crypto.use_of_weak_crypto.use-of-DES",
      "message": "DES (Data Encryption Standard) cipher algorithm is being used, which is considered insecure. DES uses a small key size (56 bits) that can be brute-forced with modern hardware. It has been deprecated and should not be used in any new applications.",
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "source-rule-url": "https://github.com/securego/gosec#available-rules",
        "category": "security",
        "technology": [
          "go"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Deprecated DES encryption algorithm",
        "fix-suggestion": "Replace DES with AES by using `cipher.NewCBCEncrypter(block, iv)` where `block` is created with `aes.NewCipher(key)`. Ensure you're using a proper key size (at least 128 bits) and secure mode of operation (like GCM). Remove all references to DES in your codebase."
      },
      "patterns": [
        {
          "pattern-inside": "import \"crypto/des\"\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "des.NewTripleDESCipher(...)\n"
            },
            {
              "pattern": "des.NewCipher(...)\n"
            }
          ]
        }
      ]
    },
    {
      "id": "go.lang.security.audit.crypto.use_of_weak_crypto.use-of-md5",
      "message": "MD5 hash algorithm is being used, which is considered cryptographically broken. MD5 is not collision-resistant, making it unsuitable for digital signatures, certificate validation, or other security purposes. Its use in security contexts can lead to forgery attacks.",
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-328: Use of Weak Hash"
        ],
        "source-rule-url": "https://github.com/securego/gosec#available-rules",
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "MEDIUM",
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Hashing Algorithm"
        ],
        "short-description": "Cryptographically broken MD5 hash algorithm",
        "fix-suggestion": "Replace MD5 with SHA-256 or SHA-3. Use `crypto/sha256.New()` or `golang.org/x/crypto/sha3.New256()` instead of `crypto/md5.New()`. For password hashing specifically, use specialized functions like bcrypt from `golang.org/x/crypto/bcrypt` package."
      },
      "patterns": [
        {
          "pattern-inside": "import \"crypto/md5\"\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "md5.New()\n"
            },
            {
              "pattern": "md5.Sum(...)\n"
            }
          ]
        }
      ]
    },
    {
      "id": "go.lang.security.audit.crypto.use_of_weak_crypto.use-of-rc4",
      "message": "RC4 cipher algorithm is being used, which has multiple known vulnerabilities. RC4 has biases in its keystream that can lead to plaintext recovery in certain scenarios. It has been deprecated by security standards and should not be used.",
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "source-rule-url": "https://github.com/securego/gosec#available-rules",
        "category": "security",
        "technology": [
          "go"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Broken RC4 stream cipher algorithm",
        "fix-suggestion": "Replace RC4 with AES in a secure mode like GCM. Use `cipher.NewGCM(aes.NewCipher(key))` for authenticated encryption. If you need a stream cipher, consider ChaCha20-Poly1305 from `golang.org/x/crypto/chacha20poly1305`. Remove all RC4 usage from your codebase."
      },
      "patterns": [
        {
          "pattern-inside": "import \"crypto/rc4\"\n...\n"
        },
        {
          "pattern": "rc4.NewCipher(...)"
        }
      ]
    },
    {
      "id": "go.lang.security.audit.crypto.use_of_weak_crypto.use-of-sha1",
      "message": "SHA1 hash algorithm is being used, which is no longer considered secure. SHA1 is not collision-resistant, making it unsuitable for cryptographic signatures and other security applications. Practical attacks against SHA1 have been demonstrated.",
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-328: Use of Weak Hash"
        ],
        "source-rule-url": "https://github.com/securego/gosec#available-rules",
        "category": "security",
        "technology": [
          "go"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Hashing Algorithm"
        ],
        "short-description": "Collision-vulnerable SHA1 hash algorithm",
        "fix-suggestion": "Replace SHA1 with SHA-256 or SHA-3. Use `crypto/sha256.New()` or `golang.org/x/crypto/sha3.New256()` instead of `crypto/sha1.New()`. For password hashing, use specialized functions like bcrypt from the `golang.org/x/crypto/bcrypt` package."
      },
      "patterns": [
        {
          "pattern-inside": "import \"crypto/sha1\"\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "sha1.New()\n"
            },
            {
              "pattern": "sha1.Sum(...)\n"
            }
          ]
        }
      ]
    },
    {
      "id": "go.lang.security.audit.crypto.use_of_weak_rsa_key.use-of-weak-rsa-key",
      "message": "An RSA key smaller than 2048 bits is being used. Short RSA keys can be factored with sufficient computing resources, compromising the security of encrypted data or digital signatures. RSA key strength directly impacts the security of cryptographic operations.",
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "metadata": {
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://github.com/securego/gosec/blob/master/rules/rsa.go",
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#algorithms"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "HIGH",
        "subcategory": [
          "audit"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Insufficient RSA key size",
        "fix-suggestion": "Increase RSA key size to at least 2048 bits, preferably 4096 bits for long-term security. Update key generation code to use sufficient bit sizes: `rsa.GenerateKey(rand, 2048)`. Consider using modern elliptic curve cryptography instead of RSA where appropriate."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "rsa.GenerateKey(..., $BITS)\n"
            },
            {
              "pattern": "rsa.GenerateMultiPrimeKey(..., $BITS)\n"
            }
          ]
        },
        {
          "metavariable-comparison": {
            "metavariable": "$BITS",
            "comparison": "$BITS < 2048"
          }
        },
        {
          "focus-metavariable": [
            "$BITS"
          ]
        }
      ],
      "fix": "2048\n"
    },
    {
      "id": "go.lang.security.audit.database.string-formatted-query.string-formatted-query",
      "languages": [
        "go"
      ],
      "message": "Constructing SQL queries using string formatting or concatenation with user input allows attackers to modify the query structure through specially crafted inputs. This SQL injection vulnerability can lead to unauthorized data access, data manipulation, or complete database compromise. Use parameterized queries to properly separate SQL code from user data and prevent injection attacks.",
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "source-rule-url": "https://github.com/securego/gosec",
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "String-formatted SQL queries enable injection vulnerabilities",
        "fix-suggestion": "Replace string formatting in SQL queries with `database/sql` package's prepared statements and placeholders. Use `db.Query(\"SELECT * FROM users WHERE username = ?\", username)` instead of direct concatenation like `db.Query(\"SELECT * FROM users WHERE username = '\" + username + \"'\")`. This ensures proper escaping of values and prevents SQL injection attacks."
      },
      "patterns": [
        {
          "metavariable-regex": {
            "metavariable": "$OBJ",
            "regex": "(?i).*(db|database)"
          }
        },
        {
          "pattern-not-inside": "$VAR = \"...\" + \"...\"\n...\n$OBJ.$SINK(..., $VAR, ...)\n"
        },
        {
          "pattern-not": "$OBJ.Exec(\"...\")"
        },
        {
          "pattern-not": "$OBJ.ExecContext($CTX, \"...\")"
        },
        {
          "pattern-not": "$OBJ.Query(\"...\")"
        },
        {
          "pattern-not": "$OBJ.QueryContext($CTX, \"...\")"
        },
        {
          "pattern-not": "$OBJ.QueryRow(\"...\")"
        },
        {
          "pattern-not": "$OBJ.QueryRow($CTX, \"...\")"
        },
        {
          "pattern-not": "$OBJ.QueryRowContext($CTX, \"...\")"
        },
        {
          "pattern-either": [
            {
              "pattern": "$OBJ.Exec($X + ...)"
            },
            {
              "pattern": "$OBJ.ExecContext($CTX, $X + ...)"
            },
            {
              "pattern": "$OBJ.Query($X + ...)"
            },
            {
              "pattern": "$OBJ.QueryContext($CTX, $X + ...)"
            },
            {
              "pattern": "$OBJ.QueryRow($X + ...)"
            },
            {
              "pattern": "$OBJ.QueryRow($CTX, $X + ...)"
            },
            {
              "pattern": "$OBJ.QueryRowContext($CTX, $X + ...)"
            },
            {
              "pattern": "$OBJ.Exec(fmt.$P(\"...\", ...))"
            },
            {
              "pattern": "$OBJ.ExecContext($CTX, fmt.$P(\"...\", ...))"
            },
            {
              "pattern": "$OBJ.Query(fmt.$P(\"...\", ...))"
            },
            {
              "pattern": "$OBJ.QueryContext($CTX, fmt.$P(\"...\", ...))"
            },
            {
              "pattern": "$OBJ.QueryRow(fmt.$P(\"...\", ...))"
            },
            {
              "pattern": "$OBJ.QueryRow($CTX, fmt.$U(\"...\", ...))"
            },
            {
              "pattern": "$OBJ.QueryRowContext($CTX, fmt.$P(\"...\", ...))"
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "$QUERY = fmt.Fprintf($F, \"$SQLSTR\", ...)"
                    },
                    {
                      "pattern": "$QUERY = fmt.Sprintf(\"$SQLSTR\", ...)"
                    },
                    {
                      "pattern": "$QUERY = fmt.Printf(\"$SQLSTR\", ...)"
                    },
                    {
                      "pattern": "$QUERY = $X + ..."
                    }
                  ]
                },
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "func $FUNC(...) {\n    ...\n    $OBJ.Query($QUERY, ...)\n    ...\n}\n"
                    },
                    {
                      "pattern-inside": "func $FUNC(...) {\n    ...\n    $OBJ.ExecContext($CTX, $QUERY, ...)\n    ...\n}\n"
                    },
                    {
                      "pattern-inside": "func $FUNC(...) {\n    ...\n    $OBJ.Exec($QUERY, ...)\n    ...\n}\n"
                    },
                    {
                      "pattern-inside": "func $FUNC(...) {\n    ...\n    $OBJ.QueryRow($CTX, $QUERY)\n    ...\n}\n"
                    },
                    {
                      "pattern-inside": "func $FUNC(...) {\n    ...\n    $OBJ.QueryRow($QUERY)\n    ...\n}\n"
                    },
                    {
                      "pattern-inside": "func $FUNC(...) {\n    ...\n    $OBJ.QueryContext($CTX, $QUERY)\n    ...\n}\n"
                    },
                    {
                      "pattern-inside": "func $FUNC(...) {\n    ...\n    $OBJ.QueryRowContext($CTX, $QUERY, ...)\n    ...\n}\n"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "go.lang.security.audit.net.cookie-missing-httponly.cookie-missing-httponly",
      "patterns": [
        {
          "pattern-not-inside": "http.Cookie{\n  ...,\n  HttpOnly: true,\n  ...,\n}\n"
        },
        {
          "pattern": "http.Cookie{\n  ...,\n}\n"
        }
      ],
      "message": "A session cookie is created without the 'HttpOnly' flag. This allows client-side scripts to access the cookie, increasing the risk of session hijacking through cross-site scripting (XSS) attacks. Session cookies with authentication data should always have the HttpOnly flag set.",
      "metadata": {
        "cwe": [
          "CWE-1004: Sensitive Cookie Without 'HttpOnly' Flag"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "references": [
          "https://github.com/0c34/govwa/blob/139693e56406b5684d2a6ae22c0af90717e149b8/util/cookie.go",
          "https://golang.org/src/net/http/cookie.go"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "MEDIUM",
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cookie Security"
        ],
        "short-description": "Session cookie accessible by client-side scripts",
        "fix-suggestion": "Set the `HttpOnly` flag to `true` in your cookie: `cookie.HttpOnly = true`. This prevents JavaScript from accessing the cookie content, reducing XSS risks. Always configure both HttpOnly and Secure flags for any cookies containing sensitive information."
      },
      "fix-regex": {
        "regex": "(HttpOnly\\s*:\\s+)false",
        "replacement": "\\1true"
      },
      "severity": "WARNING",
      "languages": [
        "go"
      ]
    },
    {
      "id": "go.lang.security.audit.net.cookie-missing-secure.cookie-missing-secure",
      "patterns": [
        {
          "pattern-not-inside": "http.Cookie{\n  ...,\n  Secure: true,\n  ...,\n}\n"
        },
        {
          "pattern": "http.Cookie{\n  ...,\n}\n"
        }
      ],
      "message": "A session cookie is created without the 'Secure' flag. This allows the cookie to be transmitted over unencrypted HTTP connections, exposing it to network eavesdropping. Session cookies should only be sent over HTTPS connections to prevent interception.",
      "metadata": {
        "cwe": [
          "CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "references": [
          "https://github.com/0c34/govwa/blob/139693e56406b5684d2a6ae22c0af90717e149b8/util/cookie.go",
          "https://golang.org/src/net/http/cookie.go"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "MEDIUM",
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cookie Security"
        ],
        "short-description": "Cookie transmitted over insecure connections",
        "fix-suggestion": "Set the `Secure` flag to `true` in your cookie: `cookie.Secure = true`. This ensures cookies are only transmitted over HTTPS connections. Configure both Secure and HttpOnly flags together for comprehensive cookie protection."
      },
      "fix-regex": {
        "regex": "(Secure\\s*:\\s+)false",
        "replacement": "\\1true"
      },
      "severity": "WARNING",
      "languages": [
        "go"
      ]
    },
    {
      "id": "go.lang.security.audit.net.dynamic-httptrace-clienttrace.dynamic-httptrace-clienttrace",
      "message": "A potentially dynamic ClientTrace is detected for HTTP request tracing. Dynamic ClientTraces can execute arbitrary functions when request events occur, posing a security risk. If an attacker can influence the trace configuration, they could execute code without your knowledge or control.",
      "metadata": {
        "cwe": [
          "CWE-913: Improper Control of Dynamically-Managed Code Resources"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "references": [
          "https://github.com/returntocorp/semgrep-rules/issues/518"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "MEDIUM",
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Security risk with dynamic HTTP request tracing",
        "fix-suggestion": "Use statically defined ClientTrace objects instead of dynamically generated ones. Ensure that any function callbacks in the ClientTrace are defined at compile time. Avoid passing ClientTrace objects directly from user-controllable sources or using reflection to create them."
      },
      "patterns": [
        {
          "pattern-not-inside": "package $PACKAGE\n...\n&httptrace.ClientTrace { ... }\n...\n"
        },
        {
          "pattern": "httptrace.WithClientTrace($ANY, $TRACE)"
        }
      ],
      "severity": "WARNING",
      "languages": [
        "go"
      ]
    },
    {
      "id": "go.lang.security.audit.net.formatted-template-string.formatted-template-string",
      "message": "Using formatted strings with template.HTML() bypasses Go's HTML escaping mechanisms, treating the content as pre-trusted HTML. If this formatted string contains user input, attackers can inject malicious scripts that execute in users' browsers. Either avoid template.HTML() entirely or ensure any dynamic content is properly sanitized before insertion.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://golang.org/pkg/html/template/#HTML"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "MEDIUM",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Unescaped template.HTML usage might lead to XSS",
        "fix-suggestion": "Avoid using `template.HTML()` with dynamically formatted strings in Go templates. Use the standard template package's automatic escaping by rendering data within proper context. If necessary, sanitize content with a trusted library like `bluemonday` before using `template.HTML()`."
      },
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-not": "template.HTML(\"...\" + \"...\")"
        },
        {
          "pattern-either": [
            {
              "pattern": "template.HTML($T + $X, ...)"
            },
            {
              "pattern": "template.HTML(fmt.$P(\"...\", ...), ...)"
            },
            {
              "pattern": "$T = \"...\"\n...\n$T = $FXN(..., $T, ...)\n...\ntemplate.HTML($T, ...)\n"
            },
            {
              "pattern": "$T = fmt.$P(\"...\", ...)\n...\ntemplate.HTML($T, ...)\n"
            },
            {
              "pattern": "$T, $ERR = fmt.$P(\"...\", ...)\n...\ntemplate.HTML($T, ...)\n"
            },
            {
              "pattern": "$T = $X + $Y\n...\ntemplate.HTML($T, ...)\n"
            },
            {
              "pattern": "$T = \"...\"\n...\n$OTHER, $ERR = fmt.$P(..., $T, ...)\n...\ntemplate.HTML($OTHER, ...)"
            }
          ]
        }
      ]
    },
    {
      "id": "go.lang.security.audit.net.unescaped-data-in-htmlattr.unescaped-data-in-htmlattr",
      "message": "Passing unsanitized data to template.HTMLAttr() bypasses Go's attribute escaping, treating the content as pre-trusted HTML attribute values. Attackers can exploit this to inject malicious attribute values that trigger JavaScript execution or modify element behavior. Properly sanitize any dynamic data before using it with template.HTMLAttr() to prevent cross-site scripting (XSS) attacks.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://golang.org/pkg/html/template/#HTMLAttr"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "template.HTMLAttr with untrusted data can allow XSS",
        "fix-suggestion": "Never pass unsanitized data to `template.HTMLAttr()` in Go templates. Use the standard template package's automatic escaping mechanisms instead of manually constructing attribute values. Validate user input against a strict allowlist of permitted attribute values to prevent XSS attacks."
      },
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "template.HTMLAttr($T + $X, ...)"
        },
        {
          "pattern": "template.HTMLAttr(fmt.$P(\"...\", ...), ...)"
        },
        {
          "pattern": "$T = \"...\"\n...\n$T = $FXN(..., $T, ...)\n...\ntemplate.HTMLAttr($T, ...)\n"
        },
        {
          "pattern": "$T = fmt.$P(\"...\", ...)\n...\ntemplate.HTMLAttr($T, ...)\n"
        },
        {
          "pattern": "$T, $ERR = fmt.$P(\"...\", ...)\n...\ntemplate.HTMLAttr($T, ...)\n"
        },
        {
          "pattern": "$T = $X + $Y\n...\ntemplate.HTMLAttr($T, ...)\n"
        },
        {
          "pattern": "$T = \"...\"\n...\n$OTHER, $ERR = fmt.$P(..., $T, ...)\n...\ntemplate.HTMLAttr($OTHER, ...)"
        }
      ]
    },
    {
      "id": "go.lang.security.audit.net.unescaped-data-in-js.unescaped-data-in-js",
      "message": "Using template.JS() with unsanitized input treats the content as pre-trusted JavaScript code, bypassing normal escaping. Attackers can exploit this to inject arbitrary JavaScript that executes in users' browsers with full page access. Either avoid template.JS() entirely or ensure any dynamic content is properly validated and sanitized before insertion.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://golang.org/pkg/html/template/#JS"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "template.JS with unsanitized input can trigger XSS",
        "fix-suggestion": "Never use `template.JS()` with user-controlled input in Go templates. Use `JSON.stringify()` to safely serialize data for JavaScript contexts and pass through standard template mechanisms. Consider a dedicated JavaScript sanitization library for dynamic script generation."
      },
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "template.JS($T + $X, ...)"
        },
        {
          "pattern": "template.JS(fmt.$P(\"...\", ...), ...)"
        },
        {
          "pattern": "$T = \"...\"\n...\n$T = $FXN(..., $T, ...)\n...\ntemplate.JS($T, ...)\n"
        },
        {
          "pattern": "$T = fmt.$P(\"...\", ...)\n...\ntemplate.JS($T, ...)\n"
        },
        {
          "pattern": "$T, $ERR = fmt.$P(\"...\", ...)\n...\ntemplate.JS($T, ...)\n"
        },
        {
          "pattern": "$T = $X + $Y\n...\ntemplate.JS($T, ...)\n"
        },
        {
          "pattern": "$T = \"...\"\n...\n$OTHER, $ERR = fmt.$P(..., $T, ...)\n...\ntemplate.JS($OTHER, ...)\n"
        }
      ]
    },
    {
      "id": "go.lang.security.audit.net.unescaped-data-in-url.unescaped-data-in-url",
      "message": "Passing unsanitized user data to template.URL() bypasses URL escaping, treating the content as a pre-trusted URL. This allows attackers to inject javascript: URIs or other malicious URL schemes that can lead to XSS or information disclosure. Validate URL schemes and properly sanitize any dynamic content before using template.URL() functions.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://golang.org/pkg/html/template/#URL"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "template.URL with user data can cause XSS or data leakage",
        "fix-suggestion": "Avoid using `template.URL()` with user-supplied data in Go templates. Validate URLs using the `net/url` package to ensure they contain only safe schemes and proper formatting. Use `url.QueryEscape()` for query parameters and validate all components separately before assembly."
      },
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "template.URL($T + $X, ...)"
        },
        {
          "pattern": "template.URL(fmt.$P(\"...\", ...), ...)"
        },
        {
          "pattern": "$T = \"...\"\n...\n$T = $FXN(..., $T, ...)\n...\ntemplate.URL($T, ...)\n"
        },
        {
          "pattern": "$T = fmt.$P(\"...\", ...)\n...\ntemplate.URL($T, ...)\n"
        },
        {
          "pattern": "$T, $ERR = fmt.$P(\"...\", ...)\n...\ntemplate.URL($T, ...)\n"
        },
        {
          "pattern": "$T = $X + $Y\n...\ntemplate.URL($T, ...)\n"
        },
        {
          "pattern": "$T = \"...\"\n...\n$OTHER, $ERR = fmt.$P(..., $T, ...)\n...\ntemplate.URL($OTHER, ...)"
        }
      ]
    },
    {
      "id": "go.lang.security.audit.net.use-tls.use-tls",
      "pattern": "http.ListenAndServe($ADDR, $HANDLER)",
      "fix": "http.ListenAndServeTLS($ADDR, certFile, keyFile, $HANDLER)",
      "metadata": {
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "references": [
          "https://golang.org/pkg/net/http/#ListenAndServeTLS"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "MEDIUM",
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "HTTP server without TLS encryption",
        "fix-suggestion": "Replace `http.ListenAndServe()` with `http.ListenAndServeTLS()` to enable HTTPS. Generate proper TLS certificates using tools like Let's Encrypt. Configure proper TLS settings including recent protocol versions and strong cipher suites in your server configuration."
      },
      "message": "An HTTP server is configured without TLS encryption. Unencrypted HTTP traffic can be intercepted, read, and modified by attackers on the network. Sensitive data transmitted over plain HTTP is vulnerable to eavesdropping and tampering.",
      "languages": [
        "go"
      ],
      "severity": "WARNING"
    },
    {
      "id": "go.lang.security.audit.net.wip-xss-using-responsewriter-and-printf.wip-xss-using-responsewriter-and-printf",
      "patterns": [
        {
          "pattern-inside": "func $FUNC(..., $W http.ResponseWriter, ...) {\n  ...\n  var $TEMPLATE = \"...\"\n  ...\n  $W.Write([]byte(fmt.$PRINTF($TEMPLATE, ...)), ...)\n  ...\n}\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "$PARAMS = r.URL.Query()\n...\n$DATA, $ERR := $PARAMS[...]\n...\n$INTERM = $ANYTHING(..., $DATA, ...)\n...\n$W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))\n"
            },
            {
              "pattern": "$PARAMS = r.URL.Query()\n...\n$DATA, $ERR := $PARAMS[...]\n...\n$INTERM = $DATA[...]\n...\n$W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))\n"
            },
            {
              "pattern": "$DATA, $ERR := r.URL.Query()[...]\n...\n$INTERM = $DATA[...]\n...\n$W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))\n"
            },
            {
              "pattern": "$DATA, $ERR := r.URL.Query()[...]\n...\n$INTERM = $ANYTHING(..., $DATA, ...)\n...\n$W.Write([]byte(fmt.$PRINTF(..., $INTERM, ...)))\n"
            },
            {
              "pattern": "$PARAMS = r.URL.Query()\n...\n$DATA, $ERR := $PARAMS[...]\n...\n$W.Write([]byte(fmt.$PRINTF(..., $DATA, ...)))\n"
            }
          ]
        }
      ],
      "message": "Writing URL query parameters directly to HTTP responses without proper escaping allows attackers to inject malicious HTML or JavaScript code. This cross-site scripting (XSS) vulnerability can lead to session hijacking, credential theft, or other client-side attacks. Use proper HTML templating with automatic escaping to ensure all user-supplied data is safely encoded before output.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "MEDIUM",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Direct writing of unescaped data to HTTP response leads to XSS",
        "fix-suggestion": "Replace direct writing to `ResponseWriter` with the `html/template` package for proper escaping. Never use `fmt.Fprintf()` with `ResponseWriter` and user input without proper escaping. If direct writing is necessary, ensure all user data is encoded with `html.EscapeString()` before output."
      },
      "severity": "WARNING",
      "languages": [
        "go"
      ]
    },
    {
      "id": "go.lang.security.audit.net.bind_all.avoid-bind-to-all-interfaces",
      "message": "The network listener is configured to bind to 0.0.0.0 or an empty string, which listens on all available network interfaces. This unnecessarily exposes the server to external networks when it may only need to be accessible locally. Binding to all interfaces increases the attack surface.",
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "metadata": {
        "cwe": [
          "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "source-rule-url": "https://github.com/securego/gosec",
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "HIGH",
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Server exposed on all network interfaces",
        "fix-suggestion": "Specify a specific IP address instead of using `0.0.0.0` or empty string. Use `127.0.0.1` for services that should only be accessible locally. For public services, consider using a reverse proxy or load balancer to control access and implement additional security measures."
      },
      "pattern-either": [
        {
          "pattern": "tls.Listen($NETWORK, \"=~/^0.0.0.0:.*$/\", ...)"
        },
        {
          "pattern": "net.Listen($NETWORK, \"=~/^0.0.0.0:.*$/\", ...)"
        },
        {
          "pattern": "tls.Listen($NETWORK, \"=~/^:.*$/\", ...)"
        },
        {
          "pattern": "net.Listen($NETWORK, \"=~/^:.*$/\", ...)"
        }
      ]
    },
    {
      "id": "go.lang.security.audit.net.pprof.pprof-debug-exposure",
      "metadata": {
        "cwe": [
          "CWE-489: Active Debug Code"
        ],
        "owasp": "A06:2017 - Security Misconfiguration",
        "source-rule-url": "https://github.com/securego/gosec#available-rules",
        "references": [
          "https://www.farsightsecurity.com/blog/txt-record/go-remote-profiling-20161028/"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "LOW",
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Active Debug Code"
        ],
        "short-description": "Exposed debugging information via pprof",
        "fix-suggestion": "Import pprof explicitly with `import \"net/http/pprof\"` instead of accessing the auto-exposed endpoints. Restrict access to pprof endpoints using authentication middleware or network controls. Consider disabling pprof in production or binding it to a separate port on localhost only."
      },
      "message": "The Go pprof debugging endpoints are automatically exposed at /debug/pprof when imported. These endpoints provide detailed information about your application's internals, including memory usage, goroutines, and execution traces. This information can help attackers understand and exploit your application.",
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "import _ \"net/http/pprof\"\n...\n"
        },
        {
          "pattern-inside": "func $ANY(...) {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "$MUX = http.NewServeMux(...)\n...\nhttp.ListenAndServe($ADDR, $MUX)\n"
        },
        {
          "pattern-not": "http.ListenAndServe(\"=~/^localhost.*/\", ...)"
        },
        {
          "pattern-not": "http.ListenAndServe(\"=~/^127[.]0[.]0[.]1.*/\", ...)"
        },
        {
          "pattern": "http.ListenAndServe(...)"
        }
      ]
    },
    {
      "id": "go.lang.security.audit.sqli.gosql-sqli.gosql-sqli",
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern": "$DB.$METHOD(...,$QUERY,...)"
                },
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "$QUERY = $X + $Y\n...\n"
                    },
                    {
                      "pattern-inside": "$QUERY += $X\n...\n"
                    },
                    {
                      "pattern-inside": "$QUERY = fmt.Sprintf(\"...\", $PARAM1, ...)\n...\n"
                    }
                  ]
                },
                {
                  "pattern-not-inside": "$QUERY += \"...\"\n...\n"
                },
                {
                  "pattern-not-inside": "$QUERY = \"...\" + \"...\"\n...\n"
                }
              ]
            },
            {
              "pattern": "$DB.$METHOD(..., $X + $Y, ...)"
            },
            {
              "pattern": "$DB.$METHOD(..., fmt.Sprintf(\"...\", $PARAM1, ...), ...)"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "$DB, ... = sql.Open(...)\n...\n"
            },
            {
              "pattern-inside": "func $FUNCNAME(..., $DB *sql.DB, ...) {\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern-not": "$DB.$METHOD(..., \"...\" + \"...\", ...)"
        },
        {
          "metavariable-regex": {
            "metavariable": "$METHOD",
            "regex": "^(Exec|ExecContent|Query|QueryContext|QueryRow|QueryRowContext)$"
          }
        }
      ],
      "languages": [
        "go"
      ],
      "message": "Constructing SQL queries by concatenating user-supplied data in Go's database/sql package allows attackers to inject malicious SQL syntax. This SQL injection vulnerability can lead to unauthorized data access, data manipulation, or privilege escalation. Use prepared statements with parameterized queries to safely separate SQL code from user input data.",
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "references": [
          "https://golang.org/pkg/database/sql/"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "LOW",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "SQL injection risk from concatenated queries in database/sql",
        "fix-suggestion": "Replace string concatenation in SQL queries with prepared statements using the `database/sql` package. Convert `db.Query(\"SELECT * FROM users WHERE name = '\" + userName + \"'\")` to `db.Query(\"SELECT * FROM users WHERE name = ?\", userName)`. This ensures proper escaping of user values and prevents SQL injection attacks."
      },
      "severity": "ERROR"
    },
    {
      "id": "go.lang.security.audit.sqli.pg-orm-sqli.pg-orm-sqli",
      "patterns": [
        {
          "pattern-inside": "import (\n  ...\n  \"$IMPORT\"\n)\n...\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$IMPORT",
            "regex": ".*go-pg"
          }
        },
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern": "$DB.$METHOD(...,$QUERY,...)"
                },
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "$QUERY = $X + $Y\n...\n"
                    },
                    {
                      "pattern-inside": "$QUERY += $X\n...\n"
                    },
                    {
                      "pattern-inside": "$QUERY = fmt.Sprintf(\"...\", $PARAM1, ...)\n...\n"
                    }
                  ]
                },
                {
                  "pattern-not-inside": "$QUERY += \"...\"\n...\n"
                },
                {
                  "pattern-not-inside": "$QUERY = \"...\" + \"...\"\n...\n"
                }
              ]
            },
            {
              "pattern": "$DB.$INTFUNC1(...).$METHOD(..., $X + $Y, ...).$INTFUNC2(...)\n"
            },
            {
              "pattern": "$DB.$METHOD(..., fmt.Sprintf(\"...\", $PARAM1, ...), ...)\n"
            },
            {
              "pattern-inside": "$DB = pg.Connect(...)\n...\n"
            },
            {
              "pattern-inside": "func $FUNCNAME(..., $DB *pg.DB, ...) {\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern-not-inside": "$QUERY = fmt.Sprintf(\"...\", ...,\"...\", ...)\n...\n"
        },
        {
          "pattern-not-inside": "$QUERY += \"...\"\n...\n"
        },
        {
          "pattern-not": "$DB.$METHOD(...,\"...\",...)"
        },
        {
          "pattern-not": "$DB.$INTFUNC1(...).$METHOD(..., \"...\", ...).$INTFUNC2(...)\n"
        },
        {
          "pattern-not-inside": "$QUERY = \"...\" + \"...\"\n"
        },
        {
          "pattern-not": "\"...\"\n"
        },
        {
          "pattern-not": "path.Join(...)"
        },
        {
          "pattern-not": "filepath.Join(...)"
        },
        {
          "metavariable-regex": {
            "metavariable": "$METHOD",
            "regex": "^(Where|WhereOr|Join|GroupExpr|OrderExpr|ColumnExpr)$"
          }
        }
      ],
      "languages": [
        "go"
      ],
      "message": "Directly embedding user input into SQL queries in the go-pg ORM bypasses the ORM's safety mechanisms, allowing SQL injection attacks. Attackers can modify query logic to access unauthorized data, manipulate database contents, or escalate privileges. Use the ORM's parameter binding mechanisms rather than string concatenation to safely incorporate user data into queries.",
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "references": [
          "https://pg.uptrace.dev/queries/"
        ],
        "category": "security",
        "technology": [
          "go-pg"
        ],
        "confidence": "LOW",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "go-pg ORM string concatenation can cause SQL injection",
        "fix-suggestion": "Use go-pg ORM's parameter binding instead of embedding user input directly in SQL strings. Replace `db.Model(&user).Where(\"email = '\" + email + \"'\")` with `db.Model(&user).Where(\"email = ?\", email)` or named parameters with `pg.Params`. This ensures all input values are properly escaped to prevent SQL injection."
      },
      "severity": "ERROR"
    },
    {
      "id": "go.lang.security.audit.sqli.pg-sqli.pg-sqli",
      "languages": [
        "go"
      ],
      "message": "Building SQL queries in go-pg by concatenating strings with user input allows attackers to inject SQL syntax that modifies query behavior. This SQL injection vulnerability can lead to unauthorized data access, data manipulation, or privilege escalation. Use parameterized queries with placeholders to safely separate SQL code from user-supplied data.",
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "references": [
          "https://pg.uptrace.dev/",
          "https://pkg.go.dev/github.com/go-pg/pg/v10"
        ],
        "category": "security",
        "technology": [
          "go-pg"
        ],
        "confidence": "LOW",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "String concatenation in go-pg queries may lead to injection",
        "fix-suggestion": "Replace string concatenation in go-pg queries with parameterized queries using placeholders. Use `db.Query(\"SELECT * FROM users WHERE email = ?\", email)` instead of concatenation like `db.Query(\"SELECT * FROM users WHERE email = '\" + email + \"'\")`. For complex queries, use named parameters with `pg.Params` to ensure proper escaping of all input values."
      },
      "severity": "ERROR",
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern": "$DB.$METHOD(...,$QUERY,...)\n"
                },
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "$QUERY = $X + $Y\n...\n"
                    },
                    {
                      "pattern-inside": "$QUERY += $X\n...\n"
                    },
                    {
                      "pattern-inside": "$QUERY = fmt.Sprintf(\"...\", $PARAM1, ...)\n...\n"
                    }
                  ]
                },
                {
                  "pattern-not-inside": "$QUERY += \"...\"\n...\n"
                },
                {
                  "pattern-not-inside": "$QUERY = \"...\" + \"...\"\n...\n"
                }
              ]
            },
            {
              "pattern": "$DB.$METHOD(..., $X + $Y, ...)"
            },
            {
              "pattern": "$DB.$METHOD(..., fmt.Sprintf(\"...\", $PARAM1, ...), ...)"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "$DB = pg.Connect(...)\n...\n"
            },
            {
              "pattern-inside": "func $FUNCNAME(..., $DB *pg.DB, ...) {\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern-not": "$DB.$METHOD(..., \"...\" + \"...\", ...)"
        },
        {
          "metavariable-regex": {
            "metavariable": "$METHOD",
            "regex": "^(Exec|ExecContext|ExecOne|ExecOneContext|Query|QueryOne|QueryContext|QueryOneContext)$"
          }
        }
      ]
    },
    {
      "id": "go.lang.security.audit.sqli.pgx-sqli.pgx-sqli",
      "languages": [
        "go"
      ],
      "message": "Constructing pgx SQL queries by concatenating user input allows attackers to modify the query structure through specially crafted inputs. This SQL injection vulnerability can lead to unauthorized data access, data manipulation, or complete database compromise. Use parameterized queries with placeholders to separate SQL code from user-supplied data.",
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "references": [
          "https://github.com/jackc/pgx",
          "https://pkg.go.dev/github.com/jackc/pgx/v4#hdr-Connection_Pool"
        ],
        "category": "security",
        "technology": [
          "pgx"
        ],
        "confidence": "LOW",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Unparameterized pgx queries risk SQL injection",
        "fix-suggestion": "Replace string concatenation in pgx queries with parameterized queries using the `$1, $2` placeholder syntax. Convert `conn.Query(\"SELECT * FROM users WHERE email = '\" + email + \"'\")` to `conn.Query(\"SELECT * FROM users WHERE email = $1\", email)`. This ensures proper escaping and prevents SQL injection attacks."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern": "$DB.$METHOD(...,$QUERY,...)"
                },
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "$QUERY = $X + $Y\n...\n"
                    },
                    {
                      "pattern-inside": "$QUERY += $X\n...\n"
                    },
                    {
                      "pattern-inside": "$QUERY = fmt.Sprintf(\"...\", $PARAM1, ...)\n...\n"
                    }
                  ]
                },
                {
                  "pattern-not-inside": "$QUERY += \"...\"\n...\n"
                },
                {
                  "pattern-not-inside": "$QUERY = \"...\" + \"...\"\n...\n"
                }
              ]
            },
            {
              "pattern": "$DB.$METHOD(..., $X + $Y, ...)"
            },
            {
              "pattern": "$DB.$METHOD(..., fmt.Sprintf(\"...\", $PARAM1, ...), ...)"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "$DB, ... = pgx.Connect(...)\n...\n"
            },
            {
              "pattern-inside": "$DB, ... = pgx.NewConnPool(...)\n...\n"
            },
            {
              "pattern-inside": "$DB, ... = pgx.ConnectConfig(...)\n...\n"
            },
            {
              "pattern-inside": "func $FUNCNAME(..., $DB *pgx.Conn, ...) {\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern-not": "$DB.$METHOD(..., \"...\" + \"...\", ...)"
        },
        {
          "metavariable-regex": {
            "metavariable": "$METHOD",
            "regex": "^(Exec|ExecEx|Query|QueryEx|QueryRow|QueryRowEx)$"
          }
        }
      ],
      "severity": "ERROR"
    },
    {
      "id": "go.lang.security.audit.xss.import-text-template.import-text-template",
      "message": "The text/template package renders templates without automatically escaping HTML special characters, unlike html/template. When output is sent to web browsers, this allows attackers to inject malicious scripts through template variables containing crafted input. Use html/template instead for web applications to ensure proper context-aware HTML escaping of user-generated content.",
      "metadata": {
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "references": [
          "https://www.veracode.com/blog/secure-development/use-golang-these-mistakes-could-compromise-your-apps-security"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "text/template lacks autoescaping, can lead to XSS in web apps",
        "fix-suggestion": "Replace the `text/template` package with `html/template` for any templates generating HTML output. Update imports from `import \"text/template\"` to `import \"html/template\"`. For mixed usage, use aliased imports like `import htmltemplate \"html/template\"` to ensure context-aware escaping."
      },
      "severity": "WARNING",
      "patterns": [
        {
          "pattern": "import \"$IMPORT\"\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$IMPORT",
            "regex": "^(text/template)$"
          }
        },
        {
          "focus-metavariable": "$IMPORT"
        }
      ],
      "fix": "html/template\n",
      "languages": [
        "go"
      ]
    },
    {
      "id": "go.lang.security.audit.xss.no-direct-write-to-responsewriter.no-direct-write-to-responsewriter",
      "languages": [
        "go"
      ],
      "message": "Writing content directly to ResponseWriter without HTML escaping allows attackers to inject malicious scripts if that content includes user input. This cross-site scripting (XSS) vulnerability can lead to session hijacking, credential theft, or malicious actions performed in the user's context. Use a proper templating system like html/template that automatically applies context-appropriate escaping.",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://blogtitle.github.io/robn-go-security-pearls-cross-site-scripting-xss/"
        ],
        "technology": [
          "go"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Writing raw data to ResponseWriter can cause XSS",
        "fix-suggestion": "Replace direct writing to `ResponseWriter` with template-based rendering using the `html/template` package. Create proper template structures and use `template.Execute()` for rendering with automatic escaping. If direct writing is necessary, first encode user data with `html.EscapeString()` to prevent XSS attacks."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "func $HANDLER(..., $WRITER http.ResponseWriter, ...) {\n  ...\n}\n"
            },
            {
              "pattern-inside": "func $HANDLER(..., $WRITER *http.ResponseWriter, ...) {\n  ...\n}\n"
            },
            {
              "pattern-inside": "func(..., $WRITER http.ResponseWriter, ...) {\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern": "$WRITER.Write(...)"
            },
            {
              "pattern": "(*$WRITER).Write(...)"
            }
          ]
        },
        {
          "pattern-not": "$WRITER.Write([]byte(\"...\"))"
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "go.lang.security.audit.xss.no-fprintf-to-responsewriter.no-fprintf-to-responsewriter",
      "message": "Using Fprintf to write directly to HTTP responses bypasses HTML escaping, allowing attackers to inject malicious scripts through user-controlled inputs. This cross-site scripting (XSS) vulnerability can lead to session hijacking or unauthorized actions performed in the user's browser. Use a template engine like html/template that automatically applies proper escaping for the output context.",
      "metadata": {
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "references": [
          "https://blogtitle.github.io/robn-go-security-pearls-cross-site-scripting-xss/"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Unescaped printf to HTTP response leads to possible XSS",
        "fix-suggestion": "Replace `fmt.Fprintf` with template-based rendering using the `html/template` package. Create proper template structures and use `template.Execute()` to render with automatic escaping. If direct writing is necessary, ensure all user values are escaped with `html.EscapeString()` before inclusion in format strings."
      },
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "func $HANDLER(..., $WRITER http.ResponseWriter, ...) {\n  ...\n}\n"
            },
            {
              "pattern-inside": "func(..., $WRITER http.ResponseWriter, ...) {\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern-not": "fmt.$PRINTF($WRITER, \"...\")"
        },
        {
          "pattern": "fmt.$PRINTF($WRITER, ...)"
        }
      ],
      "languages": [
        "go"
      ]
    },
    {
      "id": "go.lang.security.audit.xss.no-interpolation-in-tag.no-interpolation-in-tag",
      "message": "Inserting dynamic data directly into HTML tag attributes without proper escaping allows attackers to break out of the attribute context. This cross-site scripting (XSS) vulnerability can lead to execution of injected scripts or manipulation of page behavior. Use a templating system with context-aware escaping or properly encode dynamically generated attribute values.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://github.com/golang/go/issues/19669",
          "https://blogtitle.github.io/robn-go-security-pearls-cross-site-scripting-xss/"
        ],
        "category": "security",
        "technology": [
          "generic"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Direct interpolation into HTML tag attributes can enable XSS",
        "fix-suggestion": "Use the `html/template` package instead of manual string building for HTML content. For manual HTML construction, use appropriate context-specific encoding functions: `html.EscapeString()` for content, `template.HTMLEscapeString()` for attributes, and `url.QueryEscape()` for URL parameters. Never interpolate user data directly into HTML strings."
      },
      "languages": [
        "generic"
      ],
      "severity": "WARNING",
      "paths": {
        "include": [
          "*.html",
          "*.thtml",
          "*.gohtml",
          "*.tmpl",
          "*.tpl"
        ]
      },
      "pattern": "<{{ ... }} ... >"
    },
    {
      "id": "go.lang.security.audit.xss.no-interpolation-js-template-string.no-interpolation-js-template-string",
      "message": "Embedding dynamic values directly into JavaScript template strings without proper escaping allows attackers to break out of the string context. This cross-site scripting (XSS) vulnerability enables execution of injected JavaScript code in the user's browser. Extract dynamic values to separate JavaScript variables with proper encoding or use a templating system with context-aware escaping.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://github.com/golang/go/issues/9200#issuecomment-66100328",
          "https://blogtitle.github.io/robn-go-security-pearls-cross-site-scripting-xss/"
        ],
        "category": "security",
        "technology": [
          "generic"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Unescaped variables in JS template strings create XSS risk",
        "fix-suggestion": "Never embed user data directly in JavaScript template strings. Convert data to JSON with `json.Marshal()` and use it with proper JavaScript handling like `var name = JSON.parse('{{json .UserName}}');`. Define a custom `json` function in templates that safely serializes data for JavaScript contexts."
      },
      "languages": [
        "generic"
      ],
      "severity": "WARNING",
      "paths": {
        "include": [
          "*.html",
          "*.thtml",
          "*.gohtml",
          "*.tmpl",
          "*.tpl"
        ]
      },
      "patterns": [
        {
          "pattern-inside": "<script ...> ... ... ... ... ... </script>"
        },
        {
          "pattern": "` ... {{ ... }} ...`"
        }
      ]
    },
    {
      "id": "go.lang.security.audit.xss.no-io-writestring-to-responsewriter.no-io-writestring-to-responsewriter",
      "message": "Using io.WriteString to send content directly to HTTP responses bypasses HTML escaping if that content includes user-supplied data. This cross-site scripting (XSS) vulnerability allows attackers to inject scripts that execute in users' browsers. Use a template engine like html/template that automatically applies context-appropriate escaping for all output.",
      "metadata": {
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "references": [
          "https://blogtitle.github.io/robn-go-security-pearls-cross-site-scripting-xss/",
          "https://golang.org/pkg/io/#WriteString"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "io.WriteString to response can bypass escaping and allow XSS",
        "fix-suggestion": "Replace direct writing with `io.WriteString` to `ResponseWriter` with template-based rendering using `html/template`. Create proper templates and use `template.Execute()` for automatic escaping. If you must use `io.WriteString`, ensure all user values are properly escaped with `html.EscapeString()` first."
      },
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "func $HANDLER(..., $WRITER http.ResponseWriter, ...) {\n  ...\n}\n"
            },
            {
              "pattern-inside": "func(..., $WRITER http.ResponseWriter, ...) {\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern-not": "io.WriteString($WRITER, \"...\")"
        },
        {
          "pattern": "io.WriteString($WRITER, $STRING)"
        }
      ],
      "languages": [
        "go"
      ]
    },
    {
      "id": "go.lang.security.audit.xss.no-printf-in-responsewriter.no-printf-in-responsewriter",
      "message": "Using printf-like functions to write directly to HTTP responses bypasses HTML escaping for any user-controlled format strings or arguments. This cross-site scripting (XSS) vulnerability allows attackers to inject scripts that execute in the browser context. Use a template engine like html/template that automatically applies proper escaping based on the output context.",
      "metadata": {
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "references": [
          "https://blogtitle.github.io/robn-go-security-pearls-cross-site-scripting-xss/"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Printing unescaped data to HTTP response can cause XSS",
        "fix-suggestion": "Replace printf-style output with template-based rendering using the `html/template` package. Create proper template structures and use `template.Execute()` for automatic escaping. If direct writing is necessary, escape all user values with `html.EscapeString()` before including them in format strings."
      },
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "func $HANDLER(..., $WRITER http.ResponseWriter, ...) {\n  ...\n}\n"
            },
            {
              "pattern-inside": "func(..., $WRITER http.ResponseWriter, ...) {\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern": "$WRITER.Write(<... fmt.$PRINTF(...) ...>, ...)\n"
        }
      ],
      "languages": [
        "go"
      ]
    },
    {
      "id": "go.lang.security.audit.xss.template-html-does-not-escape.unsafe-template-type",
      "message": "Using template.HTML() treats the provided string as pre-trusted HTML that bypasses Go's automatic HTML escaping. If non-constant data reaches this function, attackers can inject malicious scripts that execute in users' browsers. Avoid using template.HTML() with dynamic content, and instead use the standard template.Execute() method with proper automatic escaping.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://golang.org/pkg/html/template/#HTML",
          "https://github.com/0c34/govwa/blob/139693e56406b5684d2a6ae22c0af90717e149b8/vulnerability/xss/xss.go#L33"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "template.HTML with dynamic data leads to XSS vulnerabilities",
        "fix-suggestion": "Avoid using `template.HTML()` entirely, especially with dynamic or user-controlled content. Use standard `html/template` mechanisms that automatically apply context-aware escaping. If formatting is required, use a dedicated HTML sanitization library like `bluemonday` before marking content as trusted."
      },
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-not": "template.$ANY(\"...\" + \"...\")"
        },
        {
          "pattern-not": "template.$ANY(\"...\")"
        },
        {
          "pattern-either": [
            {
              "pattern": "template.HTML(...)"
            },
            {
              "pattern": "template.CSS(...)"
            },
            {
              "pattern": "template.HTMLAttr(...)"
            },
            {
              "pattern": "template.JS(...)"
            },
            {
              "pattern": "template.JSStr(...)"
            },
            {
              "pattern": "template.Srcset(...)"
            },
            {
              "pattern": "template.URL(...)"
            }
          ]
        }
      ]
    },
    {
      "id": "go.lang.security.bad_tmp.bad-tmp-file-creation",
      "message": "Files are being created in a shared temporary directory without using secure creation methods like ioutil.TempFile. This can lead to insecure file operations vulnerable to race conditions, symlink attacks, and unauthorized access. Temporary files need special handling to prevent security issues.",
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "metadata": {
        "cwe": [
          "CWE-377: Insecure Temporary File"
        ],
        "source-rule-url": "https://github.com/securego/gosec",
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "LOW",
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Insecure temporary file creation",
        "fix-suggestion": "Replace manual file creation with `ioutil.TempFile()` which handles security concerns automatically. Use `os.CreateTemp()` in newer Go versions. Ensure proper permissions are set and temp files are cleaned up after use with `defer os.Remove()`."
      },
      "pattern-either": [
        {
          "pattern": "ioutil.WriteFile(\"=~//tmp/.*$/\", ...)"
        },
        {
          "pattern": "os.Create(\"=~//tmp/.*$/\", ...)"
        }
      ]
    },
    {
      "id": "go.lang.security.decompression_bomb.potential-dos-via-decompression-bomb",
      "message": "Decompressing data without size limits can trigger denial-of-service when a small compressed file (zip bomb) expands to an extremely large size, consuming all available memory or disk space. Attackers can craft malicious compressed files with very high compression ratios that expand to gigabytes or terabytes of data. Implement decompression size limits and monitor resource usage to prevent denial-of-service attacks through malicious compressed files.",
      "severity": "WARNING",
      "languages": [
        "go"
      ],
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "io.Copy(...)"
            },
            {
              "pattern": "io.CopyBuffer(...)"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "gzip.NewReader(...)\n...\n"
            },
            {
              "pattern-inside": "zlib.NewReader(...)\n...\n"
            },
            {
              "pattern-inside": "zlib.NewReaderDict(...)\n...\n"
            },
            {
              "pattern-inside": "bzip2.NewReader(...)\n...\n"
            },
            {
              "pattern-inside": "flate.NewReader(...)\n...\n"
            },
            {
              "pattern-inside": "flate.NewReaderDict(...)\n...\n"
            },
            {
              "pattern-inside": "lzw.NewReader(...)\n...\n"
            },
            {
              "pattern-inside": "tar.NewReader(...)\n...\n"
            },
            {
              "pattern-inside": "zip.NewReader(...)\n...\n"
            },
            {
              "pattern-inside": "zip.OpenReader(...)\n...\n"
            }
          ]
        }
      ],
      "fix-regex": {
        "regex": "(.*)(Copy|CopyBuffer)\\((.*?),(.*?)(\\)|,.*\\))",
        "replacement": "\\1CopyN(\\3, \\4, 1024*1024*256)"
      },
      "metadata": {
        "cwe": [
          "CWE-400: Uncontrolled Resource Consumption"
        ],
        "source-rule-url": "https://github.com/securego/gosec",
        "references": [
          "https://golang.org/pkg/io/#CopyN",
          "https://github.com/securego/gosec/blob/master/rules/decompression-bomb.go"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Denial-of-Service (DoS)"
        ],
        "short-description": "Zip bomb could cause denial-of-service via huge decompression",
        "fix-suggestion": "Implement strict resource controls when decompressing untrusted data to prevent DoS attacks. Add size limits by monitoring decompressed output size and abort if it exceeds reasonable thresholds. Use streaming decompression to process data incrementally rather than loading entire archives into memory."
      }
    },
    {
      "id": "go.lang.security.injection.open-redirect.open-redirect",
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "message": "User input is directly used to control HTTP redirect destinations. This open redirect vulnerability allows attackers to craft URLs that appear legitimate but redirect users to malicious websites. Phishing attacks often exploit open redirects to gain user trust.",
      "options": {
        "interfile": true
      },
      "metadata": {
        "cwe": [
          "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')"
        ],
        "references": [
          "https://knowledge-base.secureflag.com/vulnerabilities/unvalidated_redirects___forwards/open_redirect_go_lang.html"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "HIGH",
        "description": "An HTTP redirect was found to be crafted from user-input leading to an open redirect vulnerability",
        "subcategory": [
          "vuln"
        ],
        "impact": "MEDIUM",
        "likelihood": "MEDIUM",
        "interfile": true,
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Open Redirect"
        ],
        "short-description": "Open redirect from user-controlled input",
        "fix-suggestion": "Implement a whitelist of allowed redirect destinations instead of accepting arbitrary URLs. Use Go's `url.Parse()` to validate URLs and check the hostname against allowed domains. Consider using relative URLs only or adding a confirmation page for external redirects."
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "label": "INPUT",
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "($REQUEST : *http.Request).$ANYTHING\n"
                },
                {
                  "pattern": "($REQUEST : http.Request).$ANYTHING\n"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$ANYTHING",
                "regex": "^(BasicAuth|Body|Cookie|Cookies|Form|FormValue|GetBody|Host|MultipartReader|ParseForm|ParseMultipartForm|PostForm|PostFormValue|Referer|RequestURI|Trailer|TransferEncoding|UserAgent|URL)$"
              }
            }
          ]
        },
        {
          "label": "CLEAN",
          "requires": "INPUT",
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "\"$URLSTR\" + $INPUT\n"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "fmt.Fprintf($F, \"$URLSTR\", $INPUT, ...)"
                        },
                        {
                          "pattern": "fmt.Sprintf(\"$URLSTR\", $INPUT, ...)"
                        },
                        {
                          "pattern": "fmt.Printf(\"$URLSTR\", $INPUT, ...)"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$URLSTR",
                "regex": ".*//[a-zA-Z0-10]+\\..*"
              }
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "requires": "INPUT and not CLEAN",
          "patterns": [
            {
              "pattern": "http.Redirect($W, $REQ, $URL, ...)"
            },
            {
              "focus-metavariable": "$URL"
            }
          ]
        }
      ]
    },
    {
      "id": "go.lang.security.injection.raw-html-format.raw-html-format",
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "message": "Manually constructing HTML strings with user input allows attackers to inject malicious scripts if that input isn't properly escaped. This cross-site scripting (XSS) vulnerability can lead to session hijacking, credential theft, or unauthorized actions in the victim's browser. Use a templating system that automatically escapes HTML rather than manual string concatenation for generating HTML content.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "references": [
          "https://blogtitle.github.io/robn-go-security-pearls-cross-site-scripting-xss/"
        ],
        "confidence": "MEDIUM",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Manual HTML building with user input can allow XSS",
        "fix-suggestion": "Replace manual HTML string construction with the `html/template` package for rendering HTML content. Create proper template structures and use `template.Execute()` for automatic escaping. If building HTML strings manually, ensure all user values are properly escaped using `html.EscapeString()` to prevent XSS attacks."
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "($REQUEST : *http.Request).$ANYTHING\n"
                },
                {
                  "pattern": "($REQUEST : http.Request).$ANYTHING\n"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$ANYTHING",
                "regex": "^(BasicAuth|Body|Cookie|Cookies|Form|FormValue|GetBody|Host|MultipartReader|ParseForm|ParseMultipartForm|PostForm|PostFormValue|Referer|RequestURI|Trailer|TransferEncoding|UserAgent|URL)$"
              }
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "pattern": "html.EscapeString(...)"
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "fmt.Printf(\"$HTMLSTR\", ...)"
                },
                {
                  "pattern": "fmt.Sprintf(\"$HTMLSTR\", ...)"
                },
                {
                  "pattern": "fmt.Fprintf($W, \"$HTMLSTR\", ...)"
                },
                {
                  "pattern": "\"$HTMLSTR\" + ..."
                }
              ]
            },
            {
              "metavariable-pattern": {
                "metavariable": "$HTMLSTR",
                "language": "generic",
                "pattern": "<$TAG ..."
              }
            }
          ]
        }
      ]
    },
    {
      "id": "go.lang.security.injection.tainted-sql-string.tainted-sql-string",
      "languages": [
        "go"
      ],
      "message": "Building SQL queries by directly inserting user input into query strings allows attackers to modify the query structure through specially crafted inputs. This SQL injection vulnerability can lead to unauthorized data access, data manipulation, or escalated database privileges. Use parameterized queries or prepared statements to safely separate SQL code from user-supplied data.",
      "options": {
        "interfile": true
      },
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://golang.org/doc/database/sql-injection",
          "https://www.stackhawk.com/blog/golang-sql-injection-guide-examples-and-prevention/"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "HIGH",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "interfile": true,
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "SQL injection from building queries with user input",
        "fix-suggestion": "Replace string concatenation in SQL queries with parameterized queries using placeholders. Convert `db.Query(\"SELECT * FROM users WHERE name = '\" + userName + \"'\")` to `db.Query(\"SELECT * FROM users WHERE name = ?\", userName)`. This ensures proper escaping of all user-supplied values and prevents SQL injection."
      },
      "mode": "taint",
      "severity": "ERROR",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "($REQUEST : *http.Request).$ANYTHING\n"
                },
                {
                  "pattern": "($REQUEST : http.Request).$ANYTHING\n"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$ANYTHING",
                "regex": "^(BasicAuth|Body|Cookie|Cookies|Form|FormValue|GetBody|Host|MultipartReader|ParseForm|ParseMultipartForm|PostForm|PostFormValue|Referer|RequestURI|Trailer|TransferEncoding|UserAgent|URL)$"
              }
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "\"$SQLSTR\" + ...\n"
                        },
                        {
                          "patterns": [
                            {
                              "pattern-inside": "$VAR = \"$SQLSTR\";\n...\n"
                            },
                            {
                              "pattern": "$VAR += ..."
                            }
                          ]
                        },
                        {
                          "patterns": [
                            {
                              "pattern-inside": "var $SB strings.Builder\n...\n"
                            },
                            {
                              "pattern-inside": "$SB.WriteString(\"$SQLSTR\")\n...\n$SB.String(...)\n"
                            },
                            {
                              "pattern": "$SB.WriteString(...)\n"
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$SQLSTR",
                        "regex": "(?i)(select|delete|insert|create|update|alter|drop).*"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "fmt.Fprintf($F, \"$SQLSTR\", ...)"
                        },
                        {
                          "pattern": "fmt.Sprintf(\"$SQLSTR\", ...)"
                        },
                        {
                          "pattern": "fmt.Printf(\"$SQLSTR\", ...)"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$SQLSTR",
                        "regex": "\\s*(?i)(select|delete|insert|create|update|alter|drop)\\b.*%(v|s|q).*"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "pattern-either": [
            {
              "pattern": "strconv.Atoi(...)"
            },
            {
              "pattern": "($X: bool)\n"
            }
          ]
        }
      ]
    },
    {
      "id": "go.lang.security.injection.tainted-url-host.tainted-url-host",
      "languages": [
        "go"
      ],
      "message": "When user input determines the host portion of a URL used in server requests, attackers can redirect requests to malicious or internal servers. This Server-Side Request Forgery (SSRF) vulnerability can lead to internal network scanning, accessing restricted services, or data exfiltration. Validate URL hosts against an allowlist or use fixed host values to prevent request redirection attacks.",
      "options": {
        "interfile": true
      },
      "metadata": {
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "references": [
          "https://goteleport.com/blog/ssrf-attacks/"
        ],
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "HIGH",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "impact": "MEDIUM",
        "likelihood": "MEDIUM",
        "interfile": true,
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "Unvalidated host in URL can cause SSRF vulnerabilities",
        "fix-suggestion": "Implement strict validation for user-supplied URL hosts to prevent SSRF attacks. Parse URLs with `net/url.Parse()` and validate the host component against an allowlist of permitted domains. For internal service communication, use service discovery or configuration rather than user input for request destinations."
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "label": "INPUT",
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "($REQUEST : *http.Request).$ANYTHING\n"
                },
                {
                  "pattern": "($REQUEST : http.Request).$ANYTHING\n"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$ANYTHING",
                "regex": "^(BasicAuth|Body|Cookie|Cookies|Form|FormValue|GetBody|Host|MultipartReader|ParseForm|ParseMultipartForm|PostForm|PostFormValue|Referer|RequestURI|Trailer|TransferEncoding|UserAgent|URL)$"
              }
            }
          ]
        },
        {
          "label": "CLEAN",
          "requires": "INPUT",
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "\"$URLSTR\" + $INPUT\n"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "fmt.Fprintf($F, \"$URLSTR\", $INPUT, ...)"
                        },
                        {
                          "pattern": "fmt.Sprintf(\"$URLSTR\", $INPUT, ...)"
                        },
                        {
                          "pattern": "fmt.Printf(\"$URLSTR\", $INPUT, ...)"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$URLSTR",
                "regex": ".*//[a-zA-Z0-10]+\\..*"
              }
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "requires": "INPUT and not CLEAN",
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "patterns": [
                            {
                              "pattern-inside": "$CLIENT := &http.Client{...}\n...\n"
                            },
                            {
                              "pattern": "$CLIENT.$METHOD($URL, ...)"
                            }
                          ]
                        },
                        {
                          "pattern": "http.$METHOD($URL, ...)"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(Get|Head|Post|PostForm)$"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "http.NewRequest(\"$METHOD\", $URL, ...)\n"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(GET|HEAD|POST|POSTFORM)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "focus-metavariable": "$URL"
            }
          ]
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "go.lang.security.zip.path-traversal-inside-zip-extraction",
      "message": "When extracting files from a zip archive, attackers can include files with path traversal sequences (like '../') in their names to write outside the intended extraction directory. This path traversal vulnerability can lead to overwriting critical files or placing malicious files in unauthorized locations. Validate all file paths during extraction to ensure they remain within the intended target directory.",
      "metadata": {
        "cwe": [
          "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
        ],
        "source_rule_url": "https://github.com/securego/gosec/issues/205",
        "category": "security",
        "technology": [
          "go"
        ],
        "confidence": "LOW",
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "short-description": "Zip extraction path traversal leads to writing outside directory",
        "fix-suggestion": "Implement proper path sanitization when extracting files from zip archives to prevent path traversal attacks. Use `filepath.Clean()` to normalize paths and verify they don't contain `../` sequences with `if strings.Contains(filepath.Clean(filePath), \"../\")`. Consider using a library specifically designed for secure zip extraction."
      },
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "pattern": "reader, $ERR := zip.OpenReader($ARCHIVE)\n...\nfor _, $FILE := range reader.File {\n  ...\n  path := filepath.Join($TARGET, $FILE.Name)\n  ...\n}\n"
    },
    {
      "id": "go.otto.security.audit.dangerous-execution.dangerous-execution",
      "message": "Running user-provided scripts in the otto JavaScript VM allows attackers to execute arbitrary JavaScript code that could exploit VM vulnerabilities or consume excessive resources. While the VM is sandboxed, malicious scripts can still potentially break out of the sandbox or cause denial of service. Sanitize all inputs before execution and implement resource usage limits to mitigate risks from untrusted code execution.",
      "metadata": {
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "otto",
          "vm"
        ],
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Otto VM executes dynamic scripts, allowing malicious code",
        "fix-suggestion": "Implement strict security controls when using the otto JavaScript VM to prevent code injection. Never execute untrusted user input in the VM without thorough validation against an allowlist. Use a sandboxed environment with resource limits and disable access to sensitive objects or functions."
      },
      "severity": "ERROR",
      "patterns": [
        {
          "pattern-inside": "$VM = otto.New(...)\n...\n"
        },
        {
          "pattern-not": "$VM.Run(\"...\", ...)"
        },
        {
          "pattern": "$VM.Run(...)"
        }
      ],
      "languages": [
        "go"
      ]
    },
    {
      "id": "html.security.plaintext-http-link.plaintext-http-link",
      "metadata": {
        "category": "security",
        "technology": [
          "html"
        ],
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "confidence": "HIGH",
        "subcategory": [
          "vuln"
        ],
        "references": [
          "https://cwe.mitre.org/data/definitions/319.html"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Insecure HTTP link instead of HTTPS",
        "fix-suggestion": "Replace HTTP URLs with HTTPS equivalents in all links. Change `http://` to `https://` in href attributes. Check if the destination supports HTTPS, as most modern websites do. Consider implementing a Content Security Policy (CSP) that enforces HTTPS for all resources."
      },
      "patterns": [
        {
          "pattern": "<a href=\"$URL\">...</a>"
        },
        {
          "metavariable-regex": {
            "metavariable": "$URL",
            "regex": "^(?i)http://"
          }
        }
      ],
      "message": "A plaintext HTTP URL is used in a link instead of HTTPS. Unencrypted HTTP connections expose user data to interception and modification by attackers. Using insecure links also reduces overall trust in your website and may trigger browser security warnings.",
      "severity": "WARNING",
      "languages": [
        "html"
      ]
    },
    {
      "id": "html.security.audit.missing-integrity.missing-integrity",
      "metadata": {
        "category": "security",
        "technology": [
          "html"
        ],
        "cwe": [
          "CWE-353: Missing Support for Integrity Check"
        ],
        "owasp": [
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Missing SRI checks for external resources",
        "fix-suggestion": "Add `integrity` and `crossorigin` attributes to external resource tags. Generate integrity hashes with tools like `openssl dgst -sha384 -binary FILENAME | base64`. For example: `<script src=\"https://example.com/script.js\" integrity=\"sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC\" crossorigin=\"anonymous\"></script>`."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "<script $...A >...</script>"
            },
            {
              "pattern": "<link $...A >"
            }
          ]
        },
        {
          "metavariable-pattern": {
            "metavariable": "$...A",
            "patterns": [
              {
                "pattern-either": [
                  {
                    "pattern": "src='... :// ...'"
                  },
                  {
                    "pattern": "src=\"... :// ...\""
                  },
                  {
                    "pattern": "href='... :// ...'"
                  },
                  {
                    "pattern": "href=\"... :// ...\""
                  },
                  {
                    "pattern": "src='//...'"
                  },
                  {
                    "pattern": "src=\"//...\""
                  },
                  {
                    "pattern": "href='//...'"
                  },
                  {
                    "pattern": "href=\"//...\""
                  }
                ]
              },
              {
                "pattern-not-regex": "(?is).*integrity="
              },
              {
                "pattern-not-regex": "(google-analytics\\.com|fonts\\.googleapis\\.com|fonts\\.gstatic\\.com|googletagmanager\\.com)"
              },
              {
                "pattern-not-regex": ".*rel\\s*=\\s*['\"]?preconnect.*"
              }
            ]
          }
        }
      ],
      "paths": {
        "include": [
          "*.html"
        ]
      },
      "message": "External resources are loaded without Subresource Integrity (SRI) checks. Without the 'integrity' attribute, there's no validation that the resource matches what you expect. If a CDN or external host is compromised, modified scripts could be delivered to your users.",
      "severity": "WARNING",
      "languages": [
        "generic"
      ]
    },
    {
      "id": "java.android.security.exported_activity.exported_activity",
      "patterns": [
        {
          "pattern-not-inside": "<activity ... android:exported=\"false\" ... />"
        },
        {
          "pattern-inside": "<activity  ... /> \n"
        },
        {
          "pattern-either": [
            {
              "pattern": "<activity ... android:exported=\"true\" ... />\n"
            },
            {
              "pattern": "<activity ... <intent-filter> ... />\n"
            }
          ]
        }
      ],
      "message": "An Android activity is exported and accessible to any application on the device. Exported activities can be launched by untrusted applications, potentially compromising your app's integrity or sensitive data. Without proper security checks, exported activities create unnecessary attack vectors.",
      "languages": [
        "generic"
      ],
      "severity": "WARNING",
      "paths": {
        "exclude": [
          "sources/",
          "classes3.dex",
          "*.so"
        ],
        "include": [
          "*AndroidManifest.xml"
        ]
      },
      "metadata": {
        "category": "security",
        "subcategory": [
          "vuln"
        ],
        "cwe": [
          "CWE-926: Improper Export of Android Application Components"
        ],
        "confidence": "MEDIUM",
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "owasp": [
          "A5:2021 Security Misconfiguration"
        ],
        "technology": [
          "Android"
        ],
        "references": [
          "https://cwe.mitre.org/data/definitions/926.html"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Unrestricted exported Android activity",
        "fix-suggestion": "Set `android:exported=\"false\"` in your AndroidManifest.xml unless the activity needs to be accessed by other apps. For activities that must remain exported, implement proper permission checks and input validation. Never allow exported activities to have privileged access to your application's internals."
      }
    },
    {
      "id": "java.aws-lambda.security.tainted-sql-string.tainted-sql-string",
      "languages": [
        "java"
      ],
      "severity": "ERROR",
      "message": "Building SQL queries by concatenating user input in AWS Lambda functions allows attackers to modify query structure through specially crafted inputs. This SQL injection vulnerability can lead to unauthorized data access, data manipulation, or complete database compromise. Use parameterized queries or ORM tools to properly separate SQL code from user-supplied data.",
      "options": {
        "interfile": true
      },
      "metadata": {
        "references": [
          "https://owasp.org/www-community/attacks/SQL_Injection"
        ],
        "category": "security",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "technology": [
          "aws-lambda"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "interfile": true,
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "String-concatenated SQL in Lambda can cause injection",
        "fix-suggestion": "Replace string concatenation in SQL queries with JDBC `PreparedStatement` objects. Use parameter placeholders (`?`) and set values with appropriate setter methods like `preparedStatement.setString(1, username)`. This prevents SQL injection by ensuring proper escaping of all user input."
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "focus-metavariable": "$EVENT"
            },
            {
              "pattern-either": [
                {
                  "pattern": "$HANDLERTYPE $HANDLER($TYPE $EVENT, com.amazonaws.services.lambda.runtime.Context $CONTEXT) {\n  ...\n}\n"
                },
                {
                  "pattern": "$HANDLERTYPE $HANDLER(InputStream $EVENT, OutputStream $OUT, com.amazonaws.services.lambda.runtime.Context $CONTEXT) {\n  ...\n}\n"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "\"$SQLSTR\" + ...\n"
                },
                {
                  "pattern": "\"$SQLSTR\".concat(...)\n"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "StringBuilder $SB = new StringBuilder(\"$SQLSTR\");\n...\n"
                    },
                    {
                      "pattern": "$SB.append(...)"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$VAR = \"$SQLSTR\";\n...\n"
                    },
                    {
                      "pattern": "$VAR += ..."
                    }
                  ]
                },
                {
                  "pattern": "String.format(\"$SQLSTR\", ...)"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$SQLSTR",
                "regex": "(?i)(select|delete|insert|create|update|alter|drop)\\b"
              }
            },
            {
              "pattern-not-inside": "System.out.$PRINTLN(...)\n"
            }
          ]
        }
      ]
    },
    {
      "id": "java.aws-lambda.security.tainted-sqli.tainted-sqli",
      "message": "Creating SQL queries using unsanitized data from AWS Lambda events allows attackers to inject SQL syntax that alters the query logic. This SQL injection vulnerability can lead to unauthorized data access, data manipulation, or privilege escalation within the database. Use parameterized queries with prepared statements to safely incorporate user data into SQL queries.",
      "languages": [
        "java"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "focus-metavariable": "$EVENT"
            },
            {
              "pattern-either": [
                {
                  "pattern": "$HANDLERTYPE $HANDLER($TYPE $EVENT, com.amazonaws.services.lambda.runtime.Context $CONTEXT) {\n  ...\n}\n"
                },
                {
                  "pattern": "$HANDLERTYPE $HANDLER(InputStream $EVENT, OutputStream $OUT, com.amazonaws.services.lambda.runtime.Context $CONTEXT) {\n  ...\n}\n"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "(java.sql.CallableStatement $STMT) = ...; \n"
                },
                {
                  "pattern": "(java.sql.Statement $STMT) = ...;\n"
                },
                {
                  "pattern": "(java.sql.PreparedStatement $STMT) = ...;\n"
                },
                {
                  "pattern": "$VAR = $CONN.prepareStatement(...)\n"
                },
                {
                  "pattern": "$PATH.queryForObject(...);\n"
                },
                {
                  "pattern": "(java.util.Map<String, Object> $STMT) = $PATH.queryForMap(...);\n"
                },
                {
                  "pattern": "(org.springframework.jdbc.support.rowset.SqlRowSet $STMT) = ...;\n"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "(String $SQL) = \"$SQLSTR\" + ...;\n...\n"
                    },
                    {
                      "pattern": "$PATH.$SQLCMD(..., $SQL, ...);"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$SQLSTR",
                        "regex": "(?i)(^SELECT.* | ^INSERT.* | ^UPDATE.*)"
                      }
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$SQLCMD",
                        "regex": "(execute|query|executeUpdate|batchUpdate)"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "options": {
        "interfile": true
      },
      "metadata": {
        "category": "security",
        "technology": [
          "sql",
          "java",
          "aws-lambda"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "interfile": true,
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Unsanitized AWS Lambda event data in SQL fosters injection",
        "fix-suggestion": "Replace direct string concatenation with parameterized queries using JDBC `PreparedStatement`. Convert `\"SELECT * FROM users WHERE id = \" + userId` to `\"SELECT * FROM users WHERE id = ?\"` with `preparedStatement.setInt(1, userId)`. Consider using an ORM framework like Hibernate that handles parameter binding securely."
      }
    },
    {
      "id": "java.java-jwt.security.audit.jwt-decode-without-verify.java-jwt-decode-without-verify",
      "message": "A JWT token is decoded without verification of its integrity. Without verification, a malicious actor could forge a token with arbitrary claims. JWT tokens must be cryptographically verified before their contents can be trusted for authentication or authorization.",
      "metadata": {
        "cwe": [
          "CWE-345: Insufficient Verification of Data Authenticity"
        ],
        "owasp": [
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "source-rule-url": "https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/",
        "category": "security",
        "technology": [
          "jwt"
        ],
        "confidence": "MEDIUM",
        "references": [
          "https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "JWT token used without signature verification",
        "fix-suggestion": "Always call `.verify()` on JWT tokens before using them. Replace `JWT.decode(token)` with `JWT.require(algorithm).build().verify(token)`. Implement proper exception handling for verification failures, and ensure you're using a secure algorithm with properly managed keys."
      },
      "languages": [
        "java"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern": "com.auth0.jwt.JWT.decode(...);\n"
        },
        {
          "pattern-not-inside": "class $CLASS {\n  ...\n  $RETURNTYPE $FUNC (...) {\n    ...\n    $VERIFIER.verify(...);\n    ...\n  }\n}"
        }
      ]
    },
    {
      "id": "java.java-jwt.security.jwt-hardcode.java-jwt-hardcoded-secret",
      "message": "Embedding JWT secrets directly in Java source code exposes them to anyone with access to the codebase or compiled application. Compromised JWT signing keys allow attackers to forge valid authentication tokens, potentially impersonating any user in the system. Store sensitive keys in environment variables or secure credential management systems rather than hardcoding them in application code.",
      "metadata": {
        "cwe": [
          "CWE-798: Use of Hard-coded Credentials"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html"
        ],
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "technology": [
          "java",
          "secrets",
          "jwt"
        ],
        "category": "security",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Hard-coded Secrets"
        ],
        "short-description": "Hardcoded JWT secret leads to compromised token security",
        "fix-suggestion": "Remove hardcoded JWT secrets from source code to prevent credential leakage. Store secrets in environment variables or secure management services like AWS Secrets Manager. Replace `Algorithm algorithm = Algorithm.HMAC256(\"hardcoded-secret\")` with `Algorithm algorithm = Algorithm.HMAC256(System.getenv(\"JWT_SECRET\"))`."
      },
      "languages": [
        "java"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "(Algorithm $ALG) = $ALGO.$HMAC(\"$Y\");\n"
            },
            {
              "pattern": "$SECRET = \"$Y\";\n...\n(Algorithm $ALG) = $ALGO.$HMAC($SECRET);\n"
            },
            {
              "pattern": "class $CLASS {\n  ...\n  $TYPE $SECRET = \"$Y\";\n  ...\n  $RETURNTYPE $FUNC (...) {\n    ...\n    (Algorithm $ALG) = $ALGO.$HMAC($SECRET);\n    ...\n  }\n  ...\n}\n"
            }
          ]
        },
        {
          "focus-metavariable": "$Y"
        },
        {
          "metavariable-regex": {
            "metavariable": "$HMAC",
            "regex": "(HMAC384|HMAC256|HMAC512)"
          }
        }
      ]
    },
    {
      "id": "java.java-jwt.security.jwt-none-alg.java-jwt-none-alg",
      "message": "The 'none' algorithm is being used for JWT token verification. This completely bypasses signature validation, assuming the token's integrity has already been verified. Attackers can forge tokens with the 'none' algorithm to gain unauthorized access.",
      "metadata": {
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/",
        "category": "security",
        "technology": [
          "jwt"
        ],
        "confidence": "HIGH",
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Insecure JWT 'none' algorithm",
        "fix-suggestion": "Never use the `none` algorithm for JWT tokens. Replace it with a secure algorithm like `HMAC256`, `RSA256`, or `ECDSA256`. Configure your JWT verification to explicitly reject tokens using the `none` algorithm. Always verify signatures with proper cryptographic keys."
      },
      "languages": [
        "java"
      ],
      "severity": "ERROR",
      "pattern-either": [
        {
          "pattern": "$JWT.sign(com.auth0.jwt.algorithms.Algorithm.none());\n"
        },
        {
          "pattern": "$NONE = com.auth0.jwt.algorithms.Algorithm.none();\n...\n$JWT.sign($NONE);\n"
        },
        {
          "pattern": "class $CLASS {\n  ...\n  $TYPE $NONE = com.auth0.jwt.algorithms.Algorithm.none();\n  ...\n  $RETURNTYPE $FUNC (...) {\n    ...\n    $JWT.sign($NONE);\n    ...\n  }\n  ...\n}"
        }
      ]
    },
    {
      "id": "java.jax-rs.security.jax-rs-path-traversal.jax-rs-path-traversal",
      "metadata": {
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#PATH_TRAVERSAL_IN",
        "references": [
          "https://www.owasp.org/index.php/Path_Traversal"
        ],
        "category": "security",
        "technology": [
          "jax-rs"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "short-description": "User input for file paths can enable path traversal",
        "fix-suggestion": "Implement strict path validation for file operations influenced by user input in JAX-RS applications. Use `java.io.File.getCanonicalPath()` to resolve full paths and verify they start with the expected base directory. Consider using Apache Commons IO's `FilenameUtils` to safely work with file paths."
      },
      "message": "This vulnerability occurs when user-controlled input determines file paths in JAX-RS applications without proper validation, allowing attackers to use path traversal sequences like '../' to access files outside intended directories. If exploited, attackers could read sensitive configuration files, access credentials, or exfiltrate proprietary source code. To prevent this, validate all user inputs that affect file paths or use path canonicalization to resolve and verify the final path before access.",
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "pattern-either": [
        {
          "pattern": "$RETURNTYPE $FUNC (..., @PathParam(...) $TYPE $VAR, ...) {\n  ...\n  new File(..., $VAR, ...);\n  ...\n}\n"
        },
        {
          "pattern": "$RETURNTYPE $FUNC (..., @javax.ws.rs.PathParam(...) $TYPE $VAR, ...) {\n  ...\n  new File(..., $VAR, ...);\n  ...\n}"
        }
      ]
    },
    {
      "id": "java.jboss.security.seam-log-injection.seam-log-injection",
      "patterns": [
        {
          "pattern": "$LOG.$INFO($X + $Y,...)\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "import org.jboss.seam.log.Log;\n...\n"
            },
            {
              "pattern-inside": "org.jboss.seam.log.Log $LOG = ...;\n...\n"
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$INFO",
            "regex": "(debug|error|fatal|info|trace|warn)"
          }
        }
      ],
      "languages": [
        "java"
      ],
      "message": "The Seam Logging API expression language feature is being used with dynamic values. Since these expressions are evaluated at runtime, untrusted input could lead to code execution. If attackers can influence the expression values, they could potentially inject malicious code.",
      "metadata": {
        "cwe": [
          "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#SEAM_LOG_INJECTION",
        "category": "security",
        "technology": [
          "jboss"
        ],
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Code injection via Seam logging expressions",
        "fix-suggestion": "Verify and sanitize all values used in Seam logging expressions. Avoid using dynamic or user-controlled data in log expressions altogether. Consider using plain string logging without expression language features for messages that include external data."
      },
      "severity": "ERROR"
    },
    {
      "id": "java.jboss.security.session_sqli.find-sql-string-concatenation",
      "message": "The vulnerability arises when SQL queries are constructed by directly concatenating strings with user input instead of using parameterized queries. This technique bypasses SQL type checking and sanitization, allowing attackers to inject malicious SQL code that can extract data, modify databases, or execute administrative operations. Implementing prepared statements creates a clear separation between code and data, preventing attackers from changing the query's intent even if they control the parameter values.",
      "languages": [
        "java"
      ],
      "severity": "ERROR",
      "pattern-either": [
        {
          "pattern": "$RETURN $METHOD(...,String $X,...){\n  ...\n  Session $SESSION = ...;\n  ...\n  String $QUERY = ... + $X + ...;\n  ...\n  PreparedStatement $PS = $SESSION.connection().prepareStatement($QUERY);\n  ...\n  ResultSet $RESULT = $PS.executeQuery();\n  ...\n}\n"
        },
        {
          "pattern": "$RETURN $METHOD(...,String $X,...){\n  ...\n  String $QUERY = ... + $X + ...;\n  ...\n  Session $SESSION = ...;\n  ...\n  PreparedStatement $PS = $SESSION.connection().prepareStatement($QUERY);\n  ...\n  ResultSet $RESULT = $PS.executeQuery();\n  ...\n}\n"
        }
      ],
      "metadata": {
        "category": "security",
        "technology": [
          "jboss"
        ],
        "confidence": "MEDIUM",
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Session SQL string concatenation risk enabling injection",
        "fix-suggestion": "Replace string concatenation in SQL queries with parameterized queries using prepared statements. Convert `\"SELECT * FROM users WHERE username = '\" + username + \"'\"` to use parameter placeholders with `preparedStatement.setString(1, username)`. With Hibernate, use `Query query = session.createQuery(\"FROM User WHERE username = :username\"); query.setParameter(\"username\", username);`."
      }
    },
    {
      "id": "java.jjwt.security.jwt-none-alg.jjwt-none-alg",
      "message": "The 'none' algorithm is being used for JWT token verification. This completely bypasses signature validation, assuming the token's integrity has already been verified. Attackers can forge tokens with the 'none' algorithm to gain unauthorized access.",
      "metadata": {
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/",
        "asvs": {
          "section": "V3: Session Management Verification Requirements",
          "control_id": "3.5.3 Insecue Stateless Session Tokens",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "jwt"
        ],
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "JWT signature verification bypass",
        "fix-suggestion": "Never use the `none` algorithm for JWT tokens. Replace it with a secure algorithm like `HS256`. Configure your JWT verification to explicitly reject tokens using the `none` algorithm. Always verify signatures with proper cryptographic keys."
      },
      "languages": [
        "java"
      ],
      "severity": "ERROR",
      "patterns": [
        {
          "pattern": "io.jsonwebtoken.Jwts.builder();\n"
        },
        {
          "pattern-not-inside": "$RETURNTYPE $FUNC(...) {\n  ...\n  $JWTS.signWith(...);\n  ...\n}"
        }
      ]
    },
    {
      "id": "java.lang.security.do-privileged-use.do-privileged-use",
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "metadata": {
        "cwe": [
          "CWE-269: Improper Privilege Management"
        ],
        "references": [
          "https://docs.oracle.com/javase/8/docs/technotes/guides/security/doprivileged.html",
          "https://wiki.sei.cmu.edu/confluence/display/java/Privilege+Escalation",
          "http://phrack.org/papers/escaping_the_java_sandbox.html"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "owasp": [
          "A04:2021 - Insecure Design"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Security risks from privileged code execution",
        "fix-suggestion": "Minimize the code within `doPrivileged()` blocks to the smallest possible scope. Move as much code as possible outside the privileged block. Review privileged operations carefully to ensure they cannot be abused. Consider alternatives to privileged execution where possible."
      },
      "message": "Code is marked as privileged using doPrivileged(), giving it access to more resources than the calling code should have. This can expand the security impact of vulnerabilities within the privileged section. If misused, it can lead to privilege escalation and bypass security controls.",
      "patterns": [
        {
          "pattern-inside": "import java.security.*;\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "AccessController.doPrivileged(...);"
            },
            {
              "pattern": "class $ACTION implements PrivilegedAction<Void> { ... }"
            }
          ]
        }
      ]
    },
    {
      "id": "java.lang.security.httpservlet-path-traversal.httpservlet-path-traversal",
      "metadata": {
        "cwe": [
          "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
        ],
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#PATH_TRAVERSAL_IN",
        "references": [
          "https://www.owasp.org/index.php/Path_Traversal"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "short-description": "User-controlled HttpServlet file path leads to directory traversal",
        "fix-suggestion": "Implement strict path validation for file operations in HttpServlet endpoints to prevent directory traversal. Use `java.io.File.getCanonicalPath()` to resolve paths and verify they start with the expected base directory. Maintain an allowlist of permitted files or use a library like Apache Commons IO's `FilenameUtils`."
      },
      "message": "This vulnerability occurs when HttpServlet endpoints build file paths using user-provided input without properly validating or sanitizing path components. Attackers can exploit this by supplying path traversal sequences (like '../') to navigate outside the intended directory structure and access sensitive files on the server. The impact can include unauthorized access to configuration files, credentials, source code, or other sensitive information that should not be accessible through the web application.",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "(HttpServletRequest $REQ)\n"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "(javax.servlet.http.Cookie[] $COOKIES) = (HttpServletRequest $REQ).getCookies(...);\n...\nfor (javax.servlet.http.Cookie $COOKIE: $COOKIES) {\n  ...\n}\n"
                    },
                    {
                      "pattern": "$COOKIE.getValue(...)\n"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$TYPE[] $VALS = (HttpServletRequest $REQ).$GETFUNC(...);\n...\n"
                    },
                    {
                      "pattern": "$PARAM = $VALS[$INDEX];\n"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "pattern": "org.apache.commons.io.FilenameUtils.getName(...)"
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "(java.io.File $FILE) = ...\n"
                },
                {
                  "pattern": "(java.io.FileOutputStream $FOS) = ...\n"
                },
                {
                  "pattern": "new java.io.FileInputStream(...)\n"
                }
              ]
            }
          ]
        }
      ],
      "severity": "ERROR",
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.lang.security.insecure-jms-deserialization.insecure-jms-deserialization",
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "metadata": {
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "asvs": {
          "section": "V5 Validation, Sanitization and Encoding",
          "control_id": "5.5.3 Insecue Deserialization",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention",
          "version": "4"
        },
        "references": [
          "https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities-wp.pdf"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "Insecure JMS object deserialization may allow code execution",
        "fix-suggestion": "Replace `ObjectMessage` deserialization with safer alternatives like `TextMessage` with JSON or XML payloads. If `ObjectMessage` cannot be avoided, implement a custom `ObjectInputStream` that restricts deserialized classes using `ObjectInputStream.setObjectInputFilter()`. Only allow specific, expected classes to be deserialized and reject all others."
      },
      "message": "This vulnerability happens when JMS Object messages from untrusted sources are deserialized without proper validation, allowing attackers to craft malicious serialized objects. When deserialized, these objects can execute arbitrary code, potentially leading to complete system compromise, data theft, or service disruption. To prevent this, only deserialize JMS messages from trusted sources or use safer data formats like JSON that don't support code execution during deserialization.",
      "patterns": [
        {
          "pattern-inside": "public class $JMS_LISTENER implements MessageListener {\n  ...\n  public void onMessage(Message $JMS_MSG) {\n      ...\n  }\n}\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "$X = $Y.getObject(...);"
            },
            {
              "pattern-inside": "$X = ($Z) $Y.getObject(...);"
            }
          ]
        }
      ]
    },
    {
      "id": "java.lang.security.jackson-unsafe-deserialization.jackson-unsafe-deserialization",
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-inside": "ObjectMapper $OM = new ObjectMapper(...);\n...\n"
                },
                {
                  "pattern-inside": "$OM.enableDefaultTyping();\n...\n"
                },
                {
                  "pattern": "$OM.readValue($JSON, ...);"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-inside": "class $CLASS {\n  ...\n  @JsonTypeInfo(use = Id.CLASS,...)\n  $TYPE $VAR;\n  ...\n}\n"
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$TYPE",
                    "regex": "(Object|Serializable|Comparable)"
                  }
                },
                {
                  "pattern": "$OM.readValue($JSON, $CLASS.class);"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-inside": "class $CLASS {\n  ...\n  ObjectMapper $OM;\n  ...\n  $INITMETHODTYPE $INITMETHOD(...) {\n    ...\n    $OM = new ObjectMapper();\n    ...\n    $OM.enableDefaultTyping();\n    ...\n  }\n  ...\n}\n"
                },
                {
                  "pattern-inside": "$METHODTYPE $METHOD(...) {\n  ...  \n}\n"
                },
                {
                  "pattern": "$OM.readValue($JSON, ...);"
                }
              ]
            }
          ]
        }
      ],
      "message": "Jackson is configured with default typing enabled, which can lead to remote code execution vulnerabilities. If an attacker can control the JSON input, they could craft payloads that deserialize into unexpected classes and execute arbitrary code. This is a known deserialization vulnerability pattern.",
      "languages": [
        "java"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "subcategory": [
          "audit"
        ],
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "confidence": "MEDIUM",
        "likelihood": "LOW",
        "impact": "HIGH",
        "owasp": [
          "A8:2017 Insecure Deserialization",
          "A8:2021 Software and Data Integrity Failures"
        ],
        "references": [
          "https://swapneildash.medium.com/understanding-insecure-implementation-of-jackson-deserialization-7b3d409d2038",
          "https://cowtowncoder.medium.com/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062",
          "https://adamcaudill.com/2017/10/04/exploiting-jackson-rce-cve-2017-7525/"
        ],
        "technology": [
          "jackson"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "Remote code execution via Jackson deserialization",
        "fix-suggestion": "Disable default typing by removing calls to `enableDefaultTyping()`. Use explicit typing instead with `@JsonTypeInfo` annotations only where needed. Avoid using `Object` or generic types for deserialization targets. Consider implementing custom deserializers for sensitive classes."
      }
    },
    {
      "id": "java.lang.security.servletresponse-writer-xss.servletresponse-writer-xss",
      "message": "This vulnerability occurs when untrusted user input is written directly to HTTP responses without proper HTML encoding or escaping. Attackers can exploit this by injecting malicious JavaScript code that executes in victims' browsers, allowing session hijacking, credential theft, or malicious actions performed under the victim's identity. To prevent this, always encode user-controlled data before including it in responses or use a secure template engine that handles encoding automatically.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#XSS_SERVLET",
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Directly writing unescaped user data in servlet leads to XSS",
        "fix-suggestion": "Replace direct writing of user input to response streams with template-based rendering that includes automatic HTML escaping. Use frameworks like JSP with JSTL's `<c:out>` tag, Thymeleaf, or FreeMarker. If direct writing is necessary, use OWASP Java Encoder's `Encode.forHtml()` to encode user input."
      },
      "severity": "ERROR",
      "patterns": [
        {
          "pattern-inside": "$TYPE $FUNC(..., HttpServletResponse $RESP, ...) { ... }"
        },
        {
          "pattern-inside": "$VAR = $REQ.getParameter(...); ..."
        },
        {
          "pattern-either": [
            {
              "pattern": "$RESP.getWriter(...).write(..., $VAR, ...);"
            },
            {
              "pattern": "$WRITER = $RESP.getWriter(...);\n...\n$WRITER.write(..., $VAR, ...);\n"
            }
          ]
        }
      ],
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.lang.security.use-snakeyaml-constructor.use-snakeyaml-constructor",
      "languages": [
        "java"
      ],
      "metadata": {
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "references": [
          "https://securitylab.github.com/research/swagger-yaml-parser-vulnerability/#snakeyaml-deserialization-vulnerability"
        ],
        "category": "security",
        "technology": [
          "snakeyaml"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "Default SnakeYAML constructor can parse malicious entities",
        "fix-suggestion": "Replace the default SnakeYAML constructor with `SafeConstructor` to prevent deserialization of arbitrary Java objects. Change `Yaml yaml = new Yaml()` to `Yaml yaml = new Yaml(new SafeConstructor())`. Consider using SnakeYAML Engine which offers better security controls by default."
      },
      "message": "This vulnerability happens when SnakeYAML is configured with the default constructor, which can deserialize arbitrary Java objects when parsing untrusted YAML input. Attackers can craft malicious YAML that, when parsed, instantiates dangerous classes with harmful side effects, potentially leading to remote code execution or denial of service. To mitigate this risk, always use SnakeYAML's SafeConstructor which restricts object creation to a safe subset of classes.",
      "patterns": [
        {
          "pattern": "$Y = new org.yaml.snakeyaml.Yaml();\n...\n$Y.load(...);\n"
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "java.lang.security.xmlinputfactory-external-entities-enabled.xmlinputfactory-external-entities-enabled",
      "severity": "ERROR",
      "metadata": {
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "asvs": {
          "section": "V5 Validation, Sanitization and Encoding",
          "control_id": "5.5.2 Insecue XML Deserialization",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention",
          "version": "4"
        },
        "references": [
          "https://semgrep.dev/blog/2022/xml-security-in-java",
          "https://semgrep.dev/docs/cheat-sheets/java-xxe/",
          "https://www.blackhat.com/docs/us-15/materials/us-15-Wang-FileCry-The-New-Age-Of-XXE-java-wp.pdf"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "External entities enabled in XMLInputFactory can cause XXE",
        "fix-suggestion": "Disable XXE processing in `XMLInputFactory` by setting appropriate security properties. Configure with `factory.setProperty(XMLInputFactory.SUPPORT_DTD, false)` and `factory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false)`. Also set the javax.xml.stream variants of these properties for complete protection."
      },
      "message": "This vulnerability occurs when XMLInputFactory processes XML with external entities enabled, allowing attackers to include references to external resources in malicious XML. When processed, these XML External Entity (XXE) attacks can lead to server-side request forgery, local file disclosure, denial of service, or port scanning. Disable external entity processing by setting the appropriate XMLInputFactory properties to false before parsing any untrusted XML content.",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "(javax.xml.stream.XMLInputFactory $XMLFACTORY).setProperty(\"javax.xml.stream.isSupportingExternalEntities\", true);"
            },
            {
              "pattern": "(javax.xml.stream.XMLInputFactory $XMLFACTORY).setProperty(javax.xml.stream.XMLInputFactory.SUPPORT_DTD, true);"
            },
            {
              "pattern": "(javax.xml.stream.XMLInputFactory $XMLFACTORY).setProperty(\"javax.xml.stream.isSupportingExternalEntities\", Boolean.TRUE);"
            },
            {
              "pattern": "(javax.xml.stream.XMLInputFactory $XMLFACTORY).setProperty(javax.xml.stream.XMLInputFactory.SUPPORT_DTD, Boolean.TRUE);"
            }
          ]
        }
      ],
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.lang.security.xmlinputfactory-possible-xxe.xmlinputfactory-possible-xxe",
      "severity": "WARNING",
      "metadata": {
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "asvs": {
          "section": "V5 Validation, Sanitization and Encoding",
          "control_id": "5.5.2 Insecue XML Deserialization",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention",
          "version": "4"
        },
        "references": [
          "https://semgrep.dev/blog/2022/xml-security-in-java",
          "https://semgrep.dev/docs/cheat-sheets/java-xxe/",
          "https://www.blackhat.com/docs/us-15/materials/us-15-Wang-FileCry-The-New-Age-Of-XXE-java-wp.pdf",
          "https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#xmlinputfactory-a-stax-parser"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "Unprotected XMLInputFactory usage leads to XXE vulnerability",
        "fix-suggestion": "Explicitly disable XXE processing in `XMLInputFactory` by setting security properties. Configure with `factory.setProperty(XMLInputFactory.SUPPORT_DTD, false)` and `factory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false)`. Set the javax.xml.stream variants of these properties as well for comprehensive protection."
      },
      "message": "This vulnerability exists when external entity processing is not explicitly disabled in XMLInputFactory, creating a risk when parsing XML from untrusted sources. Attackers can craft XML containing external entity references that, when processed, may lead to file system access, server-side request forgery, or denial of service attacks. To prevent this, explicitly disable external entity processing by setting the appropriate properties before handling any XML content.",
      "patterns": [
        {
          "pattern-not-inside": "$METHOD(...) {\n  ...\n  $XMLFACTORY.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", false);\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "$METHOD(...) {\n  ...\n  $XMLFACTORY.setProperty(javax.xml.stream.XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "$METHOD(...) {\n  ...\n  $XMLFACTORY.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", Boolean.FALSE);\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "$METHOD(...) {\n  ...\n  $XMLFACTORY.setProperty(javax.xml.stream.XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n  ...\n}\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "javax.xml.stream.XMLInputFactory.newFactory(...)"
            },
            {
              "pattern": "new XMLInputFactory(...)"
            }
          ]
        }
      ],
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.lang.security.audit.anonymous-ldap-bind.anonymous-ldap-bind",
      "metadata": {
        "cwe": [
          "CWE-287: Improper Authentication"
        ],
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A07:2021 - Identification and Authentication Failures"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#LDAP_ANONYMOUS",
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Anonymous LDAP binding allows unauthorized directory access",
        "fix-suggestion": "Replace anonymous LDAP binds with authenticated connections using appropriate credentials. Update your code to always provide a username and password with `env.put(Context.SECURITY_AUTHENTICATION, \"simple\")` and the corresponding principal and credentials properties. Store credentials securely in configuration or environment variables, not in source code."
      },
      "message": "This vulnerability occurs when LDAP connections are configured to allow anonymous binds, removing the authentication barrier for directory access. Attackers can exploit this to enumerate directory information, access sensitive data, or potentially modify directory entries depending on anonymous user permissions. Requiring authentication for all LDAP operations ensures that only authorized users can access directory services and establishes an audit trail of access.",
      "severity": "WARNING",
      "pattern": "$ENV.put($CTX.SECURITY_AUTHENTICATION, \"none\");\n...\n$DCTX = new InitialDirContext($ENV, ...);\n",
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.lang.security.audit.bad-hexa-conversion.bad-hexa-conversion",
      "metadata": {
        "cwe": [
          "CWE-704: Incorrect Type Conversion or Cast"
        ],
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#BAD_HEXA_CONVERSION",
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://cwe.mitre.org/data/definitions/704.html"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "Insecure hexadecimal conversion weakens hashes",
        "fix-suggestion": "Replace `Integer.toHexString()` with `String.format(\"%02X\", value)` to preserve leading zeros. This ensures consistent, fixed-length output for each byte. For converting byte arrays, use a loop with String.format or a dedicated hex conversion library."
      },
      "message": "The Integer.toHexString() method is being used to convert bytes to hexadecimal, which strips leading zeros. This weakens hash values by introducing more collisions for similar inputs. The resulting inconsistent representation can cause security and comparison issues.",
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "pattern": "$X $METHOD(...) {\n  ...\n  MessageDigest $MD = ...;\n  ...\n  $MD.digest(...);\n  ...\n  Integer.toHexString(...);\n}"
    },
    {
      "id": "java.lang.security.audit.blowfish-insufficient-key-size.blowfish-insufficient-key-size",
      "metadata": {
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#BLOWFISH_KEY_SIZE",
        "asvs": {
          "section": "V6 Stored Cryptography Verification Requirements",
          "control_id": "6.2.5 Insecure Algorithm",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Weak encryption from insufficient key size",
        "fix-suggestion": "Increase Blowfish key size to at least 128 bits (16 bytes). Consider switching to AES instead, which is the modern standard for symmetric encryption. Use at least 256-bit keys for AES when encrypting sensitive data."
      },
      "message": "Blowfish encryption is being used with a key size less than 128 bits. Short keys reduce the security of encryption and make it more vulnerable to brute force attacks. Cryptographic strength directly depends on key length, and insufficient keys undermine security.",
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "patterns": [
        {
          "pattern": "$KEYGEN = KeyGenerator.getInstance(\"Blowfish\");\n...\n$KEYGEN.init($SIZE);\n"
        },
        {
          "metavariable-comparison": {
            "metavariable": "$SIZE",
            "comparison": "$SIZE < 128"
          }
        }
      ]
    },
    {
      "id": "java.lang.security.audit.cbc-padding-oracle.cbc-padding-oracle",
      "message": "CBC mode with PKCS5Padding is vulnerable to padding oracle attacks. This combination can leak information about encrypted data through error messages, allowing attackers to decrypt data without knowing the key. Additionally, CBC mode provides no integrity checking.",
      "metadata": {
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#PADDING_ORACLE",
        "references": [
          "https://capec.mitre.org/data/definitions/463.html",
          "https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#cipher-modes",
          "https://find-sec-bugs.github.io/bugs.htm#CIPHER_INTEGRITY"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Padding oracle vulnerability in CBC mode",
        "fix-suggestion": "Replace CBC mode with GCM (Galois/Counter Mode) which provides both confidentiality and integrity: `Cipher.getInstance(\"AES/GCM/NoPadding\")`. GCM is an authenticated encryption mode that prevents padding oracle attacks and ensures data hasn't been tampered with."
      },
      "severity": "WARNING",
      "fix": "\"AES/GCM/NoPadding\"\n",
      "languages": [
        "java"
      ],
      "patterns": [
        {
          "pattern-inside": "Cipher.getInstance(\"=~/.*\\/CBC\\/PKCS5Padding/\")"
        },
        {
          "pattern": "\"=~/.*\\/CBC\\/PKCS5Padding/\"\n"
        }
      ]
    },
    {
      "id": "java.lang.security.audit.command-injection-formatted-runtime-call.command-injection-formatted-runtime-call",
      "patterns": [
        {
          "metavariable-pattern": {
            "metavariable": "$RUNTIME",
            "patterns": [
              {
                "pattern-either": [
                  {
                    "pattern": "(java.lang.Runtime $R)"
                  },
                  {
                    "pattern": "java.lang.Runtime.getRuntime(...)"
                  }
                ]
              }
            ]
          }
        },
        {
          "pattern-either": [
            {
              "pattern": "$RUNTIME.exec($X + $Y);"
            },
            {
              "pattern": "$RUNTIME.exec(String.format(...));"
            },
            {
              "pattern": "$RUNTIME.loadLibrary($X + $Y);"
            },
            {
              "pattern": "$RUNTIME.loadLibrary(String.format(...));"
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", $ARG,...)\n"
                    },
                    {
                      "pattern": "$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n"
                    },
                    {
                      "pattern": "$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n"
                    },
                    {
                      "patterns": [
                        {
                          "pattern-either": [
                            {
                              "pattern": "$RUNTIME.exec($CMD,\"-c\",$ARG,...)\n"
                            },
                            {
                              "pattern": "$RUNTIME.exec(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n"
                            },
                            {
                              "pattern": "$RUNTIME.exec(new String[]{$CMD,\"-c\",$ARG,...},...)\n"
                            }
                          ]
                        },
                        {
                          "pattern-inside": "$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n...\n"
                        }
                      ]
                    },
                    {
                      "patterns": [
                        {
                          "pattern-either": [
                            {
                              "pattern": "$RUNTIME.exec($CMD, $EXECUTE, $ARG, ...)\n"
                            }
                          ]
                        },
                        {
                          "pattern-inside": "$CMD = new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", ...};\n...\n"
                        }
                      ]
                    },
                    {
                      "patterns": [
                        {
                          "pattern-either": [
                            {
                              "pattern": "$RUNTIME.exec(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", $BASH, $ARG,...)\n"
                            },
                            {
                              "pattern": "$RUNTIME.exec(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...),...)\n"
                            },
                            {
                              "pattern": "$RUNTIME.exec(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",$BASH,$ARG,...},...)\n"
                            }
                          ]
                        },
                        {
                          "pattern-inside": "$BASH = new String[]{\"=~/(-c)/\", ...};\n...\n"
                        }
                      ]
                    }
                  ]
                },
                {
                  "pattern-not-inside": "$ARG = \"...\";\n...\n"
                },
                {
                  "pattern-not": "$RUNTIME.exec(\"...\",\"...\",\"...\",...)\n"
                },
                {
                  "pattern-not": "$RUNTIME.exec(new String[]{\"...\",\"...\",\"...\",...},...)\n"
                },
                {
                  "pattern-not": "$RUNTIME.exec(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n"
                }
              ]
            }
          ]
        }
      ],
      "message": "This vulnerability arises when Runtime.exec() commands are constructed using string formatting or concatenation with user-supplied input. Attackers can inject shell metacharacters or command separators to execute additional unintended commands with the privileges of the application. This can lead to unauthorized access, data exfiltration, or complete system compromise depending on the application's permission level.",
      "metadata": {
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#COMMAND_INJECTION.",
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Runtime.exec with formatted strings can enable command injection",
        "fix-suggestion": "Replace string formatting in command execution with `ProcessBuilder` using a list of separate arguments. Never include user input directly in command strings without strict validation against an allowlist. When possible, avoid executing shell commands altogether and use native Java APIs instead."
      },
      "severity": "ERROR",
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.lang.security.audit.command-injection-process-builder.command-injection-process-builder",
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern": "new ProcessBuilder($CMD,...)\n"
            },
            {
              "pattern-not-inside": "$CMD = \"...\";\n...\n"
            },
            {
              "pattern-not-inside": "$CMD = Arrays.asList(\"...\",...);\n...\n"
            },
            {
              "pattern-not-inside": "$CMD = new String[]{\"...\",...};\n...\n"
            },
            {
              "pattern-not": "new ProcessBuilder(\"...\",...)\n"
            },
            {
              "pattern-not": "new ProcessBuilder(new String[]{\"...\",...},...)\n"
            },
            {
              "pattern-not": "new ProcessBuilder(Arrays.asList(\"...\",...),...)\n"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern": "$PB.command($CMD,...)\n"
            },
            {
              "pattern-inside": "$TYPE $PB = new ProcessBuilder(...);\n...\n"
            },
            {
              "pattern-not-inside": "$CMD = \"...\";\n...\n"
            },
            {
              "pattern-not-inside": "$CMD = Arrays.asList(\"...\",...);\n...\n"
            },
            {
              "pattern-not-inside": "$CMD = new String[]{\"...\",...};\n...\n"
            },
            {
              "pattern-not": "$PB.command(\"...\",...)\n"
            },
            {
              "pattern-not": "$PB.command(new String[]{\"...\",...},...)\n"
            },
            {
              "pattern-not": "$PB.command(Arrays.asList(\"...\",...),...)\n"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "new ProcessBuilder(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n"
                },
                {
                  "pattern": "new ProcessBuilder(\"cmd\",\"/c\",$ARG,...)\n"
                },
                {
                  "pattern": "new ProcessBuilder(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n"
                },
                {
                  "pattern": "new ProcessBuilder(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "new ProcessBuilder($CMD,\"/c\",$ARG,...)\n"
                        },
                        {
                          "pattern": "new ProcessBuilder(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n"
                        },
                        {
                          "pattern": "new ProcessBuilder(new String[]{$CMD,\"/c\",$ARG,...},...)\n"
                        }
                      ]
                    },
                    {
                      "pattern-inside": "$CMD = \"cmd\";\n...\n"
                    }
                  ]
                }
              ]
            },
            {
              "pattern-not-inside": "$ARG = \"...\";\n...\n"
            },
            {
              "pattern-not": "new ProcessBuilder(\"...\",\"...\",\"...\",...)\n"
            },
            {
              "pattern-not": "new ProcessBuilder(new String[]{\"...\",\"...\",\"...\",...},...)\n"
            },
            {
              "pattern-not": "new ProcessBuilder(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$PB.command(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...)\n"
                },
                {
                  "pattern": "$PB.command(\"cmd\",\"/c\",$ARG,...)\n"
                },
                {
                  "pattern": "$PB.command(Arrays.asList(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...),...)\n"
                },
                {
                  "pattern": "$PB.command(Arrays.asList(\"cmd\",\"/c\",$ARG,...),...)\n"
                },
                {
                  "pattern": "$PB.command(new String[]{\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$ARG,...},...)\n"
                },
                {
                  "pattern": "$PB.command(new String[]{\"cmd\",\"/c\",$ARG,...},...)\n"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "$PB.command($CMD,\"-c\",$ARG,...)\n"
                        },
                        {
                          "pattern": "$PB.command(Arrays.asList($CMD,\"-c\",$ARG,...),...)\n"
                        },
                        {
                          "pattern": "$PB.command(new String[]{$CMD,\"-c\",$ARG,...},...)\n"
                        }
                      ]
                    },
                    {
                      "pattern-inside": "$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\";\n...\n"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "$PB.command($CMD,\"/c\",$ARG,...)\n"
                        },
                        {
                          "pattern": "$PB.command(Arrays.asList($CMD,\"/c\",$ARG,...),...)\n"
                        },
                        {
                          "pattern": "$PB.command(new String[]{$CMD,\"/c\",$ARG,...},...)\n"
                        }
                      ]
                    },
                    {
                      "pattern-inside": "$CMD = \"cmd\";\n...\n"
                    }
                  ]
                }
              ]
            },
            {
              "pattern-inside": "$TYPE $PB = new ProcessBuilder(...);\n...\n"
            },
            {
              "pattern-not-inside": "$ARG = \"...\";\n...\n"
            },
            {
              "pattern-not": "$PB.command(\"...\",\"...\",\"...\",...)\n"
            },
            {
              "pattern-not": "$PB.command(new String[]{\"...\",\"...\",\"...\",...},...)\n"
            },
            {
              "pattern-not": "$PB.command(Arrays.asList(\"...\",\"...\",\"...\",...),...)\n"
            }
          ]
        }
      ],
      "message": "This vulnerability occurs when ProcessBuilder is used with commands constructed from unsanitized user input, allowing attackers to inject additional commands or arguments. If exploited, attackers can execute arbitrary system commands with the same privileges as the application, potentially leading to system compromise, data theft, or service disruption. To prevent this, use fixed command strings with parameterized arguments or thoroughly validate and sanitize all user-controlled inputs used in command construction.",
      "metadata": {
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "ProcessBuilder with user input triggers possible injection",
        "fix-suggestion": "Never include user-controlled input directly in `ProcessBuilder` commands without validation. Use `ProcessBuilder` with separate arguments (`new ProcessBuilder(\"command\", \"arg1\", \"arg2\")`) rather than shell commands. Consider alternatives to shell execution by using built-in Java libraries for the same functionality."
      },
      "severity": "ERROR",
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.lang.security.audit.cookie-missing-httponly.cookie-missing-httponly",
      "metadata": {
        "cwe": [
          "CWE-1004: Sensitive Cookie Without 'HttpOnly' Flag"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#HTTPONLY_COOKIE",
        "asvs": {
          "section": "V3: Session Management Verification Requirements",
          "control_id": "3.4.2 Missing Cookie Attribute",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v34-cookie-based-session-management",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A05_2021-Security_Misconfiguration"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cookie Security"
        ],
        "short-description": "Cookie accessible by client-side scripts",
        "fix-suggestion": "Set the HttpOnly flag on cookies by calling `cookie.setHttpOnly(true)`. This prevents JavaScript from accessing the cookie, reducing the risk of cookie theft through XSS attacks. Always set both HttpOnly and Secure flags on cookies containing sensitive information."
      },
      "message": "A cookie is set without the 'HttpOnly' flag. This allows client-side scripts to access the cookie, increasing the risk of session hijacking through cross-site scripting (XSS) attacks. Cookies containing sensitive authentication data should always have the HttpOnly flag set.",
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "patterns": [
        {
          "pattern-not-inside": "$COOKIE.setValue(\"\"); ..."
        },
        {
          "pattern-either": [
            {
              "pattern": "$COOKIE.setHttpOnly(false);"
            },
            {
              "patterns": [
                {
                  "pattern-not-inside": "$COOKIE.setHttpOnly(...); ..."
                },
                {
                  "pattern-not-inside": "$COOKIE = ResponseCookie.from(...). ...; ..."
                },
                {
                  "pattern": "$RESPONSE.addCookie($COOKIE);"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "java.lang.security.audit.cookie-missing-secure-flag.cookie-missing-secure-flag",
      "metadata": {
        "cwe": [
          "CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#INSECURE_COOKIE",
        "asvs": {
          "section": "V3: Session Management Verification Requirements",
          "control_id": "3.4.1 Missing Cookie Attribute",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v34-cookie-based-session-management",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A05_2021-Security_Misconfiguration"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cookie Security"
        ],
        "short-description": "Cookie transmitted over insecure connections",
        "fix-suggestion": "Set the secure flag on the cookie by calling `cookie.setSecure(true)`. This ensures the cookie is only transmitted over HTTPS connections. Configure both secure and HttpOnly flags for cookies containing sensitive information to protect against both network and client-side threats."
      },
      "message": "A cookie is set without the 'secure' flag. This allows the cookie to be transmitted over unencrypted HTTP connections, exposing it to network eavesdropping. Cookies containing sensitive data should only be sent over HTTPS connections.",
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "patterns": [
        {
          "pattern-not-inside": "$COOKIE.setValue(\"\"); ..."
        },
        {
          "pattern-either": [
            {
              "pattern": "$COOKIE.setSecure(false);"
            },
            {
              "patterns": [
                {
                  "pattern-not-inside": "$COOKIE.setSecure(...); ..."
                },
                {
                  "pattern-not-inside": "$COOKIE = ResponseCookie.from(...). ...; ..."
                },
                {
                  "pattern": "$RESPONSE.addCookie($COOKIE);"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "java.lang.security.audit.crlf-injection-logs.crlf-injection-logs",
      "message": "Untrusted data is included in log messages without proper neutralization. An attacker could inject CRLF (carriage return, line feed) sequences to forge log entries or include malicious content. Manipulated logs can mislead investigators or hide malicious activities.",
      "metadata": {
        "cwe": [
          "CWE-93: Improper Neutralization of CRLF Sequences ('CRLF Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#CRLF_INJECTION_LOGS",
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "Log forging via CRLF injection",
        "fix-suggestion": "Sanitize data before logging by replacing newline characters and other control characters. Use a security library like OWASP ESAPI to encode data properly: `ESAPI.encoder().encodeForHTML(userInput)`. Consider using a structured logging framework that handles this automatically."
      },
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-inside": "class $CLASS {\n  ...\n  Logger $LOG = ...;\n  ...\n}\n"
                },
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "$X $METHOD(...,HttpServletRequest $REQ,...) {\n  ...\n}\n"
                    },
                    {
                      "pattern-inside": "$X $METHOD(...,ServletRequest $REQ,...) {\n  ...\n}\n"
                    },
                    {
                      "pattern-inside": "$X $METHOD(...) {\n  ...\n  HttpServletRequest $REQ = ...;\n  ...\n}\n"
                    },
                    {
                      "pattern-inside": "$X $METHOD(...) {\n  ...\n  ServletRequest $REQ = ...;\n  ...\n}\n"
                    }
                  ]
                }
              ]
            },
            {
              "pattern-inside": "$X $METHOD(...) {\n  ...\n  Logger $LOG = ...;\n  ...\n  HttpServletRequest $REQ = ...;\n  ...\n}\n"
            },
            {
              "pattern-inside": "$X $METHOD(...) {\n  ...\n  Logger $LOG = ...;\n  ...\n  ServletRequest $REQ = ...;\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern": "String $VAL = $REQ.getParameter(...);\n...\n$LOG.$LEVEL(<... $VAL ...>);\n"
            },
            {
              "pattern": "String $VAL = $REQ.getParameter(...);\n...\n$LOG.log($LEVEL,<... $VAL ...>);\n"
            },
            {
              "pattern": "$LOG.$LEVEL(<... $REQ.getParameter(...) ...>);\n"
            },
            {
              "pattern": "$LOG.log($LEVEL,<... $REQ.getParameter(...) ...>);\n"
            }
          ]
        }
      ]
    },
    {
      "id": "java.lang.security.audit.dangerous-groovy-shell.dangerous-groovy-shell",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$SHELL.parse(...)\n"
            },
            {
              "pattern": "$SHELL.evaluate(...)\n"
            },
            {
              "pattern": "$SHELL.parseClass(...)\n"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "groovy.lang.GroovyShell $SHELL = ...;\n...\n"
            },
            {
              "pattern-inside": "groovy.lang.GroovyClassLoader $SHELL = ...;\n...\n"
            }
          ]
        },
        {
          "pattern-not": "$SHELL.parse(\"...\",...)\n"
        },
        {
          "pattern-not": "$SHELL.evaluate(\"...\",...)\n"
        },
        {
          "pattern-not": "$SHELL.parseClass(\"...\",...)\n"
        }
      ],
      "message": "This vulnerability arises when Groovy shell expressions are constructed using dynamic user-supplied values without proper validation. When executed, these expressions can run arbitrary code with the permissions of the application, allowing attackers to access sensitive data, modify system configurations, or establish persistence. Implement strict validation for any user input that influences Groovy expressions, or ideally avoid executing dynamic Groovy code based on user input entirely.",
      "metadata": {
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#GROOVY_SHELL",
        "category": "security",
        "technology": [
          "groovy"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Groovy shell with dynamic code can run malicious commands",
        "fix-suggestion": "Avoid executing dynamic Groovy expressions containing user input to prevent code injection. If necessary, implement strict validation allowing only a predefined set of safe expressions. Consider replacing dynamic evaluation with a more restrictive approach like a command pattern or domain-specific language with limited capabilities."
      },
      "languages": [
        "java"
      ],
      "severity": "WARNING"
    },
    {
      "id": "java.lang.security.audit.el-injection.el-injection",
      "metadata": {
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#EL_INJECTION",
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Expression Language injection can lead to arbitrary code",
        "fix-suggestion": "Never incorporate user input directly into Expression Language expressions. Bind user input as variables in a separate context rather than embedding in expressions. Implement a custom EL resolver with restricted capabilities allowing access only to a whitelist of safe methods and properties."
      },
      "message": "This vulnerability occurs when Expression Language (EL) expressions are dynamically constructed using unvalidated user input. Attackers can inject malicious EL syntax that accesses sensitive Java objects, invokes methods, or executes code when evaluated by the EL interpreter. This can lead to information disclosure, authentication bypass, or remote code execution depending on the application context and available objects in the EL environment.",
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "class $CLASS {\n  ...\n  ExpressionFactory $EF;\n  ...\n  $X $METHOD(...) {\n    ...\n    $EF.createValueExpression($CTX,$INPUT,...);\n    ...\n  }\n  ...\n}\n"
            },
            {
              "pattern": "class $CLASS {\n  ...\n  ExpressionFactory $EF = ...;\n  ...\n  $X $METHOD(...) {\n    ...\n    $EF.createValueExpression($CTX,$INPUT,...);\n    ...\n  }\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  ExpressionFactory $EF = ...;\n  ...\n  $EF.createValueExpression($CTX,$INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,ExpressionFactory $EF,...) {\n  ...\n  $EF.createValueExpression($CTX,$INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "class $CLASS {\n  ...\n  ExpressionFactory $EF;\n  ...\n  $X $METHOD(...) {\n    ...\n    $EF.createMethodExpression($CTX,$INPUT,...);\n    ...\n  }\n  ...\n}\n"
            },
            {
              "pattern": "class $CLASS {\n  ...\n  ExpressionFactory $EF = ...;\n  ...\n  $X $METHOD(...) {\n    ...\n    $EF.createMethodExpression($CTX,$INPUT,...);\n    ...\n  }\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  ExpressionFactory $EF = ...;\n  ...\n  $EF.createMethodExpression($CTX,$INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,ExpressionFactory $EF,...) {\n  ...\n  $EF.createMethodExpression($CTX,$INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(String $INPUT, ...) {\n  ...\n  $OBJECT.buildConstraintViolationWithTemplate($INPUT, ...);\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $EF.createValueExpression($CTX,\"...\",...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $S = \"...\";\n  ...\n  $EF.createValueExpression($CTX,$S,...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $EF.createMethodExpression($CTX,\"...\",...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $S = \"...\";\n  ...\n  $EF.createMethodExpression($CTX,$S,...);\n  ...\n}\n"
        }
      ]
    },
    {
      "id": "java.lang.security.audit.formatted-sql-string.formatted-sql-string",
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION",
        "asvs": {
          "section": "V5: Validation, Sanitization and Encoding Verification Requirements",
          "control_id": "5.3.5 Injection",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements",
          "version": "4"
        },
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html",
          "https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html#create_ps",
          "https://software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Formatted SQL queries with untrusted data enable injection",
        "fix-suggestion": "Replace all string formatting in SQL queries with parameterized queries using `PreparedStatement` objects. Use placeholders (`?` or named parameters) and bind values through setter methods (`setString`, `setInt`). If dynamic query structure is necessary, use a query builder library with proper parameterization or implement careful validation against an allowlist."
      },
      "options": {
        "taint_assume_safe_numbers": true,
        "taint_assume_safe_booleans": true
      },
      "message": "This vulnerability happens when SQL queries are constructed using string formatting or concatenation with user-supplied values instead of parameterized queries. Attackers can insert specially crafted input containing SQL syntax that alters the query's structure, allowing unauthorized data access, modification, or deletion. Using PreparedStatements with parameter binding ensures the database treats user input as data rather than executable SQL code, preventing injection attacks.",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "(HttpServletRequest $REQ)\n"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$ANNOT $FUNC (..., $INPUT, ...) {\n  ...\n}\n"
                    },
                    {
                      "pattern": "(String $INPUT)"
                    }
                  ]
                }
              ]
            },
            {
              "focus-metavariable": "$INPUT"
            }
          ],
          "label": "INPUT"
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$X + $INPUT"
                },
                {
                  "pattern": "$X += $INPUT"
                },
                {
                  "pattern": "$STRB.append($INPUT)"
                },
                {
                  "pattern": "String.format(..., $INPUT, ...)"
                },
                {
                  "pattern": "String.join(..., $INPUT, ...)"
                },
                {
                  "pattern": "(String $STR).concat($INPUT)"
                },
                {
                  "pattern": "$INPUT.concat(...)"
                },
                {
                  "pattern": "new $STRB(..., $INPUT, ...)"
                }
              ]
            }
          ],
          "label": "CONCAT",
          "requires": "INPUT"
        }
      ],
      "pattern-propagators": [
        {
          "pattern": "(StringBuffer $S).append($X)",
          "from": "$X",
          "to": "$S"
        },
        {
          "pattern": "(StringBuilder $S).append($X)",
          "from": "$X",
          "to": "$S"
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-not": "$S.$SQLFUNC(<... \"=~/.*TABLE *$/\" ...>)"
            },
            {
              "pattern-not": "$S.$SQLFUNC(<... \"=~/.*TABLE %s$/\" ...>)"
            },
            {
              "pattern-either": [
                {
                  "pattern": "(Statement $S).$SQLFUNC(...)"
                },
                {
                  "pattern": "(PreparedStatement $P).$SQLFUNC(...)"
                },
                {
                  "pattern": "(Connection $C).createStatement(...).$SQLFUNC(...)"
                },
                {
                  "pattern": "(Connection $C).prepareStatement(...).$SQLFUNC(...)"
                },
                {
                  "pattern": "(EntityManager $EM).$SQLFUNC(...)"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$SQLFUNC",
                "regex": "execute|executeQuery|createQuery|query|addBatch|nativeSQL|create|prepare"
              }
            }
          ],
          "requires": "CONCAT"
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern": "(CriteriaBuilder $CB).$ANY(...)"
            }
          ]
        }
      ],
      "severity": "ERROR",
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.lang.security.audit.http-response-splitting.http-response-splitting",
      "metadata": {
        "cwe": [
          "CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#HTTP_RESPONSE_SPLITTING",
        "references": [
          "https://www.owasp.org/index.php/HTTP_Response_Splitting"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "HTTP response splitting vulnerability",
        "fix-suggestion": "Validate or encode all user input before including it in HTTP headers. Remove all CR, LF, and other control characters from data used in headers. Consider using a security library like OWASP ESAPI: `response.setHeader(\"Location\", ESAPI.encoder().encodeForURL(userInput))`."
      },
      "message": "HTTP header values contain unvalidated user input, potentially allowing HTTP response splitting attacks. If CRLF sequences can be injected into headers, attackers can manipulate the HTTP response, potentially leading to cache poisoning or cross-site scripting.",
      "severity": "INFO",
      "languages": [
        "java"
      ],
      "pattern-either": [
        {
          "pattern": "$VAR = $REQ.getParameter(...);\n...\n$COOKIE = new Cookie(..., $VAR, ...);\n...\n$RESP.addCookie($COOKIE, ...);\n"
        },
        {
          "patterns": [
            {
              "pattern-inside": "$RETTYPE $FUNC(...,@PathVariable $TYPE $VAR, ...) {\n  ...\n}\n"
            },
            {
              "pattern": "$COOKIE = new Cookie(..., $VAR, ...);\n...\n$RESP.addCookie($COOKIE, ...);\n"
            }
          ]
        }
      ]
    },
    {
      "id": "java.lang.security.audit.insecure-smtp-connection.insecure-smtp-connection",
      "metadata": {
        "cwe": [
          "CWE-297: Improper Validation of Certificate with Host Mismatch"
        ],
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#INSECURE_SMTP_SSL",
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Email vulnerable to interception",
        "fix-suggestion": "Enable certificate verification by setting `email.setSSLCheckServerIdentity(true)`. Configure proper SSL/TLS for all email connections. Ensure your SMTP client validates certificates against trusted certificate authorities and verifies hostname matching."
      },
      "message": "An insecure SMTP connection is established without proper SSL certificate verification. This connection will trust any SSL certificate, enabling man-in-the-middle attacks. Email communications could be intercepted, read, or modified without detection.",
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-not-inside": "$EMAIL.setSSLCheckServerIdentity(true);\n...\n"
        },
        {
          "pattern-inside": "$EMAIL = new SimpleEmail(...);\n...\n"
        },
        {
          "pattern": "$EMAIL.send(...);"
        }
      ],
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.lang.security.audit.java-reverse-shell.java-reverse-shell",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "Socket $S=new Socket(...);\n...\nInputStream $SI = $S.getInputStream();\n...\nwhile(!$S.isClosed())\n{\n  ...\n  while($SI.available()>0)$PO.write($SI.read());\n  ...\n  $SO.flush();\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern-inside": "Process $P=new ProcessBuilder(...).redirectErrorStream(true).start();\n...\n$P.destroy();\n"
        }
      ],
      "message": "This vulnerability occurs when application code includes functionality that establishes outbound network connections and transfers command execution control to the remote endpoint. Once established, this reverse shell connection allows attackers to run arbitrary commands on the compromised system with the application's permission level, bypassing firewall restrictions on inbound connections. Such backdoor functionality represents a severe security risk that can lead to complete system compromise, data theft, and lateral movement within the network.",
      "severity": "WARNING",
      "metadata": {
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Potential Java reverse shell discovered, indicating remote access risk",
        "fix-suggestion": "Remove code that establishes unauthorized network connections to external servers, especially when combined with command execution. Implement remote management using secure, authenticated APIs with proper authorization controls rather than direct shell access. Validate all network connections against an allowlist of authorized destinations."
      },
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.lang.security.audit.jdbc-sql-formatted-string.jdbc-sql-formatted-string",
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION_SPRING_JDBC",
        "asvs": {
          "section": "V5: Validation, Sanitization and Encoding Verification Requirements",
          "control_id": "5.3.5 Injection",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "jdbc"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "JDBC SQL with string formatting exposes injection threat",
        "fix-suggestion": "Replace string formatting in JDBC queries with parameterized `PreparedStatement` objects. Use placeholders in SQL strings and set values with appropriate `setXXX` methods (`setString`, `setInt`). If dynamic query structure is required, validate structural elements against an allowlist and use parameterization for all data values."
      },
      "message": "This vulnerability arises when JDBC SQL queries are constructed through string formatting or concatenation with unvalidated user input. Attackers can inject malicious SQL code that changes the query's intent, potentially allowing unauthorized data access, modification of database contents, or execution of administrative commands. Using parameterized queries with PreparedStatement objects creates a secure separation between the SQL command and the data, preventing attackers from manipulating the query structure.",
      "patterns": [
        {
          "pattern-inside": "$JDBC = new JdbcTemplate(...);\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "$JDBC.queryForObject($STR + $VAR, ...);"
            },
            {
              "pattern": "$JDBC.queryForObject(String.format(...), ...);"
            },
            {
              "pattern": "String $Q = $STR + $VAR;\n...\n$JDBC.queryForObject($Q, ...);\n"
            },
            {
              "pattern": "String $Q = String.format(...);\n...\n$JDBC.queryForObject($Q, ...);\n"
            },
            {
              "pattern": "StringBuilder $Q = new StringBuilder(...);\n...\n$Q.append($STR + $VAR);\n...\n$JDBC.queryForObject($Q, ...);\n"
            },
            {
              "pattern": "$JDBC.queryForList($STR + $VAR);"
            },
            {
              "pattern": "$JDBC.queryForList(String.format(...));"
            },
            {
              "pattern": "String $Q = $STR + $VAR;\n...\n$JDBC.queryForList($Q);\n"
            },
            {
              "pattern": "String $Q = String.format(...);\n...\n$JDBC.queryForList($Q);\n"
            },
            {
              "pattern": "StringBuilder $Q = new StringBuilder(...);\n...\n$Q.append($STR + $VAR);\n...\n$JDBC.queryForList($Q, ...);\n"
            },
            {
              "pattern": "$JDBC.update($STR + $VAR);"
            },
            {
              "pattern": "$JDBC.update(String.format(...));"
            },
            {
              "pattern": "String $Q = $STR + $VAR;\n...\n$JDBC.update($Q);\n"
            },
            {
              "pattern": "String $Q = String.format(...);\n...\n$JDBC.update($Q);\n"
            },
            {
              "pattern": "StringBuilder $Q = new StringBuilder(...);\n...\n$Q.append($STR + $VAR);\n...\n$JDBC.update($Q, ...);\n"
            },
            {
              "pattern": "$JDBC.execute($STR + $VAR);"
            },
            {
              "pattern": "$JDBC.execute(String.format(...));"
            },
            {
              "pattern": "String $Q = $STR + $VAR;\n...\n$JDBC.execute($Q);\n"
            },
            {
              "pattern": "String $Q = String.format(...);\n...\n$JDBC.execute($Q);\n"
            },
            {
              "pattern": "StringBuilder $Q = new StringBuilder(...);\n...\n$Q.append($STR + $VAR);\n...\n$JDBC.execute($Q, ...);\n"
            },
            {
              "pattern": "$JDBC.insert($STR + $VAR);"
            },
            {
              "pattern": "$JDBC.insert(String.format(...));"
            },
            {
              "pattern": "String $Q = $STR + $VAR;\n...\n$JDBC.insert($Q);\n"
            },
            {
              "pattern": "String $Q = String.format(...);\n...\n$JDBC.insert($Q);\n"
            },
            {
              "pattern": "StringBuilder $Q = new StringBuilder(...);\n...\n$Q.append($STR + $VAR);\n...\n$JDBC.insert($Q, ...);\n"
            }
          ]
        }
      ],
      "severity": "WARNING",
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.lang.security.audit.ldap-entry-poisoning.ldap-entry-poisoning",
      "metadata": {
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-90: Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#LDAP_ENTRY_POISONING",
        "asvs": {
          "section": "V5: Validation, Sanitization and Encoding Verification Requirements",
          "control_id": "5.3.7 Injection",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements",
          "version": "4"
        },
        "references": [
          "https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf",
          "https://cheatsheetseries.owasp.org/cheatsheets/LDAP_Injection_Prevention_Cheat_Sheet.html"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "LDAP Injection"
        ],
        "short-description": "Code execution via LDAP object returns",
        "fix-suggestion": "Modify LDAP searches to return specific attributes instead of entire objects. Use `SearchControls.setReturningAttributes()` to specify exactly which attributes you need. Avoid deserializing objects from untrusted LDAP sources, and implement proper input validation for LDAP queries."
      },
      "message": "An LDAP search is configured to return objects rather than attributes. This allows attackers to control the LDAP response and potentially execute code through serialization vulnerabilities. If an attacker can influence LDAP queries, this could lead to remote code execution.",
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "new SearchControls($S, $CL, $TL, $AT, true, $DEREF)\n"
        },
        {
          "pattern": "SearchControls $VAR = new SearchControls();\n...\n$VAR.setReturningObjFlag(true);\n"
        }
      ],
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.lang.security.audit.ldap-injection.ldap-injection",
      "message": "Non-constant data is passed into an LDAP query without proper sanitization. If this data comes from external users, it can lead to LDAP injection attacks. Attackers could manipulate LDAP filters to bypass authentication or access unauthorized data.",
      "metadata": {
        "cwe": [
          "CWE-90: Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#LDAP_INJECTION",
        "asvs": {
          "section": "V5: Validation, Sanitization and Encoding Verification Requirements",
          "control_id": "5.3.7 Injection",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "LDAP Injection"
        ],
        "short-description": "LDAP injection from unsanitized input",
        "fix-suggestion": "Use LDAP query parameterization instead of string concatenation. Sanitize all user input used in LDAP queries by escaping special characters like `()/*\\&|<>=`. Consider using a security library with LDAP encoding functions or prepared statements for LDAP."
      },
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "$X $METHOD(...) {\n  ...\n  InitialDirContext $CTX = ...;\n  ...\n}\n"
            },
            {
              "pattern-inside": "$X $METHOD(...) {\n  ...\n  DirContext $CTX = ...;\n  ...\n}\n"
            },
            {
              "pattern-inside": "$X $METHOD(...) {\n  ...\n  InitialLdapContext $CTX = ...;\n  ...\n}\n"
            },
            {
              "pattern-inside": "$X $METHOD(...) {\n  ...\n  LdapContext $CTX = ...;\n  ...\n}\n"
            },
            {
              "pattern-inside": "$X $METHOD(...) {\n  ...\n  LdapCtx $CTX = ...;\n  ...\n}\n"
            },
            {
              "pattern-inside": "$X $METHOD(...) {\n  ...\n  EventDirContext $CTX = ...;\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern": "$X $METHOD(...) {\n  ...\n  $CTX.search($Y,$INPUT,...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $CTX.search($Y,\"...\",...);\n  ...\n}\n"
        }
      ]
    },
    {
      "id": "java.lang.security.audit.md5-used-as-password.md5-used-as-password",
      "languages": [
        "java"
      ],
      "severity": "WARNING",
      "message": "MD5 is being used for password hashing. MD5 is cryptographically broken and can be cracked quickly using modern hardware. Password hashes must be computationally expensive and include salts to defend against brute force and rainbow table attacks.",
      "metadata": {
        "category": "security",
        "technology": [
          "java",
          "md5"
        ],
        "references": [
          "https://tools.ietf.org/id/draft-lvelvindron-tls-md5-sha1-deprecate-01.html",
          "https://github.com/returntocorp/semgrep-rules/issues/1609",
          "https://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html#SecretKeyFactory",
          "https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/crypto/bcrypt/BCryptPasswordEncoder.html"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Insecure password storage using MD5",
        "fix-suggestion": "Replace MD5 with a secure password hashing function like PBKDF2 or bcrypt. Use `SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\")` with a high iteration count and random salt. For Spring applications, consider using `org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder`."
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-inside": "$TYPE $MD = MessageDigest.getInstance(\"MD5\");\n...\n"
            },
            {
              "pattern": "$MD.digest(...);"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$MODEL.$METHOD(...);"
            },
            {
              "metavariable-regex": {
                "metavariable": "$METHOD",
                "regex": "(?i)(.*password.*)"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "java.lang.security.audit.object-deserialization.object-deserialization",
      "metadata": {
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#OBJECT_DESERIALIZATION",
        "references": [
          "https://www.owasp.org/index.php/Deserialization_of_untrusted_data",
          "https://www.oracle.com/java/technologies/javase/seccodeguide.html#8"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "Untrusted ObjectInputStream can allow code execution",
        "fix-suggestion": "Replace Java's native deserialization with safer alternatives like JSON parsing (Jackson/Gson) or XML (JAXB). If unavoidable, implement an `ObjectInputFilter` (Java 9+) to restrict which classes can be deserialized. For earlier Java versions, use libraries like SerialKiller to filter the class stream."
      },
      "message": "This vulnerability occurs when applications deserialize Java objects from untrusted sources using ObjectInputStream without proper validation or filtering. Attackers can craft malicious serialized objects that, when deserialized, execute arbitrary code through deserialization callbacks, potentially leading to remote code execution. To mitigate this risk, avoid deserializing content from untrusted sources, implement serialization filters, or use safer data interchange formats like JSON.",
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "pattern": "new ObjectInputStream(...);"
    },
    {
      "id": "java.lang.security.audit.ognl-injection.ognl-injection",
      "message": "This vulnerability happens when OGNL expressions are dynamically constructed using unsanitized user input. Attackers can inject malicious OGNL syntax that, when evaluated, can access sensitive Java objects, modify application state, or execute arbitrary code on the server. Applications using frameworks that leverage OGNL (such as Struts) are particularly vulnerable if they don't properly validate user input before including it in expression evaluation.",
      "metadata": {
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#OGNL_INJECTION",
        "category": "security",
        "technology": [
          "ognl"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "OGNL injection can run arbitrary code from user input",
        "fix-suggestion": "Avoid constructing OGNL expressions using user input to prevent expression injection. Implement strict allowlist validation for dynamic expressions or replace with a restricted domain-specific language. For Struts applications, enable the OGNL sandbox protection and set `struts.enable.DynamicMethodInvocation` to `false`."
      },
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$X $METHOD(...,OgnlReflectionProvider $P,...) {\n  ...\n  $P.getGetMethod($T, $INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,OgnlReflectionProvider $P,...) {\n  ...\n  $P.getSetMethod($T, $INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,OgnlReflectionProvider $P,...) {\n  ...\n  $P.getField($T, $INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,OgnlReflectionProvider $P,...) {\n  ...\n  $P.setProperties($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,OgnlReflectionProvider $P,...) {\n  ...\n  $P.setProperty($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,OgnlReflectionProvider $P,...) {\n  ...\n  $P.getValue($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,OgnlReflectionProvider $P,...) {\n  ...\n  $P.setValue($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,ReflectionProvider $P,...) {\n  ...\n  $P.getGetMethod($T, $INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,ReflectionProvider $P,...) {\n  ...\n  $P.getSetMethod($T, $INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,ReflectionProvider $P,...) {\n  ...\n  $P.getField($T, $INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,ReflectionProvider $P,...) {\n  ...\n  $P.setProperties($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,ReflectionProvider $P,...) {\n  ...\n  $P.setProperty($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,ReflectionProvider $P,...) {\n  ...\n  $P.getValue($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,ReflectionProvider $P,...) {\n  ...\n  $P.setValue($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,TextParseUtil $P,...) {\n  ...\n  $P.translateVariables($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,TextParseUtil $P,...) {\n  ...\n  $P.translateVariablesCollection($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,TextParseUtil $P,...) {\n  ...\n  $P.shallBeIncluded($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,TextParseUtil $P,...) {\n  ...\n  $P.commaDelimitedStringToSet($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,TextParser $P,...) {\n  ...\n  $P.evaluate($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,OgnlTextParser $P,...) {\n  ...\n  $P.evaluate($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,OgnlUtil $P,...) {\n  ...\n  $P.setProperties($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,OgnlUtil $P,...) {\n  ...\n  $P.setProperty($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,OgnlUtil $P,...) {\n  ...\n  $P.getValue($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,OgnlUtil $P,...) {\n  ...\n  $P.setValue($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,OgnlUtil $P,...) {\n  ...\n  $P.callMethod($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,OgnlUtil $P,...) {\n  ...\n  $P.compile($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,VelocityStrutsUtil $P,...) {\n  ...\n  $P.evaluate($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,StrutsUtil $P,...) {\n  ...\n  $P.isTrue($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,StrutsUtil $P,...) {\n  ...\n  $P.findString($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,StrutsUtil $P,...) {\n  ...\n  $P.findValue($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,StrutsUtil $P,...) {\n  ...\n  $P.getText($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,StrutsUtil $P,...) {\n  ...\n  $P.translateVariables($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,StrutsUtil $P,...) {\n  ...\n  $P.makeSelectList($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,OgnlTool $P,...) {\n  ...\n  $P.findValue($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,ValueStack $P,...) {\n  ...\n  $P.findString($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,ValueStack $P,...) {\n  ...\n  $P.findValue($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,ValueStack $P,...) {\n  ...\n  $P.setValue($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...,ValueStack $P,...) {\n  ...\n  $P.setParameter($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  OgnlReflectionProvider $P = ...;\n  ...\n  $P.getGetMethod($T, $INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  OgnlReflectionProvider $P = ...;\n  ...\n  $P.getSetMethod($T, $INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  OgnlReflectionProvider $P = ...;\n  ...\n  $P.getField($T, $INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  OgnlReflectionProvider $P = ...;\n  ...\n  $P.setProperties($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  OgnlReflectionProvider $P = ...;\n  ...\n  $P.setProperty($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  OgnlReflectionProvider $P = ...;\n  ...\n  $P.getValue($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  OgnlReflectionProvider $P = ...;\n  ...\n  $P.setValue($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  ReflectionProvider $P = ...;\n  ...\n  $P.getGetMethod($T, $INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  ReflectionProvider $P = ...;\n  ...\n  $P.getSetMethod($T, $INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  ReflectionProvider $P = ...;\n  ...\n  $P.getField($T, $INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  ReflectionProvider $P = ...;\n  ...\n  $P.setProperties($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  ReflectionProvider $P = ...;\n  ...\n  $P.setProperty($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  ReflectionProvider $P = ...;\n  ...\n  $P.getValue($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  ReflectionProvider $P = ...;\n  ...\n  $P.setValue($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  TextParseUtil $P = ...;\n  ...\n  $P.translateVariables($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  TextParseUtil $P = ...;\n  ...\n  $P.translateVariablesCollection($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  TextParseUtil $P = ...;\n  ...\n  $P.shallBeIncluded($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  TextParseUtil $P = ...;\n  ...\n  $P.commaDelimitedStringToSet($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  TextParser $P = ...;\n  ...\n  $P.evaluate($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  OgnlTextParser $P = ...;\n  ...\n  $P.evaluate($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  OgnlUtil $P = ...;\n  ...\n  $P.setProperties($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  OgnlUtil $P = ...;\n  ...\n  $P.setProperty($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  OgnlUtil $P = ...;\n  ...\n  $P.getValue($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  OgnlUtil $P = ...;\n  ...\n  $P.setValue($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  OgnlUtil $P = ...;\n  ...\n  $P.callMethod($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  OgnlUtil $P = ...;\n  ...\n  $P.compile($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  VelocityStrutsUtil $P = ...;\n  ...\n  $P.evaluate($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  StrutsUtil $P = ...;\n  ...\n  $P.isTrue($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  StrutsUtil $P = ...;\n  ...\n  $P.findString($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  StrutsUtil $P = ...;\n  ...\n  $P.findValue($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  StrutsUtil $P = ...;\n  ...\n  $P.getText($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  StrutsUtil $P = ...;\n  ...\n  $P.translateVariables($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  StrutsUtil $P = ...;\n  ...\n  $P.makeSelectList($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  OgnlTool $P = ...;\n  ...\n  $P.findValue($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  ValueStack $P = ...;\n  ...\n  $P.findString($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  ValueStack $P = ...;\n  ...\n  $P.findValue($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  ValueStack $P = ...;\n  ...\n  $P.setValue($INPUT,...);\n  ...\n}\n"
            },
            {
              "pattern": "$X $METHOD(...) {\n  ...\n  ValueStack $P = ...;\n  ...\n  $P.setParameter($INPUT,...);\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $P.getGetMethod($T,\"...\",...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $P.getSetMethod($T,\"...\",...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $P.getField($T,\"...\",...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $P.setProperties(\"...\",...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $P.setProperty(\"...\",...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $P.getValue(\"...\",...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $P.setValue(\"...\",...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $P.translateVariables(\"...\",...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $P.translateVariablesCollection(\"...\",...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $P.shallBeIncluded(\"...\",...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $P.commaDelimitedStringToSet(\"...\",...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $P.evaluate(\"...\",...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $P.callMethod(\"...\",...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $P.compile(\"...\",...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $P.isTrue(\"...\",...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $P.findString(\"...\",...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $P.findValue(\"...\",...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $P.getText(\"...\",...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $P.makeSelectList(\"...\",...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $P.setParameter(\"...\",...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $S = \"...\";\n  ...\n  $P.getGetMethod($T,$S,...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $S = \"...\";\n  ...\n  $P.getSetMethod($T,$S,...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $S = \"...\";\n  ...\n  $P.getField($T,$S,...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $S = \"...\";\n  ...\n  $P.setProperties($S,...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $S = \"...\";\n  ...\n  $P.setProperty($S,...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $S = \"...\";\n  ...\n  $P.getValue($S,...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $S = \"...\";\n  ...\n  $P.setValue($S,...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $S = \"...\";\n  ...\n  $P.translateVariables($S,...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $S = \"...\";\n  ...\n  $P.translateVariablesCollection($S,...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $S = \"...\";\n  ...\n  $P.shallBeIncluded($S,...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $S = \"...\";\n  ...\n  $P.commaDelimitedStringToSet($S,...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $S = \"...\";\n  ...\n  $P.evaluate($S,...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $S = \"...\";\n  ...\n  $P.callMethod($S,...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $S = \"...\";\n  ...\n  $P.compile($S,...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $S = \"...\";\n  ...\n  $P.isTrue($S,...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $S = \"...\";\n  ...\n  $P.findString($S,...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $S = \"...\";\n  ...\n  $P.findValue($S,...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $S = \"...\";\n  ...\n  $P.getText($S,...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $S = \"...\";\n  ...\n  $P.makeSelectList($S,...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $S = \"...\";\n  ...\n  $P.setParameter($S,...);\n  ...\n}\n"
        }
      ]
    },
    {
      "id": "java.lang.security.audit.overly-permissive-file-permission.overly-permissive-file-permission",
      "message": "This vulnerability occurs when files are created with excessive permissions that grant read, write, or execute access to unintended users or groups. These overly permissive settings can allow attackers to access sensitive configuration data, credentials, or modify critical files that affect application behavior. Limiting file permissions to the minimum necessary privileges helps ensure that sensitive files remain protected from unauthorized access or modification.",
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "metadata": {
        "cwe": [
          "CWE-276: Incorrect Default Permissions"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#OVERLY_PERMISSIVE_FILE_PERMISSION",
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Excessive file permissions may expose or modify sensitive data",
        "fix-suggestion": "Use the most restrictive file permissions necessary for your application's functionality. Replace overly permissive settings like `0777` (rwxrwxrwx) with more restrictive ones such as `0600` (rw-------). When creating files programmatically, use `Files.createFile()` with `PosixFilePermissions.asFileAttribute()` to explicitly set secure permissions."
      },
      "pattern-either": [
        {
          "pattern": "java.nio.file.Files.setPosixFilePermissions($FILE, java.nio.file.attribute.PosixFilePermissions.fromString(\"=~/(^......r..$)|(^.......w.$)|(^........x$)/\"));"
        },
        {
          "pattern": "$TYPE $P = java.nio.file.attribute.PosixFilePermissions.fromString(\"=~/(^......r..$)|(^.......w.$)|(^........x$)/\");\n...\njava.nio.file.Files.setPosixFilePermissions($FILE, $P);\n"
        },
        {
          "pattern": "$P.add(java.nio.file.attribute.PosixFilePermission.OTHERS_READ);\n...\njava.nio.file.Files.setPosixFilePermissions($FILE, $P);\n"
        },
        {
          "pattern": "$P.add(java.nio.file.attribute.PosixFilePermission.OTHERS_WRITE);\n...\njava.nio.file.Files.setPosixFilePermissions($FILE, $P);\n"
        },
        {
          "pattern": "$P.add(java.nio.file.attribute.PosixFilePermission.OTHERS_EXECUTE);\n...\njava.nio.file.Files.setPosixFilePermissions($FILE, $P);"
        }
      ]
    },
    {
      "id": "java.lang.security.audit.permissive-cors.permissive-cors",
      "message": "A permissive CORS (Cross-Origin Resource Sharing) policy allows any origin to access the application's resources. This removes Same-Origin Policy restrictions that prevent cross-site attacks. Overly permissive CORS can lead to unauthorized data access and cross-site request forgery.",
      "metadata": {
        "cwe": [
          "CWE-183: Permissive List of Allowed Inputs"
        ],
        "asvs": {
          "section": "V14: Configuration Verification Requirements",
          "control_id": "14.4.8 Permissive CORS",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x22-V14-Config.md#v144-http-security-headers-requirements",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "java"
        ],
        "owasp": [
          "A04:2021 - Insecure Design"
        ],
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "Security bypass from permissive CORS",
        "fix-suggestion": "Restrict the allowed origins in your CORS policy to only trusted domains. Replace wildcard origins (`*`) with a specific list of trusted domains. Set appropriate values for allowed methods, headers, and credentials. Consider implementing a proper CORS filter with request validation."
      },
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "pattern-either": [
        {
          "pattern": "HttpServletResponse $RES = ...;\n...\n$RES.addHeader(\"=~/access-control-allow-origin/i\", \"=~/^\\*|null$/i\");\n"
        },
        {
          "pattern": "HttpServletResponse $RES = ...;\n...\n$RES.setHeader(\"=~/access-control-allow-origin/i\", \"=~/^\\*|null$/i\");\n"
        },
        {
          "pattern": "ServerHttpResponse $RES = ...;\n...\n$RES.getHeaders().add(\"=~/access-control-allow-origin/i\", \"=~/^\\*|null$/i\");\n"
        },
        {
          "pattern": "HttpHeaders $HEADERS = ...;\n...\n$HEADERS.set(\"=~/access-control-allow-origin/i\", \"=~/^\\*|null$/i\");\n"
        },
        {
          "pattern": "ServerWebExchange $SWE = ...;\n...\n$SWE.getResponse().getHeaders().add(\"Access-Control-Allow-Origin\", \"*\");\n"
        },
        {
          "pattern": "$X $METHOD(...,HttpServletResponse $RES,...) {\n  ...\n  $RES.addHeader(\"=~/access-control-allow-origin/i\", \"=~/^\\*|null$/i\");\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...,HttpServletResponse $RES,...) {\n  ...\n  $RES.setHeader(\"=~/access-control-allow-origin/i\", \"=~/^\\*|null$/i\");\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...,ServerHttpResponse $RES,...) {\n  ...\n  $RES.getHeaders().add(\"=~/access-control-allow-origin/i\", \"=~/^\\*|null$/i\");\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...,ServerWebExchange $SWE,...) {\n  ...\n  $SWE.getResponse().getHeaders().add(\"=~/access-control-allow-origin/i\", \"=~/^\\*|null$/i\");\n  ...\n}\n"
        },
        {
          "pattern": "ResponseEntity.$RES().header(\"=~/access-control-allow-origin/i\", \"=~/^\\*|null$/i\")"
        },
        {
          "pattern": "ServerResponse.$RES().header(\"=~/access-control-allow-origin/i\", \"=~/^\\*|null$/i\")"
        }
      ]
    },
    {
      "id": "java.lang.security.audit.script-engine-injection.script-engine-injection",
      "message": "This vulnerability arises when user-controlled input is passed directly to a ScriptEngine for evaluation without proper validation or sandboxing. Attackers can supply malicious scripts that, when executed, can access sensitive information, modify application state, or run arbitrary code with the application's privileges. Script evaluation should be avoided for user input, or if necessary, strictly limited to a safe subset of functionality in a properly sandboxed environment.",
      "metadata": {
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#SCRIPT_ENGINE_INJECTION",
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Running untrusted scripts in a ScriptEngine allows code execution",
        "fix-suggestion": "Avoid passing user-controlled input to `ScriptEngine`'s eval methods to prevent code injection. If script evaluation is necessary, implement a strict allowlist of permitted scripts or templates. Create a restricted sandbox by customizing the script context and binding only necessary objects with limited capabilities."
      },
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "class $CLASS {\n  ...\n  ScriptEngine $SE;\n  ...\n}\n"
            },
            {
              "pattern-inside": "class $CLASS {\n  ...\n  ScriptEngine $SE = ...;\n  ...\n}\n"
            },
            {
              "pattern-inside": "$X $METHOD(...) {\n  ...\n  ScriptEngine $SE = ...;\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern": "$X $METHOD(...) {\n  ...\n  $SE.eval(...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $SE.eval(\"...\");\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $S = \"...\";\n  ...\n  $SE.eval($S);\n  ...\n}\n"
        }
      ]
    },
    {
      "id": "java.lang.security.audit.tainted-cmd-from-http-request.tainted-cmd-from-http-request",
      "message": "This vulnerability occurs when data from HTTP requests is used to construct system commands without thorough validation or sanitization. Attackers can inject shell metacharacters or additional commands that will be executed on the server with the application's privileges. This can lead to unauthorized system access, data theft, or service disruption depending on the application's permission level and the underlying system configuration.",
      "languages": [
        "java"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "(HttpServletRequest $REQ)\n"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "(javax.servlet.http.Cookie[] $COOKIES) = (HttpServletRequest $REQ).getCookies(...);\n...\nfor (javax.servlet.http.Cookie $COOKIE: $COOKIES) {\n  ...\n}\n"
                    },
                    {
                      "pattern": "$COOKIE.getValue(...)\n"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "(ProcessBuilder $PB) = ...;\n"
                },
                {
                  "patterns": [
                    {
                      "pattern": "(Process $P) = ...;\n"
                    },
                    {
                      "pattern-not": "(Process $P) = (java.lang.Runtime $R).exec(...);\n"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "(java.lang.Runtime $R).exec($CMD, ...);"
                    },
                    {
                      "focus-metavariable": "$CMD"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "(java.util.List<$TYPE> $ARGLIST) = ...;  \n...\n(ProcessBuilder $PB) = ...;\n...\n$PB.command($ARGLIST);\n"
                        },
                        {
                          "pattern-inside": "(java.util.List<$TYPE> $ARGLIST) = ...;  \n...\n(ProcessBuilder $PB) = ...;\n"
                        },
                        {
                          "pattern-inside": "(java.util.List<$TYPE> $ARGLIST) = ...;  \n...\n(Process $P) = ...;\n"
                        }
                      ]
                    },
                    {
                      "pattern": "$ARGLIST.add(...);\n"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "metadata": {
        "category": "security",
        "technology": [
          "java"
        ],
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "HTTP request data used in commands can cause injection",
        "fix-suggestion": "Never use HTTP request parameters directly in command execution. Implement a strict mapping of user inputs to predefined command templates using an allowlist approach. Use `ProcessBuilder` with separate arguments rather than shell commands to prevent command injection through shell metacharacters."
      }
    },
    {
      "id": "java.lang.security.audit.tainted-env-from-http-request.tainted-env-from-http-request",
      "message": "This vulnerability happens when HTTP request data is directly passed into the environment for command execution without proper validation. Attackers can manipulate environment variables to affect program behavior, inject command arguments, or exploit command interpretation vulnerabilities. To prevent this, avoid passing user-controlled data to command environments or use methods that clearly separate the command from its arguments to prevent injection attacks.",
      "languages": [
        "java"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "(HttpServletRequest $REQ)\n"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "(javax.servlet.http.Cookie[] $COOKIES) = (HttpServletRequest $REQ).getCookies(...);\n...\nfor (javax.servlet.http.Cookie $COOKIE: $COOKIES) {\n  ...\n}\n"
                    },
                    {
                      "pattern": "$COOKIE.getValue(...)\n"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "(java.lang.Runtime $R).exec($CMD, $ENV_ARGS, ...);"
            },
            {
              "focus-metavariable": "$ENV_ARGS"
            }
          ]
        }
      ],
      "metadata": {
        "category": "security",
        "technology": [
          "java"
        ],
        "cwe": [
          "CWE-454: External Initialization of Trusted Variables or Data Stores"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": false,
        "cwe2021-top25": false,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "User input in environment variables leads to command injection",
        "fix-suggestion": "Never pass HTTP request parameters directly to environment variables for command execution. Implement strict validation using allowlists before affecting command environments. Use `ProcessBuilder` with its `environment()` method to set environment variables explicitly rather than embedding them in command strings."
      }
    },
    {
      "id": "java.lang.security.audit.tainted-ldapi-from-http-request.tainted-ldapi-from-http-request",
      "message": "User input from an HTTP request is used directly in an LDAP query without proper sanitization. This can lead to LDAP injection attacks where attackers manipulate the LDAP structure. Such vulnerabilities could allow unauthorized access to directory information or authentication bypass.",
      "metadata": {
        "cwe": [
          "CWE-90: Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://sensei.securecodewarrior.com/recipes/scw%3Ajava%3ALDAP-injection"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "subcategory": [
          "vuln"
        ],
        "impact": "MEDIUM",
        "likelihood": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "LDAP Injection"
        ],
        "short-description": "LDAP injection from HTTP request data",
        "fix-suggestion": "Sanitize all user input before using it in LDAP queries. Escape special LDAP characters like `()/*\\&|<>=` in user inputs. Consider using parameterized LDAP queries or LDAP-specific security libraries. Implement strict input validation using allowlists for expected input patterns."
      },
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "(HttpServletRequest $REQ)"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "(javax.naming.directory.InitialDirContext $IDC).search(...)\n"
                },
                {
                  "pattern": "(javax.naming.directory.DirContext $CTX).search(...)\n"
                }
              ]
            },
            {
              "pattern-not": "(javax.naming.directory.InitialDirContext $IDC).search($Y, \"...\", ...)\n"
            },
            {
              "pattern-not": "(javax.naming.directory.DirContext $CTX).search($Y, \"...\", ...)\n"
            }
          ]
        }
      ]
    },
    {
      "id": "java.lang.security.audit.tainted-session-from-http-request.tainted-session-from-http-request",
      "message": "User input from an HTTP request is directly stored in session attributes. This can lead to a trust boundary violation where untrusted data is later treated as trusted. If malicious code is injected into session attributes, developers might unknowingly use this data in sensitive operations.",
      "languages": [
        "java"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern": "(HttpServletRequest $REQ).$FUNC(...)\n"
                    },
                    {
                      "pattern-not": "(HttpServletRequest $REQ).getSession()\n"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "(javax.servlet.http.Cookie[] $COOKIES) = (HttpServletRequest $REQ).getCookies(...);\n...\nfor (javax.servlet.http.Cookie $COOKIE: $COOKIES) {\n  ...\n}\n"
                    },
                    {
                      "pattern": "$COOKIE.getValue(...)\n"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$TYPE[] $VALS = (HttpServletRequest $REQ).$GETFUNC(... );\n...\n"
                    },
                    {
                      "pattern": "$PARAM = $VALS[$INDEX];\n"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$HEADERS = (HttpServletRequest $REQ).getHeaders(...);\n...\n$PARAM = $HEADERS.$FUNC(...);\n...\n"
                    },
                    {
                      "pattern": "java.net.URLDecoder.decode($PARAM, ...)\n"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "(HttpServletRequest $REQ).getSession().$FUNC($NAME, $VALUE);"
            },
            {
              "metavariable-regex": {
                "metavariable": "$FUNC",
                "regex": "^(putValue|setAttribute)$"
              }
            },
            {
              "focus-metavariable": "$VALUE"
            }
          ]
        }
      ],
      "options": {
        "interfile": true
      },
      "metadata": {
        "category": "security",
        "technology": [
          "java"
        ],
        "cwe": [
          "CWE-501: Trust Boundary Violation"
        ],
        "owasp": [
          "A04:2021 - Insecure Design"
        ],
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design"
        ],
        "subcategory": [
          "vuln"
        ],
        "impact": "MEDIUM",
        "likelihood": "MEDIUM",
        "confidence": "MEDIUM",
        "interfile": true,
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Trust boundary violation in session storage",
        "fix-suggestion": "Thoroughly validate and sanitize all user input before storing it in session attributes. Use input validation with allowlists to ensure only expected values are accepted. Consider using dedicated data transfer objects (DTOs) for session storage instead of raw user input."
      }
    },
    {
      "id": "java.lang.security.audit.tainted-xpath-from-http-request.tainted-xpath-from-http-request",
      "message": "User input from an HTTP request is used directly in XPath queries without proper sanitization. This can lead to XPath injection attacks, allowing unauthorized access to sensitive information in XML documents. Attackers could bypass authentication or extract all data from XML files.",
      "languages": [
        "java"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "(HttpServletRequest $REQ).$FUNC(...)\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "(javax.xml.xpath.XPath $XP).evaluate(...)\n"
                },
                {
                  "pattern": "(javax.xml.xpath.XPath $XP).compile(...).evaluate(...)\n"
                }
              ]
            }
          ]
        }
      ],
      "metadata": {
        "category": "security",
        "technology": [
          "java"
        ],
        "cwe": [
          "CWE-643: Improper Neutralization of Data within XPath Expressions ('XPath Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XPath Injection"
        ],
        "short-description": "XPath injection from HTTP request data",
        "fix-suggestion": "Use parameterized XPath queries instead of string concatenation. Sanitize all user inputs before using them in XPath expressions. Consider using XPath variable binding if available in your XPath implementation. Implement strict input validation for all query parameters."
      }
    },
    {
      "id": "java.lang.security.audit.unsafe-reflection.unsafe-reflection",
      "patterns": [
        {
          "pattern": "Class.forName($CLASS,...)\n"
        },
        {
          "pattern-not": "Class.forName(\"...\",...)\n"
        },
        {
          "pattern-not-inside": "$CLASS = \"...\";\n...\n"
        }
      ],
      "message": "When user input determines which class to instantiate or method to invoke, attackers can manipulate the application's control flow in unintended ways. This reflection vulnerability may allow bypassing authentication, circumventing access controls, or causing unexpected application behavior. Always validate and restrict the values used for dynamic class loading or method invocation.",
      "metadata": {
        "cwe": [
          "CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "source-rule-url": "https://owasp.org/www-community/vulnerabilities/Unsafe_use_of_Reflection",
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Unsafe reflection enables control flow manipulation",
        "fix-suggestion": "Implement strict validation for any user input used in reflection operations. Use an allowlist approach to limit which classes and methods can be dynamically loaded or invoked. Consider redesigning your code to avoid dynamic class loading based on user input entirely."
      },
      "severity": "WARNING",
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.lang.security.audit.unvalidated-redirect.unvalidated-redirect",
      "message": "The application redirects to URLs specified by user input without proper validation. This unvalidated redirect vulnerability allows attackers to direct users to malicious websites, potentially enabling phishing attacks. Always validate user-supplied redirect destinations against an allowlist of approved URLs.",
      "metadata": {
        "cwe": [
          "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#UNVALIDATED_REDIRECT",
        "asvs": {
          "section": "V5: Validation, Sanitization and Encoding Verification Requirements",
          "control_id": "5.1.5 Open Redirect",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v51-input-validation-requirements",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control"
        ],
        "subcategory": [
          "vuln"
        ],
        "impact": "LOW",
        "likelihood": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Open Redirect"
        ],
        "short-description": "Unvalidated redirects enable phishing attacks",
        "fix-suggestion": "Implement an allowlist validation mechanism for all redirect URLs derived from user input. Validate that destination URLs match approved patterns or domains before performing any redirects. Consider using relative URLs or route names instead of allowing absolute URLs in redirects."
      },
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "pattern-either": [
        {
          "pattern": "$X $METHOD(...,HttpServletResponse $RES,...,String $URL,...) {\n  ...\n  $RES.sendRedirect($URL);\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...,String $URL,...,HttpServletResponse $RES,...) {\n  ...\n  $RES.sendRedirect($URL);\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...,HttpServletRequest $REQ,...,HttpServletResponse $RES,...) {\n  ...\n  String $URL = $REQ.getParameter(...);\n  ...\n  $RES.sendRedirect($URL);\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...,HttpServletResponse $RES,...,HttpServletRequest $REQ,...) {\n  ...\n  String $URL = $REQ.getParameter(...);\n  ...\n  $RES.sendRedirect($URL);\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...,String $URL,...) {\n  ...\n  HttpServletResponse $RES = ...;\n  ...\n  $RES.sendRedirect($URL);\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...,HttpServletRequest $REQ,...,HttpServletResponse $RES,...) {\n  ...\n  $RES.sendRedirect($REQ.getParameter(...));\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...,HttpServletResponse $RES,...,HttpServletRequest $REQ,...) {\n  ...\n  $RES.sendRedirect($REQ.getParameter(...));\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...,HttpServletResponse $RES,...,String $URL,...) {\n  ...\n  $RES.addHeader(\"Location\",$URL);\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...,String $URL,...,HttpServletResponse $RES,...) {\n  ...\n  $RES.addHeader(\"Location\",$URL);\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...,HttpServletRequest $REQ,...,HttpServletResponse $RES,...) {\n  ...\n  String $URL = $REQ.getParameter(...);\n  ...\n  $RES.addHeader(\"Location\",$URL);\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...,HttpServletResponse $RES,...,HttpServletRequest $REQ,...) {\n  ...\n  String $URL = $REQ.getParameter(...);\n  ...\n  $RES.addHeader(\"Location\",$URL);\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...,String $URL,...) {\n  ...\n  HttpServletResponse $RES = ...;\n  ...\n  $RES.addHeader(\"Location\",$URL);\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...,HttpServletRequest $REQ,...,HttpServletResponse $RES,...) {\n  ...\n  $RES.addHeader(\"Location\",$REQ.getParameter(...));\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...,HttpServletResponse $RES,...,HttpServletRequest $REQ,...) {\n  ...\n  $RES.addHeader(\"Location\",$REQ.getParameter(...));\n  ...\n}"
        }
      ]
    },
    {
      "id": "java.lang.security.audit.url-rewriting.url-rewriting",
      "message": "URL rewriting exposes session IDs directly in the URL, making them visible to third parties through browser history, server logs, or referrer headers. This exposure significantly increases the risk of session hijacking attacks. Use secure cookies with the HttpOnly flag instead of URL rewriting for session management.",
      "metadata": {
        "cwe": [
          "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#URL_REWRITING",
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "URL rewriting exposes session IDs",
        "fix-suggestion": "Replace URL rewriting with secure cookie-based session management. Configure your application to use `HttpOnly` and `Secure` cookies for storing session identifiers. Implement proper session timeout and rotation mechanisms to reduce the impact of potential session ID exposure."
      },
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "pattern-either": [
        {
          "pattern": "$X $METHOD(...,HttpServletResponse $RES,...) {\n  ...\n  $RES.encodeURL(...);\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...,HttpServletResponse $RES,...) {\n  ...\n  $RES.encodeUrl(...);\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...,HttpServletResponse $RES,...) {\n  ...\n  $RES.encodeRedirectURL(...);\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...,HttpServletResponse $RES,...) {\n  ...\n  $RES.encodeRedirectUrl(...);\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...) {\n  ...\n  HttpServletResponse $RES = ...;\n  ...\n  $RES.encodeURL(...);\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...) {\n  ...\n  HttpServletResponse $RES = ...;\n  ...\n  $RES.encodeUrl(...);\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...) {\n  ...\n  HttpServletResponse $RES = ...;\n  ...\n  $RES.encodeRedirectURL(...);\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...) {\n  ...\n  HttpServletResponse $RES = ...;\n  ...\n  $RES.encodeRedirectUrl(...);\n  ...\n}"
        }
      ]
    },
    {
      "id": "java.lang.security.audit.weak-ssl-context.weak-ssl-context",
      "metadata": {
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source_rule_url": "https://find-sec-bugs.github.io/bugs.htm#SSL_CONTEXT",
        "references": [
          "https://tools.ietf.org/html/rfc7568",
          "https://tools.ietf.org/id/draft-ietf-tls-oldversions-deprecate-02.html"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Weak SSL/TLS protocol configuration",
        "fix-suggestion": "Update your code to use `SSLContext.getInstance(\"TLSv1.2\")` or preferably `SSLContext.getInstance(\"TLSv1.3\")` for secure communication. Explicitly disable older protocols in your SSL configuration. Regularly update your security dependencies to maintain protection against evolving threats."
      },
      "message": "Your application is using an insecure SSL/TLS configuration that relies on outdated protocols. TLS versions 1.0, 1.1, and all SSL versions have known vulnerabilities and are deprecated. Using weak encryption protocols exposes your application to potential interception and modification of encrypted traffic.",
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "patterns": [
        {
          "pattern-not": "SSLContext.getInstance(\"TLSv1.3\")"
        },
        {
          "pattern-not": "SSLContext.getInstance(\"TLSv1.2\")"
        },
        {
          "pattern": "SSLContext.getInstance(\"...\")"
        }
      ],
      "fix-regex": {
        "regex": "(.*?)\\.getInstance\\(.*?\\)",
        "replacement": "\\1.getInstance(\"TLSv1.2\")"
      }
    },
    {
      "id": "java.lang.security.audit.xml-decoder.xml-decoder",
      "message": "This vulnerability arises when XMLDecoder processes untrusted XML content, which can lead to arbitrary code execution due to XMLDecoder's ability to instantiate Java objects and invoke methods. Attackers can craft malicious XML that, when decoded, creates dangerous objects or calls sensitive methods, potentially resulting in remote code execution. Avoid using XMLDecoder for parsing untrusted data and consider safer alternatives like JAXB or DOM processing with external entities disabled.",
      "metadata": {
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#XML_DECODER",
        "references": [
          "https://semgrep.dev/blog/2022/xml-security-in-java",
          "https://semgrep.dev/docs/cheat-sheets/java-xxe/",
          "https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "XMLDecoder on untrusted data can cause remote code execution",
        "fix-suggestion": "Avoid using `XMLDecoder` entirely for processing untrusted data due to deserialization risks. Replace with safer alternatives like JAXB, Jackson's XML module, or DOM processing. If `XMLDecoder` must be used, implement a custom `SecurityManager` during deserialization or use it only with verified data from secure sources."
      },
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "patterns": [
        {
          "pattern": "$X $METHOD(...) {\n  ...\n  new XMLDecoder(...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  new XMLDecoder(\"...\");\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $STR = \"...\";\n  ...\n  new XMLDecoder($STR);\n  ...\n}"
        }
      ]
    },
    {
      "id": "java.lang.security.audit.xssrequestwrapper-is-insecure.xssrequestwrapper-is-insecure",
      "metadata": {
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#XSS_REQUEST_WRAPPER",
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Ineffective XSSRequestWrapper can be bypassed, leading to script injection",
        "fix-suggestion": "Replace custom `XSSRequestWrapper` implementations with established security libraries for XSS protection. Use mature libraries like OWASP Java Encoder, ESAPI, or jsoup for proper context-aware encoding rather than regex-based filtering. Leverage XSS protection in modern frameworks like Spring Security or implement Content-Security-Policy headers."
      },
      "message": "This vulnerability occurs when applications rely on custom XSSRequestWrapper implementations that use insufficient regex patterns or filtering logic to prevent cross-site scripting attacks. These inadequate wrappers can be bypassed using alternative encoding techniques or specially crafted payloads that evade the implemented filters. Instead of custom filtering, use established framework solutions that automatically handle context-appropriate HTML encoding to provide more comprehensive protection against XSS attacks.",
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "pattern-either": [
        {
          "pattern": "class XSSRequestWrapper extends HttpServletRequestWrapper {\n  ...\n}\n"
        },
        {
          "pattern": "$P = $X.compile(\"</script>\", $X.CASE_INSENSITIVE);\n$V = $P.matcher(...).replaceAll(\"\");"
        }
      ]
    },
    {
      "id": "java.lang.security.audit.crypto.des-is-deprecated.des-is-deprecated",
      "message": "Your code is using the DES encryption algorithm which has been officially deprecated by NIST since 2005. DES uses short keys that can be broken through brute force attacks with modest computing resources. Replace DES with AES, which offers significantly stronger security and is the current recommended standard for symmetric encryption.",
      "metadata": {
        "functional-categories": [
          "crypto::search::symmetric-algorithm::javax.crypto"
        ],
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#DES_USAGE",
        "asvs": {
          "section": "V6 Stored Cryptography Verification Requirements",
          "control_id": "6.2.5 Insecure Algorithm",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms",
          "version": "4"
        },
        "references": [
          "https://www.nist.gov/news-events/news/2005/06/nist-withdraws-outdated-data-encryption-standard",
          "https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#algorithms"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Deprecated DES encryption algorithm usage",
        "fix-suggestion": "Replace all uses of `DES` with the AES encryption algorithm in your cryptographic operations. Use `Cipher.getInstance(\"AES/GCM/NoPadding\")` with appropriate key sizes (at least 128 bits). Consider using higher-level cryptographic libraries that implement secure defaults rather than managing encryption primitives directly."
      },
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "$CIPHER.getInstance(\"=~/DES/.*/\")"
            },
            {
              "pattern-inside": "$CIPHER.getInstance(\"DES\")"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern": "\"=~/DES/.*/\"\n"
            },
            {
              "pattern": "\"DES\"\n"
            }
          ]
        }
      ],
      "fix": "\"AES/GCM/NoPadding\"\n",
      "languages": [
        "java",
        "kt"
      ]
    },
    {
      "id": "java.lang.security.audit.crypto.desede-is-deprecated.desede-is-deprecated",
      "message": "Your code uses Triple DES (3DES/DESede) encryption, which is considered deprecated due to its vulnerability to sweet32 birthday attacks and slow performance. 3DES's small block size (64 bits) makes it susceptible to collision attacks when large amounts of data are encrypted. Upgrade to AES, which provides superior security and performance.",
      "metadata": {
        "functional-categories": [
          "crypto::search::symmetric-algorithm::javax.crypto"
        ],
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#TDES_USAGE",
        "references": [
          "https://csrc.nist.gov/News/2017/Update-to-Current-Use-and-Deprecation-of-TDEA"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Deprecated Triple DES encryption algorithm",
        "fix-suggestion": "Replace all instances of `DESede` or Triple DES with the AES algorithm in your cryptographic operations. Use `Cipher.getInstance(\"AES/GCM/NoPadding\")` with appropriate key sizes (at least 128 bits). Update any dependent systems or protocols to ensure compatibility with the new encryption algorithm."
      },
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$CIPHER.getInstance(\"=~/DESede.*/\")\n"
            },
            {
              "pattern": "$CRYPTO.KeyGenerator.getInstance(\"DES\")\n"
            }
          ]
        }
      ],
      "languages": [
        "java",
        "kt"
      ]
    },
    {
      "id": "java.lang.security.audit.crypto.ecb-cipher.ecb-cipher",
      "metadata": {
        "functional-categories": [
          "crypto::search::mode::javax.crypto"
        ],
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#ECB_MODE",
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Insecure ECB encryption mode",
        "fix-suggestion": "Replace ECB mode with an authenticated encryption mode like `GCM` by using `Cipher.getInstance(\"AES/GCM/NoPadding\")`. Ensure you include the necessary authentication data when using GCM mode. If GCM is not available, use CBC mode with a proper HMAC or other authentication mechanism."
      },
      "message": "Your code uses ECB (Electronic Codebook) mode for encryption, which is fundamentally insecure for most applications. ECB encrypts identical plaintext blocks to identical ciphertext blocks, revealing patterns in the encrypted data. This mode also lacks integrity checking, allowing attackers to modify the ciphertext without detection. Use GCM or CBC with proper authentication instead.",
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "patterns": [
        {
          "pattern": "Cipher $VAR = $CIPHER.getInstance($MODE);\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$MODE",
            "regex": ".*ECB.*"
          }
        }
      ]
    },
    {
      "id": "java.lang.security.audit.crypto.gcm-nonce-reuse.gcm-nonce-reuse",
      "metadata": {
        "functional-categories": [
          "crypto::search::randomness::javax.crypto"
        ],
        "cwe": [
          "CWE-323: Reusing a Nonce, Key Pair in Encryption"
        ],
        "category": "security",
        "source-rule-url": "https://www.youtube.com/watch?v=r1awgAl90wM",
        "technology": [
          "java"
        ],
        "owasp": [
          "A02:2021 - Cryptographic Failures"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "GCM encryption nonce reuse breaks security",
        "fix-suggestion": "Generate a new random IV for each encryption operation using `SecureRandom` to create a 12-byte nonce. Never store or reuse a static IV/nonce with GCM mode. Consider using a cryptographic library that handles nonce generation and management automatically."
      },
      "languages": [
        "java"
      ],
      "message": "Your code reuses the same IV/nonce with GCM encryption mode, which completely breaks the security of the encryption. When a nonce is reused with GCM, attackers can determine the authentication key, compute arbitrary forgeries, and potentially recover plaintext. Always use a unique nonce for each encryption operation with GCM mode.",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "new GCMParameterSpec(..., \"...\".getBytes(...), ...);"
            },
            {
              "pattern": "byte[] $NONCE = \"...\".getBytes(...); ... new GCMParameterSpec(..., $NONCE, ...);"
            }
          ]
        }
      ],
      "severity": "ERROR"
    },
    {
      "id": "java.lang.security.audit.crypto.no-null-cipher.no-null-cipher",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "new NullCipher(...);"
            },
            {
              "pattern": "new javax.crypto.NullCipher(...);"
            }
          ]
        }
      ],
      "metadata": {
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#NULL_CIPHER",
        "asvs": {
          "section": "V6 Stored Cryptography Verification Requirements",
          "control_id": "6.2.5 Insecure Algorithm",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "NullCipher provides no actual encryption",
        "fix-suggestion": "Replace all instances of `NullCipher` with a proper encryption implementation such as `Cipher.getInstance(\"AES/GCM/NoPadding\")`. Ensure you use appropriate key sizes (at least 128 bits for AES) and proper key management. Review all security-sensitive code to ensure no test or debug encryption implementations remain in production."
      },
      "message": "Your code uses NullCipher, which provides no encryption at all\u00e2\u20ac\u201dthe 'encrypted' output is identical to the input plaintext. This creates a false sense of security while offering no actual protection for sensitive data. Replace NullCipher with a strong encryption algorithm to properly secure your data.",
      "severity": "WARNING",
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.lang.security.audit.crypto.no-static-initialization-vector.no-static-initialization-vector",
      "message": "Your code uses a static (hardcoded or reused) Initialization Vector (IV) for encryption. Static IVs compromise encryption security by producing identical ciphertext for identical plaintext, allowing pattern recognition. Each encryption operation should use a unique, randomly generated IV to ensure that identical plaintexts encrypt to different ciphertexts.",
      "metadata": {
        "cwe": [
          "CWE-329: Generation of Predictable IV with CBC Mode"
        ],
        "owasp": [
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#STATIC_IV",
        "asvs": {
          "section": "V6 Stored Cryptography Verification Requirements",
          "control_id": "6.2.5 Insecure Algorithm",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms",
          "version": "4"
        },
        "references": [
          "https://cwe.mitre.org/data/definitions/329.html"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Static encryption IV weakens cipher security",
        "fix-suggestion": "Generate a new random IV for each encryption operation using `SecureRandom`. Store the IV alongside the ciphertext (it doesn't need to be secret) and retrieve it for decryption. Consider using a cryptographic library that handles IV generation and management automatically."
      },
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "pattern-either": [
        {
          "pattern": "byte[] $IV = {\n    ...\n};\n...\nnew IvParameterSpec($IV, ...);\n"
        },
        {
          "pattern": "class $CLASS {\n    byte[] $IV = {\n        ...\n    };\n    ...\n    $METHOD(...) {\n        ...\n        new IvParameterSpec($IV, ...);\n        ...\n    }\n}\n"
        }
      ]
    },
    {
      "id": "java.lang.security.audit.crypto.rsa-no-padding.rsa-no-padding",
      "metadata": {
        "functional-categories": [
          "crypto::search::mode::javax.crypto"
        ],
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#RSA_NO_PADDING",
        "references": [
          "https://rdist.root.org/2009/10/06/why-rsa-encryption-padding-is-critical/"
        ],
        "asvs": {
          "section": "V6 Stored Cryptography Verification Requirements",
          "control_id": "6.2.5 Insecure Algorithm",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "java",
          "kotlin"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "RSA without OAEP padding is vulnerable",
        "fix-suggestion": "Update your RSA encryption to use OAEP padding by specifying `Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-256AndMGF1Padding\")`. Ensure your RSA key size is at least 2048 bits. Consider using hybrid encryption (combining RSA for key exchange and AES for data encryption) for better performance and security."
      },
      "message": "Your code uses RSA encryption without OAEP (Optimal Asymmetric Encryption Padding), which is vulnerable to various attacks including padding oracle attacks. Unpadded RSA or RSA with PKCS#1 v1.5 padding has known security weaknesses. Always use RSA with OAEP padding for maximum security in asymmetric encryption.",
      "severity": "WARNING",
      "languages": [
        "java",
        "kt"
      ],
      "pattern": "$CIPHER.getInstance(\"=~/RSA/[Nn][Oo][Nn][Ee]/NoPadding/\")"
    },
    {
      "id": "java.lang.security.audit.crypto.unencrypted-socket.unencrypted-socket",
      "metadata": {
        "functional-categories": [
          "net::search::crypto-config::java.net"
        ],
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#UNENCRYPTED_SOCKET",
        "asvs": {
          "section": "V6 Stored Cryptography Verification Requirements",
          "control_id": "6.2.5 Insecure Algorithm",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Unencrypted socket communication",
        "fix-suggestion": "Replace standard `Socket` usage with `SSLSocket` objects created by `SSLSocketFactory` or `SSLServerSocketFactory`. Configure your SSL context to use strong protocols like TLSv1.2 or TLSv1.3. Implement proper certificate validation to prevent man-in-the-middle attacks."
      },
      "message": "Your application uses unencrypted socket connections, allowing attackers to intercept and read all transmitted data through network sniffing. Unencrypted communication exposes sensitive information including credentials, personal data, and session tokens. Always use encrypted connections for transmitting sensitive information over networks.",
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "pattern-either": [
        {
          "pattern": "new ServerSocket(...)"
        },
        {
          "pattern": "new Socket(...)"
        }
      ]
    },
    {
      "id": "java.lang.security.audit.crypto.use-of-aes-ecb.use-of-aes-ecb",
      "pattern": "$CIPHER.getInstance(\"=~/AES/ECB.*/\")",
      "metadata": {
        "functional-categories": [
          "crypto::search::mode::javax.crypto"
        ],
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures",
          "https://googleprojectzero.blogspot.com/2022/10/rc4-is-still-considered-harmful.html"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Insecure AES-ECB mode reveals data patterns",
        "fix-suggestion": "Replace ECB mode with GCM by using `Cipher.getInstance(\"AES/GCM/NoPadding\")` for authenticated encryption. Ensure you generate a unique IV for each encryption operation using `SecureRandom`. If GCM is not available, use CBC mode with a proper HMAC for integrity validation."
      },
      "message": "Your code uses AES with ECB mode, which is fundamentally insecure for most applications. ECB mode encrypts identical blocks to identical ciphertext, revealing patterns in the data and allowing attackers to identify repeated content. Use a secure mode like GCM or CBC with proper IVs instead of ECB for reliable encryption.",
      "severity": "WARNING",
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.lang.security.audit.crypto.use-of-blowfish.use-of-blowfish",
      "pattern": "$CIPHER.getInstance(\"Blowfish\")",
      "metadata": {
        "functional-categories": [
          "crypto::search::symmetric-algorithm::javax.crypto"
        ],
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures",
          "https://googleprojectzero.blogspot.com/2022/10/rc4-is-still-considered-harmful.html"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Blowfish encryption vulnerable to birthday attacks",
        "fix-suggestion": "Replace Blowfish with AES by using `Cipher.getInstance(\"AES/GCM/NoPadding\")` for authenticated encryption. Use key sizes of at least 128 bits for AES. Review all cryptographic code to ensure consistent use of secure algorithms and proper key management."
      },
      "message": "Your code uses the Blowfish encryption algorithm, which has a small 64-bit block size that makes it vulnerable to birthday attacks when encrypting large amounts of data. Modern security standards consider Blowfish non-compliant for secure applications. Replace Blowfish with AES, which uses 128-bit blocks and offers superior security.",
      "severity": "WARNING",
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.lang.security.audit.crypto.use-of-default-aes.use-of-default-aes",
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "import javax;\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "javax.crypto.Cipher.getInstance(\"AES\")"
                },
                {
                  "pattern": "(javax.crypto.Cipher $CIPHER).getInstance(\"AES\")"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "import javax.*;\n...\n"
                },
                {
                  "pattern-inside": "import javax.crypto;\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "crypto.Cipher.getInstance(\"AES\")"
                },
                {
                  "pattern": "(crypto.Cipher $CIPHER).getInstance(\"AES\")"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "import javax.crypto.*;\n...\n"
                },
                {
                  "pattern-inside": "import javax.crypto.Cipher;\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "Cipher.getInstance(\"AES\")"
                },
                {
                  "pattern": "(Cipher $CIPHER).getInstance(\"AES\")"
                }
              ]
            }
          ]
        }
      ],
      "metadata": {
        "functional-categories": [
          "crypto::search::mode::javax.crypto"
        ],
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures",
          "https://googleprojectzero.blogspot.com/2022/10/rc4-is-still-considered-harmful.html"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Default AES uses insecure ECB mode",
        "fix-suggestion": "Always specify the encryption mode explicitly when using AES by using `Cipher.getInstance(\"AES/GCM/NoPadding\")` for authenticated encryption. Generate unique IVs for each encryption operation. Consider using a higher-level cryptographic library that implements secure defaults."
      },
      "message": "Your code uses AES without specifying an encryption mode, which defaults to insecure ECB mode in Java. ECB mode encrypts identical blocks to identical ciphertext, revealing patterns in your data. Always explicitly specify a secure mode (GCM or CBC) when using encryption algorithms to ensure proper security.",
      "severity": "WARNING",
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.lang.security.audit.crypto.use-of-md5-digest-utils.use-of-md5-digest-utils",
      "message": "Your code uses the MD5 hash algorithm, which is cryptographically broken and unsuitable for security purposes. MD5 is vulnerable to collision attacks, allowing attackers to generate different inputs with the same hash. For data integrity or signatures, use secure alternatives like SHA-256 or HMAC with a strong hash function.",
      "languages": [
        "java"
      ],
      "severity": "WARNING",
      "metadata": {
        "functional-categories": [
          "crypto::search::hash-algorithm::org.apache.commons"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-328: Use of Weak Hash"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#WEAK_MESSAGE_DIGEST_MD5",
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Hashing Algorithm"
        ],
        "short-description": "MD5 hash vulnerable to collision attacks",
        "fix-suggestion": "Replace MD5 with a secure hashing algorithm such as `SHA-256` or `SHA-3`. For signature or integrity verification purposes, use `HMAC` with a secure hash function like `HmacSHA256`. Ensure all security-sensitive code is updated to use modern cryptographic algorithms."
      },
      "patterns": [
        {
          "pattern": "$DU.$GET_ALGO().digest(...)\n"
        },
        {
          "metavariable-pattern": {
            "metavariable": "$GET_ALGO",
            "pattern": "getMd5Digest"
          }
        },
        {
          "metavariable-pattern": {
            "metavariable": "$DU",
            "pattern": "DigestUtils"
          }
        },
        {
          "focus-metavariable": "$GET_ALGO"
        }
      ],
      "fix": "getSha512Digest\n"
    },
    {
      "id": "java.lang.security.audit.crypto.use-of-md5.use-of-md5",
      "message": "Your code uses the MD5 hash algorithm, which is cryptographically broken and unsuitable for security purposes. MD5 is vulnerable to collision attacks, allowing attackers to generate different inputs with the same hash. For data integrity or signatures, use secure alternatives like SHA-256 or HMAC with a strong hash function.",
      "languages": [
        "java"
      ],
      "severity": "WARNING",
      "metadata": {
        "functional-categories": [
          "crypto::search::hash-algorithm::java.security"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-328: Use of Weak Hash"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#WEAK_MESSAGE_DIGEST_MD5",
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Hashing Algorithm"
        ],
        "short-description": "MD5 hash vulnerable to collision attacks",
        "fix-suggestion": "Replace MD5 with a secure hashing algorithm such as `SHA-256` or `SHA-3`. For signature or integrity verification purposes, use `HMAC` with a secure hash function like `HmacSHA256`. Ensure all security-sensitive code is updated to use modern cryptographic algorithms."
      },
      "patterns": [
        {
          "pattern": "java.security.MessageDigest.getInstance($ALGO, ...);\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$ALGO",
            "regex": "(.MD5.)"
          }
        },
        {
          "focus-metavariable": "$ALGO"
        }
      ],
      "fix": "\"SHA-512\"\n"
    },
    {
      "id": "java.lang.security.audit.crypto.use-of-rc2.use-of-rc2",
      "pattern": "$CIPHER.getInstance(\"RC2\")",
      "metadata": {
        "functional-categories": [
          "crypto::search::symmetric-algorithm::javax.crypto"
        ],
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures",
          "https://googleprojectzero.blogspot.com/2022/10/rc4-is-still-considered-harmful.html"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "RC2 encryption vulnerable to related-key attacks",
        "fix-suggestion": "Replace RC2 with AES by using `Cipher.getInstance(\"AES/GCM/NoPadding\")` for authenticated encryption. Use key sizes of at least 128 bits for AES. Update any dependent systems to ensure compatibility with the more secure encryption algorithm."
      },
      "message": "Your code uses the RC2 encryption algorithm, which is considered cryptographically weak and vulnerable to related-key attacks. RC2 has been deprecated in modern security standards due to its short key length and known vulnerabilities. Replace RC2 with AES, which provides significantly stronger security guarantees.",
      "severity": "WARNING",
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.lang.security.audit.crypto.use-of-rc4.use-of-rc4",
      "pattern": "$CIPHER.getInstance(\"RC4\")",
      "metadata": {
        "functional-categories": [
          "crypto::search::symmetric-algorithm::javax.crypto"
        ],
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures",
          "https://googleprojectzero.blogspot.com/2022/10/rc4-is-still-considered-harmful.html"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "RC4 cipher with known cryptographic weaknesses",
        "fix-suggestion": "Replace RC4 with AES by using `Cipher.getInstance(\"AES/GCM/NoPadding\")` for authenticated encryption. Use key sizes of at least 128 bits for AES. Ensure that all security-sensitive code is reviewed to remove outdated cryptographic algorithms."
      },
      "message": "Your code uses the RC4 stream cipher, which has been broken in multiple ways and is now prohibited in standards like TLS. RC4 is vulnerable to several statistical attacks that can recover portions of the plaintext. Replace RC4 with a modern encryption algorithm like AES in an authenticated mode for secure communications.",
      "severity": "WARNING",
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.lang.security.audit.crypto.use-of-sha1.use-of-sha1",
      "message": "Your code uses the SHA-1 hash algorithm, which is no longer considered secure for cryptographic purposes. SHA-1 is vulnerable to collision attacks, allowing attackers to create documents with the same hash. For cryptographic signatures or integrity verification, use SHA-256 or SHA-512 instead.",
      "languages": [
        "java"
      ],
      "severity": "WARNING",
      "metadata": {
        "functional-categories": [
          "crypto::search::hash-algorithm::javax.crypto"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-328: Use of Weak Hash"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#WEAK_MESSAGE_DIGEST_SHA1",
        "asvs": {
          "section": "V6 Stored Cryptography Verification Requirements",
          "control_id": "6.2.5 Insecure Algorithm",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Hashing Algorithm"
        ],
        "short-description": "SHA-1 hash vulnerable to collision attacks",
        "fix-suggestion": "Replace SHA-1 with `SHA-256` or `SHA-512` for general hashing needs. For password storage, use specialized password hashing algorithms like `PBKDF2`, `bcrypt`, or `Argon2`. Update all security-sensitive code to use modern cryptographic algorithms with appropriate parameters."
      },
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern": "java.security.MessageDigest.getInstance(\"$ALGO\", ...);\n"
            },
            {
              "metavariable-regex": {
                "metavariable": "$ALGO",
                "regex": "(SHA1|SHA-1)"
              }
            }
          ]
        },
        {
          "pattern": "$DU.getSha1Digest().digest(...)\n"
        }
      ]
    },
    {
      "id": "java.lang.security.audit.crypto.use-of-sha224.use-of-sha224",
      "message": "Your code uses SHA-224, which is disallowed in some security policies and standards like FIPS 140-3. While not as broken as SHA-1, SHA-224 provides a smaller security margin than recommended for applications requiring long-term security. Upgrade to SHA-256, SHA-384, or SHA-512 to ensure compliance with common security standards.",
      "languages": [
        "java"
      ],
      "severity": "WARNING",
      "metadata": {
        "functional-categories": [
          "crypto::search::hash-algorithm::javax.crypto"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-328: Use of Weak Hash"
        ],
        "asvs": {
          "section": "V6 Stored Cryptography Verification Requirements",
          "control_id": "6.2.5 Insecure Algorithm",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar3.ipd.pdf",
          "https://www.cyber.gov.au/resources-business-and-government/essential-cyber-security/ism/cyber-security-guidelines/guidelines-cryptography"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Hashing Algorithm"
        ],
        "short-description": "SHA-224 doesn't meet some security standards",
        "fix-suggestion": "Replace SHA-224 with `SHA-256` or preferably `SHA-384` or `SHA-512` for applications requiring higher security assurance. Use `MessageDigest.getInstance(\"SHA-256\")` or higher to meet common security standards. Review security requirements for your specific application domain to ensure compliance."
      },
      "pattern-either": [
        {
          "pattern": "org.apache.commons.codec.digest.DigestUtils.getSha3_224Digest()"
        },
        {
          "pattern": "org.apache.commons.codec.digest.DigestUtils.getSha512_224Digest()"
        },
        {
          "pattern": "org.apache.commons.codec.digest.DigestUtils.sha3_224(...)"
        },
        {
          "pattern": "org.apache.commons.codec.digest.DigestUtils.sha3_224Hex(...)"
        },
        {
          "pattern": "org.apache.commons.codec.digest.DigestUtils.sha512_224(...)"
        },
        {
          "pattern": "org.apache.commons.codec.digest.DigestUtils.sha512_224Hex(...)"
        },
        {
          "pattern": "new org.apache.commons.codec.digest.DigestUtils(org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA_224)"
        },
        {
          "pattern": "new org.apache.commons.codec.digest.DigestUtils(org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA_512_224)"
        },
        {
          "pattern": "new org.apache.commons.codec.digest.DigestUtils(org.apache.commons.codec.digest.MessageDigestAlgorithms.SHA3_224)"
        },
        {
          "patterns": [
            {
              "pattern": "java.security.MessageDigest.getInstance(\"$ALGO\", ...);"
            },
            {
              "metavariable-regex": {
                "metavariable": "$ALGO",
                "regex": ".*224"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "java.lang.security.audit.crypto.weak-random.weak-random",
      "message": "Your code uses Math.random() or java.util.Random(), which are not cryptographically secure and can produce predictable sequences. When used for security purposes like generating tokens or cryptographic keys, these weak random number generators can lead to successful attacks. Always use SecureRandom for security-sensitive random number generation.",
      "languages": [
        "java"
      ],
      "severity": "WARNING",
      "metadata": {
        "functional-categories": [
          "crypto::search::randomness::java.security"
        ],
        "owasp": [
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-330: Use of Insufficiently Random Values"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Weak random generator for security purposes",
        "fix-suggestion": "Replace `Math.random()` or `java.util.Random()` with `java.security.SecureRandom` for any security-related randomness including session tokens, password reset tokens, and cryptographic keys. Properly seed `SecureRandom` by using the no-argument constructor rather than specifying your own seed."
      },
      "pattern-either": [
        {
          "pattern": "new java.util.Random(...).$FUNC(...)\n"
        },
        {
          "pattern": "java.lang.Math.random(...)\n"
        }
      ]
    },
    {
      "id": "java.lang.security.audit.crypto.ssl.avoid-implementing-custom-digests.avoid-implementing-custom-digests",
      "metadata": {
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#CUSTOM_MESSAGE_DIGEST",
        "asvs": {
          "section": "V6 Stored Cryptography Verification Requirements",
          "control_id": "6.2.2 Insecure Custom Algorithm",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms",
          "version": "4"
        },
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#custom-algorithms"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Custom cryptographic digest implementation risks",
        "fix-suggestion": "Replace your custom digest implementation with standard JCA classes like `MessageDigest.getInstance(\"SHA-256\")`. Use vetted cryptographic libraries from trusted sources instead of custom implementations. Even small implementation errors can completely compromise security, so rely on well-tested code."
      },
      "message": "Your code implements a custom cryptographic message digest algorithm, which is extremely risky. Cryptographic algorithms require extensive validation and testing to be secure, and subtle implementation flaws can completely undermine security. Use standard, well-tested implementations from the JCA (Java Cryptography Architecture) instead of creating your own.",
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "pattern": "class $CLASS extends MessageDigest {\n  ...\n}"
    },
    {
      "id": "java.lang.security.audit.crypto.ssl.defaulthttpclient-is-deprecated.defaulthttpclient-is-deprecated",
      "metadata": {
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#DEFAULT_HTTP_CLIENT",
        "asvs": {
          "section": "V9 Communications Verification Requirements",
          "control_id": "9.1.3 Weak TLS",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x17-V9-Communications.md#v91-client-communications-security-requirements",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Deprecated HTTP client lacks TLS 1.2 support",
        "fix-suggestion": "Replace `DefaultHttpClient` with `HttpClientBuilder` from the Apache HttpComponents library. Use `.setSSLContext()` to configure TLS 1.2 or higher for secure connections. Ensure your HTTP client validates certificates properly by avoiding unsafe trust manager configurations."
      },
      "message": "Your code uses DefaultHttpClient, which is deprecated and does not support secure TLS 1.2 connections. This means your HTTP connections might use outdated, insecure protocols vulnerable to known attacks. Replace with HttpClientBuilder which supports modern security standards and receives security updates.",
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "pattern": "new DefaultHttpClient(...);",
      "fix-regex": {
        "regex": "DefaultHttpClient",
        "replacement": "HttpClientBuilder"
      }
    },
    {
      "id": "java.lang.security.audit.crypto.ssl.insecure-hostname-verifier.insecure-hostname-verifier",
      "message": "Your code uses an insecure HostnameVerifier that accepts any SSL certificate regardless of whether the hostname matches. This completely bypasses a critical TLS security check, allowing attackers to perform man-in-the-middle attacks using valid certificates for different domains. Always properly verify hostnames against certificates in production code.",
      "metadata": {
        "cwe": [
          "CWE-295: Improper Certificate Validation"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A07:2021 - Identification and Authentication Failures"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#WEAK_HOSTNAME_VERIFIER",
        "asvs": {
          "section": "V9 Communications Verification Requirements",
          "control_id": "9.2.1 Weak TLS",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x17-V9-Communications.md#v92-server-communications-security-requirements",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "java"
        ],
        "references": [
          "https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Hostname verification bypass enables MITM attacks",
        "fix-suggestion": "Remove custom `HostnameVerifier` implementations that bypass hostname validation. Use the default verifier provided by your HTTP client library. If you must implement a custom verifier, ensure it properly validates that certificate hostnames match the server you're connecting to."
      },
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "pattern-either": [
        {
          "pattern": "class $CLASS implements HostnameVerifier {\n  ...\n  public boolean verify(...) { return true; }\n}\n"
        },
        {
          "pattern": "new HostnameVerifier(...){\n  public boolean verify(...) {\n    return true;\n  }\n}"
        },
        {
          "pattern": "import org.apache.http.conn.ssl.NoopHostnameVerifier;"
        }
      ]
    },
    {
      "id": "java.lang.security.audit.crypto.ssl.insecure-trust-manager.insecure-trust-manager",
      "metadata": {
        "cwe": [
          "CWE-295: Improper Certificate Validation"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A07:2021 - Identification and Authentication Failures"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#WEAK_TRUST_MANAGER",
        "asvs": {
          "section": "V9 Communications Verification Requirements",
          "control_id": "9.2.1 Weak TLS",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x17-V9-Communications.md#v92-server-communications-security-requirements",
          "version": "4"
        },
        "references": [
          "https://stackoverflow.com/questions/2642777/trusting-all-certificates-using-httpclient-over-https"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Empty TrustManager bypasses certificate validation",
        "fix-suggestion": "Remove insecure `TrustManager` implementations that blindly accept all certificates. Use a properly configured `TrustManagerFactory` with a `KeyStore` containing trusted CA certificates. For testing environments, consider using self-signed certificates properly installed in a test-specific trust store."
      },
      "message": "Your code implements an empty or permissive TrustManager that accepts any SSL certificate without validation. This completely compromises the security of your HTTPS connections, allowing attackers to intercept traffic using fake certificates. Always properly validate certificates against trusted certificate authorities in production code.",
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "class $CLASS implements X509TrustManager {\n  ...\n}\n"
            },
            {
              "pattern-inside": "new X509TrustManager() {\n  ...\n}\n"
            },
            {
              "pattern-inside": "class $CLASS implements X509ExtendedTrustManager {\n  ...\n}\n"
            },
            {
              "pattern-inside": "new X509ExtendedTrustManager() {\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern-not": "public void checkClientTrusted(...) { $SOMETHING; }"
        },
        {
          "pattern-not": "public void checkServerTrusted(...) { $SOMETHING; }"
        },
        {
          "pattern-either": [
            {
              "pattern": "public void checkClientTrusted(...) {}"
            },
            {
              "pattern": "public void checkServerTrusted(...) {}"
            },
            {
              "pattern": "public X509Certificate[] getAcceptedIssuers(...) { return null; }"
            }
          ]
        }
      ]
    },
    {
      "id": "java.lang.security.audit.crypto.weak-rsa.use-of-weak-rsa-key",
      "message": "Your code uses an RSA key with insufficient key length, which is vulnerable to factoring attacks as computing power increases. NIST and other security standards require RSA keys to be at least 2048 bits in length for adequate security. Shorter keys can be compromised, exposing encrypted data or allowing signature forgery.",
      "languages": [
        "java"
      ],
      "severity": "WARNING",
      "metadata": {
        "functional-categories": [
          "crypto::search::key-length::java.security"
        ],
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#RSA_KEY_SIZE",
        "asvs": {
          "section": "V6 Stored Cryptography Verification Requirements",
          "control_id": "6.2.5 Insecure Algorithm",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms",
          "version": "4"
        },
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#algorithms"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "RSA key length below security standards",
        "fix-suggestion": "Increase your RSA key size to at least `2048` bits, and preferably `3072` bits for longer-term security. Generate new keys using `KeyPairGenerator` with the proper key size parameters. Update any systems or certificates using the weak keys to ensure consistent security."
      },
      "patterns": [
        {
          "pattern": "KeyPairGenerator $KEY = $G.getInstance(\"RSA\");\n...\n$KEY.initialize($BITS);\n"
        },
        {
          "metavariable-comparison": {
            "metavariable": "$BITS",
            "comparison": "$BITS < 2048"
          }
        }
      ]
    },
    {
      "id": "java.lang.security.audit.sqli.hibernate-sqli.hibernate-sqli",
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "String $SQL = $X + $Y;\n...\n"
                },
                {
                  "pattern-inside": "String $SQL = String.format(...);\n...\n"
                },
                {
                  "pattern-inside": "$VAL $FUNC(...,String $SQL,...) {\n...\n}\n"
                }
              ]
            },
            {
              "pattern-not-inside": "String $SQL = \"...\" + \"...\";\n...\n"
            },
            {
              "pattern": "org.hibernate.criterion.Restrictions.sqlRestriction($SQL,...)"
            }
          ]
        },
        {
          "pattern": "org.hibernate.criterion.Restrictions.sqlRestriction(String.format(...),...)"
        },
        {
          "patterns": [
            {
              "pattern": "org.hibernate.criterion.Restrictions.sqlRestriction($X + $Y,...)"
            },
            {
              "pattern-not": "org.hibernate.criterion.Restrictions.sqlRestriction(\"...\" + \"...\",...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "String $SQL = $X + $Y;\n...\n"
                        },
                        {
                          "pattern-inside": "String $SQL = String.format(...);\n...\n"
                        },
                        {
                          "pattern-inside": "$TYPE $FUNC(...,String $SQL,...) {\n  ...\n}\n"
                        }
                      ]
                    },
                    {
                      "pattern-not-inside": "String $SQL = \"...\" + \"...\";\n...\n"
                    },
                    {
                      "pattern": "$SESSION.$METHOD($SQL,...)"
                    }
                  ]
                },
                {
                  "pattern": "$SESSION.$METHOD(String.format(...),...);\n"
                },
                {
                  "pattern": "$SESSION.$METHOD($X + $Y,...);\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "org.hibernate.Session $SESSION = ...;\n...\n"
                },
                {
                  "pattern-inside": "$TYPE $FUNC(...,org.hibernate.Session $SESSION,...) {\n  ...\n}\n"
                }
              ]
            },
            {
              "pattern-not": "$SESSION.$METHOD(\"...\" + \"...\",...);\n"
            },
            {
              "metavariable-regex": {
                "metavariable": "$METHOD",
                "regex": "^(createQuery|createSQLQuery)$"
              }
            }
          ]
        }
      ],
      "message": "This vulnerability happens when Hibernate queries are constructed by directly embedding user input into strings instead of using parameterized queries. Attackers can inject SQL syntax that alters the query structure, potentially gaining unauthorized data access or performing database modifications. Using Hibernate's parameter binding mechanisms ensures user input is properly escaped and treated as data rather than executable SQL, preventing injection attacks.",
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#SQL_INJECTION_HIBERNATE",
        "asvs": {
          "section": "V5 Stored Cryptography Verification Requirements",
          "control_id": "5.3.5 Insecure Custom Algorithm",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "hibernate"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Raw SQL in Hibernate with user input fosters injection",
        "fix-suggestion": "Replace string concatenation in Hibernate queries with parameterized queries using positional (`?`) or named (`:name`) parameters. Use `setParameter()` to safely bind user input and avoid constructing queries with `Session.createQuery()` and dynamically built strings. For dynamic conditions, use Criteria API or HQL with parameterized values."
      },
      "languages": [
        "java"
      ],
      "severity": "WARNING"
    },
    {
      "id": "java.lang.security.audit.sqli.jdbc-sqli.jdbc-sqli",
      "message": "This vulnerability arises when SQL queries in JDBC are built by concatenating or formatting strings with unsanitized user input. Attackers can inject malicious SQL fragments that change the query's intended behavior, allowing unauthorized data access, modification, or execution of administrative commands. Using PreparedStatement objects with parameter placeholders properly separates SQL code from data, preventing attackers from altering the query structure.",
      "languages": [
        "java"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "String $SQL = $X + $Y;\n...\n"
                    },
                    {
                      "pattern-inside": "String $SQL = String.format(...);\n...\n"
                    },
                    {
                      "pattern-inside": "$VAL $FUNC(...,String $SQL,...) {\n  ...\n}\n"
                    }
                  ]
                },
                {
                  "pattern-not-inside": "String $SQL = \"...\" + \"...\";\n...\n"
                },
                {
                  "pattern": "$S.$METHOD($SQL,...)"
                }
              ]
            },
            {
              "pattern": "$S.$METHOD(String.format(...),...);\n"
            },
            {
              "pattern": "$S.$METHOD($X + $Y,...);\n"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "java.sql.Statement $S = ...;\n...\n"
            },
            {
              "pattern-inside": "$TYPE $FUNC(...,java.sql.Statement $S,...) {\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern-not": "$S.$METHOD(\"...\" + \"...\",...);\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$METHOD",
            "regex": "^(executeQuery|execute|executeUpdate|executeLargeUpdate|addBatch|nativeSQL)$"
          }
        }
      ],
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "category": "security",
        "technology": [
          "jdbc"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "JDBC queries built with dynamic strings risk SQL injection",
        "fix-suggestion": "Replace string concatenation in JDBC queries with `PreparedStatement` objects and parameter binding. Use question marks as placeholders and set values with appropriate setter methods (`setString`, `setInt`). Never interpolate user input directly into SQL strings using concatenation or functions like `String.format()`."
      }
    },
    {
      "id": "java.lang.security.audit.sqli.jdo-sqli.jdo-sqli",
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "String $SQL = $X + $Y;\n...\n"
                        },
                        {
                          "pattern-inside": "String $SQL = String.format(...);\n...\n"
                        },
                        {
                          "pattern-inside": "$TYPE $FUNC(...,String $SQL,...) {\n  ...\n}\n"
                        }
                      ]
                    },
                    {
                      "pattern-not-inside": "String $SQL = \"...\" + \"...\";\n...\n"
                    },
                    {
                      "pattern": "$Q.$METHOD($SQL,...)"
                    }
                  ]
                },
                {
                  "pattern": "$Q.$METHOD(String.format(...),...);\n"
                },
                {
                  "pattern": "$Q.$METHOD($X + $Y,...);\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "javax.jdo.Query $Q = ...;\n...\n"
                },
                {
                  "pattern-inside": "$TYPE $FUNC(...,javax.jdo.Query $Q,...) {\n  ...\n}\n"
                }
              ]
            },
            {
              "pattern-not": "$Q.$METHOD(\"...\" + \"...\",...);\n"
            },
            {
              "metavariable-regex": {
                "metavariable": "$METHOD",
                "regex": "^(setFilter|setGrouping)$"
              }
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "String $SQL = $X + $Y;\n...\n"
                        },
                        {
                          "pattern-inside": "String $SQL = String.format(...);\n...\n"
                        },
                        {
                          "pattern-inside": "$VAL $FUNC(...,String $SQL,...) {\n  ...\n}\n"
                        }
                      ]
                    },
                    {
                      "pattern-not-inside": "String $SQL = \"...\" + \"...\";\n...\n"
                    },
                    {
                      "pattern": "$PM.newQuery(...,$SQL,...)"
                    }
                  ]
                },
                {
                  "pattern": "$PM.newQuery(...,String.format(...),...);\n"
                },
                {
                  "pattern": "$PM.newQuery(...,$X + $Y,...);\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "javax.jdo.PersistenceManager $PM = ...;\n...\n"
                },
                {
                  "pattern-inside": "$TYPE $FUNC(...,javax.jdo.PersistenceManager $PM,...) {\n  ...\n}\n"
                }
              ]
            },
            {
              "pattern-not": "$PM.newQuery(...,\"...\" + \"...\",...);\n"
            }
          ]
        }
      ],
      "message": "This vulnerability occurs when JDO queries are constructed by concatenating strings with user-supplied values instead of using parameterized queries. Attackers can inject specially crafted input containing SQL syntax that alters the query's intent, potentially allowing unauthorized access to data or database manipulation. Using JDO's parameter binding mechanisms ensures that user input is properly escaped and treated as literal values rather than executable code.",
      "languages": [
        "java"
      ],
      "severity": "WARNING",
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "category": "security",
        "technology": [
          "java"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "String-based queries in JDO with user data can be injected",
        "fix-suggestion": "Replace string concatenation in JDO queries with parameterized queries using named parameters. Use `setParameter()` to safely bind user input and leverage `Query.setParameters()` for multiple parameters. Avoid building dynamic queries with user input and use JDO's typed queries or JDOQL when possible."
      }
    },
    {
      "id": "java.lang.security.audit.sqli.jpa-sqli.jpa-sqli",
      "message": "This vulnerability occurs when JPA queries are built by concatenating or formatting strings with user input instead of using parameterized queries. Attackers can insert malicious SQL code that alters query behavior, potentially accessing unauthorized data or manipulating database contents. Using JPA's parameter binding mechanisms properly separates the query structure from user data, preventing attackers from changing the query's intended functionality.",
      "languages": [
        "java"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "String $SQL = $X + $Y;\n...\n"
                    },
                    {
                      "pattern-inside": "String $SQL = String.format(...);\n...\n"
                    },
                    {
                      "pattern-inside": "$TYPE $FUNC(...,String $SQL,...) {\n  ...\n}\n"
                    }
                  ]
                },
                {
                  "pattern-not-inside": "String $SQL = \"...\" + \"...\";\n...\n"
                },
                {
                  "pattern": "$EM.$METHOD($SQL,...)"
                }
              ]
            },
            {
              "pattern": "$EM.$METHOD(String.format(...),...);\n"
            },
            {
              "pattern": "$EM.$METHOD($X + $Y,...);\n"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "EntityManager $EM = ...;\n...\n"
            },
            {
              "pattern-inside": "$TYPE $FUNC(...,EntityManager $EM,...) {\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern-not": "$EM.$METHOD(\"...\" + \"...\",...);\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$METHOD",
            "regex": "^(createQuery|createNativeQuery)$"
          }
        }
      ],
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "category": "security",
        "technology": [
          "jpa"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Dynamically built JPA queries expose injection vulnerability",
        "fix-suggestion": "Replace string concatenation in JPA queries with parameterized queries using positional parameters (`?`) or named parameters (`:name`). Use the `setParameter()` method to safely bind user input to query parameters instead of directly including it in query strings. Consider using the JPA Criteria API for dynamic query conditions which provides type-safe query construction."
      }
    },
    {
      "id": "java.lang.security.audit.sqli.tainted-sql-from-http-request.tainted-sql-from-http-request",
      "message": "This vulnerability happens when data from HTTP requests flows directly into SQL queries without proper sanitization or parameterization. Attackers can craft malicious input containing SQL syntax that modifies the query structure when executed, potentially leading to unauthorized data access, data manipulation, or privilege escalation. Implementing parameterized queries ensures that user-supplied values are always treated as data rather than executable code, regardless of their content.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "category": "security",
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "cwe2021-top25": true,
        "cwe2022-top25": true,
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html",
          "https://owasp.org/www-community/attacks/SQL_Injection"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "sql",
          "java",
          "servlets",
          "spring"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Untrusted HTTP input in SQL query leads to injection threat",
        "fix-suggestion": "Never include HTTP request parameters directly in SQL queries; always use prepared statements with parameter binding (`setString()`, `setInt()`, etc.). For frameworks like Spring or Hibernate, utilize their parameterized query features (JdbcTemplate with placeholder characters, HQL with named parameters). Implement additional input validation on HTTP parameters before using them in database operations, even with parameterized queries."
      },
      "languages": [
        "java"
      ],
      "mode": "taint",
      "options": {
        "taint_assume_safe_numbers": true,
        "taint_assume_safe_booleans": true
      },
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "(HttpServletRequest $REQ).$REQFUNC(...)\n"
                },
                {
                  "pattern": "(ServletRequest $REQ).$REQFUNC(...) \n"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$REQFUNC",
                "regex": "(getInputStream|getParameter|getParameterMap|getParameterValues|getReader|getCookies|getHeader|getHeaderNames|getHeaders|getPart|getParts|getQueryString)"
              }
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "(java.sql.CallableStatement $STMT) = ...; \n"
                },
                {
                  "pattern": "(java.sql.Statement $STMT) = ...;\n...\n$OUTPUT = $STMT.$FUNC(...);\n"
                },
                {
                  "pattern": "(java.sql.PreparedStatement $STMT) = ...;\n"
                },
                {
                  "pattern": "$VAR = $CONN.prepareStatement(...)\n"
                },
                {
                  "pattern": "$PATH.queryForObject(...);\n"
                },
                {
                  "pattern": "(java.util.Map<String, Object> $STMT) = $PATH.queryForMap(...);\n"
                },
                {
                  "pattern": "(org.springframework.jdbc.support.rowset.SqlRowSet $STMT) = ...;\n"
                },
                {
                  "pattern": "(org.springframework.jdbc.core.JdbcTemplate $TEMPL).batchUpdate(...)\n"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "(String $SQL) = \"$SQLSTR\" + ...;\n...\n"
                    },
                    {
                      "pattern": "$PATH.$SQLCMD(..., $SQL, ...);"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$SQLSTR",
                        "regex": "(?i)(^SELECT.* | ^INSERT.* | ^UPDATE.*)"
                      }
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$SQLCMD",
                        "regex": "(execute|query|executeUpdate|batchUpdate)"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "java.lang.security.audit.sqli.turbine-sqli.turbine-sqli",
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "String $SQL = $X + $Y;\n...\n"
                        },
                        {
                          "pattern-inside": "String $SQL = String.format(...);\n...\n"
                        },
                        {
                          "pattern-inside": "$VAL $FUNC(...,String $SQL,...) {\n  ...\n}\n"
                        }
                      ]
                    },
                    {
                      "pattern-not-inside": "String $SQL = \"...\" + \"...\";\n...\n"
                    },
                    {
                      "pattern": "$PEER.executeQuery($SQL,...)"
                    }
                  ]
                },
                {
                  "pattern": "$PEER.executeQuery(String.format(...),...)\n"
                },
                {
                  "pattern": "$PEER.executeQuery($X + $Y,...)\n"
                }
              ]
            },
            {
              "pattern-not": "$PEER.executeQuery(\"...\" + \"...\",...)\n"
            },
            {
              "metavariable-regex": {
                "metavariable": "$PEER",
                "regex": "(BasePeer|GroupPeer)"
              }
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "String $SQL = $X + $Y;\n...\n"
                        },
                        {
                          "pattern-inside": "String $SQL = String.format(...);\n...\n"
                        },
                        {
                          "pattern-inside": "$VAL $FUNC(...,String $SQL,...) {\n  ...\n}\n"
                        }
                      ]
                    },
                    {
                      "pattern-not-inside": "String $SQL = \"...\" + \"...\";\n...\n"
                    },
                    {
                      "pattern": "$P.executeQuery($SQL,...)"
                    }
                  ]
                },
                {
                  "pattern": "$P.executeQuery(String.format(...),...)\n"
                },
                {
                  "pattern": "$P.executeQuery($X + $Y,...)\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "BasePeer $P = ...;\n...\n"
                },
                {
                  "pattern-inside": "GroupPeer $P = ...;\n...\n"
                },
                {
                  "pattern-inside": "$VAL $FUNC(...,GroupPeer $P,...) {\n  ...\n}\n"
                },
                {
                  "pattern-inside": "$VAL $FUNC(...,BasePeer $P,...) {\n  ...\n}\n"
                }
              ]
            },
            {
              "pattern-not": "$P.executeQuery(\"...\" + \"...\",...)\n"
            }
          ]
        }
      ],
      "message": "This vulnerability arises when Turbine SQL queries are constructed by directly embedding user input into query strings without proper parameterization. Attackers can inject SQL syntax that changes the query's structure and behavior, potentially gaining unauthorized data access or executing database operations. Using prepared statements with parameter binding ensures user input is treated as literal data rather than executable SQL, preventing injection attacks.",
      "languages": [
        "java"
      ],
      "severity": "WARNING",
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "category": "security",
        "technology": [
          "turbine"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Turbine string-based SQL with user data can cause injection",
        "fix-suggestion": "Replace string concatenation in Turbine SQL queries with parameterized queries using `BasePeer.executeQuery()` with prepared statements. Use question marks as placeholders in SQL strings and provide parameters as separate value lists. Consider using Turbine's object-relational mapping features instead of raw SQL queries to benefit from built-in SQL injection protection."
      }
    },
    {
      "id": "java.lang.security.audit.sqli.vertx-sqli.vertx-sqli",
      "message": "This vulnerability occurs when Vert.x SQL queries are built by concatenating user input directly into the query string instead of using parameterized queries. Attackers can insert SQL fragments that alter the query's intended behavior, potentially exposing sensitive data or modifying database contents. Using Vert.x's parameterized query features ensures user input is properly escaped and treated as data rather than executable SQL code.",
      "languages": [
        "java"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "String $SQL = $X + $Y;\n...\n"
                    },
                    {
                      "pattern-inside": "String $SQL = String.format(...);\n...\n"
                    },
                    {
                      "pattern-inside": "$TYPE $FUNC(...,String $SQL,...) {\n  ...\n}\n"
                    }
                  ]
                },
                {
                  "pattern-not-inside": "String $SQL = \"...\" + \"...\";\n...\n"
                },
                {
                  "pattern": "$SC.$METHOD($SQL,...)"
                }
              ]
            },
            {
              "pattern": "$SC.$METHOD(String.format(...),...);\n"
            },
            {
              "pattern": "$SC.$METHOD($X + $Y,...);\n"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "SqlClient $SC = ...;\n...\n"
            },
            {
              "pattern-inside": "SqlConnection $SC = ...;\n...\n"
            },
            {
              "pattern-inside": "$TYPE $FUNC(...,SqlClient $SC,...) {\n  ...\n}\n"
            },
            {
              "pattern-inside": "$TYPE $FUNC(...,SqlConnection $SC,...) {\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern-not": "$SC.$METHOD(\"...\" + \"...\",...);\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$METHOD",
            "regex": "^(query|preparedQuery|prepare)$"
          }
        }
      ],
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "category": "security",
        "technology": [
          "vertx"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Vert.x raw SQL with unsanitized input is injection-prone",
        "fix-suggestion": "Replace string concatenation in Vert.x SQL queries with parameterized queries using the `client.queryWithParams()` method. Use question marks or named parameters as placeholders in SQL strings with parameters supplied as separate `JsonArray` or `Tuple` objects. Consider using Vert.x's reactive SQL clients with tuple binding for built-in protection against SQL injection."
      }
    },
    {
      "id": "java.lang.security.audit.xss.no-direct-response-writer.no-direct-response-writer",
      "message": "This vulnerability happens when applications write user input directly to the HTTP response output stream without proper HTML escaping. Attackers can inject malicious scripts that execute in users' browsers when the page is viewed, potentially stealing session cookies, credentials, or performing actions under the victim's identity. Using a template engine or view technology that automatically applies context-appropriate escaping helps prevent cross-site scripting attacks.",
      "severity": "WARNING",
      "options": {
        "interfile": true
      },
      "metadata": {
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "cwe2021-top25": true,
        "cwe2022-top25": true,
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://www3.ntu.edu.sg/home/ehchua/programming/java/JavaServerFaces.html"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "java",
          "servlets"
        ],
        "interfile": true,
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Directly writing unescaped user data can cause XSS",
        "fix-suggestion": "Replace direct writing to response output streams with template engines that automatically apply context-appropriate HTML escaping. If direct writing is necessary, use security libraries like OWASP Java Encoder to properly encode dynamic content based on its output context (HTML, JavaScript, CSS). Never write unencoded user input directly to the response, as different contexts require different encoding strategies."
      },
      "languages": [
        "java"
      ],
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "(HttpServletRequest $REQ).$REQFUNC(...)\n"
                },
                {
                  "pattern": "(ServletRequest $REQ).$REQFUNC(...) \n"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$REQFUNC",
                "regex": "(getInputStream|getParameter|getParameterMap|getParameterValues|getReader|getCookies|getHeader|getHeaderNames|getHeaders|getPart|getParts|getQueryString)"
              }
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "(HttpServletResponse $RESPONSE).getWriter(...).$WRITE(...)\n"
                },
                {
                  "pattern": "(HttpServletResponse $RESPONSE).getOutputStream(...).$WRITE(...)\n"
                },
                {
                  "pattern": "(java.io.PrintWriter $WRITER).$WRITE(...)\n"
                },
                {
                  "pattern": "(PrintWriter $WRITER).$WRITE(...)\n"
                },
                {
                  "pattern": "(javax.servlet.ServletOutputStream $WRITER).$WRITE(...)\n"
                },
                {
                  "pattern": "(ServletOutputStream $WRITER).$WRITE(...)\n"
                },
                {
                  "pattern": "(java.io.OutputStream $WRITER).$WRITE(...)\n"
                },
                {
                  "pattern": "(OutputStream $WRITER).$WRITE(...)\n"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "pattern-either": [
            {
              "pattern": "Encode.forHtml(...)"
            },
            {
              "pattern": "(PolicyFactory $POLICY).sanitize(...)"
            },
            {
              "pattern": "(AntiSamy $AS).scan(...)"
            },
            {
              "pattern": "JSoup.clean(...)"
            },
            {
              "pattern": "org.apache.commons.lang.StringEscapeUtils.escapeHtml(...)"
            },
            {
              "pattern": "org.springframework.web.util.HtmlUtils.htmlEscape(...)"
            },
            {
              "pattern": "org.owasp.esapi.ESAPI.encoder().encodeForHTML(...)"
            }
          ]
        }
      ]
    },
    {
      "id": "java.lang.security.audit.xss.jsf.autoescape-disabled.autoescape-disabled",
      "message": "Your JSF template has HTML escaping explicitly disabled, allowing data to be rendered directly as HTML. This creates a serious cross-site scripting (XSS) vulnerability if any user-controlled content reaches these unescaped elements. Attackers could inject malicious scripts executed in users' browsers, leading to session hijacking or data theft.",
      "metadata": {
        "owasp": "A07:2017 - Cross-Site Scripting (XSS)",
        "cwe": [
          "CWE-150: Improper Neutralization of Escape, Meta, or Control Sequences"
        ],
        "references": [
          "https://stackoverflow.com/a/7442668"
        ],
        "category": "security",
        "technology": [
          "jsf"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "Disabled HTML escaping enables XSS attacks",
        "fix-suggestion": "Remove `escape=\"false\"` attributes from JSF elements that may contain user-generated content. By default, JSF will escape content, so removing this attribute enables automatic XSS protection. If you need to display HTML content, implement proper sanitization using a library like OWASP HTML Sanitizer."
      },
      "pattern-regex": ".*escape.*?=.*?false.*",
      "paths": {
        "include": [
          "*.html",
          "*.xhtml"
        ]
      },
      "languages": [
        "regex"
      ],
      "severity": "WARNING"
    },
    {
      "id": "java.lang.security.audit.xxe.documentbuilderfactory-disallow-doctype-decl-false.documentbuilderfactory-disallow-doctype-decl-false",
      "severity": "ERROR",
      "metadata": {
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "asvs": {
          "section": "V5 Validation, Sanitization and Encoding",
          "control_id": "5.5.2 Insecue XML Deserialization",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention",
          "version": "4"
        },
        "references": [
          "https://semgrep.dev/blog/2022/xml-security-in-java",
          "https://semgrep.dev/docs/cheat-sheets/java-xxe/",
          "https://blog.sonarsource.com/secure-xml-processor",
          "https://xerces.apache.org/xerces2-j/features.html"
        ],
        "category": "security",
        "technology": [
          "java",
          "xml"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "DOCTYPE declarations enabled in DocumentBuilderFactory cause XXE risk",
        "fix-suggestion": "Configure `DocumentBuilderFactory` to prevent XXE attacks by setting `http://apache.org/xml/features/disallow-doctype-decl` feature to `true`. If DTDs are required, disable external entity resolution by setting both `http://xml.org/sax/features/external-general-entities` and `http://xml.org/sax/features/external-parameter-entities` to `false`. Always apply these settings before creating document builders and use a helper method to consistently secure all XML parsers."
      },
      "message": "This vulnerability arises when DocumentBuilderFactory is configured to allow DOCTYPE declarations, enabling XML External Entity (XXE) processing. Attackers can submit malicious XML containing external entity references that, when processed, can lead to server-side request forgery, local file disclosure, or denial of service attacks. Explicitly disabling DOCTYPE declarations or restricting external entity resolution prevents the parser from processing potentially dangerous external references.",
      "patterns": [
        {
          "pattern": "$DBFACTORY.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", false);"
        },
        {
          "pattern-not-inside": "$RETURNTYPE $METHOD(...){\n  ...\n  $DBF.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n  ...\n  $DBF.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "$RETURNTYPE $METHOD(...){\n  ...\n  $DBF.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n  ...\n  $DBF.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "$RETURNTYPE $METHOD(...){\n  ...\n  $DBF.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n  ...\n  $DBF.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "$RETURNTYPE $METHOD(...){\n  ...\n  $DBF.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n  ...\n  $DBF.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n  ...\n}\n"
        }
      ],
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.lang.security.audit.xxe.documentbuilderfactory-disallow-doctype-decl-missing.documentbuilderfactory-disallow-doctype-decl-missing",
      "severity": "ERROR",
      "metadata": {
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "asvs": {
          "section": "V5 Validation, Sanitization and Encoding",
          "control_id": "5.5.2 Insecue XML Deserialization",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention",
          "version": "4"
        },
        "references": [
          "https://semgrep.dev/blog/2022/xml-security-in-java",
          "https://semgrep.dev/docs/cheat-sheets/java-xxe/",
          "https://blog.sonarsource.com/secure-xml-processor",
          "https://xerces.apache.org/xerces2-j/features.html"
        ],
        "category": "security",
        "technology": [
          "java",
          "xml"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "Disallow-doctype-decl not set, exposing DocumentBuilderFactory to XXE",
        "fix-suggestion": "Secure your `DocumentBuilderFactory` by explicitly setting the `http://apache.org/xml/features/disallow-doctype-decl` feature to `true` before creating document builders. If DTDs must be supported, disable external entity resolution by setting `http://xml.org/sax/features/external-general-entities` and `http://xml.org/sax/features/external-parameter-entities` to `false`. Consider enabling secure processing via `factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true)` to provide additional protection."
      },
      "message": "This vulnerability occurs when DocumentBuilderFactory is used without explicitly disabling DOCTYPE declarations, leaving the application susceptible to XXE attacks. Attackers can exploit this by submitting XML with malicious external entity references that may expose sensitive files, enable server-side request forgery, or cause denial of service. Setting the FEATURE_SECURE_PROCESSING feature or explicitly disabling DOCTYPE declarations mitigates this vulnerability by preventing the processing of external entities.",
      "mode": "taint",
      "pattern-sources": [
        {
          "by-side-effect": true,
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$FACTORY = DocumentBuilderFactory.newInstance();\n"
                },
                {
                  "patterns": [
                    {
                      "pattern": "$FACTORY"
                    },
                    {
                      "pattern-inside": "class $C {\n  ...\n  $V $FACTORY = DocumentBuilderFactory.newInstance();\n  ...\n}\n"
                    },
                    {
                      "pattern-not-inside": "class $C {\n  ...\n  $V $FACTORY = DocumentBuilderFactory.newInstance();\n  static {\n    ...\n    $FACTORY.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n    ...\n  }\n  ...\n}\n"
                    },
                    {
                      "pattern-not-inside": "class $C {\n  ...\n  $V $FACTORY = DocumentBuilderFactory.newInstance();\n  static {\n    ...\n    $FACTORY.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n    ...\n    $FACTORY.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n    ...\n  }\n  ...\n}\n"
                    },
                    {
                      "pattern-not-inside": "class $C {\n  ...\n  $V $FACTORY = DocumentBuilderFactory.newInstance();\n  static {\n    ...\n    $FACTORY.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n    ...\n    $FACTORY.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n    ...\n  }\n  ...\n}\n"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$FACTORY.newDocumentBuilder();"
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "by-side-effect": true,
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "$FACTORY.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n"
                    },
                    {
                      "pattern": "$FACTORY.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n...\n$FACTORY.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n"
                    },
                    {
                      "pattern": "$FACTORY.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n...\n$FACTORY.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n"
                    }
                  ]
                },
                {
                  "focus-metavariable": "$FACTORY"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "class $C {\n  ...\n  $T $M(...) {\n    ...\n    $FACTORY.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\",\n    true);\n    ...\n  }\n  ...\n}\n"
                    },
                    {
                      "pattern-inside": "class $C {\n  ...\n  $T $M(...) {\n    ...\n    $FACTORY.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n    ...\n    $FACTORY.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n    ...\n  }\n  ...\n}\n"
                    },
                    {
                      "pattern-inside": "class $C {\n  ...\n  $T $M(...) {\n    ...\n    $FACTORY.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n    ...\n    $FACTORY.setFeature(\"http://xml.org/sax/features/external-general-entities\",false);\n    ...\n  }\n  ...\n}\n"
                    }
                  ]
                },
                {
                  "pattern": "$M($X)"
                },
                {
                  "focus-metavariable": "$X"
                }
              ]
            }
          ]
        }
      ],
      "fix": "$FACTORY.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n$FACTORY.newDocumentBuilder();\n",
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.lang.security.audit.xxe.documentbuilderfactory-external-general-entities-true.documentbuilderfactory-external-general-entities-true",
      "severity": "ERROR",
      "metadata": {
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "asvs": {
          "section": "V5 Validation, Sanitization and Encoding",
          "control_id": "5.5.2 Insecue XML Deserialization",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention",
          "version": "4"
        },
        "references": [
          "https://semgrep.dev/blog/2022/xml-security-in-java",
          "https://semgrep.dev/docs/cheat-sheets/java-xxe/",
          "https://blog.sonarsource.com/secure-xml-processor"
        ],
        "category": "security",
        "technology": [
          "java",
          "xml"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "External general entities enabled lead to XXE vulnerabilities",
        "fix-suggestion": "Explicitly disable external general entity processing by setting the `http://xml.org/sax/features/external-general-entities` feature to `false` on your DocumentBuilderFactory. Additionally disable external parameter entities with `http://xml.org/sax/features/external-parameter-entities` set to `false` and prevent DTD loading with `http://apache.org/xml/features/nonvalidating/load-external-dtd`. For maximum security, consider disabling DOCTYPE declarations entirely with `http://apache.org/xml/features/disallow-doctype-decl` set to `true`."
      },
      "message": "This vulnerability happens when external general entities are explicitly enabled in DocumentBuilderFactory, allowing the XML parser to process external references. Attackers can craft XML with malicious external entity references that, when resolved, may lead to information disclosure, server-side request forgery, or resource exhaustion. Disabling external entity processing by setting the appropriate feature flags to false prevents the parser from resolving potentially harmful external references.",
      "pattern": "$DBFACTORY.setFeature(\"http://xml.org/sax/features/external-general-entities\", true);",
      "fix": "$DBFACTORY.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);",
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.lang.security.audit.xxe.documentbuilderfactory-external-parameter-entities-true.documentbuilderfactory-external-parameter-entities-true",
      "severity": "ERROR",
      "metadata": {
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "asvs": {
          "section": "V5 Validation, Sanitization and Encoding",
          "control_id": "5.5.2 Insecue XML Deserialization",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention",
          "version": "4"
        },
        "references": [
          "https://semgrep.dev/blog/2022/xml-security-in-java",
          "https://semgrep.dev/docs/cheat-sheets/java-xxe/",
          "https://blog.sonarsource.com/secure-xml-processor"
        ],
        "category": "security",
        "technology": [
          "java",
          "xml"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "External parameter entities allowed can cause XXE exploitation",
        "fix-suggestion": "Disable external parameter entity processing by setting `http://xml.org/sax/features/external-parameter-entities` to `false` on your DocumentBuilderFactory. Also disable external general entities with `http://xml.org/sax/features/external-general-entities` set to `false` and prevent loading of external DTDs with `http://apache.org/xml/features/nonvalidating/load-external-dtd` set to `false`. For complete protection, consider disabling DOCTYPE processing entirely with `http://apache.org/xml/features/disallow-doctype-decl` set to `true`."
      },
      "message": "This vulnerability arises when external parameter entities are enabled in DocumentBuilderFactory, allowing XML parsers to resolve references to external resources. Attackers can exploit this by submitting XML documents with malicious parameter entity declarations that access local files, make network requests, or cause denial of service conditions. Disabling external parameter entity processing by setting the appropriate feature flag to false prevents these attacks by restricting entity resolution.",
      "pattern": "$DBFACTORY.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", true);",
      "fix": "$DBFACTORY.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);",
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.lang.security.audit.xxe.saxparserfactory-disallow-doctype-decl-missing.saxparserfactory-disallow-doctype-decl-missing",
      "severity": "ERROR",
      "metadata": {
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "asvs": {
          "section": "V5 Validation, Sanitization and Encoding",
          "control_id": "5.5.2 Insecue XML Deserialization",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention",
          "version": "4"
        },
        "references": [
          "https://semgrep.dev/blog/2022/xml-security-in-java",
          "https://semgrep.dev/docs/cheat-sheets/java-xxe/",
          "https://blog.sonarsource.com/secure-xml-processor",
          "https://xerces.apache.org/xerces2-j/features.html"
        ],
        "category": "security",
        "technology": [
          "java",
          "xml"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "SAXParserFactory with DOCTYPE declarations enabled triggers XXE risk",
        "fix-suggestion": "Secure your `SAXParserFactory` against XXE attacks by setting the `http://apache.org/xml/features/disallow-doctype-decl` feature to `true` before creating parsers. If DTD processing is required, disable external entity resolution by setting `http://xml.org/sax/features/external-general-entities` and `http://xml.org/sax/features/external-parameter-entities` to `false`. Enable `XMLConstants.FEATURE_SECURE_PROCESSING` by calling `setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true)` for additional protection."
      },
      "message": "This vulnerability occurs when SAXParserFactory is used without explicitly disabling DOCTYPE declarations, leaving applications open to XXE attacks. Attackers can submit XML with external entity references that, when processed, may expose sensitive files, enable server-side request forgery, or cause resource exhaustion. Setting the feature to disallow DOCTYPE declarations or disable external entity resolution prevents the parser from processing potentially dangerous external references.",
      "mode": "taint",
      "pattern-sources": [
        {
          "by-side-effect": true,
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$FACTORY = SAXParserFactory.newInstance();\n"
                },
                {
                  "patterns": [
                    {
                      "pattern": "$FACTORY"
                    },
                    {
                      "pattern-inside": "class $C {\n  ...\n  $V $FACTORY = SAXParserFactory.newInstance();\n  ...\n}\n"
                    },
                    {
                      "pattern-not-inside": "class $C {\n  ...\n  $V $FACTORY = SAXParserFactory.newInstance();\n  static {\n    ...\n    $FACTORY.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n    ...\n  }\n  ...\n}\n"
                    },
                    {
                      "pattern-not-inside": "class $C {\n  ...\n  $V $FACTORY = SAXParserFactory.newInstance();\n  static {\n    ...\n    $FACTORY.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n    ...\n    $FACTORY.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n    ...\n  }\n  ...\n}\n"
                    },
                    {
                      "pattern-not-inside": "class $C {\n  ...\n  $V $FACTORY = SAXParserFactory.newInstance();\n  static {\n    ...\n    $FACTORY.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n    ...\n    $FACTORY.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n    ...\n  }\n  ...\n}\n"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$FACTORY.newSAXParser();"
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "by-side-effect": true,
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "$FACTORY.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n"
                    },
                    {
                      "pattern": "$FACTORY.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n...\n$FACTORY.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n"
                    },
                    {
                      "pattern": "$FACTORY.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n...\n$FACTORY.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n"
                    }
                  ]
                },
                {
                  "focus-metavariable": "$FACTORY"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "class $C {\n  ...\n  $T $M(...) {\n    ...\n    $FACTORY.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\",\n    true);\n    ...\n  }\n  ...\n}\n"
                    },
                    {
                      "pattern-inside": "class $C {\n  ...\n  $T $M(...) {\n    ...\n    $FACTORY.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n    ...\n    $FACTORY.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n    ...\n  }\n  ...\n}\n"
                    },
                    {
                      "pattern-inside": "class $C {\n  ...\n  $T $M(...) {\n    ...\n    $FACTORY.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n    ...\n    $FACTORY.setFeature(\"http://xml.org/sax/features/external-general-entities\",false);\n    ...\n  }\n  ...\n}\n"
                    }
                  ]
                },
                {
                  "pattern": "$M($X)"
                },
                {
                  "focus-metavariable": "$X"
                }
              ]
            }
          ]
        }
      ],
      "fix": "$FACTORY.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n$FACTORY.newSAXParser();\n",
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.lang.security.audit.xxe.transformerfactory-dtds-not-disabled.transformerfactory-dtds-not-disabled",
      "severity": "ERROR",
      "metadata": {
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "asvs": {
          "section": "V5 Validation, Sanitization and Encoding",
          "control_id": "5.5.2 Insecue XML Deserialization",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention",
          "version": "4"
        },
        "references": [
          "https://semgrep.dev/blog/2022/xml-security-in-java",
          "https://semgrep.dev/docs/cheat-sheets/java-xxe/",
          "https://blog.sonarsource.com/secure-xml-processor",
          "https://xerces.apache.org/xerces2-j/features.html"
        ],
        "category": "security",
        "technology": [
          "java",
          "xml"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "DTD access enabled in TransformerFactory leads to XXE",
        "fix-suggestion": "Secure your `TransformerFactory` against XXE attacks by calling `setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true)` to enable secure processing mode. Disable external DTDs and stylesheets with `setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\")` and `setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\")`. For older Java versions, use the string values directly: `setAttribute(\"http://javax.xml.XMLConstants/property/accessExternalDTD\", \"\")`."
      },
      "message": "This vulnerability happens when TransformerFactory is configured without disabling DTD processing or external stylesheet access. Attackers can craft XML with malicious external entity references or stylesheets that, when transformed, may lead to information disclosure, server-side request forgery, or denial of service attacks. Setting the appropriate attributes to disable DTD processing and external stylesheet access prevents the transformer from resolving potentially harmful external references.",
      "mode": "taint",
      "pattern-sources": [
        {
          "by-side-effect": true,
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$FACTORY = TransformerFactory.newInstance();\n"
                },
                {
                  "patterns": [
                    {
                      "pattern": "$FACTORY"
                    },
                    {
                      "pattern-inside": "class $C {\n  ...\n  $V $FACTORY = TransformerFactory.newInstance();\n  ...\n}\n"
                    },
                    {
                      "pattern-not-inside": "class $C {\n  ...\n  $V $FACTORY = TransformerFactory.newInstance();\n  static {\n    ...\n    $FACTORY.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n    ...\n    $FACTORY.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\");\n    ...\n  }\n  ...\n}\n"
                    },
                    {
                      "pattern-not-inside": "class $C {\n  ...\n  $V $FACTORY = TransformerFactory.newInstance();\n  static {\n    ...\n    $FACTORY.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\");\n    ...\n    $FACTORY.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n    ...\n  }\n  ...\n}\n"
                    },
                    {
                      "pattern-not-inside": "class $C {\n  ...\n  $V $FACTORY = TransformerFactory.newInstance();\n  static {\n    ...\n    $FACTORY.setAttribute(\"=~/.*accessExternalDTD.*/\", \"\");\n    ...\n    $FACTORY.setAttribute(\"=~/.*accessExternalStylesheet.*/\", \"\");\n    ...\n  }\n  ...\n}\n"
                    },
                    {
                      "pattern-not-inside": "class $C {\n  ...\n  $V $FACTORY = TransformerFactory.newInstance();\n  static {\n    ...\n    $FACTORY.setAttribute(\"=~/.*accessExternalStylesheet.*/\", \"\");\n    ...\n    $FACTORY.setAttribute(\"=~/.*accessExternalDTD.*/\", \"\");\n    ...\n  }\n  ...\n}\n"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$FACTORY.newTransformer(...);"
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "by-side-effect": true,
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "$FACTORY.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\"); ...\n$FACTORY.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n"
                    },
                    {
                      "pattern": "$FACTORY.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n...\n$FACTORY.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\");\n"
                    },
                    {
                      "pattern": "$FACTORY.setAttribute(\"=~/.*accessExternalStylesheet.*/\", \"\"); ...\n$FACTORY.setAttribute(\"=~/.*accessExternalDTD.*/\", \"\");\n"
                    },
                    {
                      "pattern": "$FACTORY.setAttribute(\"=~/.*accessExternalDTD.*/\", \"\");\n...\n$FACTORY.setAttribute(\"=~/.*accessExternalStylesheet.*/\", \"\");\n"
                    }
                  ]
                },
                {
                  "focus-metavariable": "$FACTORY"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "class $C {\n  ...\n  $T $M(...) {\n    ...\n    $FACTORY.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\");\n    ...\n    $FACTORY.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n    ...\n  }\n  ...\n}\n"
                    },
                    {
                      "pattern-inside": "class $C {\n  ...\n  $T $M(...) {\n    ...\n    $FACTORY.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n    ...\n    $FACTORY.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\");\n    ...\n  }\n  ...\n}\n"
                    },
                    {
                      "pattern-inside": "class $C {\n  ...\n  $T $M(...) {\n    ...\n    $FACTORY.setAttribute(\"=~/.*accessExternalStylesheet.*/\", \"\");\n    ...\n    $FACTORY.setAttribute(\"=~/.*accessExternalDTD.*/\", \"\");\n    ...\n  }\n  ...\n}\n"
                    },
                    {
                      "pattern-inside": "class $C {\n  ...\n  $T $M(...) {\n    ...\n    $FACTORY.setAttribute(\"=~/.*accessExternalDTD.*/\", \"\");\n    ...\n    $FACTORY.setAttribute(\"=~/.*accessExternalStylesheet.*/\", \"\");\n    ...\n  }\n  ...\n}\n"
                    }
                  ]
                },
                {
                  "pattern": "$M($X)"
                },
                {
                  "focus-metavariable": "$X"
                }
              ]
            }
          ]
        }
      ],
      "fix": "$FACTORY.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\"); $FACTORY.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\");\n$FACTORY.newTransformer(...);\n",
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.rmi.security.server-dangerous-class-deserialization.server-dangerous-class-deserialization",
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "metadata": {
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "references": [
          "https://mogwailabs.de/blog/2019/03/attacking-java-rmi-services-after-jep-290/"
        ],
        "category": "security",
        "technology": [
          "rmi"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "RMI class deserialization can lead to remote code execution",
        "fix-suggestion": "Avoid using complex non-primitive classes in RMI interfaces that could be exploited during deserialization. Implement a custom RMI socket factory with `ObjectInputFilter` (Java 9+) to restrict deserialized classes. Consider using interfaces that pass simple identifiers instead of complex objects, retrieving the actual data through a separate, secured channel."
      },
      "message": "This vulnerability arises when Java RMI uses complex deserialization of non-primitive classes from untrusted sources. Attackers can craft malicious serialized objects that, when deserialized by the RMI server, execute arbitrary code through deserialization callbacks or gadget chains. Using simple identifiers or safer serialization approaches helps mitigate this risk by limiting the attack surface exposed through the deserialization process.",
      "patterns": [
        {
          "pattern": "interface $INTERFACE extends Remote {\n  $RETURNTYPE $METHOD($CLASS $PARAM) throws RemoteException;\n}\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$CLASS",
            "regex": "(?!int|boolean|short|long|byte|char|float|double)"
          }
        }
      ]
    },
    {
      "id": "java.rmi.security.server-dangerous-object-deserialization.server-dangerous-object-deserialization",
      "severity": "ERROR",
      "metadata": {
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "references": [
          "https://frohoff.github.io/appseccali-marshalling-pickles/",
          "https://book.hacktricks.xyz/network-services-pentesting/1099-pentesting-java-rmi",
          "https://youtu.be/t_aw1mDNhzI",
          "https://github.com/qtc-de/remote-method-guesser",
          "https://github.com/openjdk/jdk/blob/master/src/java.rmi/share/classes/sun/rmi/server/UnicastRef.java#L303C4-L331"
        ],
        "category": "security",
        "technology": [
          "rmi"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "Deserializing arbitrary RMI objects is vulnerable to code injection",
        "fix-suggestion": "Implement deserialization filtering for RMI servers using an `ObjectInputFilter` (Java 9+) to restrict which classes can be deserialized. For earlier Java versions, use a custom `ObjectInputStream` implementation that validates class names before deserialization. Redesign your RMI interfaces to use safer alternatives like simple data types or implement custom serialization methods that restrict class instantiation."
      },
      "message": "This vulnerability occurs when Java RMI deserializes arbitrary objects from untrusted clients without proper validation or filtering. Attackers can send malicious serialized objects that trigger unintended code execution during the deserialization process, potentially leading to remote code execution on the RMI server. Implementing a secure object identification approach using simple identifiers or applying deserialization filters helps prevent exploitation of this vulnerability.",
      "languages": [
        "java"
      ],
      "patterns": [
        {
          "pattern": "interface $INTERFACE extends Remote {\n  $RETURNTYPE $METHOD($PARAMTYPE $PARAM) throws RemoteException;\n}\n"
        },
        {
          "metavariable-pattern": {
            "metavariable": "$PARAMTYPE",
            "language": "generic",
            "patterns": [
              {
                "pattern-not": "String"
              },
              {
                "pattern-not": "java.lang.String"
              },
              {
                "pattern-not": "boolean"
              },
              {
                "pattern-not": "Boolean"
              },
              {
                "pattern-not": "java.lang.Boolean"
              },
              {
                "pattern-not": "byte"
              },
              {
                "pattern-not": "Byte"
              },
              {
                "pattern-not": "java.lang.Byte"
              },
              {
                "pattern-not": "char"
              },
              {
                "pattern-not": "Character"
              },
              {
                "pattern-not": "java.lang.Character"
              },
              {
                "pattern-not": "double"
              },
              {
                "pattern-not": "Double"
              },
              {
                "pattern-not": "java.lang.Double"
              },
              {
                "pattern-not": "float"
              },
              {
                "pattern-not": "Float"
              },
              {
                "pattern-not": "java.lang.Float"
              },
              {
                "pattern-not": "int"
              },
              {
                "pattern-not": "Integer"
              },
              {
                "pattern-not": "java.lang.Integer"
              },
              {
                "pattern-not": "long"
              },
              {
                "pattern-not": "Long"
              },
              {
                "pattern-not": "java.lang.Long"
              },
              {
                "pattern-not": "short"
              },
              {
                "pattern-not": "Short"
              },
              {
                "pattern-not": "java.lang.Short"
              }
            ]
          }
        }
      ]
    },
    {
      "id": "java.servlets.security.cookie-issecure-false.cookie-issecure-false",
      "patterns": [
        {
          "pattern": "$COOKIE = new Cookie($...ARGS);"
        },
        {
          "pattern-not-inside": "$COOKIE = new Cookie(...);\n...\n$COOKIE.setSecure(...);\n"
        }
      ],
      "message": "Your servlet creates cookies without setting the 'secure' flag, allowing transmission over insecure HTTP connections. This exposes cookie data, including sensitive session tokens, to interception by attackers on the network. Always set the 'secure' flag on cookies containing sensitive information to ensure they are only transmitted via HTTPS.",
      "fix": "$COOKIE = new Cookie($...ARGS);\n$COOKIE.setSecure(true);\n",
      "metadata": {
        "vulnerability": "Insecure Transport",
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "references": [
          "https://docs.oracle.com/javaee/6/api/javax/servlet/http/Cookie.html#setSecure(boolean)",
          "https://owasp.org/www-community/controls/SecureCookieAttribute"
        ],
        "category": "security",
        "technology": [
          "java",
          "cookie"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Cookies missing secure flag allow HTTP transmission",
        "fix-suggestion": "Set the secure flag on all cookies by calling `cookie.setSecure(true)` when creating cookies. This ensures cookies will only be transmitted over HTTPS connections. Also consider adding `cookie.setHttpOnly(true)` to prevent JavaScript access to sensitive cookies."
      },
      "languages": [
        "java"
      ],
      "severity": "WARNING"
    },
    {
      "id": "java.spring.security.unrestricted-request-mapping.unrestricted-request-mapping",
      "patterns": [
        {
          "pattern-inside": "@RequestMapping(...)\n$RETURNTYPE $METHOD(...) { ... }\n"
        },
        {
          "pattern-not-inside": "@RequestMapping(..., method = $X, ...)\n$RETURNTYPE $METHOD(...) { ... }\n"
        },
        {
          "pattern": "RequestMapping\n"
        }
      ],
      "message": "This vulnerability happens when Spring controller methods don't specify which HTTP methods they accept, allowing them to be called with any method including GET. Attackers can exploit this by crafting cross-site request forgery (CSRF) attacks that trick users' browsers into making state-changing requests without their knowledge. Explicitly specifying required HTTP methods (especially POST, PUT, DELETE for state-changing operations) ensures that such operations cannot be triggered by simple GET requests, mitigating CSRF risk.",
      "severity": "WARNING",
      "metadata": {
        "cwe": [
          "CWE-352: Cross-Site Request Forgery (CSRF)"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING",
        "references": [
          "https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_UNRESTRICTED_REQUEST_MAPPING"
        ],
        "category": "security",
        "technology": [
          "spring"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site Request Forgery (CSRF)"
        ],
        "short-description": "Undefined HTTP methods on Spring endpoints risk CSRF",
        "fix-suggestion": "Explicitly specify allowed HTTP methods in `RequestMapping` annotations by adding the `method` attribute, e.g., `@RequestMapping(value = \"/endpoint\", method = RequestMethod.POST)`. For Spring 4.3+, use specific method annotations (`@GetMapping`, `@PostMapping`, etc.) which clearly indicate the intended HTTP method. Ensure Spring Security's CSRF protection is enabled for complete protection against CSRF attacks."
      },
      "languages": [
        "java"
      ]
    },
    {
      "id": "java.spring.security.audit.spel-injection.spel-injection",
      "message": "This vulnerability arises when Spring Expression Language (SpEL) expressions are dynamically constructed using unvalidated user input. Attackers can inject malicious SpEL syntax that accesses sensitive objects, modifies application state, or executes arbitrary code when evaluated by the SpEL interpreter. Avoiding dynamic construction of SpEL expressions with user input or implementing strict validation ensures that only intended expressions are evaluated, preventing injection attacks.",
      "metadata": {
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#SPEL_INJECTION",
        "category": "security",
        "technology": [
          "spring"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "SpEL injection from user input can allow code execution",
        "fix-suggestion": "Never construct SpEL expressions dynamically using user input; instead, use fixed expression templates with parameterized values passed through the evaluation context. Replace code like `parser.parseExpression(userInput + \".property\")` with `parser.parseExpression(\"#input.property\")` and add user input to the evaluation context. When using SpEL, set up a restricted evaluation context using `SimpleEvaluationContext.forReadOnlyDataBinding()` which doesn't allow method execution or constructors."
      },
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "class $CLASS {\n  ...\n  ExpressionParser $PARSER;\n  ...\n}\n"
            },
            {
              "pattern-inside": "class $CLASS {\n  ...\n  ExpressionParser $PARSER = ...;\n  ...\n}\n"
            },
            {
              "pattern-inside": "$X $METHOD(...) {\n  ...\n  ExpressionParser $PARSER = ...;\n  ...\n}\n"
            },
            {
              "pattern-inside": "class $CLASS {\n  ...\n  SpelExpressionParser $PARSER;\n  ...\n}\n"
            },
            {
              "pattern-inside": "class $CLASS {\n  ...\n  SpelExpressionParser $PARSER = ...;\n  ...\n}\n"
            },
            {
              "pattern-inside": "$X $METHOD(...) {\n  ...\n  SpelExpressionParser $PARSER = ...;\n  ...\n}\n"
            },
            {
              "pattern-inside": "class $CLASS {\n  ...\n  TemplateAwareExpressionParser $PARSER;\n  ...\n}\n"
            },
            {
              "pattern-inside": "class $CLASS {\n  ...\n  TemplateAwareExpressionParser $PARSER = ...;\n  ...\n}\n"
            },
            {
              "pattern-inside": "$X $METHOD(...) {\n  ...\n  TemplateAwareExpressionParser $PARSER = ...;\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern": "$X $METHOD(...) {\n  ...\n  $PARSER.parseExpression(...);\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  $PARSER.parseExpression(\"...\");\n  ...\n}\n"
        },
        {
          "pattern-not": "$X $METHOD(...) {\n  ...\n  String $S = \"...\";\n  ...\n  $PARSER.parseExpression($S);\n  ...\n}\n"
        }
      ]
    },
    {
      "id": "java.spring.security.audit.spring-actuator-fully-enabled.spring-actuator-fully-enabled",
      "pattern": "management.endpoints.web.exposure.include=*",
      "message": "Your Spring Boot application has fully enabled Actuator endpoints without access restrictions. This exposes sensitive operational data and functionality, including environment variables, log files, heap dumps, and more. Unauthenticated access to these endpoints allows attackers to gather internal information and potentially compromise your application.",
      "severity": "ERROR",
      "languages": [
        "generic"
      ],
      "paths": {
        "include": [
          "*properties"
        ]
      },
      "metadata": {
        "cwe": [
          "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "references": [
          "https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html#production-ready-endpoints-exposing-endpoints",
          "https://medium.com/walmartglobaltech/perils-of-spring-boot-actuators-misconfiguration-185c43a0f785",
          "https://blog.maass.xyz/spring-actuator-security-part-1-stealing-secrets-using-spring-actuators"
        ],
        "category": "security",
        "technology": [
          "spring"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Unrestricted Spring Actuator exposes sensitive endpoints",
        "fix-suggestion": "Secure Actuator endpoints by implementing Spring Security or restrict which endpoints are exposed using `management.endpoints.web.exposure.include` in your configuration. Disable sensitive endpoints like `env`, `heapdump`, and others in production environments. Consider moving Actuator to a different port accessible only from your internal network."
      }
    },
    {
      "id": "java.spring.security.audit.spring-csrf-disabled.spring-csrf-disabled",
      "message": "This vulnerability occurs when CSRF protection is explicitly disabled in Spring Security configuration, removing a critical defense against cross-site request forgery attacks. Attackers can craft malicious websites that make state-changing requests to the vulnerable application using the victim's authenticated session. Enabling CSRF protection requires attackers to obtain a valid CSRF token before submitting state-changing requests, significantly reducing the risk of successful CSRF attacks.",
      "metadata": {
        "cwe": [
          "CWE-352: Cross-Site Request Forgery (CSRF)"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#SPRING_CSRF_PROTECTION_DISABLED",
        "asvs": {
          "section": "V4 Access Control",
          "control_id": "4.2.2 CSRF",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V4-Access-Control.md#v42-operation-level-access-control",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "spring"
        ],
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site Request Forgery (CSRF)"
        ],
        "short-description": "CSRF protection disabled in Spring, exposing state changes",
        "fix-suggestion": "Remove the `.csrf().disable()` call from your Spring Security configuration to re-enable CSRF protection. Configure proper CSRF token handling by ensuring your forms include a `_csrf` field with the token value. For REST APIs, implement a custom CSRF token strategy using the `CsrfTokenRepository` interface to handle tokens in headers instead of cookies."
      },
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "pattern": "$OBJ.csrf(...).disable(...)"
    },
    {
      "id": "java.spring.security.audit.spring-jsp-eval.spring-jsp-eval",
      "pattern": "<spring:eval ... expression=...>\n",
      "message": "Your code builds Spring Expression Language (SpEL) expressions using dynamic values, which can lead to code injection vulnerabilities. If unvalidated user input influences these expressions, attackers could inject malicious SpEL code that executes arbitrary Java methods. Always properly validate and sanitize any dynamic values used in Spring expressions.",
      "severity": "WARNING",
      "languages": [
        "generic"
      ],
      "metadata": {
        "cwe": [
          "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#JSP_SPRING_EVAL",
        "category": "security",
        "technology": [
          "spring"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Dynamic Spring expressions enable code injection",
        "fix-suggestion": "Avoid building Spring expressions dynamically from user-controlled input. Use expression variables or template parameters instead of embedding user input directly into expressions. Implement strict validation of any values that must influence expressions, limiting them to an approved set of safe values or patterns."
      },
      "paths": {
        "include": [
          "*.jsp"
        ]
      }
    },
    {
      "id": "java.spring.security.audit.spring-sqli.spring-sqli",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "$ARG"
            },
            {
              "pattern-inside": "public $T $M (..., String $ARG,...){...}\n"
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "not_conflicting": true,
          "pattern-either": [
            {
              "patterns": [
                {
                  "focus-metavariable": "$A"
                },
                {
                  "pattern-inside": "new $TYPE(...,$A,...);\n"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "focus-metavariable": "$A"
                    },
                    {
                      "pattern": "new PreparedStatementCreatorFactory($A,...);\n"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "focus-metavariable": "$A"
                    },
                    {
                      "pattern": "(JdbcTemplate $T).$M($A,...)\n"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "(String $A)"
                    },
                    {
                      "pattern-inside": "(JdbcTemplate $T).batchUpdate(...)\n"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "focus-metavariable": "$A"
                    },
                    {
                      "pattern": "NamedParameterBatchUpdateUtils.$M($A,...)\n"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "focus-metavariable": "$A"
                    },
                    {
                      "pattern": "BatchUpdateUtils.$M($A,...)\n"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "message": "This vulnerability happens when raw SQL queries in Spring applications are constructed by concatenating or formatting strings with unsanitized user input. Attackers can inject malicious SQL code that alters the query's behavior, potentially accessing unauthorized data or manipulating database contents. Using Spring's JdbcTemplate with parameterized queries or an ORM like Hibernate with parameter binding ensures user input is properly escaped and treated as data rather than executable code.",
      "languages": [
        "java"
      ],
      "severity": "WARNING",
      "options": {
        "taint_assume_safe_numbers": true,
        "taint_assume_safe_booleans": true
      },
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "category": "security",
        "technology": [
          "spring"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Unsanitized SQL in Spring leads to injection vulnerabilities",
        "fix-suggestion": "Replace string concatenation in Spring JDBC queries with parameterized queries using `JdbcTemplate` with question mark placeholders or named parameters. Use `jdbcTemplate.query(\"SELECT * FROM users WHERE username = ?\", new Object[]{username}, ...)` instead of string concatenation. For dynamic query structures, use QueryBuilder libraries or implement strict validation of structural elements, and always use parameterization for data values."
      }
    },
    {
      "id": "java.spring.security.audit.spring-unvalidated-redirect.spring-unvalidated-redirect",
      "message": "Your Spring application redirects users to URLs specified by unvalidated user input. This unvalidated redirect vulnerability allows attackers to craft links to your application that redirect victims to malicious sites. These attacks can lead to phishing, credential theft, or malware installation through the trusted context of your site.",
      "metadata": {
        "cwe": [
          "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#UNVALIDATED_REDIRECT",
        "category": "security",
        "technology": [
          "spring"
        ],
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Open Redirect"
        ],
        "short-description": "Unvalidated Spring redirects enable phishing attacks",
        "fix-suggestion": "Implement strict validation for all redirect URLs derived from user input. Use a whitelist approach that only allows redirects to verified domains or paths within your application. Consider using Spring's built-in redirect capabilities with predefined route names instead of allowing absolute URLs."
      },
      "severity": "WARNING",
      "languages": [
        "java"
      ],
      "pattern-either": [
        {
          "pattern": "$X $METHOD(...,String $URL,...) {\n  return \"redirect:\" + $URL;\n}\n"
        },
        {
          "pattern": "$X $METHOD(...,String $URL,...) {\n  ...\n  String $REDIR = \"redirect:\" + $URL;\n  ...\n  return $REDIR;\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...,String $URL,...) {\n  ...\n  new ModelAndView(\"redirect:\" + $URL);\n  ...\n}\n"
        },
        {
          "pattern": "$X $METHOD(...,String $URL,...) {\n  ...\n  String $REDIR = \"redirect:\" + $URL;\n  ...\n  new ModelAndView($REDIR);\n  ...\n}"
        }
      ]
    },
    {
      "id": "java.spring.security.injection.tainted-file-path.tainted-file-path",
      "languages": [
        "java"
      ],
      "severity": "ERROR",
      "message": "Your Spring application allows user input to influence file paths without proper sanitization. This path traversal vulnerability enables attackers to access files outside the intended directory using sequences like '../'. Attackers could potentially read sensitive application files, configuration data, or system files, depending on the application's permissions.",
      "options": {
        "interfile": true
      },
      "metadata": {
        "cwe": [
          "CWE-23: Relative Path Traversal"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "references": [
          "https://owasp.org/www-community/attacks/Path_Traversal"
        ],
        "category": "security",
        "technology": [
          "java",
          "spring"
        ],
        "subcategory": [
          "vuln"
        ],
        "impact": "HIGH",
        "likelihood": "MEDIUM",
        "confidence": "HIGH",
        "interfile": true,
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "short-description": "Path traversal through unsanitized file paths",
        "fix-suggestion": "Sanitize all user-provided file paths using `org.apache.commons.io.FilenameUtils.getName()` to extract just the filename component. Validate file paths against a whitelist of allowed directories and never allow path traversal characters. Consider storing files using an abstraction like Spring Resource that provides safe access methods."
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\n  ...\n}\n"
                },
                {
                  "pattern-inside": "$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\n  ...\n}\n"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$TYPE",
                "regex": "^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))"
              }
            },
            {
              "metavariable-regex": {
                "metavariable": "$REQ",
                "regex": "(RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue|ModelAttribute)"
              }
            },
            {
              "focus-metavariable": "$SOURCE"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "new File(...)"
                },
                {
                  "pattern": "new java.io.File(...)"
                },
                {
                  "pattern": "new FileReader(...)"
                },
                {
                  "pattern": "new java.io.FileReader(...)"
                },
                {
                  "pattern": "new FileInputStream(...)"
                },
                {
                  "pattern": "new java.io.FileInputStream(...)"
                },
                {
                  "pattern": "(Paths $PATHS).get(...)"
                },
                {
                  "patterns": [
                    {
                      "pattern": "$CLASS.$FUNC(...)\n"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$FUNC",
                        "regex": "^(getResourceAsStream|getResource)$"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "new ClassPathResource($FILE, ...)"
                        },
                        {
                          "pattern": "ResourceUtils.getFile($FILE, ...)"
                        },
                        {
                          "pattern": "new FileOutputStream($FILE, ...)"
                        },
                        {
                          "pattern": "new java.io.FileOutputStream($FILE, ...)"
                        },
                        {
                          "pattern": "new StreamSource($FILE, ...)"
                        },
                        {
                          "pattern": "new javax.xml.transform.StreamSource($FILE, ...)"
                        },
                        {
                          "pattern": "FileUtils.openOutputStream($FILE, ...)"
                        }
                      ]
                    },
                    {
                      "focus-metavariable": "$FILE"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "pattern": "org.apache.commons.io.FilenameUtils.getName(...)"
        }
      ]
    },
    {
      "id": "java.spring.security.injection.tainted-html-string.tainted-html-string",
      "languages": [
        "java"
      ],
      "severity": "ERROR",
      "message": "This vulnerability occurs when HTML content is manually constructed by concatenating user input without proper escaping or sanitization. Attackers can inject malicious JavaScript that executes in users' browsers when the page is rendered, potentially stealing session cookies, credentials, or performing actions as the victim. Using template engines that automatically apply context-appropriate HTML escaping helps prevent cross-site scripting attacks by ensuring user input is properly encoded.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html"
        ],
        "category": "security",
        "technology": [
          "java",
          "spring"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Building HTML with user input may allow XSS",
        "fix-suggestion": "Avoid manually constructing HTML by concatenating strings with user input; instead use template engines like Thymeleaf or FreeMarker which automatically apply HTML escaping. If you must generate HTML programmatically, use secure HTML encoding libraries like OWASP Java Encoder (e.g., `Encode.forHtml(userInput)`) to properly escape user data. For rich text that needs to preserve some HTML, use libraries like jsoup with a whitelist configuration: `Jsoup.clean(userHtml, Safelist.basic())`."
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "label": "INPUT",
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\n  ...\n}\n"
                },
                {
                  "pattern-inside": "$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\n  ...\n}\n"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$TYPE",
                "regex": "^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))"
              }
            },
            {
              "metavariable-regex": {
                "metavariable": "$REQ",
                "regex": "(RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue|ModelAttribute)"
              }
            },
            {
              "focus-metavariable": "$SOURCE"
            }
          ]
        },
        {
          "label": "CONCAT",
          "by-side-effect": true,
          "requires": "INPUT",
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "\"$HTMLSTR\" + ...\n"
                },
                {
                  "pattern": "\"$HTMLSTR\".concat(...)\n"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "StringBuilder $SB = new StringBuilder(\"$HTMLSTR\");\n...\n"
                    },
                    {
                      "pattern": "$SB.append(...)"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$VAR = \"$HTMLSTR\";\n...\n"
                    },
                    {
                      "pattern": "$VAR += ..."
                    }
                  ]
                },
                {
                  "pattern": "String.format(\"$HTMLSTR\", ...)"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "String $VAR = \"$HTMLSTR\";\n...\n"
                    },
                    {
                      "pattern": "String.format($VAR, ...)"
                    }
                  ]
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$HTMLSTR",
                "regex": "^<\\w+"
              }
            }
          ]
        }
      ],
      "pattern-propagators": [
        {
          "pattern": "(StringBuilder $SB).append($...TAINTED)",
          "from": "$...TAINTED",
          "to": "$SB"
        },
        {
          "pattern": "$VAR += $...TAINTED",
          "from": "$...TAINTED",
          "to": "$VAR"
        }
      ],
      "pattern-sinks": [
        {
          "requires": "CONCAT",
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "new ResponseEntity<>($PAYLOAD, ...)"
                },
                {
                  "pattern": "new ResponseEntity<$ERROR>($PAYLOAD, ...)"
                },
                {
                  "pattern": "ResponseEntity. ... .body($PAYLOAD)"
                },
                {
                  "patterns": [
                    {
                      "pattern": "ResponseEntity.$RESPFUNC($PAYLOAD). ...\n"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$RESPFUNC",
                        "regex": "^(ok|of)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "focus-metavariable": "$PAYLOAD"
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "pattern-either": [
            {
              "pattern": "Encode.forHtml(...)"
            },
            {
              "pattern": "(PolicyFactory $POLICY).sanitize(...)"
            },
            {
              "pattern": "(AntiSamy $AS).scan(...)"
            },
            {
              "pattern": "JSoup.clean(...)"
            }
          ]
        }
      ]
    },
    {
      "id": "java.spring.security.injection.tainted-sql-string.tainted-sql-string",
      "languages": [
        "java"
      ],
      "severity": "ERROR",
      "message": "This vulnerability arises when SQL queries in Spring applications are built by directly embedding user input into query strings without parameterization. Attackers can insert SQL syntax that alters the query structure, potentially accessing unauthorized data, modifying database contents, or executing administrative commands. Using parameterized queries or ORM methods with proper binding ensures user input is treated as data rather than executable SQL code.",
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.oracle.com/javase/7/docs/api/java/sql/PreparedStatement.html"
        ],
        "category": "security",
        "technology": [
          "spring"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "interfile": true,
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Concatenating user input in Spring SQL invites injection",
        "fix-suggestion": "Replace string concatenation in Spring SQL queries with parameterized queries using `JdbcTemplate`: `jdbcTemplate.query(\"SELECT * FROM users WHERE username = ?\", new Object[]{username}, RowMapper)`. For named parameters, use `NamedParameterJdbcTemplate`: `namedParameterJdbcTemplate.query(\"SELECT * FROM users WHERE username = :username\", new MapSqlParameterSource(\"username\", username), RowMapper)`. For dynamic query construction, use Spring Data's Specification API or QueryDSL instead of string concatenation."
      },
      "options": {
        "taint_assume_safe_numbers": true,
        "taint_assume_safe_booleans": true,
        "interfile": true
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\n  ...\n}\n"
                },
                {
                  "pattern-inside": "$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\n  ...\n}\n"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$REQ",
                "regex": "(RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue)"
              }
            },
            {
              "metavariable-regex": {
                "metavariable": "$TYPE",
                "regex": "^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))"
              }
            },
            {
              "focus-metavariable": "$SOURCE"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "\"$SQLSTR\" + ...\n"
                },
                {
                  "pattern": "\"$SQLSTR\".concat(...)\n"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "StringBuilder $SB = new StringBuilder(\"$SQLSTR\");\n...\n"
                    },
                    {
                      "pattern": "$SB.append(...)"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$VAR = \"$SQLSTR\";\n...\n"
                    },
                    {
                      "pattern": "$VAR += ..."
                    }
                  ]
                },
                {
                  "pattern": "String.format(\"$SQLSTR\", ...)"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "String $VAR = \"$SQLSTR\";\n...\n"
                    },
                    {
                      "pattern": "String.format($VAR, ...)"
                    }
                  ]
                }
              ]
            },
            {
              "pattern-not-inside": "System.out.println(...)"
            },
            {
              "pattern-not-inside": "$LOG.info(...)"
            },
            {
              "pattern-not-inside": "$LOG.warn(...)"
            },
            {
              "pattern-not-inside": "$LOG.warning(...)"
            },
            {
              "pattern-not-inside": "$LOG.debug(...)"
            },
            {
              "pattern-not-inside": "$LOG.debugging(...)"
            },
            {
              "pattern-not-inside": "$LOG.error(...)"
            },
            {
              "pattern-not-inside": "new Exception(...)"
            },
            {
              "pattern-not-inside": "throw ...;"
            },
            {
              "metavariable-regex": {
                "metavariable": "$SQLSTR",
                "regex": "(?i)(select|delete|insert|create|update|alter|drop)\\b"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "java.spring.security.injection.tainted-system-command.tainted-system-command",
      "languages": [
        "java"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-propagators": [
        {
          "pattern": "(StringBuilder $STRB).append($INPUT)",
          "from": "$INPUT",
          "to": "$STRB",
          "label": "CONCAT",
          "requires": "INPUT"
        }
      ],
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\n  ...\n}\n"
                },
                {
                  "pattern-inside": "$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\n  ...\n}\n"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$TYPE",
                "regex": "^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))"
              }
            },
            {
              "metavariable-regex": {
                "metavariable": "$REQ",
                "regex": "(RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue|ModelAttribute)"
              }
            },
            {
              "focus-metavariable": "$SOURCE"
            }
          ],
          "label": "INPUT"
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$X + $SOURCE"
                },
                {
                  "pattern": "$SOURCE + $Y"
                },
                {
                  "pattern": "String.format(\"...\", ..., $SOURCE, ...)"
                },
                {
                  "pattern": "String.join(\"...\", ..., $SOURCE, ...)"
                },
                {
                  "pattern": "(String $STR).concat($SOURCE)"
                },
                {
                  "pattern": "$SOURCE.concat(...)"
                },
                {
                  "pattern": "$X += $SOURCE"
                },
                {
                  "pattern": "$SOURCE += $X"
                }
              ]
            }
          ],
          "label": "CONCAT",
          "requires": "INPUT"
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "(Process $P) = new Process(...);\n"
                },
                {
                  "pattern": "(ProcessBuilder $PB).command(...);\n"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "(Runtime $R).$EXEC(...);\n"
                        },
                        {
                          "pattern": "Runtime.getRuntime(...).$EXEC(...);\n"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$EXEC",
                        "regex": "(exec|loadLibrary|load)"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "(ProcessBuilder $PB).command(...).$ADD(...);\n"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$ADD",
                        "regex": "(add|addAll)"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "patterns": [
                            {
                              "pattern-inside": "$BUILDER = new ProcessBuilder(...);\n...\n"
                            },
                            {
                              "pattern": "$BUILDER.start(...)"
                            }
                          ]
                        },
                        {
                          "pattern": "new ProcessBuilder(...). ... .start(...);\n"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "requires": "CONCAT"
        }
      ],
      "message": "This vulnerability happens when system commands are constructed using unsanitized user input, allowing attackers to inject additional commands or arguments. When executed, these injected commands run with the application's privileges, potentially leading to unauthorized system access, data theft, or system compromise. Using ProcessBuilder with a fixed command and separate arguments list, combined with strict input validation, prevents command injection by maintaining clear separation between the command and its parameters.",
      "metadata": {
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "java",
          "spring"
        ],
        "confidence": "HIGH",
        "references": [
          "https://www.stackhawk.com/blog/command-injection-java/",
          "https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html",
          "https://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-078/ExecUnescaped.java"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "System commands built with user input can cause injection",
        "fix-suggestion": "Avoid executing system commands with user input; use Java built-in libraries instead when possible. If command execution is necessary, use `ProcessBuilder` with separate arguments rather than a single command string: `new ProcessBuilder(\"command\", \"arg1\", \"arg2\").start()` instead of `Runtime.getRuntime().exec(\"command \" + userInput)`. Implement strict input validation using an allowlist approach that maps user inputs to predefined, safe command templates."
      }
    },
    {
      "id": "java.spring.security.injection.tainted-url-host.tainted-url-host",
      "languages": [
        "java"
      ],
      "severity": "ERROR",
      "message": "This vulnerability occurs when the host portion of URLs is dynamically constructed using user-supplied input without validation. Attackers can manipulate this input to redirect requests to malicious servers or access internal network resources, potentially leading to data exfiltration or server-side request forgery. Implementing strict validation of URL hosts against an allowlist of permitted domains prevents attackers from directing requests to unauthorized destinations.",
      "options": {
        "interfile": true
      },
      "metadata": {
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html"
        ],
        "category": "security",
        "technology": [
          "java",
          "spring"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "impact": "MEDIUM",
        "likelihood": "MEDIUM",
        "confidence": "MEDIUM",
        "interfile": true,
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "Unvalidated host in URL can lead to SSRF in Spring",
        "fix-suggestion": "Validate all URL hosts against a strict allowlist of permitted domains before making network requests with user-supplied URLs. Implement a URL validation utility that extracts and validates the hostname: `boolean isAllowedHost(String url) { try { String host = new URL(url).getHost(); return allowedHosts.contains(host); } catch (Exception e) { return false; } }`. When using `RestTemplate` or `WebClient`, implement a request interceptor that validates URLs before sending requests."
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$METHODNAME(..., @$REQ(...) $TYPE $SOURCE,...) {\n  ...\n}\n"
                },
                {
                  "pattern-inside": "$METHODNAME(..., @$REQ $TYPE $SOURCE,...) {\n  ...\n}\n"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$TYPE",
                "regex": "^(?!(Integer|Long|Float|Double|Char|Boolean|int|long|float|double|char|boolean))"
              }
            },
            {
              "metavariable-regex": {
                "metavariable": "$REQ",
                "regex": "(RequestBody|PathVariable|RequestParam|RequestHeader|CookieValue|ModelAttribute)"
              }
            },
            {
              "focus-metavariable": "$SOURCE"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "pattern-either": [
            {
              "pattern": "new URL($ONEARG)"
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "\"$URLSTR\" + ...\n"
                    },
                    {
                      "pattern": "\"$URLSTR\".concat(...)\n"
                    },
                    {
                      "patterns": [
                        {
                          "pattern-inside": "StringBuilder $SB = new StringBuilder(\"$URLSTR\");\n...\n"
                        },
                        {
                          "pattern": "$SB.append(...)"
                        }
                      ]
                    },
                    {
                      "patterns": [
                        {
                          "pattern-inside": "$VAR = \"$URLSTR\";\n...\n"
                        },
                        {
                          "pattern": "$VAR += ..."
                        }
                      ]
                    },
                    {
                      "patterns": [
                        {
                          "pattern": "String.format(\"$URLSTR\", ...)"
                        },
                        {
                          "pattern-not": "String.format(\"$URLSTR\", \"...\", ...)"
                        }
                      ]
                    },
                    {
                      "patterns": [
                        {
                          "pattern-inside": "String $VAR = \"$URLSTR\";\n...\n"
                        },
                        {
                          "pattern": "String.format($VAR, ...)"
                        }
                      ]
                    }
                  ]
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$URLSTR",
                    "regex": "http(s?)://%(v|s|q).*"
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.ajv.security.audit.ajv-allerrors-true.ajv-allerrors-true",
      "message": "This vulnerability arises when the Ajv JSON schema validator is configured with 'allErrors: true' without appropriate limits in place. Attackers can submit extremely complex or deeply nested JSON that generates a large number of error objects, potentially causing memory exhaustion and denial of service. In production environments, this setting should be avoided or used with additional measures like limiting input size and complexity to prevent resource consumption attacks.",
      "metadata": {
        "cwe": [
          "CWE-400: Uncontrolled Resource Consumption"
        ],
        "category": "security",
        "technology": [
          "ajv"
        ],
        "references": [
          "https://ajv.js.org/options.html#allerrors"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Denial-of-Service (DoS)"
        ],
        "short-description": "allErrors: true may create excessive error objects for DoS",
        "fix-suggestion": "Modify your Ajv configuration to use the `allErrors: false` setting in production environments to stop validation at the first error. If comprehensive validation is needed, set size limits with `maxItems`, `maxProperties`, and `maxLength` keywords in your schemas. Configure limits on error generation with Ajv options `jsonPointers: true` and `maxErrors: 10` to cap the number of errors produced."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "new Ajv({...,allErrors: true,...},...)\n"
        },
        {
          "patterns": [
            {
              "pattern": "new Ajv($SETTINGS,...)\n"
            },
            {
              "pattern-inside": "$SETTINGS = {...,allErrors: true,...}\n...\n"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.angular.security.detect-angular-element-methods.detect-angular-element-methods",
      "message": "This vulnerability happens when angular.element is used with user-supplied data to create or manipulate DOM elements without proper sanitization. Attackers can inject malicious HTML or JavaScript that executes when inserted into the page, potentially leading to cross-site scripting attacks. Ensuring all user data is properly sanitized before being passed to angular.element methods prevents the insertion of potentially dangerous content into the DOM.",
      "metadata": {
        "confidence": "LOW",
        "references": [
          "https://docs.angularjs.org/api/ng/function/angular.element",
          "https://owasp.org/www-chapter-london/assets/slides/OWASPLondon20170727_AngularJS.pdf"
        ],
        "category": "security",
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "technology": [
          "angularjs"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "angular.element usage with untrusted data can cause XSS",
        "fix-suggestion": "Avoid passing user-controlled data directly to `angular.element()` or methods like `.html()`, `.append()` on Angular element objects. Use Angular's built-in security mechanisms: property binding with interpolation `{{ expression }}` which automatically escapes content. For HTML content, inject the `DomSanitizer` service and use `bypassSecurityTrustHtml()` only after sanitizing with DOMPurify: `sanitizer.bypassSecurityTrustHtml(DOMPurify.sanitize(userHtml))`."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "INFO",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-inside": "function(..., $SCOPE, ...) { ... }\n"
                    },
                    {
                      "focus-metavariable": "$SCOPE"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$SCOPE",
                        "regex": "^\\$scope$"
                      }
                    }
                  ]
                },
                {
                  "pattern": "$rootScope"
                },
                {
                  "pattern": "$injector.get('$rootScope')"
                },
                {
                  "pattern": "$injector.get('$scope')"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "angular.element(...). ... .$SINK($QUERY)\n"
                },
                {
                  "pattern-inside": "$ANGULAR = angular.element(...)\n...\n$ANGULAR. ... .$SINK($QUERY)\n"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$SINK",
                "regex": "^(after|append|html|prepend|replaceWith|wrap)$"
              }
            },
            {
              "focus-metavariable": "$QUERY"
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$sce.getTrustedHtml(...)"
                },
                {
                  "pattern": "$sanitize(...)"
                },
                {
                  "pattern": "DOMPurify.sanitize(...)"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.angular.security.detect-angular-element-taint.detect-angular-element-taint",
      "message": "This vulnerability occurs when user-controlled data flows into angular.element without proper sanitization, allowing attackers to inject malicious content. When inserted into the DOM, this content can execute arbitrary JavaScript in users' browsers, potentially stealing session data or performing actions as the victim. Properly sanitizing user input before using it with angular.element prevents cross-site scripting by ensuring only safe content is added to the page.",
      "metadata": {
        "confidence": "MEDIUM",
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "references": [
          "https://docs.angularjs.org/api/ng/function/angular.element",
          "https://owasp.org/www-chapter-london/assets/slides/OWASPLondon20170727_AngularJS.pdf"
        ],
        "category": "security",
        "technology": [
          "angularjs"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Unsanitized data with angular.element leads to DOM-based XSS",
        "fix-suggestion": "Never pass user-controlled data directly to `angular.element()` without proper sanitization. Use Angular's template binding syntax with `{{ expression }}` which automatically escapes content. If HTML content insertion is needed, inject Angular's `DomSanitizer` service and use it with a dedicated sanitization library: `sanitizer.bypassSecurityTrustHtml(DOMPurify.sanitize(userContent))`."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "window.location.search"
                },
                {
                  "pattern": "window.document.location.search"
                },
                {
                  "pattern": "document.location.search"
                },
                {
                  "pattern": "location.search"
                },
                {
                  "pattern": "$location.search(...)"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$DECODE(<... location.hash ...>)"
                },
                {
                  "pattern": "$DECODE(<... window.location.hash ...>)"
                },
                {
                  "pattern": "$DECODE(<... document.location.hash ...>)"
                },
                {
                  "pattern": "$DECODE(<... location.href ...>)"
                },
                {
                  "pattern": "$DECODE(<... window.location.href ...>)"
                },
                {
                  "pattern": "$DECODE(<... document.location.href ...>)"
                },
                {
                  "pattern": "$DECODE(<... document.URL ...>)"
                },
                {
                  "pattern": "$DECODE(<... window.document.URL ...>)"
                },
                {
                  "pattern": "$DECODE(<... document.location.href ...>)"
                },
                {
                  "pattern": "$DECODE(<... document.location.href ...>)"
                },
                {
                  "pattern": "$DECODE(<... $location.absUrl() ...>)"
                },
                {
                  "pattern": "$DECODE(<... $location.url() ...>)"
                },
                {
                  "pattern": "$DECODE(<... $location.hash() ...>)"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$DECODE",
                "regex": "^(unescape|decodeURI|decodeURIComponent)$"
              }
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$http.$METHOD(...).$CONTINUE(function $FUNC($RES) {...})"
            },
            {
              "metavariable-regex": {
                "metavariable": "$METHOD",
                "regex": "^(get|delete|head|jsonp|post|put|patch)"
              }
            },
            {
              "pattern": "$RES.data"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "angular.element(...). ... .$SINK($QUERY)\n"
                },
                {
                  "pattern-inside": "$ANGULAR = angular.element(...)\n...\n$ANGULAR. ... .$SINK($QUERY)\n"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$SINK",
                "regex": "^(after|append|html|prepend|replaceWith|wrap)$"
              }
            },
            {
              "focus-metavariable": "$QUERY"
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$sce.getTrustedHtml(...)"
                },
                {
                  "pattern": "$sanitize(...)"
                },
                {
                  "pattern": "DOMPurify.sanitize(...)"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.angular.security.detect-angular-open-redirect.detect-angular-open-redirect",
      "message": "This vulnerability arises when $window.location.href is set using unsanitized user input, enabling open redirect attacks. Attackers can craft malicious URLs that redirect users to phishing sites designed to steal credentials or distribute malware. Implementing strict validation of redirect URLs against an allowlist of trusted destinations prevents attackers from redirecting users to arbitrary malicious websites.",
      "metadata": {
        "asvs": {
          "section": "V5 Validation, Sanitization and Encoding",
          "control_id": "5.5.1 Insecue Redirect",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v51-input-validation",
          "version": "4"
        },
        "references": [
          "https://docs.angularjs.org/api/ng/service/$sce#trustAsJs",
          "https://owasp.org/www-chapter-london/assets/slides/OWASPLondon20170727_AngularJS.pdf"
        ],
        "category": "security",
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "technology": [
          "angular"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Unvalidated $window.location.href can enable open redirects",
        "fix-suggestion": "Never directly assign user-controlled values to `$window.location` or `$window.location.href`. Implement a URL validation function that checks URLs against an allowlist of trusted domains: `function isSafeUrl(url) { if (url.startsWith('/')) return true; const allowedDomains = ['trusted-domain.com']; try { const urlObj = new URL(url); return allowedDomains.includes(urlObj.hostname); } catch (e) { return false; } }`. For Angular routes, use the Angular Router instead of directly manipulating location."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "patterns": [
        {
          "pattern": "$window.location.href = ...\n"
        },
        {
          "pattern-not": "$window.location.href = \"...\"\n"
        }
      ]
    },
    {
      "id": "javascript.angular.security.detect-angular-resource-loading.detect-angular-resource-loading",
      "message": "This vulnerability happens when $sceDelegateProvider is configured with overly permissive resource allowlists that include wildcards. Attackers can exploit these loose restrictions to load resources from malicious domains that match the wildcard patterns, potentially leading to data exfiltration or script injection. Restricting resource loading to specific, fully-qualified domains rather than using wildcards helps prevent unauthorized resource loading from attacker-controlled sources.",
      "metadata": {
        "references": [
          "https://docs.angularjs.org/api/ng/service/$sce#trustAsJs",
          "https://owasp.org/www-chapter-london/assets/slides/OWASPLondon20170727_AngularJS.pdf"
        ],
        "category": "security",
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "technology": [
          "angular"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Loose $sceDelegateProvider allowlists risk loading malicious content",
        "fix-suggestion": "Replace overly permissive resource allowlists in `$sceDelegateProvider.resourceUrlWhitelist()` that use wildcards like `'https://*.example.com/**'` with specific patterns like `'https://api.example.com/resources/**'`. Avoid using double-wildcards `'**'` in the hostname portion of allowlist entries. Implement a strict allowlist of specific, fully-qualified domains instead of broad patterns."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "$sceDelegateProvider.resourceUrlWhitelist([...,'**',...]);\n"
        },
        {
          "patterns": [
            {
              "pattern": "$sceDelegateProvider.resourceUrlWhitelist([...,$DOM,...]);\n"
            },
            {
              "metavariable-regex": {
                "metavariable": "$DOM",
                "regex": "^'.*\\*\\*.+'$"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.angular.security.detect-angular-sce-disabled.detect-angular-sce-disabled",
      "message": "This vulnerability occurs when AngularJS's Strict Contextual Escaping (SCE) is disabled, removing a key defense against cross-site scripting attacks. Without SCE, applications lose automatic context-sensitive escaping of potentially dangerous content, making it easier for attackers to inject malicious scripts. Keeping SCE enabled ensures that user-supplied content is properly escaped based on context before being rendered, reducing the risk of XSS vulnerabilities.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "references": [
          "https://docs.angularjs.org/api/ng/service/$sce",
          "https://owasp.org/www-chapter-london/assets/slides/OWASPLondon20170727_AngularJS.pdf"
        ],
        "category": "security",
        "technology": [
          "angular"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Disabling Angular SCE removes built-in XSS protection",
        "fix-suggestion": "Remove any code that disables Angular's Strict Contextual Escaping service, particularly calls to `$sceProvider.enabled(false)` or `$sce.enabled(false)`. If trusted HTML content is needed, use appropriate `$sce.trustAs*` methods after proper sanitization: `$sce.trustAsHtml(DOMPurify.sanitize(userHtml))`. For newer Angular versions, use the `DomSanitizer` service instead of disabling security features."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "pattern": "$sceProvider.enabled(false);\n"
    },
    {
      "id": "javascript.angular.security.detect-angular-trust-as-html-method.detect-angular-trust-as-html-method",
      "message": "This vulnerability arises when $sce.trustAsHtml is used with unsanitized user input, bypassing Angular's built-in XSS protections. When the trusted HTML is rendered, any malicious scripts it contains will execute in the user's browser, potentially stealing sensitive information or performing actions as the victim. Only use trustAsHtml with content from trusted sources or after applying proper sanitization to prevent injection of malicious code.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.angularjs.org/api/ng/service/$sce#trustAsHtml",
          "https://owasp.org/www-chapter-london/assets/slides/OWASPLondon20170727_AngularJS.pdf"
        ],
        "category": "security",
        "technology": [
          "angular"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "trustAsHtml with untrusted data leads to XSS risk",
        "fix-suggestion": "Never pass unsanitized user input directly to `$sce.trustAsHtml()` or `DomSanitizer.bypassSecurityTrustHtml()`. Always sanitize content first using a dedicated HTML sanitization library: `$sce.trustAsHtml(DOMPurify.sanitize(userHtml))` or `sanitizer.bypassSecurityTrustHtml(DOMPurify.sanitize(userHtml))`. Consider if HTML is truly needed - for many cases, using `{{ textContent }}` with automatic escaping is safer."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$SOURCE = $scope.$INPUT;\n$sce.trustAsHtml($SOURCE);\n"
            },
            {
              "pattern": "$sce.trustAsHtml($scope.$INPUT);\n"
            }
          ]
        },
        {
          "pattern-inside": "app.controller(..., function($scope,$sce){\n...\n});\n"
        }
      ]
    },
    {
      "id": "javascript.angular.security.detect-angular-trust-as-js-method.detect-angular-trust-as-js-method",
      "message": "This vulnerability happens when $sce.trustAsJs is used with user-controlled data, creating a direct avenue for JavaScript injection attacks. When the trusted JavaScript is executed, attackers can run arbitrary code in the user's browser context, potentially accessing sensitive data or performing unauthorized actions. Avoid using trustAsJs with dynamic content, especially user input, and restrict its use to static, developer-controlled scripts that have been thoroughly reviewed for safety.",
      "metadata": {
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.angularjs.org/api/ng/service/$sce#trustAsJs",
          "https://owasp.org/www-chapter-london/assets/slides/OWASPLondon20170727_AngularJS.pdf"
        ],
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "category": "security",
        "technology": [
          "angular"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "trustAsJs usage with user input can cause script injection",
        "fix-suggestion": "Avoid using `$sce.trustAsJs()` or `DomSanitizer.bypassSecurityTrustScript()` entirely, especially with user-controlled input. Redesign your application to avoid executing dynamic JavaScript from user input. Consider alternatives like restrictive expression evaluators (`jsep` or `expr-eval`) with controlled scope or implementing a domain-specific language with limited capabilities."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$SOURCE = $scope.$INPUT;\n$sce.trustAsJs($SOURCE);\n"
            },
            {
              "pattern": "$sce.trustAsJs($scope.$INPUT);\n"
            }
          ]
        },
        {
          "pattern-inside": "app.controller(..., function($scope,$sce){\n...\n});\n"
        }
      ]
    },
    {
      "id": "javascript.angular.security.detect-angular-trust-as-method.detect-angular-trust-as-method",
      "message": "This vulnerability occurs when $sce.trustAs is used to bypass Angular's Strict Contextual Escaping for user-supplied content. Depending on the trust type (HTML, JS, URL, etc.), attackers can inject various forms of malicious content that execute when rendered or processed by the browser. Only use trustAs methods with static content from trusted sources, and never with unsanitized user input that could contain malicious payloads.",
      "metadata": {
        "references": [
          "https://docs.angularjs.org/api/ng/service/$sce",
          "https://owasp.org/www-chapter-london/assets/slides/OWASPLondon20170727_AngularJS.pdf"
        ],
        "category": "security",
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "technology": [
          "angular"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "trustAs bypass with dynamic data can allow code injection",
        "fix-suggestion": "Avoid using `$sce.trustAs()` with user-controlled input as it bypasses Angular's Strict Contextual Escaping. Use specific contextual methods (`$sce.trustAsHtml()`, `$sce.trustAsUrl()`) which are more explicit about the security context. Always sanitize content before trusting it using appropriate sanitization for each context: for HTML use `DOMPurify.sanitize(userHtml)`, for URLs validate against an allowlist."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-inside": "app.controller(..., function($scope,$sce) {\n...\n});\n"
            },
            {
              "pattern": "$scope.$X"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "pattern": "$sce.trustAs(...)"
        },
        {
          "pattern": "$sce.trustAsHtml(...)"
        }
      ]
    },
    {
      "id": "javascript.angular.security.detect-angular-trust-as-resourceurl-method.detect-angular-trust-as-resourceurl-method",
      "message": "This vulnerability arises when $sce.trustAsResourceUrl is used with user-controlled URLs, bypassing Angular's security checks for resource loading. Attackers can provide malicious URLs that, once trusted, can load harmful resources, exfiltrate data through JSONP, or exploit vulnerable services. Only use trustAsResourceUrl with hardcoded URLs or after applying strict validation against an allowlist of trusted domains to prevent loading resources from attacker-controlled sources.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.angularjs.org/api/ng/service/$sce#trustAsResourceUrl",
          "https://owasp.org/www-chapter-london/assets/slides/OWASPLondon20170727_AngularJS.pdf"
        ],
        "category": "security",
        "technology": [
          "angular"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "trustAsResourceUrl with unvalidated input can load malicious resources",
        "fix-suggestion": "Never pass user-controlled input directly to `$sce.trustAsResourceUrl()` or `DomSanitizer.bypassSecurityTrustResourceUrl()`. Implement strict URL validation with an allowlist of trusted domains: `function isTrustedResourceUrl(url) { try { const urlObj = new URL(url); return TRUSTED_DOMAINS.includes(urlObj.hostname); } catch (e) { return false; } }`. Only trust URLs that pass validation: `if (isTrustedResourceUrl(userUrl)) { return $sce.trustAsResourceUrl(userUrl); }`."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$SOURCE = $scope.$INPUT;\n$sce.trustAsResourceUrl($SOURCE);\n"
            },
            {
              "pattern": "$sce.trustAsResourceUrl($scope.$INPUT);\n"
            }
          ]
        },
        {
          "pattern-inside": "app.controller(..., function($scope,$sce){\n...\n});\n"
        }
      ]
    },
    {
      "id": "javascript.angular.security.detect-angular-trust-as-url-method.detect-angular-trust-as-url-method",
      "message": "This vulnerability happens when $sce.trustAsUrl is used with user-supplied URL data without proper validation. When these trusted URLs are used in navigation or resource loading, they can lead to open redirects, cross-site scripting, or data exfiltration. Implement strict validation of any URLs before marking them as trusted to ensure they point only to legitimate destinations and don't contain potentially malicious protocols like javascript:.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.angularjs.org/api/ng/service/$sce#trustAsUrl",
          "https://owasp.org/www-chapter-london/assets/slides/OWASPLondon20170727_AngularJS.pdf"
        ],
        "category": "security",
        "technology": [
          "angular"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "trustAsUrl with user input can lead to XSS or open redirects",
        "fix-suggestion": "Do not pass user-controlled input directly to `$sce.trustAsUrl()` or `DomSanitizer.bypassSecurityTrustUrl()`. Implement strict URL validation before trusting any URL, validating the URL scheme to prevent `javascript:` URLs and checking against an allowlist of trusted domains. Only trust URLs that pass both validations: `if (hasValidScheme(userUrl) && isTrustedDomain(userUrl)) { return $sce.trustAsUrl(userUrl); }`."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$SOURCE = $scope.$INPUT;\n$sce.trustAsUrl($SOURCE);\n"
            },
            {
              "pattern": "$sce.trustAsUrl($scope.$INPUT);\n"
            }
          ]
        },
        {
          "pattern-inside": "app.controller(..., function($scope,$sce){\n...\n});\n"
        }
      ]
    },
    {
      "id": "javascript.angular.security.detect-angular-trust-as-css.detect-angular-trust-as-css-method",
      "message": "This vulnerability occurs when $sce.trustAsCss is used with user-controlled CSS input without proper validation. Attackers can inject malicious CSS that steals data through exfiltration techniques or executes JavaScript in certain browsers using expression() functions. Thoroughly validate any dynamic CSS content before marking it as trusted, and consider using a CSS sanitizer library to remove potentially dangerous constructs.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.angularjs.org/api/ng/service/$sce#trustAsCss",
          "https://owasp.org/www-chapter-london/assets/slides/OWASPLondon20170727_AngularJS.pdf"
        ],
        "category": "security",
        "technology": [
          "angular"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "trustAsCss with untrusted data can produce malicious CSS injection",
        "fix-suggestion": "Avoid using `$sce.trustAsCss()` or `DomSanitizer.bypassSecurityTrustStyle()` with user-controlled input. If dynamic CSS is necessary, validate input against a strict allowlist of safe CSS properties and values. Where possible, use Angular's built-in style binding with controlled values: `[style.width.px]=\"userWidth\"` rather than `[style]=\"userStyle\"`."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$SOURCE = $scope.$INPUT;\n$sce.trustAsCss($SOURCE);\n"
            },
            {
              "pattern": "$sce.trustAsCss($scope.$INPUT);\n"
            }
          ]
        },
        {
          "pattern-inside": "app.controller(..., function($scope,$sce){\n...\n});\n"
        }
      ]
    },
    {
      "id": "javascript.angular.security.detect-third-party-angular-translate.detect-angular-translateprovider-translations-method",
      "message": "This vulnerability arises when user data is directly fed into $translateProvider.translations without proper sanitization. Attackers can inject malicious content into translation strings that may be rendered as trusted HTML, potentially leading to cross-site scripting attacks. Sanitize all translations from untrusted sources and consider using Angular Translate's sanitize option to ensure potentially dangerous content is properly escaped.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "references": [
          "https://docs.angularjs.org/api/ng/service/$sce#trustAsUrl",
          "https://owasp.org/www-chapter-london/assets/slides/OWASPLondon20170727_AngularJS.pdf"
        ],
        "category": "security",
        "technology": [
          "angular",
          "typescript"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "User input in translations can lead to code injection",
        "fix-suggestion": "Do not pass user-controlled content directly to `$translateProvider.translations()`. Enable the sanitize option in translate configuration: `$translateProvider.useSanitizeValueStrategy('sanitize')`. Pre-sanitize user-sourced translations with DOMPurify before adding them to the translation service and consider using translation variables for dynamic content: `$translate.instant('GREETING', { name: userName })`."
      },
      "languages": [
        "javascript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern": "$translateProvider.translations(...,$SOURCE);\n"
        },
        {
          "pattern-inside": "app.controller(..., function($scope,$sce){\n...\n});\n"
        }
      ]
    },
    {
      "id": "javascript.apollo.security.apollo-axios-ssrf.apollo-axios-ssrf",
      "message": "This vulnerability happens when user input directly influences URL construction in Axios requests within Apollo applications. Attackers can provide URLs pointing to internal network resources or malicious external servers, potentially exposing sensitive information or enabling server-side request forgery. Implement strict validation of URLs against an allowlist of permitted domains and IP ranges to prevent requests to unauthorized destinations.",
      "metadata": {
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "category": "security",
        "technology": [
          "apollo",
          "axios"
        ],
        "references": [
          "https://www.cvedetails.com/cve/CVE-2020-28168/",
          "https://owasp.org/www-community/attacks/Server_Side_Request_Forgery"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "Unvalidated user data in Axios requests can cause SSRF",
        "fix-suggestion": "Validate all URLs in Apollo Client HTTP requests that include user input with a validation function checking against allowed domains and protocols. Use the `uri` option with fixed URLs in Apollo Client configuration instead of dynamically constructed ones. When using Axios within Apollo Link, implement request interceptors that validate URLs before requests are sent: `axios.interceptors.request.use(config => { if (!isValidUrl(config.url)) throw new Error('Invalid URL'); return config; })`."
      },
      "languages": [
        "javascript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern": "const $RESPONSE = await axios.request($INNERARG,...)"
        },
        {
          "pattern-inside": "Query: {\n  $METHOD(parent, args, context, info) {\n    ...\n    $DATA = args.$DATAVAL\n    ...\n    async function $INNERFUNC(...,$INNERARG,...){\n      ...\n    }\n    ...\n    return $INNERFUNC(...,$DATA,...)\n    }\n  }\n"
        }
      ]
    },
    {
      "id": "javascript.argon2.security.unsafe-argon2-config.unsafe-argon2-config",
      "message": "Your code uses Argon2 password hashing but not the recommended Argon2id variant. RFC9016 recommends Argon2id as it provides protection against both side-channel attacks and GPU-based cracking attempts. Using other Argon2 variants can reduce security in certain attack scenarios where adversaries might have access to your computing environment.",
      "metadata": {
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html",
          "https://eprint.iacr.org/2016/759.pdf",
          "https://www.cs.tau.ac.il/~tromer/papers/cache-joc-20090619.pdf",
          "https://datatracker.ietf.org/doc/html/rfc9106#section-4"
        ],
        "category": "security",
        "cwe": [
          "CWE-916: Use of Password Hash With Insufficient Computational Effort"
        ],
        "technology": [
          "argon2",
          "cryptography"
        ],
        "owasp": [
          "A02:2021 - Cryptographic Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "impact": "LOW",
        "likelihood": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Hashing Algorithm"
        ],
        "short-description": "Non-recommended Argon2 variant reduces protection",
        "fix-suggestion": "Change your Argon2 implementation to use the `Argon2id` variant instead of other variants. Ensure your memory, iteration, and parallelism parameters are appropriate for your threat model. Follow OWASP recommendations for Argon2 parameters based on your application's security requirements."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-inside": "$ARGON = require('argon2');\n...\n"
            },
            {
              "pattern": "{type: ...}\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$Y\n"
            },
            {
              "pattern-inside": "$ARGON.hash(...,$Y)\n"
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern": "{type: $ARGON.argon2id}\n...\n"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.audit.detect-replaceall-sanitization.detect-replaceall-sanitization",
      "message": "This vulnerability occurs when developers attempt to sanitize HTML by using custom replaceAll solutions that often fail to handle all possible encoding variations and attack vectors. Attackers can bypass these simplistic sanitization attempts by using alternative encodings or unexpected character combinations to inject malicious scripts. Instead of building custom sanitization, use established libraries like DOMPurify or sanitize-html that comprehensively handle the complexity of proper HTML sanitization.",
      "metadata": {
        "category": "security",
        "technology": [
          "javascript",
          "typescript"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "references": [
          "https://www.npmjs.com/package/dompurify",
          "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Insecure HTML escaping via replaceAll can be bypassed",
        "fix-suggestion": "Replace custom HTML sanitization based on string replacement (`replaceAll`, `replace`, regex) with dedicated security libraries. Use established sanitization libraries: client-side with `DOMPurify.sanitize(userHtml)` or Node.js with `sanitizeHtml(userHtml, { allowedTags: ['b', 'i', 'em', 'strong'] })`. If you need to completely strip all HTML, use methods that extract only text content: `new DOMParser().parseFromString(userHtml, 'text/html').body.textContent` for browsers."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "INFO",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$STR.$FUNC('<', '&lt;')"
            },
            {
              "pattern": "$STR.$FUNC('>', '&gt;')"
            },
            {
              "pattern": "$STR.$FUNC('\"', '&quot;')"
            },
            {
              "pattern": "$STR.$FUNC(\"'\", '&apos;')"
            },
            {
              "pattern": "$STR.$FUNC('&', '&amp;')"
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$FUNC",
            "regex": "(replace|replaceAll)"
          }
        }
      ]
    },
    {
      "id": "javascript.aws-lambda.security.detect-child-process.detect-child-process",
      "message": "This vulnerability arises when AWS Lambda functions spawn child processes using user-supplied input without proper validation. Attackers can inject shell metacharacters or command separators to execute arbitrary commands within the Lambda execution environment. Avoid passing user input to child process functions or implement strict input validation with an allowlist approach to ensure only safe, expected values are used.",
      "metadata": {
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "javascript",
          "aws-lambda"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Spawning child processes with user input allows command injection",
        "fix-suggestion": "Avoid using `child_process` methods with user-supplied input in AWS Lambda functions. Use AWS SDK methods for service interactions rather than executing shell commands. If process execution is necessary, use `child_process.execFile()` with fixed command paths and separate arguments: `execFile('/bin/ls', ['-la', validatedDir])` instead of `exec('ls -la ' + userInput)`."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "$EVENT"
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "exports.handler = function ($EVENT, ...) {\n  ...\n}\n"
                },
                {
                  "pattern-inside": "function $FUNC ($EVENT, ...) {...}\n...\nexports.handler = $FUNC\n"
                },
                {
                  "pattern-inside": "$FUNC = function ($EVENT, ...) {...}\n...\nexports.handler = $FUNC\n"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$CMD"
            },
            {
              "pattern-either": [
                {
                  "pattern": "exec($CMD,...)"
                },
                {
                  "pattern": "execSync($CMD,...)"
                },
                {
                  "pattern": "spawn($CMD,...)"
                },
                {
                  "pattern": "spawnSync($CMD,...)"
                },
                {
                  "pattern": "$CP.exec($CMD,...)"
                },
                {
                  "pattern": "$CP.execSync($CMD,...)"
                },
                {
                  "pattern": "$CP.spawn($CMD,...)"
                },
                {
                  "pattern": "$CP.spawnSync($CMD,...)"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "require('child_process')\n...\n"
                },
                {
                  "pattern-inside": "import 'child_process'\n...\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.aws-lambda.security.dynamodb-request-object.dynamodb-request-object",
      "message": "Your Lambda function passes user input directly from event objects to DynamoDB queries without sanitization. This creates a NoSQL injection vulnerability where attackers can manipulate query structure to access unauthorized data or bypass application logic. Always explicitly validate and sanitize user-controlled fields before using them in database operations.",
      "metadata": {
        "cwe": [
          "CWE-943: Improper Neutralization of Special Elements in Data Query Logic"
        ],
        "owasp": [
          "A01:2017 - Injection"
        ],
        "category": "security",
        "technology": [
          "javascript",
          "aws-lambda",
          "dynamodb"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "Unsanitized DynamoDB queries enable NoSQL injection",
        "fix-suggestion": "Explicitly extract and validate each field from the `event` object before using it in DynamoDB queries. Use specific data types and structures rather than passing entire objects from the event. Implement schema validation for incoming data using a library like Joi or JSON Schema."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "$EVENT"
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "exports.handler = function ($EVENT, ...) {\n  ...\n}\n"
                },
                {
                  "pattern-inside": "function $FUNC ($EVENT, ...) {...}\n...\nexports.handler = $FUNC\n"
                },
                {
                  "pattern-inside": "$FUNC = function ($EVENT, ...) {...}\n...\nexports.handler = $FUNC\n"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$SINK"
            },
            {
              "pattern": "$DC.$METHOD($SINK, ...)\n"
            },
            {
              "metavariable-regex": {
                "metavariable": "$METHOD",
                "regex": "(query|send|scan|delete|put|transactWrite|update|batchExecuteStatement|executeStatement|executeTransaction|transactWriteItems)"
              }
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "$DC = new $AWS.DocumentClient(...);\n...\n"
                },
                {
                  "pattern-inside": "$DC = new $AWS.DynamoDB(...);\n...\n"
                },
                {
                  "pattern-inside": "$DC = new DynamoDBClient(...);\n...\n"
                },
                {
                  "pattern-inside": "$DC = DynamoDBDocumentClient.from(...);\n...\n"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern": "{...}\n"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.aws-lambda.security.knex-sqli.knex-sqli",
      "message": "This vulnerability happens when Knex.js queries in AWS Lambda functions are built using user input without proper parameterization. Attackers can inject SQL syntax that alters the query structure, potentially accessing unauthorized data or manipulating database contents. Use Knex's parameter binding with question marks or named parameters to ensure user input is properly escaped and treated as data rather than executable code.",
      "metadata": {
        "references": [
          "https://knexjs.org/#Builder-fromRaw",
          "https://knexjs.org/#Builder-whereRaw"
        ],
        "category": "security",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "technology": [
          "aws-lambda",
          "knex"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Knex query built from user data is injection-prone",
        "fix-suggestion": "Replace string concatenation with Knex.js parameterized queries to prevent SQL injection vulnerabilities. Use `knex.raw('SELECT * FROM users WHERE username = ?', [username])` instead of `knex.raw('SELECT * FROM users WHERE username = \\'' + username + '\\'')` or better yet use the query builder like `knex('users').where('username', username)`. For dynamic column names, validate against an allowlist with `const ALLOWED_COLUMNS = ['id', 'name', 'email']; if (!ALLOWED_COLUMNS.includes(columnName)) throw new Error('Invalid column')`."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "exports.handler = function ($EVENT, ...) {\n  ...\n}\n"
                },
                {
                  "pattern-inside": "function $FUNC ($EVENT, ...) {...}\n...\nexports.handler = $FUNC\n"
                },
                {
                  "pattern-inside": "$FUNC = function ($EVENT, ...) {...}\n...\nexports.handler = $FUNC\n"
                }
              ]
            },
            {
              "pattern": "$EVENT"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$QUERY"
            },
            {
              "pattern-either": [
                {
                  "pattern": "$KNEX.fromRaw($QUERY, ...)"
                },
                {
                  "pattern": "$KNEX.whereRaw($QUERY, ...)"
                },
                {
                  "pattern": "$KNEX.raw($QUERY, ...)"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "require('knex')\n...\n"
                },
                {
                  "pattern-inside": "import 'knex'\n...\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.aws-lambda.security.mysql-sqli.mysql-sqli",
      "message": "This vulnerability occurs when MySQL queries in AWS Lambda functions are constructed by directly embedding user input into query strings. Attackers can insert malicious SQL code that changes the query's behavior, potentially leading to unauthorized data access or database manipulation. Using prepared statements with parameter placeholders ensures user input is properly escaped and treated as data rather than part of the SQL command.",
      "metadata": {
        "references": [
          "https://www.npmjs.com/package/mysql2"
        ],
        "category": "security",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "technology": [
          "aws-lambda",
          "mysql",
          "mysql2"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Building MySQL queries with untrusted data can cause injection",
        "fix-suggestion": "Eliminate SQL injection by using parameterized queries instead of string concatenation in MySQL operations. Use `connection.query('SELECT * FROM users WHERE username = ?', [username], ...)` rather than direct concatenation, or for multiple parameters `connection.query('SELECT * FROM users WHERE username = ? AND status = ?', [username, status], ...)`. When dynamic table names are needed, validate them with `const ALLOWED_TABLES = ['users', 'products']; if (!ALLOWED_TABLES.includes(tableName)) throw new Error('Invalid table')`."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "exports.handler = function ($EVENT, ...) {\n  ...\n}\n"
                },
                {
                  "pattern-inside": "function $FUNC ($EVENT, ...) {...}\n...\nexports.handler = $FUNC\n"
                },
                {
                  "pattern-inside": "$FUNC = function ($EVENT, ...) {...}\n...\nexports.handler = $FUNC\n"
                }
              ]
            },
            {
              "pattern": "$EVENT"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$QUERY"
            },
            {
              "pattern-either": [
                {
                  "pattern": "$POOL.query($QUERY, ...)"
                },
                {
                  "pattern": "$POOL.execute($QUERY, ...)"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "require('mysql')\n...\n"
                },
                {
                  "pattern-inside": "require('mysql2')\n...\n"
                },
                {
                  "pattern-inside": "require('mysql2/promise')\n...\n"
                },
                {
                  "pattern-inside": "import 'mysql'\n...\n"
                },
                {
                  "pattern-inside": "import 'mysql2'\n...\n"
                },
                {
                  "pattern-inside": "import 'mysql2/promise'\n...\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.aws-lambda.security.pg-sqli.pg-sqli",
      "message": "This vulnerability arises when PostgreSQL queries in AWS Lambda functions are built by concatenating user input directly into the query string. Attackers can provide specially crafted input containing SQL syntax that alters the query's structure and behavior, potentially exposing or modifying sensitive data. Using parameterized queries with the pg module's parameter binding capabilities prevents SQL injection by ensuring user input is properly escaped before query execution.",
      "metadata": {
        "references": [
          "https://node-postgres.com/features/queries"
        ],
        "category": "security",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "technology": [
          "aws-lambda",
          "postgres",
          "pg"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "PostgreSQL query concatenation in Lambda leads to injection",
        "fix-suggestion": "Secure PostgreSQL queries by using numbered parameters like `client.query('SELECT * FROM users WHERE username = $1', [username])` instead of concatenating user input. For multiple parameters use `client.query('SELECT * FROM users WHERE username = $1 AND email = $2', [username, email])`, or with pg-promise use named parameters like `db.query('SELECT * FROM users WHERE username = ${username}', {username: username})`. For dynamic column names, implement validation with `const ALLOWED_COLUMNS = ['id', 'name', 'email']; if (!ALLOWED_COLUMNS.includes(columnName)) throw new Error('Invalid column')`."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "exports.handler = function ($EVENT, ...) {\n  ...\n}\n"
                },
                {
                  "pattern-inside": "function $FUNC ($EVENT, ...) {...}\n...\nexports.handler = $FUNC\n"
                },
                {
                  "pattern-inside": "$FUNC = function ($EVENT, ...) {...}\n...\nexports.handler = $FUNC\n"
                }
              ]
            },
            {
              "pattern": "$EVENT"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$QUERY"
            },
            {
              "pattern-either": [
                {
                  "pattern": "$DB.query($QUERY, ...)"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "require('pg')\n...\n"
                },
                {
                  "pattern-inside": "import 'pg'\n...\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.aws-lambda.security.sequelize-sqli.sequelize-sqli",
      "message": "This vulnerability happens when Sequelize ORM queries in AWS Lambda functions incorporate unsanitized user input directly into SQL strings. Attackers can inject SQL code that compromises query integrity, potentially leading to unauthorized data access or database manipulation. Use Sequelize's built-in parameterization capabilities with replacements or bind parameters to ensure user input is properly escaped and treated as data rather than executable SQL.",
      "metadata": {
        "references": [
          "https://sequelize.org/master/manual/raw-queries.html"
        ],
        "category": "security",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "technology": [
          "aws-lambda",
          "sequelize"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Sequelize queries with unsanitized data risk SQL injection",
        "fix-suggestion": "Prevent SQL injection in Sequelize by avoiding string concatenation and using parameterized queries. Replace unsafe queries with `sequelize.query('SELECT * FROM users WHERE username = ?', { replacements: [username], type: sequelize.QueryTypes.SELECT })` or named parameters with `sequelize.query('SELECT * FROM users WHERE username = :username', { replacements: {username: username}, type: sequelize.QueryTypes.SELECT })`. Whenever possible, use Sequelize models like `User.findAll({ where: { username: username } })` which automatically handle parameterization."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "exports.handler = function ($EVENT, ...) {\n  ...\n}\n"
                },
                {
                  "pattern-inside": "function $FUNC ($EVENT, ...) {...}\n...\nexports.handler = $FUNC\n"
                },
                {
                  "pattern-inside": "$FUNC = function ($EVENT, ...) {...}\n...\nexports.handler = $FUNC\n"
                }
              ]
            },
            {
              "pattern": "$EVENT"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$QUERY"
            },
            {
              "pattern-either": [
                {
                  "pattern": "$DB.query($QUERY, ...)"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "require('sequelize')\n...\n"
                },
                {
                  "pattern-inside": "import 'sequelize'\n...\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.aws-lambda.security.tainted-eval.tainted-eval",
      "message": "The `eval()` function executes JavaScript code passed as a string, creating a security risk when the input comes from external sources. An attacker could inject malicious code that would execute with the same privileges as your application. Always validate and sanitize any dynamic content before evaluation, or ideally, use safer alternatives to `eval()`.",
      "metadata": {
        "cwe": [
          "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "javascript",
          "aws-lambda"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Unsanitized input in eval exposes code injection risk",
        "fix-suggestion": "Replace `eval()` with safer alternatives like JSON.parse() for data parsing or a template system for dynamic content. If eval is absolutely necessary, implement strict input validation that only accepts a constrained format of input with a whitelist approach. Consider using content security policies to prevent eval execution entirely."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "$EVENT"
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "exports.handler = function ($EVENT, ...) {\n  ...\n}\n"
                },
                {
                  "pattern-inside": "function $FUNC ($EVENT, ...) {...}\n...\nexports.handler = $FUNC\n"
                },
                {
                  "pattern-inside": "$FUNC = function ($EVENT, ...) {...}\n...\nexports.handler = $FUNC\n"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$CODE"
            },
            {
              "pattern-either": [
                {
                  "pattern": "eval($CODE)"
                },
                {
                  "pattern": "Function(...,$CODE)"
                },
                {
                  "pattern": "new Function(...,$CODE)"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.aws-lambda.security.tainted-html-response.tainted-html-response",
      "message": "This vulnerability occurs when AWS Lambda functions directly include user input in HTML responses without proper escaping. When this unescaped content is rendered in users' browsers, attackers can inject scripts that execute in the page context, potentially stealing sensitive data or performing unauthorized actions. Always escape user-controlled data before including it in HTML responses or use template libraries that automatically apply context-appropriate escaping.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "aws-lambda"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Directly sending unsanitized user data in HTML can cause XSS",
        "fix-suggestion": "Guard against XSS by never including user input directly in HTML responses without proper encoding. Use templating engines with automatic escaping like `app.render('template', { userContent: userInput })` or encode manually with `const { escapeHTML } = require('escape-html'); return `<div>${escapeHTML(userInput)}</div>`. For rich content, implement sanitization through libraries like `const sanitizeHtml = require('sanitize-html'); return `<div>${sanitizeHtml(userHtml, { allowedTags: ['b', 'i', 'em'] })}</div>`."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "exports.handler = function ($EVENT, ...) {\n  ...\n}\n"
                },
                {
                  "pattern-inside": "function $FUNC ($EVENT, ...) {...}\n...\nexports.handler = $FUNC\n"
                },
                {
                  "pattern-inside": "$FUNC = function ($EVENT, ...) {...}\n...\nexports.handler = $FUNC\n"
                }
              ]
            },
            {
              "pattern": "$EVENT"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$BODY"
            },
            {
              "pattern-inside": "{..., headers: {..., 'Content-Type': 'text/html', ...}, body: $BODY, ... }\n"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.aws-lambda.security.tainted-html-string.tainted-html-string",
      "message": "This vulnerability arises when HTML strings in AWS Lambda functions are manually constructed by concatenating user input without proper sanitization. When rendered in the browser, this can lead to cross-site scripting attacks where injected scripts execute in the user's context. Use template systems with automatic HTML escaping or sanitize user input with specialized libraries to ensure malicious content cannot be injected into the generated HTML.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "aws-lambda"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Manually building HTML with user input leads to XSS risk",
        "fix-suggestion": "Mitigate XSS risks by avoiding manual HTML construction with user input concatenation. Implement template engines with automatic escaping like `const html = template({ userContent: userInput })` or use proper encoding with `const { escapeHTML } = require('escape-html'); const html = `<div>${escapeHTML(userInput)}</div>`. When rich text is needed, sanitize content using libraries such as `const sanitizeHtml = require('sanitize-html'); const html = `<div>${sanitizeHtml(userHtml, { allowedTags: ['b', 'i', 'em', 'strong'], allowedAttributes: {} })}</div>`."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "exports.handler = function ($EVENT, ...) {\n  ...\n}\n"
                },
                {
                  "pattern-inside": "function $FUNC ($EVENT, ...) {...}\n...\nexports.handler = $FUNC\n"
                },
                {
                  "pattern-inside": "$FUNC = function ($EVENT, ...) {...}\n...\nexports.handler = $FUNC\n"
                }
              ]
            },
            {
              "pattern": "$EVENT"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "\"$HTMLSTR\" + $EXPR\n"
                        },
                        {
                          "pattern": "\"$HTMLSTR\".concat(...)\n"
                        },
                        {
                          "pattern": "$UTIL.format($HTMLSTR, ...)"
                        },
                        {
                          "pattern": "format($HTMLSTR, ...)"
                        }
                      ]
                    },
                    {
                      "metavariable-pattern": {
                        "metavariable": "$HTMLSTR",
                        "language": "generic",
                        "pattern": "<$TAG ..."
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "`...${...}...`\n"
                    },
                    {
                      "pattern-regex": ".*<\\w+.*\n"
                    }
                  ]
                }
              ]
            },
            {
              "pattern-not-inside": "console.$LOG(...)\n"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.aws-lambda.security.vm-runincontext-injection.vm-runincontext-injection",
      "message": "This vulnerability happens when Node.js vm module's runInContext method is used with user-controlled code in AWS Lambda functions. Attackers who can influence the executed code can potentially break out of the VM sandbox and execute arbitrary code in the Lambda environment. Never pass untrusted input to vm methods, as even with a sandbox, various techniques may allow attackers to escape the isolation and gain broader execution privileges.",
      "metadata": {
        "owasp": [
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "category": "security",
        "technology": [
          "javascript",
          "aws-lambda"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "vm-runInContext with untrusted code can enable RCE",
        "fix-suggestion": "Eliminate code injection risks by avoiding Node.js `vm.runInContext` method with user-supplied input. If dynamic code execution is necessary, implement strict input validation with an allowlist that only permits expected patterns. Consider replacing the `vm` module with purpose-built expression evaluators or rule engine libraries that provide better security controls."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "$EVENT"
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "exports.handler = function ($EVENT, ...) {\n  ...\n}\n"
                },
                {
                  "pattern-inside": "function $FUNC ($EVENT, ...) {...}\n...\nexports.handler = $FUNC\n"
                },
                {
                  "pattern-inside": "$FUNC = function ($EVENT, ...) {...}\n...\nexports.handler = $FUNC\n"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "require('vm');\n...\n"
                },
                {
                  "pattern-inside": "import 'vm'\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$VM.runInContext($X,...)"
                },
                {
                  "pattern": "$VM.runInNewContext($X,...)"
                },
                {
                  "pattern": "$VM.runInThisContext($X,...)"
                },
                {
                  "pattern": "$VM.compileFunction($X,...)"
                },
                {
                  "pattern": "new $VM.Script($X,...)"
                },
                {
                  "pattern": "new $VM.SourceTextModule($X,...)"
                },
                {
                  "pattern": "runInContext($X,...)"
                },
                {
                  "pattern": "runInNewContext($X,...)"
                },
                {
                  "pattern": "runInThisContext($X,...)"
                },
                {
                  "pattern": "compileFunction($X,...)"
                },
                {
                  "pattern": "new Script($X,...)"
                },
                {
                  "pattern": "new SourceTextModule($X,...)"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.bluebird.security.audit.tofastproperties-code-execution.tofastproperties-code-execution",
      "message": "This vulnerability occurs when the internal toFastProperties function from Bluebird is exposed and used with user-controlled input. This function internally uses eval() on its input, allowing attackers to execute arbitrary JavaScript code if they can control the parameter value. Avoid using this internal optimization function with any form of dynamic or user-influenced data to prevent remote code execution vulnerabilities.",
      "metadata": {
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "bluebird"
        ],
        "references": [
          "http://bluebirdjs.com/docs/getting-started.html"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "toFastProperties with dynamic input uses eval, enabling injection",
        "fix-suggestion": "Remove all usage of the internal Bluebird `toFastProperties` function which was not designed for direct use and uses `eval()` internally. For performance optimization, use safer alternatives like object literal initialization or standard V8 optimization techniques. Never pass user-controlled or dynamic data to internal library functions, especially those that might execute code."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-inside": "function ... (..., $ARG,...) {...}"
            },
            {
              "focus-metavariable": "$ARG"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$UTIL.toFastProperties($SINK,...)"
                },
                {
                  "pattern": "toFastProperties($SINK,...)"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "$BB = require('bluebird');\n...\n"
                },
                {
                  "pattern-inside": "import 'bluebird';\n...\n"
                }
              ]
            },
            {
              "focus-metavariable": "$SINK"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.browser.security.dom-based-xss.dom-based-xss",
      "message": "This vulnerability arises when client-side JavaScript code uses values from the URL (like query parameters or hash fragments) to dynamically update page content without proper sanitization. Attackers can craft malicious URLs that, when visited, inject and execute JavaScript in the victim's browser context. Properly sanitize and validate all data extracted from URLs before inserting it into the DOM to prevent DOM-based cross-site scripting attacks.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/www-community/attacks/DOM_Based_XSS"
        ],
        "category": "security",
        "technology": [
          "browser"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "DOM-based XSS from insecurely handling URL parts in the DOM",
        "fix-suggestion": "Protect against DOM-based XSS by sanitizing all data from URLs before DOM insertion. Use `DOMPurify` to clean HTML content, and avoid directly inserting values from query parameters into `innerHTML`, `outerHTML`, or `document.write`. Instead, use `textContent` or `innerText` which treat content as plain text, or construct elements with DOM methods like `createElement` and `setAttribute`."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "pattern-either": [
        {
          "pattern": "document.write(<... document.location.$W ...>)"
        },
        {
          "pattern": "document.write(<... location.$W ...>)"
        }
      ]
    },
    {
      "id": "javascript.browser.security.eval-detected.eval-detected",
      "message": "Using the `eval()` function to execute dynamically generated code creates significant security risks. When executing content from external sources, attackers can inject and execute malicious code within your application's context. This can lead to cross-site scripting (XSS) attacks, data theft, or complete application compromise.",
      "metadata": {
        "cwe": [
          "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "asvs": {
          "section": "V5 Validation, Sanitization and Encoding",
          "control_id": "5.2.4 Dynamic Code Execution Features",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v52-sanitization-and-sandboxing",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "browser"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Eval function creates code injection vulnerability",
        "fix-suggestion": "Replace `eval()` with safer alternatives like `JSON.parse()` for data parsing or a template system for dynamic content generation. If dynamic code execution is necessary, consider using the Function constructor with carefully validated inputs. Implement content security policies with `script-src` directives to restrict script execution sources."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-not": "eval(\"...\")"
        },
        {
          "pattern": "eval(...)"
        }
      ]
    },
    {
      "id": "javascript.browser.security.insecure-document-method.insecure-document-method",
      "message": "This vulnerability happens when DOM manipulation methods like innerHTML, outerHTML, or document.write are used with user-controlled data. These methods interpret their input as HTML, allowing attackers to inject and execute malicious scripts when the content is rendered. Use safer alternatives like textContent (which treats all input as plain text) or DOM creation methods with explicit attribute setting to prevent unintended script execution.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "browser"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Using unsafe DOM methods with user data can lead to XSS",
        "fix-suggestion": "Address XSS vulnerabilities by replacing unsafe DOM methods (`innerHTML`, `outerHTML`, `document.write`) with safer alternatives. Use `textContent` or `innerText` for setting text content, or build elements safely with DOM methods like `createElement`, `appendChild`, and `setAttribute`. If HTML processing is necessary, sanitize input first with libraries like `DOMPurify` to remove malicious content."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$EL.innerHTML = $HTML;\n"
            },
            {
              "pattern": "$EL.outerHTML = $HTML;\n"
            },
            {
              "pattern": "document.write(...)"
            }
          ]
        },
        {
          "pattern-not": "$EL.innerHTML = \"...\";\n"
        },
        {
          "pattern-not": "$EL.outerHTML = \"...\";\n"
        },
        {
          "pattern-not": "document.write(\"...\")"
        }
      ]
    },
    {
      "id": "javascript.browser.security.insufficient-postmessage-origin-validation.insufficient-postmessage-origin-validation",
      "message": "The event listener for `message` events lacks origin validation, creating a cross-origin security vulnerability. Without verifying the sender's origin, any website can send messages to your application that will be processed as trusted. This could lead to data leakage or malicious code execution through cross-site scripting attacks.",
      "metadata": {
        "owasp": [
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "cwe": [
          "CWE-345: Insufficient Verification of Data Authenticity"
        ],
        "category": "security",
        "technology": [
          "browser"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "PostMessage lacks origin validation enabling XSS",
        "fix-suggestion": "Add origin validation by checking the `event.origin` property in your message event handler. Implement code like `if (event.origin !== 'https://trusted-domain.com') { return; }` at the beginning of the handler. Create a whitelist of trusted origins rather than blacklisting known bad sources for better security."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern": "window.addEventListener('message', $FUNC, ...)\n"
            },
            {
              "metavariable-pattern": {
                "patterns": [
                  {
                    "pattern": "function($OBJ) { ... }\n"
                  },
                  {
                    "pattern-not": "function($OBJ) { ... if (<... $OBJ.origin ...>) { ... } ... }\n"
                  }
                ],
                "metavariable": "$FUNC"
              }
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function $FNAME($OBJ) { $CONTEXT }\n...\n"
                },
                {
                  "pattern-inside": "$FNAME = (...) => { $CONTEXT }\n...\n"
                }
              ]
            },
            {
              "pattern": "window.addEventListener('message', $FNAME,...)\n"
            },
            {
              "metavariable-pattern": {
                "patterns": [
                  {
                    "pattern-not": "... if (<... $OBJ.origin ...>) { ... } ...\n"
                  }
                ],
                "metavariable": "$CONTEXT"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.browser.security.raw-html-concat.raw-html-concat",
      "message": "This vulnerability occurs when HTML strings are constructed by concatenating user input without proper escaping or sanitization. When inserted into the DOM, this raw HTML can contain malicious scripts that execute in the page context, enabling cross-site scripting attacks. Always apply context-appropriate encoding to user data before including it in HTML, or use templating libraries that automatically handle escaping.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/www-community/attacks/xss/"
        ],
        "category": "security",
        "technology": [
          "browser"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Concatenating user input directly into HTML string fosters XSS",
        "fix-suggestion": "Avoid string concatenation for HTML content creation to prevent XSS attacks. Use DOM methods like `createElement()`, `appendChild()`, and `setAttribute()` to safely build elements programmatically. For cases requiring HTML string processing, sanitize the content with `DOMPurify` before insertion, or use frameworks with built-in XSS protections like React or Vue."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "location.href"
                },
                {
                  "pattern": "location.hash"
                },
                {
                  "pattern": "location.search"
                },
                {
                  "pattern": "$WINDOW. ... .location.href"
                },
                {
                  "pattern": "$WINDOW. ... .location.hash"
                },
                {
                  "pattern": "$WINDOW. ... .location.search"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern": "$STRING + $EXPR"
                    },
                    {
                      "pattern-not": "$STRING + \"...\""
                    },
                    {
                      "metavariable-pattern": {
                        "patterns": [
                          {
                            "pattern": "<$TAG ..."
                          },
                          {
                            "pattern-not": "<$TAG ...>...</$TAG>..."
                          }
                        ],
                        "metavariable": "$STRING",
                        "language": "generic"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "$EXPR + $STRING"
                    },
                    {
                      "pattern-not": "\"...\" + $STRING"
                    },
                    {
                      "metavariable-pattern": {
                        "patterns": [
                          {
                            "pattern": "... </$TAG"
                          }
                        ],
                        "metavariable": "$STRING",
                        "language": "generic"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "[..., $STRING, ...].join(...)"
                    },
                    {
                      "metavariable-pattern": {
                        "patterns": [
                          {
                            "pattern": "<$TAG ..."
                          }
                        ],
                        "metavariable": "$STRING",
                        "language": "generic"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "[..., $STRING, ...].join(...)"
                    },
                    {
                      "metavariable-pattern": {
                        "patterns": [
                          {
                            "pattern": "... </$TAG"
                          }
                        ],
                        "metavariable": "$STRING",
                        "language": "generic"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "$VAR += $STRING"
                    },
                    {
                      "metavariable-pattern": {
                        "patterns": [
                          {
                            "pattern": "<$TAG ..."
                          }
                        ],
                        "metavariable": "$STRING",
                        "language": "generic"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "$VAR += $STRING"
                    },
                    {
                      "metavariable-pattern": {
                        "patterns": [
                          {
                            "pattern": "... </$TAG"
                          }
                        ],
                        "metavariable": "$STRING",
                        "language": "generic"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "import $S from \"underscore.string\"\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from \"underscore.string\"\n...\n"
                },
                {
                  "pattern-inside": "import $S from \"underscore.string\"\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"underscore.string\")\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$S.escapeHTML(...)"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "import $S from \"dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "import { ..., $S,... } from \"dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from \"dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"dompurify\")\n...\n"
                },
                {
                  "pattern-inside": "import $S from \"isomorphic-dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from \"isomorphic-dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"isomorphic-dompurify\")\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-inside": "$VALUE = $S(...)\n...\n"
                    },
                    {
                      "pattern": "$VALUE.sanitize(...)"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$VALUE = $S.sanitize\n...\n"
                    },
                    {
                      "pattern": "$S(...)"
                    }
                  ]
                },
                {
                  "pattern": "$S.sanitize(...)"
                },
                {
                  "pattern": "$S(...)"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "import $S from 'xss';\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from 'xss';\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"xss\")\n...\n"
                }
              ]
            },
            {
              "pattern": "$S(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "import $S from 'sanitize-html';\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from \"sanitize-html\";\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"sanitize-html\")\n...\n"
                }
              ]
            },
            {
              "pattern": "$S(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$S = new Remarkable()\n...\n"
                }
              ]
            },
            {
              "pattern": "$S.render(...)"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.browser.security.wildcard-postmessage-configuration.wildcard-postmessage-configuration",
      "message": "The `window.postMessage()` API is configured with a wildcard target origin ('*'), allowing any website to receive the sent messages. This creates a significant information disclosure risk because sensitive data could be intercepted by malicious websites. Cross-origin messaging should be restricted to specific, trusted domains.",
      "metadata": {
        "owasp": [
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "cwe": [
          "CWE-345: Insufficient Verification of Data Authenticity"
        ],
        "category": "security",
        "technology": [
          "browser"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "references": [
          "https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Wildcard in postMessage exposes data to any origin",
        "fix-suggestion": "Replace the wildcard (`*`) with specific target origins like `https://trusted-domain.com` in your `postMessage` calls. Use exact origin URLs rather than partial domain matching to prevent subdomain attacks. Implement additional message authentication if sending sensitive information across origins."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "pattern": "$OBJECT.postMessage(...,'*')"
    },
    {
      "id": "javascript.browser.security.open-redirect.js-open-redirect",
      "message": "User-controlled input is being used to set window location without validation, creating an open redirect vulnerability. Attackers can craft URLs that appear to be from your domain but redirect users to malicious websites. This enables phishing attacks and can be used to steal credentials or distribute malware.",
      "options": {
        "interfile": true
      },
      "metadata": {
        "interfile": true,
        "cwe": [
          "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "asvs": {
          "section": "V5 Validation, Sanitization and Encoding",
          "control_id": "5.5.1 Insecue Redirect",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v51-input-validation",
          "version": "4"
        },
        "category": "security",
        "confidence": "HIGH",
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html"
        ],
        "technology": [
          "browser"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Open Redirect"
        ],
        "short-description": "Unvalidated redirects enable phishing attacks",
        "fix-suggestion": "Implement strict validation of all redirect URLs before setting `window.location`. Create a whitelist of allowed destinations or verify that URLs are relative paths that stay within your domain. Use a URL parsing library to properly analyze the destination and reject URLs containing unexpected protocols like `javascript:` that could lead to XSS."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "new URLSearchParams($WINDOW. ... .location.search).get('...')\n"
                },
                {
                  "pattern": "new URLSearchParams(location.search).get('...')\n"
                },
                {
                  "pattern": "new URLSearchParams($WINDOW. ... .location.hash.substring(1)).get('...')\n"
                },
                {
                  "pattern": "new URLSearchParams(location.hash.substring(1)).get('...')\n"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$PROPS = new URLSearchParams($WINDOW. ... .location.search)\n...\n"
                },
                {
                  "pattern-inside": "$PROPS = new URLSearchParams(location.search)\n...\n"
                },
                {
                  "pattern-inside": "$PROPS = new URLSearchParams($WINDOW. ... .location.hash.substring(1))\n...\n"
                },
                {
                  "pattern-inside": "$PROPS = new URLSearchParams(location.hash.substring(1))\n...\n"
                }
              ]
            },
            {
              "pattern": "$PROPS.get('...')"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$PROPS = new URL($WINDOW. ... .location.href)\n...\n"
                },
                {
                  "pattern-inside": "$PROPS = new URL(location.href)\n...\n"
                }
              ]
            },
            {
              "pattern": "$PROPS.searchParams.get('...')"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "new URL($WINDOW. ... .location.href).searchParams.get('...')\n"
                },
                {
                  "pattern": "new URL(location.href).searchParams.get('...')\n"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "location.href = $SINK"
                },
                {
                  "pattern": "$THIS. ... .location.href = $SINK"
                },
                {
                  "pattern": "location.replace($SINK)"
                },
                {
                  "pattern": "$THIS. ... .location.replace($SINK)"
                },
                {
                  "pattern": "location = $SINK"
                },
                {
                  "pattern": "$WINDOW. ... .location = $SINK"
                }
              ]
            },
            {
              "focus-metavariable": "$SINK"
            },
            {
              "metavariable-pattern": {
                "patterns": [
                  {
                    "pattern-not": "\"...\" + $VALUE\n"
                  },
                  {
                    "pattern-not": "`...${$VALUE}`\n"
                  }
                ],
                "metavariable": "$SINK"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.chrome-remote-interface.security.audit.chrome-remote-interface-compilescript-injection.chrome-remote-interface-compilescript-injection",
      "message": "This vulnerability arises when user input is passed to the compileScript method in Chrome Remote Interface without proper validation. Attackers can inject malicious code that executes in the controlled browser context or exploits the connection to make unauthorized network requests. Carefully validate and restrict any user input that influences script compilation to prevent server-side request forgery or code execution vulnerabilities.",
      "metadata": {
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "category": "security",
        "technology": [
          "chrome-remote-interface"
        ],
        "references": [
          "https://github.com/cyrus-and/chrome-remote-interface"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "Untrusted input to compileScript can enable SSRF or code injection",
        "fix-suggestion": "Protect Chrome Remote Interface from script injection by implementing strict validation for any user input influencing script compilation. Create an allowlist of permitted patterns or templates with parameterized placeholders where user input can be safely inserted. Consider using prepared script templates where only specific values (not structural elements) can be provided by users."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-inside": "function ... (..., $ARG,...) {...}"
            },
            {
              "focus-metavariable": "$ARG"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "require('chrome-remote-interface');\n...\n"
                },
                {
                  "pattern-inside": "import 'chrome-remote-interface';\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$RUNTIME.compileScript({expression: $SINK},...)\n"
                },
                {
                  "pattern": "$RUNTIME.evaluate({expression: $SINK},...)\n"
                },
                {
                  "pattern": "$PAGE.navigate({url: $SINK},...)\n"
                },
                {
                  "pattern": "$RUNTIME.printToPDF({headerTemplate: $SINK},...)\n"
                },
                {
                  "pattern": "$RUNTIME.printToPDF({footerTemplate: $SINK},...)\n"
                },
                {
                  "pattern": "$PAGE.setDocumentContent({html: $SINK},...)\n"
                }
              ]
            },
            {
              "focus-metavariable": "$SINK"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.deno.security.audit.deno-dangerous-run.deno-dangerous-run",
      "message": "This vulnerability happens when Deno.run() executes commands constructed with user-supplied input without proper validation. Attackers can inject shell metacharacters or additional commands that execute with the permissions of the Deno process, potentially compromising the host system. Only use literal command strings with Deno.run() or implement strict validation of any dynamic parts to ensure they cannot alter the intended command structure.",
      "metadata": {
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "deno"
        ],
        "references": [
          "https://deno.land/manual/examples/subprocess#simple-example"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Deno.run with dynamic user input can cause command injection",
        "fix-suggestion": "Prevent command injection in Deno by avoiding dynamic user input in `Deno.run()` calls. Replace unsafe patterns like `Deno.run({ cmd: ['sh', '-c', userInput] })` with safer alternatives that use fixed commands and separate arguments: `Deno.run({ cmd: ['program', '--flag', userInput] })`. Implement strict input validation with an allowlist approach and run commands with minimal permissions using Deno's security flags."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-inside": "function ... (..., $ARG,...) {...}"
            },
            {
              "focus-metavariable": "$ARG"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "Deno.run({cmd: [$INPUT,...]},...)\n"
                },
                {
                  "pattern": "Deno.run({cmd: [\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",$INPUT,...]},...)\n"
                },
                {
                  "patterns": [
                    {
                      "pattern": "Deno.run({cmd: [$CMD,\"-c\",$INPUT,...]},...)\n"
                    },
                    {
                      "pattern-inside": "$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\"\n...\n"
                    }
                  ]
                }
              ]
            },
            {
              "focus-metavariable": "$INPUT"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.cors-misconfiguration.cors-misconfiguration",
      "message": "CORS parameters are being dynamically configured using user input, creating a security risk. This could lead to cross-origin resource sharing policies being bypassed, allowing malicious websites to access sensitive data from your application. Dynamic CORS configuration undermines the same-origin security model of browsers.",
      "metadata": {
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "cwe": [
          "CWE-346: Origin Validation Error"
        ],
        "category": "security",
        "references": [
          "https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS"
        ],
        "technology": [
          "express"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "User-controlled CORS settings bypass security boundaries",
        "fix-suggestion": "Replace dynamic CORS configuration with static, hardcoded values. Use a whitelist approach with `cors({ origin: ['https://trusted-domain.com', 'https://another-trusted.com'] })` instead of user-provided values. For more complex scenarios, implement a validation function that checks origins against a predefined allowlist."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$RES.set($HEADER, $X)"
                },
                {
                  "pattern": "$RES.header($HEADER, $X)"
                },
                {
                  "pattern": "$RES.setHeader($HEADER, $X)"
                },
                {
                  "pattern": "$RES.set({$HEADER: $X}, ...)\n"
                },
                {
                  "pattern": "$RES.writeHead($STATUS, {$HEADER: $X}, ...)\n"
                }
              ]
            },
            {
              "focus-metavariable": "$X"
            },
            {
              "metavariable-regex": {
                "metavariable": "$HEADER",
                "regex": ".*(Access-Control-Allow-Origin|access-control-allow-origin).*"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.express-data-exfiltration.express-data-exfiltration",
      "message": "User-controlled data is being passed to `Object.assign()`, potentially allowing mass assignment vulnerabilities. Attackers can manipulate request parameters to set or override sensitive properties of objects, leading to unauthorized access, data exposure, or security control bypasses.",
      "metadata": {
        "owasp": [
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "cwe": [
          "CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes"
        ],
        "references": [
          "https://en.wikipedia.org/wiki/Mass_assignment_vulnerability",
          "https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mass Assignment"
        ],
        "short-description": "Mass assignment vulnerability exposes sensitive data",
        "fix-suggestion": "Implement explicit property whitelisting instead of directly passing user input to `Object.assign()`. Create a sanitized object by manually copying only allowed properties like `const safeData = { allowedProp1: req.body.allowedProp1, allowedProp2: req.body.allowedProp2 }`. Consider using libraries that support schema validation and explicit property mapping."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "pattern": "Object.assign(...)"
        }
      ]
    },
    {
      "id": "javascript.express.security.express-expat-xxe.express-expat-xxe",
      "message": "This vulnerability occurs when the XML parser in an Express application processes user-supplied XML without disabling external entity resolution. Attackers can craft XML containing external entity references that, when processed, may lead to file disclosure, server-side request forgery, or denial of service. Ensure XML parsing libraries have external entity processing disabled and validate XML input before processing it to prevent XML External Entity (XXE) attacks.",
      "options": {
        "interfile": true
      },
      "metadata": {
        "interfile": true,
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "asvs": {
          "section": "V5 Validation, Sanitization and Encoding",
          "control_id": "5.5.2 Insecue XML Deserialization",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention",
          "version": "4"
        },
        "references": [
          "https://github.com/astro/node-expat"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "Unprotected expat parsing can cause XXE vulnerabilities",
        "fix-suggestion": "Protect against XXE attacks by configuring XML parsers to disable external entity processing. For node-expat or similar parsers, check for options to disable DTD processing or external entity resolution. If these options aren't available, switch to more secure alternatives like `xml2js` with the `explicitCharkey` option, or `libxmljs` with `LIBXML_NONET` to prevent network access during parsing."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$XML = require('node-expat')\n...\n"
                },
                {
                  "pattern-inside": "import $XML from 'node-expat'\n...\n"
                },
                {
                  "pattern-inside": "import * as $XML from 'node-expat'\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "$PARSER = new $XML.Parser(...);\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$PARSER.parse($QUERY)"
                },
                {
                  "pattern": "$PARSER.write($QUERY)"
                }
              ]
            },
            {
              "focus-metavariable": "$QUERY"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.express-insecure-template-usage.express-insecure-template-usage",
      "message": "User input is being compiled directly into templates, creating a Server-Side Template Injection (SSTI) vulnerability. Attackers can inject template syntax that may execute arbitrary code on the server with the application's privileges. This is a critical risk that could lead to complete system compromise.",
      "options": {
        "interfile": true
      },
      "metadata": {
        "interfile": true,
        "category": "security",
        "cwe": [
          "CWE-1336: Improper Neutralization of Special Elements Used in a Template Engine"
        ],
        "owasp": [
          "A03:2021 - Injection",
          "A01:2017 - Injection"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html"
        ],
        "technology": [
          "javascript",
          "typescript",
          "express",
          "pug",
          "jade",
          "dot",
          "ejs",
          "nunjucks",
          "lodash",
          "handlbars",
          "mustache",
          "hogan.js",
          "eta",
          "squirrelly"
        ],
        "source_rule_url": [
          "https://github.com/github/codeql/blob/2ba2642c7ab29b9eedef33bcc2b8cd1d203d0c10/javascript/ql/test/query-tests/Security/CWE-094/CodeInjection/template-sinks.js"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Template injection allows server-side code execution",
        "fix-suggestion": "Never compile templates with user input - instead pass user data as context to pre-compiled templates. Use template engine context like `res.render('template', { userProvided: req.body.userValue })` where the template is separate from the values. Implement input sanitization and consider using safer template engines that don't support code execution."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-propagators": [
        {
          "pattern": "$MODEL.$FIND($E).then((...,$S,...)=>{...})",
          "from": "$E",
          "to": "$S"
        }
      ],
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "$PUG = require('pug')\n...\n"
                    },
                    {
                      "pattern-inside": "import * as $PUG from 'pug'\n...\n"
                    },
                    {
                      "pattern-inside": "$PUG = require('jade')\n...\n"
                    },
                    {
                      "pattern-inside": "import * as $PUG from 'jade'\n...\n"
                    }
                  ]
                },
                {
                  "pattern-either": [
                    {
                      "pattern": "$PUG.compile(...)"
                    },
                    {
                      "pattern": "$PUG.compileClient(...)"
                    },
                    {
                      "pattern": "$PUG.compileClientWithDependenciesTracked(...)"
                    },
                    {
                      "pattern": "$PUG.render(...)"
                    }
                  ]
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "$PUG = require('dot')\n...\n"
                    },
                    {
                      "pattern-inside": "import * as $PUG from 'dot'\n...\n"
                    }
                  ]
                },
                {
                  "pattern-either": [
                    {
                      "pattern": "$PUG.template(...)"
                    },
                    {
                      "pattern": "$PUG.compile(...)"
                    }
                  ]
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "$PUG = require('ejs')\n...\n"
                    },
                    {
                      "pattern-inside": "import * as $PUG from 'ejs'\n...\n"
                    }
                  ]
                },
                {
                  "pattern-either": [
                    {
                      "pattern": "$PUG.render(...)"
                    }
                  ]
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "$PUG = require('nunjucks')\n...\n"
                    },
                    {
                      "pattern-inside": "import * as $PUG from 'nunjucks'\n...\n"
                    }
                  ]
                },
                {
                  "pattern-either": [
                    {
                      "pattern": "$PUG.renderString(...)"
                    }
                  ]
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "$PUG = require('lodash')\n...\n"
                    },
                    {
                      "pattern-inside": "import * as $PUG from 'lodash'\n...\n"
                    }
                  ]
                },
                {
                  "pattern-either": [
                    {
                      "pattern": "$PUG.template(...)"
                    }
                  ]
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "$PUG = require('mustache')\n...\n"
                    },
                    {
                      "pattern-inside": "import * as $PUG from 'mustache'\n...\n"
                    },
                    {
                      "pattern-inside": "$PUG = require('eta')\n...\n"
                    },
                    {
                      "pattern-inside": "import * as $PUG from 'eta'\n...\n"
                    },
                    {
                      "pattern-inside": "$PUG = require('squirrelly')\n...\n"
                    },
                    {
                      "pattern-inside": "import * as $PUG from 'squirrelly'\n...\n"
                    }
                  ]
                },
                {
                  "pattern-either": [
                    {
                      "pattern": "$PUG.render(...)"
                    }
                  ]
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "$PUG = require('hogan.js')\n...\n"
                    },
                    {
                      "pattern-inside": "import * as $PUG from 'hogan.js'\n...\n"
                    },
                    {
                      "pattern-inside": "$PUG = require('handlebars')\n...\n"
                    },
                    {
                      "pattern-inside": "import * as $PUG from 'handlebars'\n...\n"
                    }
                  ]
                },
                {
                  "pattern-either": [
                    {
                      "pattern": "$PUG.compile(...)"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.express-jwt-hardcoded-secret.express-jwt-hardcoded-secret",
      "message": "This vulnerability arises when JWT verification secrets are hardcoded directly in Express application source code. Attackers who gain access to the code can discover the secret and use it to forge valid JWT tokens, potentially bypassing authentication or authorization controls. Store JWT secrets in environment variables or secure credential management systems to prevent exposure in source code, configuration files, or version control systems.",
      "options": {
        "interfile": true
      },
      "metadata": {
        "interfile": true,
        "cwe": [
          "CWE-798: Use of Hard-coded Credentials"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html"
        ],
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "category": "security",
        "technology": [
          "express",
          "secrets"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Hard-coded Secrets"
        ],
        "short-description": "Hardcoded Express JWT secret can be easily compromised",
        "fix-suggestion": "Improve security by removing hardcoded JWT secrets from source code. Store secrets in environment variables with packages like `dotenv` and load them at runtime with `const secret = process.env.JWT_SECRET`. For production environments, use secure secrets management services like AWS Secrets Manager or HashiCorp Vault, and implement secret rotation policies."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "$JWT = require('express-jwt');\n...\n"
            },
            {
              "pattern-inside": "import $JWT from 'express-jwt';\n...\n"
            },
            {
              "pattern-inside": "import * as $JWT from 'express-jwt';\n...\n"
            },
            {
              "pattern-inside": "import { ..., $JWT, ... } from 'express-jwt';\n...\n"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern": "$JWT({...,secret: \"$Y\",...},...)\n"
            },
            {
              "pattern": "$OPTS = \"$Y\";\n...\n$JWT({...,secret: $OPTS},...);\n"
            }
          ]
        },
        {
          "focus-metavariable": "$Y"
        }
      ]
    },
    {
      "id": "javascript.express.security.express-phantom-injection.express-phantom-injection",
      "message": "This vulnerability happens when Express applications pass unsanitized user input to PhantomJS methods. Attackers can exploit this to execute arbitrary JavaScript in the PhantomJS context or make unauthorized network requests, potentially leading to server-side request forgery. Validate all user input before passing it to PhantomJS and avoid using user-controlled URLs or content in headless browser operations.",
      "metadata": {
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "references": [
          "https://phantomjs.org/page-automation.html"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "PhantomJS calls with user input can cause SSRF",
        "fix-suggestion": "Defend against PhantomJS injection by implementing strict validation for all user input used in PhantomJS operations. Validate URLs against an allowlist of permitted domains and patterns using only safe protocols (`http:`, `https:`). Use fixed templates with parameterized values rather than incorporating user input directly into script code."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "require('phantom');\n...\n"
                },
                {
                  "pattern-inside": "import 'phantom';\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$PAGE.open($SINK,...)"
                },
                {
                  "pattern": "$PAGE.setContent($SINK,...)"
                },
                {
                  "pattern": "$PAGE.openUrl($SINK,...)"
                },
                {
                  "pattern": "$PAGE.evaluateJavaScript($SINK,...)"
                },
                {
                  "pattern": "$PAGE.property(\"content\",$SINK,...)"
                }
              ]
            },
            {
              "focus-metavariable": "$SINK"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.express-puppeteer-injection.express-puppeteer-injection",
      "message": "This vulnerability occurs when user input directly influences Puppeteer operations in Express applications without proper validation. Attackers can provide malicious URLs or scripts that, when processed by Puppeteer, may access internal resources, exfiltrate data, or execute harmful code. Implement strict validation of any user data that influences browser automation operations to prevent server-side request forgery and code execution vulnerabilities.",
      "metadata": {
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "references": [
          "https://pptr.dev/api/puppeteer.page"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "Unvalidated data to Puppeteer in Express leads to SSRF",
        "fix-suggestion": "Prevent Puppeteer injection vulnerabilities by strictly validating all user inputs that influence Puppeteer operations. For URLs, implement an allowlist of permitted domains and patterns with only safe protocols, and when executing scripts in browser context, use prepared templates with parameterized values. Run Puppeteer with restricted permissions, using the `--no-sandbox` flag only when absolutely necessary."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "require('puppeteer');\n...\n"
                },
                {
                  "pattern-inside": "import 'puppeteer';\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$PAGE.goto($SINK,...)"
                },
                {
                  "pattern": "$PAGE.setContent($SINK,...)"
                },
                {
                  "pattern": "$PAGE.evaluate($SINK,...)"
                },
                {
                  "pattern": "$PAGE.evaluate($CODE,$SINK,...)"
                },
                {
                  "pattern": "$PAGE.evaluateHandle($SINK,...)"
                },
                {
                  "pattern": "$PAGE.evaluateHandle($CODE,$SINK,...)"
                },
                {
                  "pattern": "$PAGE.evaluateOnNewDocument($SINK,...)"
                },
                {
                  "pattern": "$PAGE.evaluateOnNewDocument($CODE,$SINK,...)"
                }
              ]
            },
            {
              "focus-metavariable": "$SINK"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.express-vm-injection.express-vm-injection",
      "message": "This vulnerability arises when Express applications pass user-controlled data to Node.js VM functions without proper safeguards. Attackers who can influence the code executed within the VM may exploit weaknesses to escape the sandbox and execute arbitrary code in the application context. Never use user input as source code for VM execution, as sandboxing cannot guarantee complete isolation from the host environment.",
      "metadata": {
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html"
        ],
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "vm usage in Express with untrusted data allows code injection",
        "fix-suggestion": "Eliminate VM-based code injection by avoiding Node.js VM functions with user-controlled input entirely. Consider safer alternatives like rule engines or expression evaluators that don't execute arbitrary code. If VM usage is necessary, create highly restricted sandboxes by removing access to sensitive globals and the `require` function, and pass user input as contextual data to fixed, trusted code."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-inside": "$VM = require('vm');\n...\n"
            },
            {
              "pattern-either": [
                {
                  "pattern": "$VM.runInContext(...)\n"
                },
                {
                  "pattern": "$VM.runInNewContext(...)\n"
                },
                {
                  "pattern": "$VM.compileFunction(...)\n"
                },
                {
                  "pattern": "$VM.runInThisContext(...)\n"
                },
                {
                  "pattern": "new $VM.Script(...)"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.express-vm2-injection.express-vm2-injection",
      "message": "This vulnerability happens when Express applications allow user input to reach vm2 functions that create JavaScript sandboxes. Despite vm2's improved sandbox compared to Node's VM module, various sandbox escape techniques may still allow attackers to execute code outside the intended environment. Avoid executing user-controlled code even in supposedly secure sandboxes, as sandbox escape vulnerabilities are regularly discovered in JavaScript isolation libraries.",
      "metadata": {
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html"
        ],
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "vm2 in Express with user input can run malicious code",
        "fix-suggestion": "Safeguard against vm2 sandbox escapes by avoiding execution of user-controlled code even in vm2 sandboxes. Implement domain-specific languages or expression evaluators that allow only safe operations instead. If vm2 is absolutely necessary, ensure you're using the latest version with all security patches and create highly restricted sandboxes with minimal access to objects and methods."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-inside": "require('vm2')\n...\n"
            },
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$VM = new VM(...)\n...\n"
                        },
                        {
                          "pattern-inside": "$VM = new NodeVM(...)\n...\n"
                        }
                      ]
                    },
                    {
                      "pattern": "$VM.run(...)\n"
                    }
                  ]
                },
                {
                  "pattern": "new VM(...).run(...)\n"
                },
                {
                  "pattern": "new NodeVM(...).run(...)\n"
                },
                {
                  "pattern": "new VMScript(...)\n"
                },
                {
                  "pattern": "new VM(...)\n"
                },
                {
                  "pattern": "new NodeVM(...)"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.express-xml2json-xxe.express-xml2json-xxe",
      "message": "This vulnerability occurs when express-xml2json processes user-supplied XML without disabling external entity processing. Attackers can craft XML containing malicious entity declarations that, when parsed, may lead to file disclosure, server-side request forgery, or denial of service. Configure XML parsers to disable DTD processing and external entity resolution, and validate XML input before conversion to prevent XXE attacks.",
      "metadata": {
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "asvs": {
          "section": "V5 Validation, Sanitization and Encoding",
          "control_id": "5.5.2 Insecue XML Deserialization",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "express"
        ],
        "references": [
          "https://www.npmjs.com/package/xml2json"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "User-supplied XML to xml2json leads to XXE risk",
        "fix-suggestion": "Prevent XXE attacks by configuring XML parsers to disable DTD processing and external entity resolution. With `xml2js`, set security options like `{ explicitCharkey: true, normalizeTags: false, explicitRoot: false, xmlnskey: '_xmlns' }`. Implement XML content validation to reject documents containing DOCTYPE declarations or entity declarations before parsing."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                },
                {
                  "pattern": "$REQ.files.$ANYTHING.data.toString('utf8')"
                },
                {
                  "pattern": "$REQ.files.$ANYTHING['data'].toString('utf8')"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                },
                {
                  "pattern": "files.$ANYTHING.data.toString('utf8')"
                },
                {
                  "pattern": "files.$ANYTHING['data'].toString('utf8')"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "require('xml2json');\n...\n"
                },
                {
                  "pattern-inside": "import 'xml2json';\n...\n"
                }
              ]
            },
            {
              "pattern": "$EXPAT.toJson($SINK,...)"
            },
            {
              "focus-metavariable": "$SINK"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.require-request.require-request",
      "message": "A dynamic `require()` call is accepting user-controlled input, creating a severe security vulnerability. Attackers can potentially load arbitrary modules or files from the server's filesystem, leading to information disclosure, denial of service, or remote code execution.",
      "options": {
        "interfile": true
      },
      "metadata": {
        "interfile": true,
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-706: Use of Incorrectly-Resolved Name or Reference"
        ],
        "source-rule-url": "https://nodesecroadmap.fyi/chapter-1/threat-UIR.html",
        "category": "security",
        "technology": [
          "express"
        ],
        "references": [
          "https://github.com/google/node-sec-roadmap/blob/master/chapter-2/dynamism.md#dynamism-when-you-need-it"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Dynamic require enables arbitrary module loading",
        "fix-suggestion": "Never use user input to determine what modules to load with `require()`. Replace dynamic requires with a mapping object like `const modules = { 'safe-module': require('safe-module') }` and then use `modules[validatedInput]`. Implement strict validation if dynamic loading is absolutely necessary, limiting to a predefined set of allowed modules."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "require($SINK)"
            },
            {
              "focus-metavariable": "$SINK"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.x-frame-options-misconfiguration.x-frame-options-misconfiguration",
      "message": "The `X-Frame-Options` header is being set with user-controlled input, which can undermine clickjacking protections. Attackers could manipulate this header to enable framing of your site by malicious websites, potentially leading to UI redressing attacks where users unknowingly interact with your application.",
      "metadata": {
        "references": [
          "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options"
        ],
        "owasp": [
          "A04:2021 - Insecure Design"
        ],
        "cwe": [
          "CWE-451: User Interface (UI) Misrepresentation of Critical Information"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "User-controlled framing settings enable clickjacking",
        "fix-suggestion": "Set the `X-Frame-Options` header with static values only, such as `res.setHeader('X-Frame-Options', 'DENY')` or `SAMEORIGIN`. Never accept user input for security header values. Consider using Content-Security-Policy with `frame-ancestors` directives for more flexible and powerful framing controls."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$RES.set($HEADER, ...)"
                },
                {
                  "pattern": "$RES.header($HEADER, ...)"
                },
                {
                  "pattern": "$RES.setHeader($HEADER, ...)"
                },
                {
                  "pattern": "$RES.set({$HEADER: ...}, ...)\n"
                },
                {
                  "pattern": "$RES.writeHead($STATUS, {$HEADER: ...}, ...)\n"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$HEADER",
                "regex": ".*(X-Frame-Options|x-frame-options).*"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.express-check-csurf-middleware-usage.express-check-csurf-middleware-usage",
      "message": "This vulnerability arises when Express applications lack CSRF protection middleware, leaving them susceptible to cross-site request forgery attacks. Attackers can create malicious websites that make unauthorized state-changing requests to the vulnerable application using the victim's authenticated session. Implement CSRF protection using libraries like csurf that validate tokens for state-changing requests, ensuring they originate from legitimate application forms.",
      "metadata": {
        "category": "security",
        "references": [
          "https://www.npmjs.com/package/csurf",
          "https://www.npmjs.com/package/csrf",
          "https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html"
        ],
        "cwe": [
          "CWE-352: Cross-Site Request Forgery (CSRF)"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "technology": [
          "javascript",
          "typescript",
          "express"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site Request Forgery (CSRF)"
        ],
        "short-description": "No CSRF middleware found, exposing Express app to cross-site forgery",
        "fix-suggestion": "Protect your Express application from CSRF attacks by implementing the `csurf` middleware. Configure it with `const csrf = require('csurf'); const cookieParser = require('cookie-parser'); app.use(cookieParser()); app.use(csrf({ cookie: true }))`. Include the CSRF token in your forms with `<input type=\"hidden\" name=\"_csrf\" value=\"{{csrfToken}}\">` and provide it to templates using `res.render('form', { csrfToken: req.csrfToken() })`."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "INFO",
      "patterns": [
        {
          "pattern-inside": "$EXPRESS = require('express')\n...\n"
        },
        {
          "pattern-not-inside": "import {$CSRF} from 'csurf'\n...\n"
        },
        {
          "pattern-not-inside": "require('csurf')\n...\n"
        },
        {
          "pattern-not-inside": "import {$CSRF} from 'csrf'\n...\n"
        },
        {
          "pattern-not-inside": "require('csrf')\n...\n"
        },
        {
          "pattern": "$APP = $EXPRESS()\n"
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.express-check-directory-listing.express-check-directory-listing",
      "message": "Directory listing is enabled in this Express application, which could expose sensitive files and directories to attackers. When directory listings are enabled, attackers can discover hidden files, backup files, configuration files, and other resources that were not intended to be publicly accessible.",
      "options": {
        "interfile": true
      },
      "metadata": {
        "interfile": true,
        "cwe": [
          "CWE-548: Exposure of Information Through Directory Listing"
        ],
        "owasp": [
          "A06:2017 - Security Misconfiguration",
          "A01:2021 - Broken Access Control"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "references": [
          "https://www.npmjs.com/package/serve-index",
          "https://www.acunetix.com/blog/articles/directory-listing-information-disclosure/"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Directory listing exposes sensitive application files",
        "fix-suggestion": "Disable directory listing by setting `{ dotfiles: 'deny', index: false }` in your Express static file serving configuration. Use specific routes to serve intended public resources rather than exposing entire directories. Implement proper authentication for any sensitive file access endpoints."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$APP.use(require('serve-index')(...))\n"
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "$SERVEINDEX = require('serve-index')\n...\n"
                    },
                    {
                      "pattern-inside": "import $SERVEINDEX from 'serve-index'\n...\n"
                    },
                    {
                      "pattern-inside": "import * as $SERVEINDEX from 'serve-index'\n...\n"
                    }
                  ]
                },
                {
                  "pattern-either": [
                    {
                      "patterns": [
                        {
                          "pattern-inside": "$VALUE = $SERVEINDEX(...)\n...\n"
                        },
                        {
                          "pattern": "$VALUE(...)\n"
                        }
                      ]
                    },
                    {
                      "pattern": "$APP.use(..., $SERVEINDEX(...), ...)\n"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.express-detect-notevil-usage.express-detect-notevil-usage",
      "message": "The application is using the `notevil` package, which is unmaintained and contains security vulnerabilities. This package attempts to provide sandboxed JavaScript evaluation but fails to properly contain malicious code execution in numerous edge cases. Any kind of `eval` functionality is inherently dangerous.",
      "metadata": {
        "category": "security",
        "references": [
          "https://github.com/mmckegg/notevil"
        ],
        "cwe": [
          "CWE-1104: Use of Unmaintained Third Party Components"
        ],
        "owasp": [
          "A06:2021 - Vulnerable and Outdated Components"
        ],
        "technology": [
          "javascript",
          "typescript"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Vulnerable notevil package enables sandbox escape",
        "fix-suggestion": "Remove the `notevil` package from your application entirely. If sandboxed evaluation is needed, consider using the maintained `vm2` package with appropriate security configuration. For data parsing, use `JSON.parse()` or other safer alternatives that don't execute code."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "import $EVAL from 'notevil'\n...\n"
            },
            {
              "pattern-inside": "import {$EVAL} from 'notevil'\n...\n"
            },
            {
              "pattern-inside": "$EVAL = require('notevil')\n...\n"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern": "$EVAL(...)"
                },
                {
                  "pattern-not": "$EVAL('...')"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "$VM.runInContext(\"$CMD\", ...)"
                    },
                    {
                      "pattern": "$VM.runInNewContext(\"$CMD\", ...)"
                    },
                    {
                      "pattern": "$VM.runInThisContext(\"$CMD\", ...)"
                    },
                    {
                      "pattern": "$VM.compileFunction(\"$CMD\", ...)"
                    }
                  ]
                },
                {
                  "metavariable-pattern": {
                    "patterns": [
                      {
                        "pattern": "$EVAL(...)"
                      },
                      {
                        "pattern-not": "$EVAL('...')"
                      }
                    ],
                    "metavariable": "$CMD",
                    "language": "typescript"
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.express-jwt-not-revoked.express-jwt-not-revoked",
      "message": "No token revocation mechanism is configured for `express-jwt`. If a token is compromised, there's no way to invalidate it before its expiration time. This creates a security vulnerability where leaked or stolen tokens remain valid and could be used by attackers to access your application.",
      "metadata": {
        "cwe": [
          "CWE-522: Insufficiently Protected Credentials"
        ],
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A04:2021 - Insecure Design"
        ],
        "source-rule-url": "https://github.com/goldbergyoni/nodebestpractices/blob/master/sections/security/expirejwt.md",
        "asvs": {
          "section": "V3: Session Management Verification Requirements",
          "control_id": "3.5.3 Insecue Stateless Session Tokens",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Missing JWT revocation allows use of compromised tokens",
        "fix-suggestion": "Configure `express-jwt` with an `isRevoked` function that checks tokens against a blocklist or database. Implement a revocation endpoint like `/logout` that adds tokens to this blocklist. Consider using shorter token expiration times with refresh tokens to limit the window of vulnerability for leaked tokens."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "$JWT = require('express-jwt');\n...\n"
        },
        {
          "pattern": "$JWT(...)"
        },
        {
          "pattern-not-inside": "$JWT(<... {isRevoked:...} ...>,...)"
        },
        {
          "pattern-not-inside": "$OPTS = <... {isRevoked:...} ...>;\n...\n$JWT($OPTS,...);"
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.express-libxml-noent.express-libxml-noent",
      "message": "This vulnerability happens when libxml is used in Express applications with the 'noent' option enabled, allowing external entity processing. Attackers can exploit this by submitting XML with malicious entity references that, when processed, may access local files or make network requests. Disable the 'noent' option when parsing XML from untrusted sources to prevent XML External Entity (XXE) attacks.",
      "options": {
        "interfile": true
      },
      "metadata": {
        "interfile": true,
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html"
        ],
        "technology": [
          "express"
        ],
        "category": "security",
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "HIGH",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "libxml with 'noent' enabled can allow XXE attacks",
        "fix-suggestion": "Mitigate XXE vulnerabilities by disabling external entity processing in libxml. Modify XML parsing configuration from `const xmlDoc = libxmljs.parseXml(xmlData, { noent: true })` to `const xmlDoc = libxmljs.parseXml(xmlData, { noent: false })`. Implement input validation to reject XML documents containing DOCTYPE declarations before parsing."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                },
                {
                  "pattern": "$REQ.files.$ANYTHING.data.toString('utf8')"
                },
                {
                  "pattern": "$REQ.files.$ANYTHING['data'].toString('utf8')"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                },
                {
                  "pattern": "files.$ANYTHING.data.toString('utf8')"
                },
                {
                  "pattern": "files.$ANYTHING['data'].toString('utf8')"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "$XML = require('$IMPORT')\n...\n"
                    },
                    {
                      "pattern-inside": "import $XML from '$IMPORT'\n  ...\n"
                    },
                    {
                      "pattern-inside": "import * as $XML from '$IMPORT'\n...\n"
                    }
                  ]
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$IMPORT",
                    "regex": "^(libxmljs|libxmljs2)$"
                  }
                },
                {
                  "pattern-inside": "$XML.$FUNC($QUERY, {...,noent:true,...})"
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$FUNC",
                    "regex": "^(parseXmlString|parseXml)$"
                  }
                },
                {
                  "focus-metavariable": "$QUERY"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.express-libxml-vm-noent.express-libxml-vm-noent",
      "message": "This vulnerability occurs when parseXml() is used with 'noent: true' in Express applications, enabling XML external entity processing. This configuration allows attackers to submit XML containing malicious entity declarations that may lead to information disclosure or server-side request forgery. Disable entity processing by setting 'noent: false' when parsing XML from untrusted sources to prevent XXE vulnerabilities.",
      "metadata": {
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html"
        ],
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "parseXml with noent allows XXE vulnerabilities",
        "fix-suggestion": "Prevent XXE attacks by ensuring the `noent` option is set to false when using parseXml(): `const result = parseXml(xmlData, { noent: false })`. Add validation to reject XML containing DOCTYPE declarations before parsing. Consider alternative data formats like JSON when possible."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "$VM.runInContext(\"$CMD\", ...)"
                    },
                    {
                      "pattern": "$VM.runInNewContext(\"$CMD\", ...)"
                    },
                    {
                      "pattern": "$VM.runInThisContext(\"$CMD\", ...)"
                    },
                    {
                      "pattern": "$VM.compileFunction(\"$CMD\", ...)"
                    }
                  ]
                },
                {
                  "metavariable-pattern": {
                    "metavariable": "$CMD",
                    "language": "typescript",
                    "pattern-either": [
                      {
                        "pattern": "$LIBXML.parseXml($DATA, {..., noent: true, ...}, ...)\n"
                      },
                      {
                        "patterns": [
                          {
                            "pattern-inside": "$OPTS = {..., noent: true, ...}\n...\n"
                          },
                          {
                            "pattern": "$LIBXML.parseXml( $DATA, $OPTS )"
                          }
                        ]
                      }
                    ]
                  }
                }
              ]
            },
            {
              "pattern": "$LIBXML.parseXml($DATA, {..., noent: true, ...}, ...)\n"
            },
            {
              "patterns": [
                {
                  "pattern-inside": "$OPTS = {..., noent: true, ...}\n...\n"
                },
                {
                  "pattern": "$LIBXML.parseXml( $DATA, $OPTS )"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.express-open-redirect.express-open-redirect",
      "message": "User-supplied input is used directly in a redirect without validation, creating an open redirect vulnerability. Attackers can craft malicious URLs that redirect users from your legitimate site to phishing sites that appear trustworthy because they originate from your domain. This facilitates credential theft and other social engineering attacks.",
      "metadata": {
        "technology": [
          "express"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html"
        ],
        "cwe": [
          "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')"
        ],
        "category": "security",
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Open Redirect"
        ],
        "short-description": "Unvalidated redirects enable phishing attacks",
        "fix-suggestion": "Implement strict validation of all redirect URLs before calling `res.redirect()`. Use a whitelist approach by either accepting only relative paths or verifying that absolute URLs point to trusted domains. Consider displaying a warning page for external redirects to alert users they're leaving your site."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "options": {
        "taint_unify_mvars": true,
        "symbolic_propagation": true
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$RES.redirect(\"$HTTP\"+$REQ. ... .$VALUE)"
                },
                {
                  "pattern": "$RES.redirect(\"$HTTP\"+$REQ. ... .$VALUE + $...A)"
                },
                {
                  "pattern": "$RES.redirect(`$HTTP${$REQ. ... .$VALUE}...`)"
                },
                {
                  "pattern": "$RES.redirect(\"$HTTP\"+$REQ.$VALUE[...])"
                },
                {
                  "pattern": "$RES.redirect(\"$HTTP\"+$REQ.$VALUE[...] + $...A)"
                },
                {
                  "pattern": "$RES.redirect(`$HTTP${$REQ.$VALUE[...]}...`)"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$HTTP",
                "regex": "^https?:\\/\\/$"
              }
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ. ... .$VALUE"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$RES.redirect($REQ. ... .$VALUE)"
                },
                {
                  "pattern": "$RES.redirect($REQ. ... .$VALUE + $...A)"
                },
                {
                  "pattern": "$RES.redirect(`${$REQ. ... .$VALUE}...`)"
                }
              ]
            },
            {
              "pattern": "$REQ. ... .$VALUE"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$RES.redirect($REQ.$VALUE['...'])"
                },
                {
                  "pattern": "$RES.redirect($REQ.$VALUE['...'] + $...A)"
                },
                {
                  "pattern": "$RES.redirect(`${$REQ.$VALUE['...']}...`)"
                }
              ]
            },
            {
              "pattern": "$REQ.$VALUE"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$ASSIGN = $REQ. ... .$VALUE\n...\n"
                },
                {
                  "pattern-inside": "$ASSIGN = $REQ.$VALUE['...']\n...\n"
                },
                {
                  "pattern-inside": "$ASSIGN = $REQ. ... .$VALUE + $...A\n...\n"
                },
                {
                  "pattern-inside": "$ASSIGN = $REQ.$VALUE['...'] + $...A\n...     \n"
                },
                {
                  "pattern-inside": "$ASSIGN = `${$REQ. ... .$VALUE}...`\n...\n"
                },
                {
                  "pattern-inside": "$ASSIGN = `${$REQ.$VALUE['...']}...`\n...                    \n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$RES.redirect($ASSIGN)"
                },
                {
                  "pattern": "$RES.redirect($ASSIGN + $...FOO)"
                },
                {
                  "pattern": "$RES.redirect(`${$ASSIGN}...`)"
                }
              ]
            },
            {
              "focus-metavariable": "$ASSIGN"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.express-path-join-resolve-traversal.express-path-join-resolve-traversal",
      "message": "This vulnerability arises when path.join or path.resolve functions in Express applications are used with unsanitized user input. Attackers can provide input containing path traversal sequences (like '../') that navigate outside the intended directory structure, potentially accessing sensitive files. Validate file paths, use path.normalize to resolve traversal attempts, and verify the final resolved path is within allowed directories before file operations.",
      "metadata": {
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
        ],
        "category": "security",
        "references": [
          "https://owasp.org/www-community/attacks/Path_Traversal"
        ],
        "technology": [
          "express",
          "node.js"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "short-description": "Path.join/resolve with user input can enable directory traversal",
        "fix-suggestion": "Prevent path traversal by sanitizing file paths before using `path.join` or `path.resolve` with user input. Implement sanitization with `const sanitizedName = sanitize(userInput)` and validate the resolved path remains within allowed boundaries: `const fullPath = path.resolve(filePath); if (!fullPath.startsWith(path.resolve(baseDir))) { return res.status(403).send('Access denied'); }`. Consider using dedicated libraries like 'express-sanitizer' or implementing an allowlist of permitted filenames."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$SINK"
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "$PATH = require('path');\n...\n"
                },
                {
                  "pattern-inside": "import $PATH from 'path';\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$PATH.join(...,$SINK,...)"
                },
                {
                  "pattern": "$PATH.resolve(...,$SINK,...)"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "focus-metavariable": "$SINK"
            },
            {
              "pattern-inside": "import 'path';\n...\n"
            },
            {
              "pattern-either": [
                {
                  "pattern": "path.join(...,$SINK,...)"
                },
                {
                  "pattern": "path.resolve(...,$SINK,...)"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "pattern": "$Y.replace(...)"
        },
        {
          "pattern": "$Y.indexOf(...)"
        },
        {
          "pattern": "function ... (...) {\n    ...\n    <... $Y.indexOf(...) ...>\n    ...\n}\n"
        },
        {
          "patterns": [
            {
              "pattern": "$FUNC(...)"
            },
            {
              "metavariable-regex": {
                "metavariable": "$FUNC",
                "regex": "sanitize"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.express-res-sendfile.express-res-sendfile",
      "message": "User input is directly passed to `res.sendFile()` without proper validation, creating a path traversal vulnerability. Attackers could manipulate the input to access files outside the intended directory, potentially exposing sensitive system files, application code, or configuration files containing secrets.",
      "metadata": {
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html"
        ],
        "technology": [
          "express"
        ],
        "category": "security",
        "cwe": [
          "CWE-73: External Control of File Name or Path"
        ],
        "owasp": [
          "A04:2021 - Insecure Design"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "short-description": "Path traversal in sendFile exposes server files",
        "fix-suggestion": "Sanitize file paths by using `path.normalize()` and validating that the resulting path is within an allowed directory. Use `path.join(safeBaseDir, path.basename(userInput))` to extract just the filename portion of user input. Implement additional authorization checks to ensure users have permission to access the requested files."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "function ... (...,$REQ: $TYPE, ...) {...}\n"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$TYPE",
                        "regex": "^(string|String)"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$RES.$METH($QUERY,...)"
                }
              ]
            },
            {
              "pattern-not-inside": "$RES.$METH($QUERY,$OPTIONS)"
            },
            {
              "metavariable-regex": {
                "metavariable": "$METH",
                "regex": "^(sendfile|sendFile)$"
              }
            },
            {
              "focus-metavariable": "$QUERY"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.express-session-hardcoded-secret.express-session-hardcoded-secret",
      "message": "This vulnerability happens when the secret used to sign session cookies in Express applications is hardcoded in source code. Attackers who gain access to the code can discover the secret and use it to forge valid session cookies, potentially hijacking user sessions. Store session secrets in environment variables or secure configuration management systems to prevent exposure through source code or version control.",
      "options": {
        "interfile": true
      },
      "metadata": {
        "interfile": true,
        "cwe": [
          "CWE-798: Use of Hard-coded Credentials"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html"
        ],
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "category": "security",
        "technology": [
          "express",
          "secrets"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "HIGH",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Hard-coded Secrets"
        ],
        "short-description": "Hardcoded Express session secret is insecure",
        "fix-suggestion": "Remove hardcoded session secrets and load them from environment variables instead. Implement with `require('dotenv').config()` and configure express-session as `app.use(session({ secret: process.env.SESSION_SECRET, resave: false, saveUninitialized: true, cookie: { secure: true } }))`. For production, use secure secrets management services like AWS Secrets Manager or HashiCorp Vault."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "$SESSION = require('express-session');\n...\n"
            },
            {
              "pattern-inside": "import $SESSION from 'express-session'\n...\n"
            },
            {
              "pattern-inside": "import {..., $SESSION, ...} from 'express-session'\n...\n"
            },
            {
              "pattern-inside": "import * as $SESSION from 'express-session'\n...\n"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$APP.use($SESSION({...}))"
                },
                {
                  "pattern": "$SECRET = $VALUE\n...\n$APP.use($SESSION($SECRET))\n"
                }
              ]
            },
            {
              "pattern": "secret: '$Y'\n"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.express-ssrf.express-ssrf",
      "message": "This vulnerability occurs when user input is used to determine the base URL for HTTP requests made by Express applications. Attackers can manipulate this input to direct requests to internal network services or malicious external servers, potentially exposing sensitive information. Validate URLs against an allowlist of permitted domains and IP ranges, and avoid letting users control the hostname or IP address used in server-side requests.",
      "metadata": {
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html"
        ],
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "technology": [
          "express"
        ],
        "category": "security",
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "Building base URL from user data can cause SSRF",
        "fix-suggestion": "Defend against SSRF by implementing URL validation against an allowlist of permitted domains. Create a validation function like `function isUrlAllowed(urlString) { try { const parsedUrl = new URL(urlString); return allowedDomains.includes(parsedUrl.hostname); } catch (e) { return false; } }`. Avoid using IP addresses directly and consider proxying requests through a dedicated service that enforces security policies."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "options": {
        "taint_unify_mvars": true
      },
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, ...) {...}"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,...) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: $EXPRESS.Request,...) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$REQUEST = require('request')\n...\n"
                },
                {
                  "pattern-inside": "import * as $REQUEST from 'request'\n...\n"
                },
                {
                  "pattern-inside": "import $REQUEST from 'request'\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQUEST.$METHOD(\"$HTTP\"+$REQ. ... .$VALUE)"
                },
                {
                  "pattern": "$REQUEST.$METHOD(\"$HTTP\"+$REQ. ... .$VALUE + $...A)"
                },
                {
                  "pattern": "$REQUEST.$METHOD(`$HTTP${$REQ. ... .$VALUE}...`)"
                },
                {
                  "pattern": "$REQUEST.$METHOD(\"$HTTP\"+$REQ.$VALUE[...])"
                },
                {
                  "pattern": "$REQUEST.$METHOD(\"$HTTP\"+$REQ.$VALUE[...] + $...A)"
                },
                {
                  "pattern": "$REQUEST.$METHOD(`$HTTP${$REQ.$VALUE[...]}...`)"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$METHOD",
                "regex": "^(get|post|put|patch|del|head|delete)$"
              }
            },
            {
              "metavariable-regex": {
                "metavariable": "$HTTP",
                "regex": "^(https?:\\/\\/|//)$"
              }
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ. ... .$VALUE"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$REQUEST = require('request')\n...\n"
                },
                {
                  "pattern-inside": "import * as $REQUEST from 'request'\n...\n"
                },
                {
                  "pattern-inside": "import $REQUEST from 'request'\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQUEST.$METHOD($REQ. ... .$VALUE,...)"
                },
                {
                  "pattern": "$REQUEST.$METHOD($REQ. ... .$VALUE + $...A,...)"
                },
                {
                  "pattern": "$REQUEST.$METHOD(`${$REQ. ... .$VALUE}...`,...)"
                }
              ]
            },
            {
              "pattern": "$REQ. ... .$VALUE"
            },
            {
              "metavariable-regex": {
                "metavariable": "$METHOD",
                "regex": "^(get|post|put|patch|del|head|delete)$"
              }
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$REQUEST = require('request')\n...\n"
                },
                {
                  "pattern-inside": "import * as $REQUEST from 'request'\n...\n"
                },
                {
                  "pattern-inside": "import $REQUEST from 'request'\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQUEST.$METHOD($REQ.$VALUE['...'],...)"
                },
                {
                  "pattern": "$REQUEST.$METHOD($REQ.$VALUE['...'] + $...A,...)"
                },
                {
                  "pattern": "$REQUEST.$METHOD(`${$REQ.$VALUE['...']}...`,...)"
                }
              ]
            },
            {
              "pattern": "$REQ.$VALUE"
            },
            {
              "metavariable-regex": {
                "metavariable": "$METHOD",
                "regex": "^(get|post|put|patch|del|head|delete)$"
              }
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$REQUEST = require('request')\n...\n"
                },
                {
                  "pattern-inside": "import * as $REQUEST from 'request'\n...\n"
                },
                {
                  "pattern-inside": "import $REQUEST from 'request'\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "$ASSIGN = $REQ. ... .$VALUE\n...\n"
                },
                {
                  "pattern-inside": "$ASSIGN = $REQ. ... .$VALUE['...']\n...\n"
                },
                {
                  "pattern-inside": "$ASSIGN = $REQ. ... .$VALUE + $...A\n...\n"
                },
                {
                  "pattern-inside": "$ASSIGN = $REQ. ... .$VALUE['...'] + $...A\n...     \n"
                },
                {
                  "pattern-inside": "$ASSIGN = `${$REQ. ... .$VALUE}...`\n...\n"
                },
                {
                  "pattern-inside": "$ASSIGN = `${$REQ. ... .$VALUE['...']}...`\n... \n"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$ASSIGN = \"$HTTP\"+ $REQ. ... .$VALUE\n...\n"
                        },
                        {
                          "pattern-inside": "$ASSIGN = \"$HTTP\"+$REQ. ... .$VALUE + $...A\n...\n"
                        },
                        {
                          "pattern-inside": "$ASSIGN = \"$HTTP\"+$REQ.$VALUE[...]\n...\n"
                        },
                        {
                          "pattern-inside": "$ASSIGN = \"$HTTP\"+$REQ.$VALUE[...] + $...A\n...\n"
                        },
                        {
                          "pattern-inside": "$ASSIGN = `$HTTP${$REQ.$VALUE[...]}...`\n...\n"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$HTTP",
                        "regex": "^(https?:\\/\\/|//)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQUEST.$METHOD($ASSIGN,...)"
                },
                {
                  "pattern": "$REQUEST.$METHOD($ASSIGN + $...FOO,...)"
                },
                {
                  "pattern": "$REQUEST.$METHOD(`${$ASSIGN}...`,...)"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "$REQUEST.$METHOD(\"$HTTP\"+$ASSIGN,...)"
                        },
                        {
                          "pattern": "$REQUEST.$METHOD(\"$HTTP\"+$ASSIGN + $...A,...)"
                        },
                        {
                          "pattern": "$REQUEST.$METHOD(`$HTTP${$ASSIGN}...`,...)"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$HTTP",
                        "regex": "^(https?:\\/\\/|//)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern": "$ASSIGN"
            },
            {
              "metavariable-regex": {
                "metavariable": "$METHOD",
                "regex": "^(get|post|put|patch|del|head|delete)$"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.express-third-party-object-deserialization.express-third-party-object-deserialization",
      "message": "This vulnerability arises when Express applications deserialize objects from untrusted sources using libraries that allow code execution during deserialization. Attackers can craft malicious serialized data that, when deserialized, exploits library behaviors to execute arbitrary code. Use safe alternatives like JSON.parse() that don't support code execution during deserialization, or implement strict type validation if more complex deserialization is necessary.",
      "options": {
        "interfile": true
      },
      "metadata": {
        "interfile": true,
        "technology": [
          "express"
        ],
        "category": "security",
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html"
        ],
        "source_rule_url": [
          "https://github.com/ajinabraham/njsscan/blob/75bfbeb9c8d72999e4d527dfa2548f7f0f3cc48a/njsscan/rules/semantic_grep/eval/eval_deserialize.yaml"
        ],
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "HIGH",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "Unsafe object deserialization in Express can allow RCE",
        "fix-suggestion": "Prevent deserialization vulnerabilities by replacing unsafe libraries with safer alternatives like `JSON.parse()` or structured formats like Protocol Buffers. If complex deserialization is needed, implement strict validation with frameworks like Joi: `const schema = joi.object({ id: joi.number().required(), name: joi.string().max(100) }); const { error, value } = schema.validate(req.body);`. Apply the principle of least privilege by only deserializing the minimum required properties."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                },
                {
                  "pattern": "$REQ.files.$ANYTHING.data.toString('utf8')"
                },
                {
                  "pattern": "$REQ.files.$ANYTHING['data'].toString('utf8')"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                },
                {
                  "pattern": "files.$ANYTHING.data.toString('utf8')"
                },
                {
                  "pattern": "files.$ANYTHING['data'].toString('utf8')"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "$SER = require('$IMPORT')\n...\n"
                    },
                    {
                      "pattern-inside": "import $SER from '$IMPORT'\n ...\n"
                    },
                    {
                      "pattern-inside": "import * as $SER from '$IMPORT'\n...\n"
                    }
                  ]
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$IMPORT",
                    "regex": "^(node-serialize|serialize-to-js)$"
                  }
                },
                {
                  "pattern": "$SER.$FUNC(...)"
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$FUNC",
                    "regex": "^(unserialize|deserialize)$"
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.express-xml2json-xxe-event.express-xml2json-xxe-event",
      "message": "This vulnerability happens when user-supplied XML is parsed during request event handling in Express applications without disabling external entity processing. Attackers can submit XML with malicious entity declarations that may access local files or make network requests when resolved. Configure XML parsers to disable DTD processing and external entity resolution, especially when parsing XML from untrusted sources during request handling.",
      "metadata": {
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "references": [
          "https://www.npmjs.com/package/xml2json"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "XML2JSON parsing untrusted data leads to XXE exploitation",
        "fix-suggestion": "Prevent XXE attacks by configuring XML parsers with secure options that disable DTD processing. Use `const parser = new xml2js.Parser({ explicitCharkey: true, normalizeTags: false, explicitRoot: false, xmlnskey: '_xmlns', allowDoctypeDecl: false, noent: false })`. Add pre-parsing validation with `function hasDtd(xmlString) { return /<!DOCTYPE|<!ENTITY/i.test(xmlString); }` to reject potentially dangerous XML before processing."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) => {...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "require('xml2json');\n...\n"
                },
                {
                  "pattern-inside": "import 'xml2json';\n...\n"
                }
              ]
            },
            {
              "pattern": "$REQ.on('...', function(...) { ... $EXPAT.toJson($INPUT,...); ... })"
            },
            {
              "focus-metavariable": "$INPUT"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.remote-property-injection.remote-property-injection",
      "message": "User-controlled input is used with bracket notation to access object properties, creating a prototype pollution vulnerability. Attackers can use this to access or modify any property of the object, including those on its prototype chain. This can lead to security bypass, denial of service, or even remote code execution.",
      "metadata": {
        "confidence": "LOW",
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A04:2021 - Insecure Design"
        ],
        "cwe": [
          "CWE-522: Insufficiently Protected Credentials"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "references": [
          "https://github.com/nodesecurity/eslint-plugin-security/blob/3c7522ca1be800353513282867a1034c795d9eb4/docs/the-dangers-of-square-bracket-notation.md"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Bracket notation enables prototype pollution attacks",
        "fix-suggestion": "Use a whitelist approach by explicitly defining which properties can be accessed from user input. Replace dynamic property access like `obj[userInput]` with a validation check like `if (ALLOWED_PROPS.includes(userInput)) { return obj[userInput]; }`. Consider using Object.create(null) for objects that will handle user input to avoid prototype chain issues."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-inside": "$OBJ[...] = ..."
            },
            {
              "pattern-not-inside": "$OBJ[\"...\"] = ..."
            },
            {
              "pattern-not-inside": "$OBJ[...] = \"...\""
            },
            {
              "pattern": "$INDEX"
            },
            {
              "pattern-not": "\"...\" + $INDEX\n"
            },
            {
              "pattern-not": "$INDEX + \"...\"\n"
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern": "var $X = ..."
            },
            {
              "pattern-not": "var $X = $REQ.$ANY"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.res-render-injection.res-render-injection",
      "message": "User-controlled data determines which template is rendered by Express, creating a path traversal vulnerability. Attackers could manipulate this input to access templates outside the intended directory or even load and execute server-side code files. This can lead to information disclosure or remote code execution.",
      "options": {
        "interfile": true
      },
      "metadata": {
        "interfile": true,
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-706: Use of Incorrectly-Resolved Name or Reference"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "references": [
          "http://expressjs.com/en/4x/api.html#res.render"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Template path injection enables unauthorized access",
        "fix-suggestion": "Never use direct user input to specify which template to render. Create a mapping of allowed template identifiers to actual template paths like `const templates = { 'profile': 'users/profile' }` and then use `res.render(templates[validatedInput])`. Implement strict validation if dynamic template selection is necessary."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$RES.render($SINK, ...)"
                }
              ]
            },
            {
              "focus-metavariable": "$SINK"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.express-cookie-settings.express-cookie-session-default-name",
      "message": "The application is using the default session cookie name, which makes it easier for attackers to fingerprint your server technology. This information can help attackers target known vulnerabilities in your server stack. Using custom cookie names improves security through obscurity and complicates automated attacks.",
      "severity": "WARNING",
      "languages": [
        "javascript",
        "typescript"
      ],
      "metadata": {
        "cwe": [
          "CWE-522: Insufficiently Protected Credentials"
        ],
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A04:2021 - Insecure Design"
        ],
        "source-rule-url": "https://expressjs.com/en/advanced/best-practice-security.html",
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "LOW",
        "confidence": "MEDIUM",
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Default cookie name reveals server technology",
        "fix-suggestion": "Set a custom name for your session cookie by configuring the `name` option in your session middleware like `app.use(session({ name: 'custom_session_name', ... }))`. Choose names that don't reveal the underlying technology. Update any client-side code that depends on the default cookie name."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "$SESSION = require('cookie-session');\n...\n"
            },
            {
              "pattern-inside": "$SESSION = require('express-session');\n...\n"
            }
          ]
        },
        {
          "pattern": "$SESSION(...)"
        },
        {
          "pattern-not-inside": "$SESSION(<... {name:...} ...>,...)"
        },
        {
          "pattern-not-inside": "$OPTS = <... {name:...} ...>;\n...\n$SESSION($OPTS,...);\n"
        },
        {
          "pattern-not-inside": "$OPTS = ...;\n...\n$OPTS.name = ...;\n...\n$SESSION($OPTS,...);\n"
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.express-cookie-settings.express-cookie-session-no-domain",
      "message": "The session cookie doesn't have a domain attribute set, which affects its security scope. Without a specified domain, browsers may apply inconsistent rules about which subdomains can access the cookie. This could lead to unexpected cookie sharing or isolation between related services.",
      "severity": "WARNING",
      "languages": [
        "javascript",
        "typescript"
      ],
      "metadata": {
        "cwe": [
          "CWE-522: Insufficiently Protected Credentials"
        ],
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A04:2021 - Insecure Design"
        ],
        "source-rule-url": "https://expressjs.com/en/advanced/best-practice-security.html",
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "LOW",
        "confidence": "MEDIUM",
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Missing domain setting causes cookie scope issues",
        "fix-suggestion": "Set the `domain` attribute in your cookie configuration with `app.use(session({ cookie: { domain: '.yourdomain.com' } }))`. Use a dot prefix for subdomain inclusion or specify exact domains for stricter control. Consider your application's architecture to determine the appropriate domain scope for your session cookies."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "$SESSION = require('cookie-session');\n...\n"
            },
            {
              "pattern-inside": "$SESSION = require('express-session');\n...\n"
            }
          ]
        },
        {
          "pattern": "$SESSION(...)"
        },
        {
          "pattern-not-inside": "$SESSION(<... {cookie:{domain:...}} ...>,...)"
        },
        {
          "pattern-not-inside": "$OPTS = <... {cookie:{domain:...}} ...>;\n...\n$SESSION($OPTS,...);\n"
        },
        {
          "pattern-not-inside": "$OPTS = ...;\n...\n$COOKIE = <... {domain:...} ...>;\n...\n$SESSION($OPTS,...);\n"
        },
        {
          "pattern-not-inside": "$OPTS = ...;\n...\n$OPTS.cookie = <... {domain:...} ...>;\n...\n$SESSION($OPTS,...);\n"
        },
        {
          "pattern-not-inside": "$OPTS = ...;\n...\n$COOKIE.domain = ...;\n...\n$SESSION($OPTS,...);\n"
        },
        {
          "pattern-not-inside": "$OPTS = ...;\n...\n$OPTS.cookie.domain = ...;\n...\n$SESSION($OPTS,...);\n"
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.express-cookie-settings.express-cookie-session-no-expires",
      "message": "Session cookies don't have an expiration date set, creating persistent sessions that rely solely on browser behavior for termination. Without explicit expiration, cookies may persist longer than intended in some browsers, extending the window of vulnerability if session tokens are compromised.",
      "severity": "WARNING",
      "languages": [
        "javascript",
        "typescript"
      ],
      "metadata": {
        "cwe": [
          "CWE-522: Insufficiently Protected Credentials"
        ],
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A04:2021 - Insecure Design"
        ],
        "source-rule-url": "https://expressjs.com/en/advanced/best-practice-security.html",
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "LOW",
        "confidence": "MEDIUM",
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Missing cookie expiration extends session vulnerability",
        "fix-suggestion": "Set an explicit expiration time for your cookies with `app.use(session({ cookie: { expires: new Date(Date.now() + 86400000) } }))` or use the `maxAge` option with a value in milliseconds. Balance security (shorter sessions) with user experience (fewer logins) based on your application's sensitivity."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "$SESSION = require('cookie-session');\n...\n"
            },
            {
              "pattern-inside": "$SESSION = require('express-session');\n...\n"
            }
          ]
        },
        {
          "pattern": "$SESSION(...)"
        },
        {
          "pattern-not-inside": "$SESSION(<... {cookie:{expires:...}} ...>,...)"
        },
        {
          "pattern-not-inside": "$OPTS = <... {cookie:{expires:...}} ...>;\n...\n$SESSION($OPTS,...);\n"
        },
        {
          "pattern-not-inside": "$OPTS = ...;\n...\n$COOKIE = <... {expires:...} ...>;\n...\n$SESSION($OPTS,...);\n"
        },
        {
          "pattern-not-inside": "$OPTS = ...;\n...\n$OPTS.cookie = <... {expires:...} ...>;\n...\n$SESSION($OPTS,...);\n"
        },
        {
          "pattern-not-inside": "$OPTS = ...;\n...\n$COOKIE.expires = ...;\n...\n$SESSION($OPTS,...);\n"
        },
        {
          "pattern-not-inside": "$OPTS = ...;\n...\n$OPTS.cookie.expires = ...;\n...\n$SESSION($OPTS,...);"
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.express-cookie-settings.express-cookie-session-no-httponly",
      "message": "Session cookies don't have the HttpOnly flag set, allowing client-side JavaScript to access them. If an attacker can execute JavaScript in the browser (via XSS), they could steal session cookies and impersonate users. The HttpOnly flag is a critical defense-in-depth measure to protect session tokens.",
      "severity": "WARNING",
      "languages": [
        "javascript",
        "typescript"
      ],
      "metadata": {
        "cwe": [
          "CWE-522: Insufficiently Protected Credentials"
        ],
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A04:2021 - Insecure Design"
        ],
        "source-rule-url": "https://expressjs.com/en/advanced/best-practice-security.html",
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "LOW",
        "confidence": "MEDIUM",
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Missing HttpOnly flag allows JavaScript cookie access",
        "fix-suggestion": "Set the HttpOnly flag on your session cookies by configuring `app.use(session({ cookie: { httpOnly: true } }))`. This prevents client-side JavaScript from accessing cookie values, mitigating XSS cookie theft. Ensure this setting is applied to all authentication and session-related cookies."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "$SESSION = require('cookie-session');\n...\n"
            },
            {
              "pattern-inside": "$SESSION = require('express-session');\n...\n"
            }
          ]
        },
        {
          "pattern": "$SESSION(...)"
        },
        {
          "pattern-not-inside": "$SESSION(<... {cookie:{httpOnly:true}} ...>,...)"
        },
        {
          "pattern-not-inside": "$OPTS = <... {cookie:{httpOnly:true}} ...>;\n...\n$SESSION($OPTS,...);\n"
        },
        {
          "pattern-not-inside": "$OPTS = ...;\n...\n$COOKIE = <... {httpOnly:true} ...>;\n...\n$SESSION($OPTS,...);\n"
        },
        {
          "pattern-not-inside": "$OPTS = ...;\n...\n$OPTS.cookie = <... {httpOnly:true} ...>;\n...\n$SESSION($OPTS,...);\n"
        },
        {
          "pattern-not-inside": "$OPTS = ...;\n...\n$COOKIE.httpOnly = true;\n...\n$SESSION($OPTS,...);\n"
        },
        {
          "pattern-not-inside": "$OPTS = ...;\n...\n$OPTS.cookie.httpOnly = true;\n...\n$SESSION($OPTS,...);\n"
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.express-cookie-settings.express-cookie-session-no-path",
      "message": "Session cookies don't have a path attribute set, which affects their availability across different URL paths. Without a specified path, the cookie may be accessible from unexpected areas of the application or might not be available where needed, causing inconsistent session behavior.",
      "severity": "WARNING",
      "languages": [
        "javascript",
        "typescript"
      ],
      "metadata": {
        "cwe": [
          "CWE-522: Insufficiently Protected Credentials"
        ],
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A04:2021 - Insecure Design"
        ],
        "source-rule-url": "https://expressjs.com/en/advanced/best-practice-security.html",
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "LOW",
        "confidence": "MEDIUM",
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Missing cookie path affects session availability",
        "fix-suggestion": "Set the `path` attribute in your cookie configuration with `app.use(session({ cookie: { path: '/' } }))`. Use the root path (`/`) for application-wide sessions or more specific paths to limit cookie scope. Ensure the path covers all routes that need session access."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "$SESSION = require('cookie-session');\n...\n"
            },
            {
              "pattern-inside": "$SESSION = require('express-session');\n...\n"
            }
          ]
        },
        {
          "pattern": "$SESSION(...)"
        },
        {
          "pattern-not-inside": "$SESSION(<... {cookie:{path:...}} ...>,...)"
        },
        {
          "pattern-not-inside": "$OPTS = <... {cookie:{path:...}} ...>;\n...\n$SESSION($OPTS,...);\n"
        },
        {
          "pattern-not-inside": "$OPTS = ...;\n...\n$COOKIE = <... {path:...} ...>;\n...\n$SESSION($OPTS,...);\n"
        },
        {
          "pattern-not-inside": "$OPTS = ...;\n...\n$OPTS.cookie = <... {path:...} ...>;\n...\n$SESSION($OPTS,...);\n"
        },
        {
          "pattern-not-inside": "$OPTS = ...;\n...\n$COOKIE.path = ...;\n...\n$SESSION($OPTS,...);\n"
        },
        {
          "pattern-not-inside": "$OPTS = ...;\n...\n$OPTS.cookie.path = ...;\n...\n$SESSION($OPTS,...);\n"
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.express-cookie-settings.express-cookie-session-no-secure",
      "message": "Session cookies don't have the Secure flag set, allowing them to be transmitted over unencrypted HTTP connections. This exposes session tokens to network eavesdropping attacks, where attackers on the same network can capture cookies and use them to hijack user sessions.",
      "severity": "WARNING",
      "languages": [
        "javascript",
        "typescript"
      ],
      "metadata": {
        "cwe": [
          "CWE-522: Insufficiently Protected Credentials"
        ],
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A04:2021 - Insecure Design"
        ],
        "source-rule-url": "https://expressjs.com/en/advanced/best-practice-security.html",
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "LOW",
        "confidence": "MEDIUM",
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Missing Secure flag exposes cookies on HTTP",
        "fix-suggestion": "Set the Secure flag on your session cookies by configuring `app.use(session({ cookie: { secure: true } }))`. This ensures cookies are only sent over HTTPS connections. If your site serves both HTTP and HTTPS, consider redirecting all traffic to HTTPS before enabling this setting."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "$SESSION = require('cookie-session');\n...\n"
            },
            {
              "pattern-inside": "$SESSION = require('express-session');\n...\n"
            }
          ]
        },
        {
          "pattern": "$SESSION(...)"
        },
        {
          "pattern-not-inside": "$SESSION(<... {cookie:{secure:true}} ...>,...)"
        },
        {
          "pattern-not-inside": "$OPTS = <... {cookie:{secure:true}} ...>;\n...\n$SESSION($OPTS,...);\n"
        },
        {
          "pattern-not-inside": "$OPTS = ...;\n...\n$COOKIE = <... {secure:true} ...>;\n...\n$SESSION($OPTS,...);\n"
        },
        {
          "pattern-not-inside": "$OPTS = ...;\n...\n$OPTS.cookie = <... {secure:true} ...>;\n...\n$SESSION($OPTS,...);\n"
        },
        {
          "pattern-not-inside": "$OPTS = ...;\n...\n$COOKIE.secure = true;\n...\n$SESSION($OPTS,...);\n"
        },
        {
          "pattern-not-inside": "$OPTS = ...;\n...\n$OPTS.cookie.secure = true;\n...\n$SESSION($OPTS,...);\n"
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.xss.direct-response-write.direct-response-write",
      "message": "This vulnerability occurs when Express applications write user input directly to response streams without proper HTML escaping. When the response is rendered in the browser, any injected scripts will execute in the user's context, potentially stealing sensitive data or performing unauthorized actions. Use template engines that automatically apply context-appropriate escaping or manually encode user data before including it in responses to prevent cross-site scripting attacks.",
      "options": {
        "interfile": true
      },
      "metadata": {
        "interfile": true,
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "short-description": "Directly writing user data to response can trigger XSS",
        "fix-suggestion": "Stop XSS vulnerabilities by using template engines with automatic HTML escaping instead of direct response writing. Replace unsafe practices like `res.send(`<h1>Hello, ${req.params.id}</h1>`)` with `res.render('user', { id: req.params.id })`. For HTML content, use sanitization libraries: `const cleanHtml = DOMPurify.sanitize(content); res.send(cleanHtml)`."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-not-inside": "function ... ($REQ, $RES) {\n    ...\n    $RES.$SET('Content-Type', '$TYPE')\n}\n"
            },
            {
              "pattern-not-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {\n    ...\n    $RES.$SET('Content-Type', '$TYPE')\n})\n"
            },
            {
              "pattern-not-inside": "function ... ($REQ, $RES, $NEXT) {\n    ...\n    $RES.$SET('Content-Type', '$TYPE')\n}\n"
            },
            {
              "pattern-not-inside": "function ... ($REQ, $RES) {\n    ...\n    $RES.set('$TYPE')\n}\n"
            },
            {
              "pattern-not-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {\n    ...\n    $RES.set('$TYPE')\n})\n"
            },
            {
              "pattern-not-inside": "function ... ($REQ, $RES, $NEXT) {\n    ...\n    $RES.set('$TYPE')\n}\n"
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "pattern-not-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{\n    ...\n    $RES.$SET('Content-Type', '$TYPE')\n}\n"
            },
            {
              "pattern-not-inside": "({ $REQ }: Request,$RES: Response) => {\n    ...\n    $RES.$SET('Content-Type', '$TYPE')\n}\n"
            },
            {
              "pattern-not-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{\n    ...\n    $RES.set('$TYPE')\n}\n"
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "body"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-inside": "function ... (..., $RES,...) {...}"
            },
            {
              "pattern-either": [
                {
                  "pattern": "$RES.write($ARG)"
                },
                {
                  "pattern": "$RES.send($ARG)"
                }
              ]
            },
            {
              "pattern-not": "$RES. ... .set('...'). ... .send($ARG)"
            },
            {
              "pattern-not": "$RES. ... .type('...'). ... .send($ARG)"
            },
            {
              "pattern-not-inside": "$RES.$METHOD({ ... })"
            },
            {
              "focus-metavariable": "$ARG"
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "import $S from \"underscore.string\"\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from \"underscore.string\"\n...\n"
                },
                {
                  "pattern-inside": "import $S from \"underscore.string\"\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"underscore.string\")\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$S.escapeHTML(...)"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "import $S from \"dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "import { ..., $S,... } from \"dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from \"dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"dompurify\")\n...\n"
                },
                {
                  "pattern-inside": "import $S from \"isomorphic-dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from \"isomorphic-dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"isomorphic-dompurify\")\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-inside": "$VALUE = $S(...)\n...\n"
                    },
                    {
                      "pattern": "$VALUE.sanitize(...)"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$VALUE = $S.sanitize\n...\n"
                    },
                    {
                      "pattern": "$S(...)"
                    }
                  ]
                },
                {
                  "pattern": "$S.sanitize(...)"
                },
                {
                  "pattern": "$S(...)"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "import $S from 'xss';\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from 'xss';\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"xss\")\n...\n"
                }
              ]
            },
            {
              "pattern": "$S(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "import $S from 'sanitize-html';\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from \"sanitize-html\";\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"sanitize-html\")\n...\n"
                }
              ]
            },
            {
              "pattern": "$S(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$S = new Remarkable()\n...\n"
                }
              ]
            },
            {
              "pattern": "$S.render(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "import $S from 'express-xss-sanitizer';\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from \"express-xss-sanitizer\";\n...\n"
                },
                {
                  "pattern-inside": "const { ..., $S, ... } = require('express-xss-sanitizer');\n...\n"
                },
                {
                  "pattern-inside": "var { ..., $S, ... } = require('express-xss-sanitizer');\n...\n"
                },
                {
                  "pattern-inside": "let { ...,$S,... } = require('express-xss-sanitizer');\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"express-xss-sanitizer\")\n...\n"
                }
              ]
            },
            {
              "pattern": "$S(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern": "$RES. ... .type('$F'). ... .send(...)"
            },
            {
              "metavariable-regex": {
                "metavariable": "$F",
                "regex": "(?!.*text/html)"
              }
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$X = [...];\n...\n"
            },
            {
              "pattern": "if(<... !$X.includes($SOURCE)...>) {\n    ...\n    return ...\n}\n...\n"
            },
            {
              "pattern": "$SOURCE"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.xss.ejs.var-in-script-src.var-in-script-src",
      "message": "This vulnerability arises when variables are used in script source attributes within EJS templates without proper validation. Attackers who can control these variables could inject malicious JavaScript file URLs or inline script code using javascript: protocol handlers. Validate all URLs used in script src attributes against an allowlist of trusted sources and ensure they use only safe protocols before including them in templates.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://www.veracode.com/blog/secure-development/nodejs-template-engines-why-default-encoders-are-not-enough",
          "https://github.com/ESAPI/owasp-esapi-js"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Unescaped variable in script src can load malicious code",
        "fix-suggestion": "Secure script source attributes by implementing URL validation against an allowlist of trusted domains. Create a validator function: `function isValidScriptSrc(url) { const allowedDomains = ['cdn.example.com']; try { const parsedUrl = new URL(url); return allowedDomains.includes(parsedUrl.hostname); } catch (e) { return false; } }`. Only use validated URLs in templates and consider implementing Subresource Integrity: `<script src=\"<%= scriptSrc %>\" integrity=\"<%= scriptIntegrity %>\" crossorigin=\"anonymous\"></script>`."
      },
      "languages": [
        "generic"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "<script ...>"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "src = '...'"
            },
            {
              "pattern-inside": "src = \"...\""
            }
          ]
        },
        {
          "pattern": "<% ... >"
        }
      ],
      "paths": {
        "include": [
          "*.ejs",
          "*.html"
        ]
      }
    },
    {
      "id": "javascript.express.security.audit.xss.ejs.var-in-script-tag.var-in-script-tag",
      "message": "This vulnerability happens when EJS templates directly embed variables inside script tags without proper encoding or validation. Even with HTML escaping, attackers who control these variables can inject JavaScript that executes in the page context, potentially compromising user data or session integrity. Consider storing data in separate JSON structures outside script tags or applying JavaScript-specific encoding to prevent script injection within these contexts.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://www.veracode.com/blog/secure-development/nodejs-template-engines-why-default-encoders-are-not-enough",
          "https://github.com/ESAPI/owasp-esapi-js"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Placing user data in script body can produce XSS",
        "fix-suggestion": "Prevent XSS when embedding variables in script tags by using `JSON.stringify()` to properly escape JavaScript data: `const username = <%- JSON.stringify(username) %>`. Separate data from code by storing values in JSON structures: `const appData = <%- JSON.stringify({ username: username, userId: userId }) %>`. Consider using HTML data attributes and accessing them via JavaScript instead of embedding directly in scripts."
      },
      "languages": [
        "generic"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "<script ...> ... </script>"
        },
        {
          "pattern-not-inside": "<script ... $ATTR = \"...\" ...>"
        },
        {
          "pattern-not-inside": "<script ... $ATTR = '...' ...>"
        },
        {
          "pattern": "<% ... >"
        }
      ],
      "paths": {
        "include": [
          "*.ejs",
          "*.html"
        ]
      }
    },
    {
      "id": "javascript.express.security.audit.xss.ejs.explicit-unescape.template-explicit-unescape",
      "message": "This vulnerability occurs when EJS templates use unescaped output (<%- ... %>) with user-controlled data. This directive bypasses EJS's automatic HTML escaping, allowing any HTML or JavaScript in the variable to be rendered and executed in the browser. Always use escaped output (<%= ... %>) for user-supplied content, or ensure thorough sanitization before using the unescaped directive to prevent cross-site scripting attacks.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "http://www.managerjs.com/blog/2015/05/will-ejs-escape-save-me-from-xss-sorta/"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Explicit unescape (<%- ... %>) in EJS can cause XSS",
        "fix-suggestion": "Avoid XSS vulnerabilities by not using unescaped output syntax (`<%- ... %>`) with user-controlled data. Use escaped output instead: `<%= userContent %>`. If HTML rendering is necessary, sanitize content first: `const sanitizedContent = DOMPurify.sanitize(userContent, { ALLOWED_TAGS: ['b', 'i', 'p'] }); res.render('page', { content: sanitizedContent })`."
      },
      "languages": [
        "regex"
      ],
      "severity": "WARNING",
      "paths": {
        "include": [
          "*.ejs",
          "*.html"
        ]
      },
      "pattern-regex": "<%-((?!include).)*?%>",
      "fix-regex": {
        "regex": "<%-(.*?)%>",
        "replacement": "<%=\\1%>"
      }
    },
    {
      "id": "javascript.express.security.audit.xss.mustache.escape-function-overwrite.escape-function-overwrite",
      "message": "This vulnerability arises when the default Mustache escape function is overwritten with a custom implementation that may not provide adequate protection. Overriding the built-in escaping mechanism can create inconsistent or incomplete protection against various XSS attack vectors. Retain the original escaping mechanism or ensure any custom implementation comprehensively handles all HTML escaping requirements to maintain proper XSS protection.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://github.com/janl/mustache.js/#variables"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Overwriting Mustache escape function disables built-in XSS protection",
        "fix-suggestion": "Avoid overriding `Mustache.escape` with custom implementations as it disables built-in XSS protection. Instead, create separate sanitization functions like `customSanitize(text)` that call `Mustache.escape(text)` and apply additional transformations. For HTML rendering needs, use helper functions in your view model that leverage sanitization libraries like `DOMPurify.sanitize()`."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "Mustache.escape = ..."
        },
        {
          "patterns": [
            {
              "pattern-inside": "$MUSTACHE = require(\"mustache\");\n...\n"
            },
            {
              "pattern": "$MUSTACHE.escape = ..."
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.xss.mustache.explicit-unescape.template-explicit-unescape",
      "message": "This vulnerability happens when Mustache templates use unescaped tags (like triple braces {{{...}}} or & operator) with user-supplied content. These syntax elements bypass Mustache's automatic HTML escaping, allowing any markup or scripts to be rendered and executed when the page loads. Only use unescaped tags with trusted, static content or after applying comprehensive sanitization to prevent cross-site scripting vulnerabilities.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://github.com/janl/mustache.js/#variables",
          "https://ractive.js.org/v0.x/0.7/mustaches#variables"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Triple-brace or & in Mustache can let malicious HTML through",
        "fix-suggestion": "Replace unescaped Mustache tags (`{{{...}}}` or `{{& ...}}`) with standard escaped tags (`{{...}}`) when working with user input. When HTML rendering is required, sanitize content first using `DOMPurify.sanitize()` with restrictive options for allowed tags and attributes. Consider implementing helper functions in view models that sanitize content before rendering with `safeHtml` methods."
      },
      "languages": [
        "regex"
      ],
      "severity": "WARNING",
      "paths": {
        "include": [
          "*.mustache",
          "*.hbs",
          "*.html"
        ]
      },
      "pattern-either": [
        {
          "pattern-regex": "{{{((?!include).)*?}}}"
        },
        {
          "pattern-regex": "{{[\\\\s]*&.*}}"
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.xss.pug.var-in-href.var-in-href",
      "message": "This vulnerability occurs when Pug templates use variables in anchor tag href attributes without validating the URL structure. Attackers can inject javascript: URLs that execute arbitrary code when the link is clicked or, in some cases, when the page loads. Validate all URLs used in href attributes to ensure they use safe protocols (like https:) and not dangerous ones (like javascript:) before including them in templates.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://github.com/pugjs/pug/issues/2952",
          "https://flask.palletsprojects.com/en/1.1.x/security/#cross-site-scripting-xss#:~:text=javascript:%20URI"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "User data in Pug href can cause JavaScript injection",
        "fix-suggestion": "Establish URL validation for dynamic values used in href attributes within Pug templates. Create an `isUrlSafe()` function that checks URLs against safe protocols (`http:`, `https:`, `mailto:`, `tel:`) and rejects any that could execute JavaScript. Use URL parsing libraries to validate both protocol and domain against a whitelist before insertion into href attributes."
      },
      "languages": [
        "regex"
      ],
      "severity": "WARNING",
      "paths": {
        "include": [
          "*.pug"
        ]
      },
      "pattern-regex": "a\\(.*href=[^'\"].*\\)"
    },
    {
      "id": "javascript.express.security.audit.xss.pug.var-in-script-tag.var-in-script-tag",
      "message": "This vulnerability arises when variables are placed directly inside script tags in Pug templates without proper JavaScript encoding. Even with HTML escaping, attackers can inject JavaScript syntax that breaks out of string contexts or executes when parsed by the browser's JavaScript engine. Store data in separate JSON structures or apply JavaScript-specific encoding to prevent script injection when dynamic data must be included within script tags.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://www.veracode.com/blog/secure-development/nodejs-template-engines-why-default-encoders-are-not-enough",
          "https://github.com/ESAPI/owasp-esapi-js"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Variables inside script tags in Pug risk XSS",
        "fix-suggestion": "Never embed user input directly in script tags; instead use `JSON.stringify()` to serialize data and assign it to variables outside script content. Store dynamic data in HTML `data-*` attributes and access it through DOM APIs when needed. Implement Content Security Policy (`CSP`) with strict `script-src` directives as an additional defense layer."
      },
      "languages": [
        "regex"
      ],
      "severity": "WARNING",
      "paths": {
        "include": [
          "*.pug"
        ]
      },
      "pattern-either": [
        {
          "pattern-regex": "script\\s*=[A-Za-z0-9]+"
        },
        {
          "pattern-regex": "script\\s*=.*[\"']\\s*\\+.*"
        },
        {
          "pattern-regex": "script\\s*=[^'\"]+\\+.*"
        },
        {
          "pattern-regex": "script\\(.*?\\)\\s*=\\s*[A-Za-z0-9]+"
        },
        {
          "pattern-regex": "script\\(.*?\\)\\s*=\\s*.*[\"']\\s*\\+.*"
        },
        {
          "pattern-regex": "script\\(.*?\\)\\s*=\\s*[^'\"]+\\+.*"
        }
      ]
    },
    {
      "id": "javascript.express.security.audit.xss.pug.and-attributes.template-and-attributes",
      "message": "This vulnerability happens when Pug templates use the &attributes syntax with user-controlled objects that define element attributes. This feature passes attribute values without proper escaping, allowing attackers to inject malicious event handlers or other dangerous attributes that execute JavaScript. Thoroughly validate any objects used with &attributes to ensure they contain only safe attributes with properly sanitized values.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://pugjs.org/language/attributes.html#attributes"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "&attributes in Pug with user data can allow XSS",
        "fix-suggestion": "When using Pug's `&attributes` syntax, sanitize dynamic attribute objects to remove dangerous HTML properties like event handlers (`onclick`, `onload`). Create a sanitization function that filters attributes through a whitelist, permitting only safe attributes like `class` and `id`. Validate attribute values, especially for properties like `href` that might contain malicious URLs."
      },
      "languages": [
        "regex"
      ],
      "severity": "WARNING",
      "paths": {
        "include": [
          "*.pug"
        ]
      },
      "pattern-regex": ".*&attributes.*"
    },
    {
      "id": "javascript.express.security.audit.xss.pug.explicit-unescape.template-explicit-unescape",
      "message": "This vulnerability occurs when Pug templates use unescaped syntax (like != or !{...}) with user-supplied content. These operators bypass Pug's automatic HTML escaping, allowing any markup or scripts to be rendered and executed in the browser context. Only use unescaped operators with trusted content or after applying thorough sanitization to prevent cross-site scripting attacks.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://pugjs.org/language/code.html#unescaped-buffered-code",
          "https://pugjs.org/language/attributes.html#unescaped-attributes"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Unescaped interpolation (!=) in Pug can yield XSS",
        "fix-suggestion": "Eliminate unescaped syntax (`!=` or `!{...}`) in Pug templates when handling user input. If HTML rendering is necessary, sanitize content first with libraries like `DOMPurify` or `sanitize-html` before unescaped output. For most cases, use standard interpolation syntax (`=` or `#{...}`) which automatically applies HTML escaping."
      },
      "languages": [
        "regex"
      ],
      "severity": "WARNING",
      "paths": {
        "include": [
          "*.pug"
        ]
      },
      "pattern-either": [
        {
          "pattern-regex": "\\w.*(!=)[^=].*"
        },
        {
          "pattern-regex": "!{.*?}"
        }
      ]
    },
    {
      "id": "javascript.express.security.express-sandbox-injection.express-sandbox-code-injection",
      "message": "This vulnerability arises when user input controls sandbox function parameters in Express applications without proper validation. Despite sandboxing, attackers may find ways to escape the restricted environment and execute arbitrary code in the application context. Always ensure user input does not influence code that will be evaluated in sandboxes, as even robust sandboxing mechanisms may have vulnerabilities or escape techniques.",
      "metadata": {
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html"
        ],
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "User-controlled sandbox calls can lead to code injection",
        "fix-suggestion": "Prevent user input from influencing code executed in sandbox environments. Implement input validation that rejects strings containing potentially harmful characters before processing. Consider alternatives to dynamic code evaluation like template engines, and if sandboxed execution is necessary, run it in a separate process with minimal privileges and proper resource limits."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-inside": "$SANDBOX = require('sandbox');\n...\n"
            },
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-inside": "$S = new $SANDBOX(...);\n...\n"
                    },
                    {
                      "pattern": "$S.run(...)\n"
                    }
                  ]
                },
                {
                  "pattern": "new $SANDBOX($OPTS).run(...)\n"
                },
                {
                  "pattern": "new $SANDBOX().run(...)"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.express-wkhtml-injection.express-wkhtmltoimage-injection",
      "message": "This vulnerability happens when user input influences wkhtmltoimage operations in Express applications without proper validation. Attackers can provide malicious URLs or HTML that, when processed, may access internal resources, leak information, or execute unauthorized code in the browser context. Thoroughly validate any user data that affects wkhtmltoimage calls and avoid using user-controlled URLs or content in HTML-to-image conversion operations.",
      "metadata": {
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "references": [
          "https://www.npmjs.com/package/wkhtmltopdf"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "wkhtmltoimage with untrusted data can cause SSRF",
        "fix-suggestion": "Implement strict validation for parameters passed to `wkhtmltoimage`, especially for user-provided URLs or HTML content. Create a whitelist of allowed domains and protocols, and validate all inputs against this list. Use predefined templates with proper escaping for user data, or sanitize HTML with `DOMPurify` or `sanitize-html` before processing."
      },
      "severity": "ERROR",
      "languages": [
        "javascript",
        "typescript"
      ],
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$WK.generate($SINK,...)"
            },
            {
              "focus-metavariable": "$SINK"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.express-wkhtml-injection.express-wkhtmltopdf-injection",
      "message": "This vulnerability occurs when user input is passed to wkhtmltopdf methods in Express applications without strict validation. Attackers can exploit this to make the server access unauthorized internal resources or process malicious HTML that leaks information through the generated PDF. Implement strict validation of any user data that influences PDF generation operations and avoid using user-controlled URLs or content in HTML-to-PDF conversion processes.",
      "metadata": {
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "references": [
          "https://www.npmjs.com/package/wkhtmltopdf"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "wkhtmltopdf usage with user input can trigger SSRF",
        "fix-suggestion": "Apply rigorous validation to any user input that influences `wkhtmltopdf` operations in Express applications. Establish a whitelist of allowed domains and protocols for URL inputs, rejecting any that don't match these criteria. For HTML content, use server-side templates with context-aware escaping or sanitize with libraries like `DOMPurify` before processing."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-inside": "$WK = require('wkhtmltopdf');\n...\n"
            },
            {
              "pattern": "$WK($SINK,...)"
            },
            {
              "focus-metavariable": "$SINK"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.injection.raw-html-format.raw-html-format",
      "message": "This vulnerability arises when Express applications manually build HTML strings by concatenating user input without proper sanitization. When rendered in the browser, this can lead to cross-site scripting attacks where injected scripts execute in the user's session context. Use template engines with automatic HTML escaping or dedicated HTML sanitization libraries to ensure user input cannot inject executable code into the generated HTML.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Concatenating user data into HTML string can cause XSS",
        "fix-suggestion": "Switch from manual HTML string construction to template engines that automatically escape output (like `EJS`, `Pug`, or `Handlebars`). When using template engines, favor their built-in escaping syntax (e.g., `<%= value %>` in EJS) over unescaped output. If manual HTML construction is unavoidable, sanitize user input with libraries like `DOMPurify` or `sanitize-html` before insertion."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "label": "EXPRESS",
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                }
              ]
            }
          ]
        },
        {
          "label": "EXPRESSTS",
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                }
              ]
            }
          ]
        },
        {
          "label": "CLEAN",
          "by-side-effect": true,
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$A($SOURCE)"
                },
                {
                  "pattern": "$SANITIZE. ... .$A($SOURCE)"
                },
                {
                  "pattern": "$A. ... .$SANITIZE($SOURCE)"
                }
              ]
            },
            {
              "focus-metavariable": "$SOURCE"
            },
            {
              "metavariable-regex": {
                "metavariable": "$A",
                "regex": "(?i)(.*valid|.*sanitiz)"
              }
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "requires": "(EXPRESS and not CLEAN) or (EXPRESSTS and not CLEAN)",
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "\"$HTMLSTR\" + $EXPR"
                        },
                        {
                          "pattern": "\"$HTMLSTR\".concat(...)"
                        },
                        {
                          "pattern": "util.format($HTMLSTR, ...)"
                        }
                      ]
                    },
                    {
                      "metavariable-pattern": {
                        "metavariable": "$HTMLSTR",
                        "language": "generic",
                        "pattern": "<$TAG ..."
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "`...`\n"
                    },
                    {
                      "pattern-regex": ".*<\\w+.*\n"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.express.security.injection.tainted-sql-string.tainted-sql-string",
      "message": "This vulnerability happens when SQL queries in Express applications are constructed by directly embedding user-supplied values into query strings. Attackers can inject SQL syntax that alters the query structure, potentially accessing unauthorized data or manipulating database contents. Use parameterized queries or prepared statements that properly separate SQL code from data to prevent injection attacks regardless of the input content.",
      "metadata": {
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "references": [
          "https://owasp.org/www-community/attacks/SQL_Injection"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "SQL injection risk from direct user input concatenation",
        "fix-suggestion": "Replace string concatenation in SQL queries with parameterized queries using placeholders (`?` or `$1`). Utilize prepared statements with parameter binding to separate SQL code from data safely. For query builders like `Knex.js`, use their parameter binding features instead of directly injecting values into SQL strings."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... (...,$REQ, ...) {...}"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "(...,{ $REQ }: Request,...) => {...}\n"
                },
                {
                  "pattern-inside": "(...,{ $REQ }: $EXPRESS.Request,...) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "\"$SQLSTR\" + $EXPR\n"
                        },
                        {
                          "pattern-inside": "\"$SQLSTR\".concat($EXPR)\n"
                        },
                        {
                          "pattern": "util.format($SQLSTR, $EXPR)"
                        },
                        {
                          "pattern": "`$SQLSTR${$EXPR}...`\n"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$SQLSTR",
                        "regex": ".*\\b(?i)(select|delete|insert|create|update\\s+.+\\sset|alter|drop)\\b.*"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "focus-metavariable": "$EXPR"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.fbjs.security.audit.insecure-createnodesfrommarkup.insecure-createnodesfrommarkup",
      "message": "This vulnerability occurs when createNodesFromMarkup is used with user-controlled markup without proper sanitization. This method directly parses and creates DOM nodes from the provided HTML, allowing attackers to inject scripts that execute in the page context. Avoid passing user input to this method or apply thorough HTML sanitization using a dedicated library before creating nodes from potentially malicious markup.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "fbjs"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "createNodesFromMarkup with untrusted data is XSS-prone",
        "fix-suggestion": "Eliminate usage of `createNodesFromMarkup` with user-controlled input to prevent XSS attacks. Use safer DOM methods like `createElement` and `appendChild` to build DOM structures programmatically. When markup parsing is necessary, sanitize user input first with libraries like `DOMPurify`, or use `textContent` instead of HTML insertion methods for simple text."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "createNodesFromMarkup(...)"
            },
            {
              "pattern": "$X.createNodesFromMarkup(...)"
            }
          ]
        },
        {
          "pattern-not": "createNodesFromMarkup(\"...\",...)"
        },
        {
          "pattern-not": "$X.createNodesFromMarkup(\"...\",...)"
        }
      ]
    },
    {
      "id": "javascript.grpc.security.grpc-nodejs-insecure-connection.grpc-nodejs-insecure-connection",
      "message": "This vulnerability arises when gRPC connections are established without TLS encryption, transmitting all data in plaintext. This exposes sensitive information to network eavesdropping and allows attackers to intercept or modify the data in transit. Implement TLS encryption for all gRPC communications by using secure channel credentials instead of insecure ones to protect data confidentiality and integrity.",
      "metadata": {
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "category": "security",
        "technology": [
          "grpc"
        ],
        "references": [
          "https://blog.gopheracademy.com/advent-2017/go-grpc-beyond-basics/#:~:text=disables%20transport%20security"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "Insecure gRPC node connection lacks TLS encryption",
        "fix-suggestion": "Convert insecure gRPC channels to TLS-secured connections by replacing `grpc.credentials.createInsecure()` with `grpc.credentials.createSsl()`. Configure proper TLS certificates for both client and server, implementing certificate validation to prevent man-in-the-middle attacks. Use trusted Certificate Authority-signed certificates in production and establish certificate rotation practices."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "pattern-either": [
        {
          "pattern": "require('grpc');\n...\n$GRPC($ADDR,...,$CREDENTIALS.createInsecure(),...);\n"
        },
        {
          "pattern": "require('grpc');\n...\nnew $GRPC($ADDR,...,$CREDENTIALS.createInsecure(),...);\n"
        },
        {
          "pattern": "require('grpc');\n...\n$CREDS = <... $CREDENTIALS.createInsecure() ...>;\n...\n$GRPC($ADDR,...,$CREDS,...);"
        },
        {
          "pattern": "require('grpc');\n...\n$CREDS = <... $CREDENTIALS.createInsecure() ...>;\n...\nnew $GRPC($ADDR,...,$CREDS,...);"
        }
      ]
    },
    {
      "id": "javascript.intercom.security.audit.intercom-settings-user-identifier-without-user-hash.intercom-settings-user-identifier-without-user-hash",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "window.intercomSettings = {..., email: $EMAIL, ...};\n"
            },
            {
              "pattern": "window.intercomSettings = {..., user_id: $USER_ID, ...};\n"
            },
            {
              "pattern": "Intercom('boot', {..., email: $EMAIL, ...});\n"
            },
            {
              "pattern": "Intercom('boot', {..., user_id: $USER_ID, ...});\n"
            },
            {
              "pattern": "$VAR = {..., email: $EMAIL, ...};\n...\nIntercom('boot', $VAR);\n"
            },
            {
              "pattern": "$VAR = {..., user_id: $EMAIL, ...};\n...\nIntercom('boot', $VAR);\n"
            }
          ]
        },
        {
          "pattern-not": "window.intercomSettings = {..., user_hash: $USER_HASH, ...};\n"
        },
        {
          "pattern-not": "Intercom('boot', {..., user_hash: $USER_HASH, ...});\n"
        },
        {
          "pattern-not": "$VAR = {..., user_hash: $USER_HASH, ...};\n...\nIntercom('boot', $VAR);\n"
        }
      ],
      "message": "Intercom Messenger is initialized with user identification but without the required `user_hash` for identity verification. This security gap allows malicious users to impersonate other users by simply changing their user identifier. Without proper identity verification, attackers could access conversations and sensitive information belonging to other users.",
      "languages": [
        "js"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "subcategory": [
          "audit"
        ],
        "cwe": [
          "CWE-287: Improper Authentication"
        ],
        "confidence": "MEDIUM",
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "technology": [
          "intercom"
        ],
        "references": [
          "https://www.intercom.com/help/en/articles/183-set-up-identity-verification-for-web-and-mobile"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Missing user verification enables Intercom impersonation",
        "fix-suggestion": "Add the `user_hash` parameter to your Intercom initialization using your Intercom secret and the user's ID like `user_hash: crypto.createHmac('sha256', INTERCOM_SECRET).update(userId).digest('hex')`. Generate this hash on your server, never in client-side code where the secret would be exposed. Review Intercom's Identity Verification documentation for implementation details."
      }
    },
    {
      "id": "javascript.jose.security.jwt-none-alg.jwt-none-alg",
      "message": "The JWT token is configured to use the 'none' algorithm, which disables signature verification entirely. This allows attackers to easily forge valid tokens with arbitrary content, completely bypassing your authentication and authorization controls. The 'none' algorithm should never be used in production environments.",
      "metadata": {
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/",
        "asvs": {
          "section": "V3: Session Management Verification Requirements",
          "control_id": "3.5.3 Insecue Stateless Session Tokens",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "jose",
          "jwt"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "None algorithm allows JWT forgery attacks",
        "fix-suggestion": "Remove the `none` algorithm option and use a secure algorithm like `HS256` or `RS256` instead. Configure your JWT library with explicit algorithm selection like `jwt.sign(payload, secret, { algorithm: 'HS256' })`. Implement signature verification on the server side to reject tokens with the `none` algorithm."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "pattern-either": [
        {
          "pattern": "var $JOSE = require(\"jose\");\n...\nvar { JWK, JWT } = $JOSE;\n...\nvar $T = JWT.verify($P, JWK.None,...);\n"
        },
        {
          "pattern": "var $JOSE = require(\"jose\");\n...\nvar { JWK, JWT } = $JOSE;\n...\n$T = JWT.verify($P, JWK.None,...);\n"
        },
        {
          "pattern": "var $JOSE = require(\"jose\");\n...\nvar { JWK, JWT } = $JOSE;\n...\nJWT.verify($P, JWK.None,...);\n"
        }
      ]
    },
    {
      "id": "javascript.jose.security.audit.jose-exposed-data.jose-exposed-data",
      "message": "Sensitive data may be leaked when objects are passed directly to jose.JWT.sign() without proper filtering. JWT tokens are often sent to clients and can be easily decoded, exposing any included data even if the signature remains secure. Always review what data is being included in token payloads before signing.",
      "metadata": {
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A04:2021 - Insecure Design"
        ],
        "cwe": [
          "CWE-522: Insufficiently Protected Credentials"
        ],
        "source-rule-url": "https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/",
        "asvs": {
          "section": "V3: Session Management Verification Requirements",
          "control_id": "3.5.2 Static API keys or secret",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "jose",
          "jwt"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "JWT payload may contain sensitive information",
        "fix-suggestion": "Filter the object passed to `jose.JWT.sign()` by creating a new object with only the necessary properties. Use a whitelist approach with `const safePayload = { sub: user.id, role: user.role }` rather than passing entire user objects directly to the signing function."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "require('jose');\n...\n"
        },
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-inside": "function (...,$INPUT,...) {...}"
                },
                {
                  "pattern-either": [
                    {
                      "pattern": "$JOSE.JWT.sign($INPUT,...)"
                    },
                    {
                      "pattern": "$JWT.sign($INPUT,...)"
                    }
                  ]
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-inside": "function $F(...,$INPUT,...) {...}"
                },
                {
                  "pattern-either": [
                    {
                      "pattern": "$JOSE.JWT.sign($INPUT,...)"
                    },
                    {
                      "pattern": "$JWT.sign($INPUT,...)"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.jose.security.jwt-hardcode.hardcoded-jwt-secret",
      "message": "Developers often hardcode JWT secrets directly in source code for convenience, creating a serious security risk when the code is exposed. If attackers gain access to the codebase (through leaks, public repositories, or insider threats), they can extract the secret and forge valid tokens to impersonate users. This vulnerability typically leads to unauthorized access, privilege escalation, and complete authentication bypass in your application.",
      "metadata": {
        "interfile": true,
        "cwe": [
          "CWE-798: Use of Hard-coded Credentials"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html"
        ],
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "asvs": {
          "section": "V3: Session Management Verification Requirements",
          "control_id": "3.5.2 Static API keys or secret",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "jose",
          "jwt",
          "secrets"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Hard-coded Secrets"
        ],
        "short-description": "Hardcoded JWT secret exposes tokens to compromise",
        "fix-suggestion": "Remove hardcoded JWT secrets from source code and use `process.env` to access secrets stored in environment variables. For production systems, implement secret management services like AWS Secrets Manager or HashiCorp Vault. Establish secret rotation policies and verify that the application won't start if required secrets are missing."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "$JOSE = require(\"jose\");\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "var {JWT} = $JOSE;\n...\n"
            },
            {
              "pattern-inside": "var {JWK, JWT} = $JOSE;\n...\n"
            },
            {
              "pattern-inside": "const {JWT} = $JOSE;\n...\n"
            },
            {
              "pattern-inside": "const {JWK, JWT} = $JOSE;\n...\n"
            },
            {
              "pattern-inside": "let {JWT} = $JOSE;\n...\n"
            },
            {
              "pattern-inside": "let {JWK, JWT} = $JOSE;\n...\n"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern": "JWT.verify($P, \"...\", ...);\n"
            },
            {
              "pattern": "JWT.sign($P, \"...\", ...);\n"
            },
            {
              "pattern": "JWT.verify($P, JWK.asKey(\"...\"), ...);     \n"
            },
            {
              "pattern": "$JWT.sign($P, JWK.asKey(\"...\"), ...);\n"
            }
          ]
        }
      ],
      "options": {
        "symbolic_propagation": true,
        "interfile": true
      }
    },
    {
      "id": "javascript.jsonwebtoken.security.jwt-none-alg.jwt-none-alg",
      "message": "Using the 'none' algorithm in JWT tokens eliminates signature verification entirely. This allows attackers to forge tokens that will be automatically accepted as valid, completely bypassing authentication and authorization controls. Always use cryptographically secure algorithms for JWT signatures.",
      "metadata": {
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/",
        "asvs": {
          "section": "V3: Session Management Verification Requirements",
          "control_id": "3.5.3 Insecue Stateless Session Tokens",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "jwt"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "JWT using insecure 'none' algorithm",
        "fix-suggestion": "Replace the `'none'` algorithm with a secure algorithm like `'HS256'`. Ensure your JWT configuration explicitly disallows the 'none' algorithm by setting appropriate validation options in your token verification functions."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "patterns": [
        {
          "pattern-inside": "$JWT = require(\"jsonwebtoken\");\n...\n"
        },
        {
          "pattern": "$JWT.verify($P, $X, {algorithms:[...,'none',...]},...)"
        }
      ]
    },
    {
      "id": "javascript.jsonwebtoken.security.audit.jwt-decode-without-verify.jwt-decode-without-verify",
      "message": "Decoding JWT tokens without verification allows manipulated tokens to be processed as valid. Any claims in unverified tokens cannot be trusted, enabling attackers to forge tokens with arbitrary claims. Always verify token signatures before trusting their content.",
      "metadata": {
        "cwe": [
          "CWE-345: Insufficient Verification of Data Authenticity"
        ],
        "owasp": [
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "source-rule-url": "https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/",
        "asvs": {
          "section": "V3: Session Management Verification Requirements",
          "control_id": "3.5.3 Insecue Stateless Session Tokens",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "jwt"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "JWT tokens decoded without signature verification",
        "fix-suggestion": "Always call `.verify()` on JWT tokens before using their contents. Replace calls to token decoding functions with verification functions that validate the signature, such as `jwt.verify(token, secretKey)` instead of `jwt.decode(token)`."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "$JWT = require('jsonwebtoken');\n...\n"
        },
        {
          "pattern-not-inside": "...\n$JWT.verify($TOKEN, ...)\n...\n"
        },
        {
          "pattern-not-inside": "...\nif (<... $JWT.verify($TOKEN, ...) ...>) { ... }\n...\n"
        },
        {
          "pattern": "$JWT.decode($TOKEN, ...)"
        }
      ]
    },
    {
      "id": "javascript.jsonwebtoken.security.audit.jwt-exposed-data.jwt-exposed-data",
      "message": "Sensitive data may be unintentionally exposed in JWT token payloads. JWT tokens are only encrypted at the signature level while the payload remains easily decodable by anyone who receives the token. Review all data passed to token signing functions to prevent information leakage.",
      "metadata": {
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A04:2021 - Insecure Design"
        ],
        "cwe": [
          "CWE-522: Insufficiently Protected Credentials"
        ],
        "source-rule-url": "https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/",
        "asvs": {
          "section": "V3: Session Management Verification Requirements",
          "control_id": "3.5.3 Insecue Stateless Session Tokens",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "jwt"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Sensitive data exposed in JWT payload",
        "fix-suggestion": "Filter the object being passed to `jsonwebtoken.sign()` by creating a new object with only the necessary claims. Use a sanitization function like `const safePayload = { id: user.id, role: user.role }` to ensure sensitive fields like passwords are never included in the token."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "$JWT = require('jsonwebtoken');\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "function (...,$INPUT,...) {...}"
            },
            {
              "pattern-inside": "function $F(...,$INPUT,...) {...}"
            }
          ]
        },
        {
          "pattern": "$JWT.sign($INPUT,...)"
        }
      ]
    },
    {
      "id": "javascript.jsonwebtoken.security.jwt-hardcode.hardcoded-jwt-secret",
      "message": "JWT secrets embedded directly in source files create a severe security vulnerability when code is visible to unauthorized parties. Attackers who discover these credentials can forge legitimate authentication tokens, effectively bypassing your security controls. This compromise typically results in unauthorized system access, identity spoofing, and potential data breaches across your application ecosystem.",
      "metadata": {
        "cwe": [
          "CWE-798: Use of Hard-coded Credentials"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html"
        ],
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "asvs": {
          "section": "V3: Session Management Verification Requirements",
          "control_id": "3.5.2 Static API keys or secret",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "jwt",
          "javascript",
          "secrets"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Hard-coded Secrets"
        ],
        "short-description": "Insecurely stored JWT secret in source code",
        "fix-suggestion": "Extract JWT secrets from source code and store them in environment variables or dedicated secret management solutions. Update code to access secrets via `process.env` with initialization checks to verify proper configuration. Implement a secret rotation policy and ensure different environments (development, testing, production) use distinct secret values."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "$X = '...' \n"
            },
            {
              "pattern": "$X = '$Y' \n"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$JWT.sign($DATA,\"...\",...);\n"
                },
                {
                  "pattern-inside": "$JWT.verify($DATA,\"...\",...);\n"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$JWT = require(\"jsonwebtoken\")\n...\n"
                },
                {
                  "pattern-inside": "import $JWT from \"jsonwebtoken\"\n...\n"
                },
                {
                  "pattern-inside": "import * as $JWT from \"jsonwebtoken\"\n...\n"
                },
                {
                  "pattern-inside": "import {...,$JWT,...} from \"jsonwebtoken\"\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "$JWT.sign($DATA,$VALUE,...);\n"
                },
                {
                  "pattern-inside": "$JWT.verify($DATA,$VALUE,...);\n"
                }
              ]
            },
            {
              "focus-metavariable": "$VALUE"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.jwt-simple.security.jwt-simple-noverify.jwt-simple-noverify",
      "message": "JWT tokens are being decoded without verification of their signatures. This allows attackers to forge tokens with arbitrary claims that will be treated as valid by your application. Always verify tokens before trusting their contents.",
      "severity": "ERROR",
      "metadata": {
        "owasp": [
          "A05:2021 - Security Misconfiguration",
          "A07:2021 - Identification and Authentication Failures"
        ],
        "cwe": [
          "CWE-287: Improper Authentication",
          "CWE-345: Insufficient Verification of Data Authenticity",
          "CWE-347: Improper Verification of Cryptographic Signature"
        ],
        "category": "security",
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "jwt-simple",
          "jwt"
        ],
        "confidence": "HIGH",
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "references": [
          "https://www.npmjs.com/package/jwt-simple",
          "https://cwe.mitre.org/data/definitions/287",
          "https://cwe.mitre.org/data/definitions/345",
          "https://cwe.mitre.org/data/definitions/347"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues",
          "Improper Authentication"
        ],
        "short-description": "JWT tokens decoded without verification",
        "fix-suggestion": "Set the `verify` parameter to `true` when decoding tokens with jwt-simple. Update your code to use `jwt.decode(token, secret, true)` to ensure the signature is verified before the token contents are trusted."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "patterns": [
        {
          "pattern-inside": "$JWT = require('jwt-simple');\n...\n"
        },
        {
          "pattern": "$JWT.decode($TOKEN, $SECRET, $NOVERIFY, ...)"
        },
        {
          "metavariable-pattern": {
            "metavariable": "$NOVERIFY",
            "patterns": [
              {
                "pattern-either": [
                  {
                    "pattern": "true\n"
                  },
                  {
                    "pattern": "\"...\"\n"
                  }
                ]
              }
            ]
          }
        }
      ]
    },
    {
      "id": "javascript.lang.security.detect-buffer-noassert.detect-buffer-noassert",
      "message": "The 'noassert' option in Buffer operations bypasses bounds checking, allowing reads and writes beyond intended memory regions. This lack of validation can lead to buffer overflow vulnerabilities, potentially exposing sensitive data from adjacent memory or corrupting critical application data. Such memory safety issues could be exploited by attackers to crash services or, in certain scenarios, execute arbitrary code on the system.",
      "metadata": {
        "cwe": [
          "CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer"
        ],
        "source-rule-url": "https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-buffer-noassert.js",
        "category": "security",
        "technology": [
          "javascript"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "references": [
          "https://cwe.mitre.org/data/definitions/119.html"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Memory Issues"
        ],
        "short-description": "'noassert' can cause out-of-bounds reads or writes",
        "fix-suggestion": "Remove the `noassert` parameter from Buffer read/write operations to enable critical bounds checking. Always use the default behavior which validates array boundaries during buffer operations. If performance optimization is required, implement your own verification checks before buffer operations to ensure safety."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern": "$OBJ.$API(..., true)"
        },
        {
          "metavariable-regex": {
            "metavariable": "$API",
            "regex": "(read|write)(U?Int8|(U?Int(16|32)|Float|Double)(LE|BE))"
          }
        }
      ]
    },
    {
      "id": "javascript.lang.security.detect-child-process.detect-child-process",
      "message": "When user-supplied input is passed directly to child_process functions without sanitization, attackers can inject additional command arguments or entirely different commands. This command injection vulnerability allows malicious users to execute arbitrary system commands with the privileges of the application process. The consequences can include unauthorized data access, service disruption, or complete system compromise through privilege escalation.",
      "metadata": {
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#do-not-use-dangerous-functions"
        ],
        "source-rule-url": "https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-child-process.js",
        "category": "security",
        "technology": [
          "javascript"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Unsanitized input to child_process leads to command injection",
        "fix-suggestion": "Use the array form of `child_process` methods instead of string concatenation for command execution. Prefer `execFile()` over `exec()` when possible as it doesn't spawn a shell by default. Implement strict input validation for user-controlled values and consider using `spawn()` with an array of arguments rather than shell command strings."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-inside": "function ... (...,$FUNC,...) {\n  ...\n}\n"
            },
            {
              "focus-metavariable": "$FUNC"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$CP = require('child_process')\n...\n"
                },
                {
                  "pattern-inside": "import * as $CP from 'child_process'\n...\n"
                },
                {
                  "pattern-inside": "import $CP from 'child_process'\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$CP.exec($CMD,...)"
                },
                {
                  "pattern": "$CP.execSync($CMD,...)"
                },
                {
                  "pattern": "$CP.spawn($CMD,...)"
                },
                {
                  "pattern": "$CP.spawnSync($CMD,...)"
                }
              ]
            },
            {
              "pattern-not-inside": "$CP.$EXEC(\"...\",...)"
            },
            {
              "pattern-not-inside": "$CP.$EXEC([\"...\",...],...)"
            },
            {
              "pattern-not-inside": "$CMD = \"...\"\n...\n"
            },
            {
              "pattern-not-inside": "$CMD = [\"...\",...]\n...\n"
            },
            {
              "focus-metavariable": "$CMD"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "child_process.exec($CMD,...)"
                },
                {
                  "pattern": "child_process.execSync($CMD,...)"
                },
                {
                  "pattern": "child_process.spawn($CMD,...)"
                },
                {
                  "pattern": "child_process.spawnSync($CMD,...)"
                }
              ]
            },
            {
              "pattern-not-inside": "child_process.$EXEC(\"...\",...)"
            },
            {
              "pattern-not-inside": "child_process.$EXEC([\"...\",...],...)"
            },
            {
              "pattern-not-inside": "$CMD = \"...\"\n...\n"
            },
            {
              "pattern-not-inside": "$CMD = [\"...\",...]\n...\n"
            },
            {
              "focus-metavariable": "$CMD"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.lang.security.detect-disable-mustache-escape.detect-disable-mustache-escape",
      "message": "HTML escaping has been disabled in a template engine. This prevents automatic sanitization of user input which creates a Cross-Site Scripting (XSS) vulnerability. Attackers can inject malicious scripts that execute in users' browsers when this content is rendered.",
      "metadata": {
        "cwe": [
          "CWE-116: Improper Encoding or Escaping of Output"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "source-rule-url": "https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-disable-mustache-escape.js",
        "category": "security",
        "technology": [
          "mustache"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Encoding"
        ],
        "short-description": "Disabled template HTML escaping enables XSS",
        "fix-suggestion": "Remove escaping disablement flags such as `{{{variable}}}` or `<%- raw_html %>` from your templates. If you must include raw HTML, create a separate sanitization function that uses a library like `DOMPurify` to clean the input before rendering."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "pattern": "$OBJ.escapeMarkup = false"
    },
    {
      "id": "javascript.lang.security.detect-eval-with-expression.detect-eval-with-expression",
      "message": "Dynamic JavaScript execution with user-controllable input detected. This pattern allows attackers to inject and execute arbitrary code in your application context, leading to Cross-Site Scripting (XSS) and potential server compromise. Avoid eval with dynamic data entirely.",
      "metadata": {
        "cwe": [
          "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "source-rule-url": "https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-eval-with-expression.js",
        "references": [
          "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#never_use_eval!"
        ],
        "category": "security",
        "technology": [
          "javascript"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Dynamic code execution enables XSS attacks",
        "fix-suggestion": "Completely avoid using `eval()`, `new Function()`, or similar dynamic code execution functions with user input. Refactor your code to use safer alternatives like JSON.parse for data processing or redesign your solution to eliminate the need for dynamic code evaluation."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$PROP = new URLSearchParams($WINDOW. ... .location.search).get('...')\n  ...\n"
                },
                {
                  "pattern-inside": "$PROP = new URLSearchParams(location.search).get('...')\n  ...\n"
                },
                {
                  "pattern-inside": "$PROP = new URLSearchParams($WINDOW. ... .location.hash.substring(1)).get('...')\n  ...\n"
                },
                {
                  "pattern-inside": "$PROP = new URLSearchParams(location.hash.substring(1)).get('...')\n  ...\n"
                }
              ]
            },
            {
              "focus-metavariable": "$PROP"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$PROPS = new URLSearchParams($WINDOW. ... .location.search)\n  ...\n"
                },
                {
                  "pattern-inside": "$PROPS = new URLSearchParams(location.search)\n  ...\n"
                },
                {
                  "pattern-inside": "$PROPS = new\nURLSearchParams($WINDOW. ... .location.hash.substring(1))\n  ...\n"
                },
                {
                  "pattern-inside": "$PROPS = new URLSearchParams(location.hash.substring(1))\n...\n"
                }
              ]
            },
            {
              "pattern": "$PROPS.get('...')"
            },
            {
              "focus-metavariable": "$PROPS"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "location.href"
                },
                {
                  "pattern": "location.hash"
                },
                {
                  "pattern": "location.search"
                },
                {
                  "pattern": "$WINDOW. ... .location.href"
                },
                {
                  "pattern": "$WINDOW. ... .location.hash"
                },
                {
                  "pattern": "$WINDOW. ... .location.search"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "eval(<... $SINK ...>)"
                },
                {
                  "pattern": "window.eval(<... $SINK ...>)"
                },
                {
                  "pattern": "new Function(<... $SINK ...>)"
                },
                {
                  "pattern": "new Function(<... $SINK ...>)(...)"
                },
                {
                  "pattern": "setTimeout(<... $SINK ...>,...)"
                },
                {
                  "pattern": "setInterval(<... $SINK ...>,...)"
                }
              ]
            },
            {
              "focus-metavariable": "$SINK"
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "location.href = $FUNC(...)"
                },
                {
                  "pattern": "location.hash = $FUNC(...)"
                },
                {
                  "pattern": "location.search = $FUNC(...)"
                },
                {
                  "pattern": "$WINDOW. ... .location.href = $FUNC(...)"
                },
                {
                  "pattern": "$WINDOW. ... .location.hash = $FUNC(...)"
                },
                {
                  "pattern": "$WINDOW. ... .location.search = $FUNC(...)"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.lang.security.detect-insecure-websocket.detect-insecure-websocket",
      "message": "Insecure WebSocket connection using the 'ws://' protocol detected. This transmits all data in plaintext, allowing attackers to intercept, read, and modify the communication. WebSocket connections should always use encryption in production environments.",
      "metadata": {
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "asvs": {
          "section": "V13: API and Web Service Verification Requirements",
          "control_id": "13.5.1 Insecure WebSocket",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x21-V13-API.md#v135-websocket-security-requirements",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "regex"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Unencrypted WebSocket connection",
        "fix-suggestion": "Replace `ws://` with `wss://` in all WebSocket connection URLs. Configure your WebSocket server to use TLS/SSL certificates and ensure your infrastructure supports secure WebSocket connections with proper certificate management."
      },
      "languages": [
        "regex"
      ],
      "severity": "ERROR",
      "patterns": [
        {
          "pattern-regex": "\\bws:\\/\\/"
        },
        {
          "pattern-not-inside": "\\bws:\\/\\/localhost.*"
        },
        {
          "pattern-not-inside": "\\bws:\\/\\/127.0.0.1.*"
        }
      ]
    },
    {
      "id": "javascript.lang.security.detect-no-csrf-before-method-override.detect-no-csrf-before-method-override",
      "message": "When methodOverride middleware processes requests before CSRF protection middleware in Express applications, attackers can bypass CSRF protections by converting GET requests to unsafe methods like POST. This middleware ordering vulnerability creates a protection gap where requests that would normally require CSRF tokens can be processed without validation. Consequently, attackers can trick authenticated users into unknowingly performing state-changing operations on the application without proper authorization checks.",
      "metadata": {
        "cwe": [
          "CWE-352: Cross-Site Request Forgery (CSRF)"
        ],
        "source-rule-url": "https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-no-csrf-before-method-override.js",
        "references": [
          "https://github.com/nodesecurity/eslint-plugin-security/blob/master/docs/bypass-connect-csrf-protection-by-abusing.md"
        ],
        "category": "security",
        "technology": [
          "javascript"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control",
          "A05:2017 - Broken Access Control"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site Request Forgery (CSRF)"
        ],
        "short-description": "CSRF middleware incorrectly placed after methodOverride",
        "fix-suggestion": "Reorder middleware in your Express application to ensure that CSRF protection runs before `methodOverride`. This sequence guarantees that all request methods, including those converted from GET to other methods, are verified for CSRF tokens. Place the `csrf` middleware before `methodOverride` in your `app.use()` sequence."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "pattern": "express.csrf();\n...\nexpress.methodOverride();\n"
    },
    {
      "id": "javascript.lang.security.insecure-object-assign.insecure-object-assign",
      "message": "User-controlled data passed to Object.assign can lead to mass assignment vulnerabilities. This allows attackers to set unexpected properties on objects, potentially overriding security controls or accessing unauthorized data. Only explicitly whitelist allowed properties for assignment.",
      "metadata": {
        "cwe": [
          "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html",
          "https://en.wikipedia.org/wiki/Mass_assignment_vulnerability"
        ],
        "category": "security",
        "technology": [
          "javascript"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Open Redirect"
        ],
        "short-description": "Object.assign enables mass assignment attacks",
        "fix-suggestion": "Create a whitelist of allowed properties and only copy those properties with explicit assignments. Instead of `Object.assign(target, userInput)`, use specific property assignments like `target.allowedProp = userInput.allowedProp` or use a validation schema library."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "JSON.parse(...)"
            },
            {
              "pattern-not": "JSON.parse(\"...\",...)"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "pattern": "Object.assign(...)"
        }
      ]
    },
    {
      "id": "javascript.lang.security.spawn-git-clone.spawn-git-clone",
      "message": "Git clone operations that incorporate unsanitized user input in the URL can be manipulated to include additional shell commands through command separators. An attacker can craft special input containing command delimiters like semicolons, pipes, or backticks that will be executed alongside the intended git command. This command injection vulnerability could allow unauthorized system access, data exfiltration, or complete system compromise at the privilege level of the application process.",
      "metadata": {
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "git"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Git clone with user input can inject shell commands",
        "fix-suggestion": "Implement a repository URL allowlist when handling `git clone` operations with user input. Use the array syntax for spawn/exec (`spawn('git', ['clone', validatedUrl])`) to prevent shell interpretation. Consider using a git library instead of direct process spawning and validate that URLs don't contain shell metacharacters."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "spawn('git', ['clone',...,$F])"
            },
            {
              "pattern": "$X.spawn('git', ['clone',...,$F])"
            },
            {
              "pattern": "spawn('git', ['clone',...,$P,$F])"
            },
            {
              "pattern": "$X.spawn('git', ['clone',...,$P,$F])"
            }
          ]
        },
        {
          "pattern-not": "spawn('git', ['clone',...,\"...\"])"
        },
        {
          "pattern-not": "$X.spawn('git', ['clone',...,\"...\"])"
        },
        {
          "pattern-not": "spawn('git', ['clone',...,\"...\",\"...\"])"
        },
        {
          "pattern-not": "$X.spawn('git', ['clone',...,\"...\",\"...\"])"
        }
      ]
    },
    {
      "id": "javascript.lang.security.audit.code-string-concat.code-string-concat",
      "message": "User-supplied data from web requests flows into eval() for dynamic evaluation. This allows attackers to inject and execute arbitrary code with the full permissions of your application. Code injection vulnerabilities are among the most severe security risks.",
      "options": {
        "interfile": true
      },
      "metadata": {
        "interfile": true,
        "confidence": "HIGH",
        "owasp": [
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"
        ],
        "references": [
          "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval",
          "https://nodejs.org/api/child_process.html#child_processexeccommand-options-callback",
          "https://www.stackhawk.com/blog/nodejs-command-injection-examples-and-prevention/",
          "https://ckarande.gitbooks.io/owasp-nodegoat-tutorial/content/tutorial/a1_-_server_side_js_injection.html"
        ],
        "category": "security",
        "technology": [
          "node.js",
          "Express",
          "Next.js"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "User input executed as code via eval()",
        "fix-suggestion": "Never use `eval()` with data from external sources. Refactor your code to use alternative approaches like JSON.parse for data processing, template literals for string formatting, or a template engine for rendering dynamic content without code execution."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "function ... ($REQ, $RES) {...}"
                    },
                    {
                      "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                    },
                    {
                      "patterns": [
                        {
                          "pattern-either": [
                            {
                              "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                            },
                            {
                              "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                            }
                          ]
                        },
                        {
                          "metavariable-regex": {
                            "metavariable": "$METHOD",
                            "regex": "^(get|post|put|head|delete|options)$"
                          }
                        }
                      ]
                    }
                  ]
                },
                {
                  "pattern-either": [
                    {
                      "pattern": "$REQ.query"
                    },
                    {
                      "pattern": "$REQ.body"
                    },
                    {
                      "pattern": "$REQ.params"
                    },
                    {
                      "pattern": "$REQ.cookies"
                    },
                    {
                      "pattern": "$REQ.headers"
                    }
                  ]
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "import { ...,$IMPORT,... } from 'next/router'\n...\n"
                    },
                    {
                      "pattern-inside": "import $IMPORT from 'next/router';\n...\n"
                    }
                  ]
                },
                {
                  "pattern-either": [
                    {
                      "patterns": [
                        {
                          "pattern-inside": "$ROUTER = $IMPORT()\n...\n"
                        },
                        {
                          "pattern-either": [
                            {
                              "pattern-inside": "const { ...,$PROPS,... } = $ROUTER.query\n...\n"
                            },
                            {
                              "pattern-inside": "var { ...,$PROPS,... } = $ROUTER.query\n...\n"
                            },
                            {
                              "pattern-inside": "let { ...,$PROPS,... } = $ROUTER.query\n...\n"
                            }
                          ]
                        },
                        {
                          "focus-metavariable": "$PROPS"
                        }
                      ]
                    },
                    {
                      "patterns": [
                        {
                          "pattern-inside": "$ROUTER = $IMPORT()\n...\n"
                        },
                        {
                          "pattern": "$ROUTER.query.$VALUE \n"
                        }
                      ]
                    },
                    {
                      "patterns": [
                        {
                          "pattern": "$IMPORT().query.$VALUE"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "eval(...)\n"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.lang.security.audit.dangerous-spawn-shell.dangerous-spawn-shell",
      "message": "When dynamic, user-provided input is passed directly to exec functions, attackers can inject additional command arguments or entirely new commands through special characters. This command injection vulnerability bypasses any intended restrictions on what commands can be executed by the application. The impact includes unauthorized system access, data theft, service disruption, or complete system compromise depending on the application's privilege level.",
      "metadata": {
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "source-rule-url": "https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-child-process.js",
        "category": "security",
        "technology": [
          "javascript"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#do-not-use-dangerous-functions"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "exec/spawn with shell=true allows malicious command injection",
        "fix-suggestion": "Replace command string concatenation with array arguments in `child_process` methods: use `execFile()` or `spawn()` with explicit `shell: false`. Implement strict input validation for any user-controlled values passed as command arguments. Consider higher-level libraries that provide safer abstractions for your required functionality."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-inside": "function ... (...,$FUNC,...) {\n  ...\n}\n"
            },
            {
              "focus-metavariable": "$FUNC"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "require('child_process')\n...\n"
                },
                {
                  "pattern-inside": "import 'child_process'\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "spawn(...)"
                },
                {
                  "pattern": "spawnSync(...)"
                },
                {
                  "pattern": "$CP.spawn(...)"
                },
                {
                  "pattern": "$CP.spawnSync(...)"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$EXEC(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",[\"-c\", $ARG, ...],...)\n"
                },
                {
                  "patterns": [
                    {
                      "pattern": "$EXEC($CMD,[\"-c\", $ARG, ...],...)"
                    },
                    {
                      "pattern-inside": "$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\"\n...\n"
                    }
                  ]
                },
                {
                  "pattern": "$EXEC(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",[$ARG, ...],...)\n"
                },
                {
                  "patterns": [
                    {
                      "pattern": "$EXEC($CMD,[$ARG, ...],...)"
                    },
                    {
                      "pattern-inside": "$CMD = \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\"\n...\n"
                    }
                  ]
                }
              ]
            },
            {
              "focus-metavariable": "$ARG"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp",
      "message": "Regular expressions created from user-controlled inputs can lead to Regular Expression Denial of Service (ReDoS) attacks. Complex patterns may cause catastrophic backtracking, blocking the main JavaScript thread and freezing your application. Always validate or limit user input for regexes.",
      "metadata": {
        "owasp": [
          "A05:2021 - Security Misconfiguration",
          "A06:2017 - Security Misconfiguration"
        ],
        "cwe": [
          "CWE-1333: Inefficient Regular Expression Complexity"
        ],
        "references": [
          "https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS"
        ],
        "source-rule-url": "https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-non-literal-regexp.js",
        "category": "security",
        "technology": [
          "javascript"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Denial-of-Service (DoS)"
        ],
        "short-description": "Dynamic RegExp enables ReDoS attacks",
        "fix-suggestion": "Use hardcoded regex patterns instead of dynamically building them from user input. If dynamic patterns are necessary, implement strict validation of user input, set execution timeouts, and consider using a library like `safe-regex` to check for potentially vulnerable patterns."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-inside": "function ... (...,$ARG,...) {...}\n"
            },
            {
              "focus-metavariable": "$ARG"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "new RegExp($ARG, ...)"
                },
                {
                  "pattern": "RegExp($ARG, ...)"
                }
              ]
            },
            {
              "pattern-not": "RegExp(\"...\", ...)"
            },
            {
              "pattern-not": "new RegExp(\"...\", ...)"
            },
            {
              "pattern-not": "RegExp(/.../, ...)"
            },
            {
              "pattern-not": "new RegExp(/.../, ...)"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.lang.security.audit.hardcoded-hmac-key.hardcoded-hmac-key",
      "message": "Embedding HMAC cryptographic keys directly in application source code exposes these critical secrets to anyone with code access. Once attackers discover these hardcoded keys, they can generate valid message authentication codes, effectively bypassing data integrity and authenticity checks in the application. This compromise allows attackers to forge seemingly legitimate messages, modify protected data without detection, or bypass security controls that rely on HMAC verification.",
      "options": {
        "interfile": true
      },
      "metadata": {
        "interfile": true,
        "category": "security",
        "technology": [
          "crypto",
          "hmac"
        ],
        "references": [
          "https://rules.sonarsource.com/javascript/RSPEC-2068",
          "https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#key-management"
        ],
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "cwe": [
          "CWE-798: Use of Hard-coded Credentials"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Hard-coded Secrets"
        ],
        "short-description": "Hardcoded HMAC key is easily discoverable",
        "fix-suggestion": "Transfer HMAC keys from source code to environment variables or secure key management services. Access keys at runtime through services like AWS Secrets Manager or using packages like `dotenv` for development. Implement key rotation mechanisms and ensure that different environments use distinct keys for proper security isolation."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "$CRYPTO.createHmac($ALGO, '...')"
        },
        {
          "patterns": [
            {
              "pattern-inside": "const $SECRET = '...'\n...\n"
            },
            {
              "pattern": "$CRYPTO.createHmac($ALGO, $SECRET)"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.lang.security.audit.incomplete-sanitization.incomplete-sanitization",
      "message": "String.replace() with a string argument only replaces the first occurrence, leaving subsequent instances unsanitized. This creates an incomplete protection against injection attacks, allowing attackers to bypass security controls. Always use regex with global flag for complete sanitization.",
      "metadata": {
        "cwe": [
          "CWE-116: Improper Encoding or Escaping of Output"
        ],
        "category": "security",
        "technology": [
          "javascript"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Encoding"
        ],
        "short-description": "Incomplete string sanitization bypasses security",
        "fix-suggestion": "Replace string literals in `replace()` with regular expressions using the global flag. Change `string.replace('dangerous', 'safe')` to `string.replace(/dangerous/g, 'safe')` or use a dedicated sanitization library designed for your specific context."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern": "$STR.replace(($CHAR: string), ...)\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$CHAR",
            "regex": "^[\\\"\\']([\\'\\\"\\<\\>\\*\\|\\{\\}\\[\\]\\%\\$]{1}|\\\\n|\\\\r|\\\\t|\\\\&)[\\\"\\']$"
          }
        }
      ]
    },
    {
      "id": "javascript.lang.security.audit.md5-used-as-password.md5-used-as-password",
      "message": "MD5 hash function is being used for password storage. MD5 is cryptographically broken, computes quickly, and is vulnerable to rainbow table attacks. Modern password security requires slow, salted, adaptive hashing algorithms specifically designed for password storage.",
      "metadata": {
        "category": "security",
        "technology": [
          "crypto",
          "md5"
        ],
        "references": [
          "https://tools.ietf.org/id/draft-lvelvindron-tls-md5-sha1-deprecate-01.html",
          "https://security.stackexchange.com/questions/211/how-to-securely-hash-passwords",
          "https://github.com/returntocorp/semgrep-rules/issues/1609",
          "https://www.npmjs.com/package/bcrypt"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Weak MD5 hash used for passwords",
        "fix-suggestion": "Replace MD5 with a modern password hashing function by using the `bcrypt` package. Implement password hashing with `bcrypt.hash(password, saltRounds)` and verify with `bcrypt.compare(password, hash)` to significantly improve security against brute force attacks."
      },
      "languages": [
        "javascript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern": "$CRYPTO.createHash(\"md5\")"
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$FUNCTION(...);"
            },
            {
              "metavariable-regex": {
                "metavariable": "$FUNCTION",
                "regex": "(?i)(.*password.*)"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.lang.security.audit.spawn-shell-true.spawn-shell-true",
      "message": "Using {shell: true} in spawn/exec calls creates a significant security risk by executing commands within a shell environment that interprets special characters. This shell interpretation enables attackers to inject additional commands through metacharacters like semicolons, pipes, or ampersands if the command string contains unsanitized user input. The resulting command injection vulnerability could lead to unauthorized command execution, data exposure, or complete system compromise with the privileges of the application process.",
      "metadata": {
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "category": "security",
        "technology": [
          "javascript"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Spawning a shell with user input simplifies injection",
        "fix-suggestion": "Eliminate the `{shell: true}` option from spawn/exec calls to prevent command injection. Use array syntax for command and arguments: `spawn('command', ['arg1', 'arg2'])` instead of string concatenation. For necessary shell operations, implement strict input validation and consider libraries like `shell-quote` to properly escape user-supplied values."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "spawn(...,{shell: $SHELL})\n"
            },
            {
              "pattern": "spawnSync(...,{shell: $SHELL})\n"
            },
            {
              "pattern": "$CP.spawn(...,{shell: $SHELL})\n"
            },
            {
              "pattern": "$CP.spawnSync(...,{shell: $SHELL})\n"
            }
          ]
        },
        {
          "pattern-not": "spawn(...,{shell: false})\n"
        },
        {
          "pattern-not": "spawnSync(...,{shell: false})\n"
        },
        {
          "pattern-not": "$CP.spawn(...,{shell: false})\n"
        },
        {
          "pattern-not": "$CP.spawnSync(...,{shell: false})\n"
        }
      ]
    },
    {
      "id": "javascript.lang.security.audit.unknown-value-with-script-tag.unknown-value-with-script-tag",
      "message": "Inserting potentially user-controlled values directly into <script> tags without proper validation creates a critical cross-site scripting (XSS) vulnerability. When these unverified values contain malicious JavaScript code, the browser will execute it in the context of the current origin, bypassing same-origin policy protections. This vulnerability allows attackers to steal sensitive user data like authentication tokens, hijack user sessions, or perform unauthorized actions on behalf of the victim user.",
      "metadata": {
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "references": [
          "https://www.developsec.com/2017/11/09/xss-in-a-script-tag/",
          "https://github.com/juice-shop/juice-shop/blob/1ceb8751e986dacd3214a618c37e7411be6bc11a/routes/videoHandler.ts#L68"
        ],
        "category": "security",
        "technology": [
          "javascript"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Unknown dynamic value in script tag can lead to XSS",
        "fix-suggestion": "Stop inserting dynamic content directly inside `<script>` tags to prevent XSS vulnerabilities. Store data in separate JSON structures with proper serialization using `JSON.stringify()`. For dynamic script paths, implement validation against a whitelist of permitted URLs or resources."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "$UNK = $ANYFUNC(...);\n...\n$OTHERFUNC(..., <... $UNK ...>, ...);\n"
        },
        {
          "pattern": "$OTHERFUNC(..., <... \"=~/.*<script.*/\" ...>, ...)"
        },
        {
          "pattern": "$UNK"
        }
      ]
    },
    {
      "id": "javascript.lang.security.audit.unsafe-formatstring.unsafe-formatstring",
      "message": "User-controlled data is used in format strings, enabling format string injection attacks. Attackers can craft inputs containing format specifiers that modify log messages, potentially leading to information disclosure or log forgery. Always sanitize input used in formatters.",
      "metadata": {
        "cwe": [
          "CWE-134: Use of Externally-Controlled Format String"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "category": "security",
        "technology": [
          "javascript"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "MEDIUM",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://cwe.mitre.org/data/definitions/134.html"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "Format string injection in logging functions",
        "fix-suggestion": "Use template literals instead of format strings for variable interpolation. Alternatively, ensure format strings are static literals by moving the format string to a constant like `const FORMAT = '%s %d'` and passing user data as separate parameters to `util.format(FORMAT, userData)`."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "INFO",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$X + $Y"
                },
                {
                  "pattern": "$X.concat($Y)"
                },
                {
                  "pattern": "`...${...}...`\n"
                }
              ]
            },
            {
              "pattern-not": "\"...\" + \"...\"\n"
            },
            {
              "pattern-not": "$X.concat(\"...\")\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$STR"
            },
            {
              "pattern-either": [
                {
                  "pattern": "console.$LOG($STR,$PARAM,...)\n"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$UTIL = require('util')\n...\n"
                    },
                    {
                      "pattern": "$UTIL.format($STR,$PARAM,...)\n"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.lang.security.audit.path-traversal.path-join-resolve-traversal.path-join-resolve-traversal",
      "message": "When user input is passed directly to path manipulation functions like path.join() or path.resolve() without proper validation, attackers can use path traversal sequences like '../' to access files outside intended directories. This path traversal vulnerability occurs because these functions normalize paths but don't restrict traversal to parent directories when processing special path components. The impact includes unauthorized access to sensitive system files, configuration data exposure, or access to protected resources outside the application's intended scope.",
      "metadata": {
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
        ],
        "category": "security",
        "references": [
          "https://owasp.org/www-community/attacks/Path_Traversal"
        ],
        "technology": [
          "javascript",
          "node.js"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "short-description": "User input in path join can cause file system traversal",
        "fix-suggestion": "Validate paths before using `path.join()` or `path.resolve()` to prevent directory traversal attacks. Normalize paths with `path.normalize()` and verify they remain within expected base directories. Create a `safePath` utility function that validates paths or use libraries like `path-is-inside` for secure file system operations."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "focus-metavariable": "$X"
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... (...,$X,...) {...}\n"
                },
                {
                  "pattern-inside": "function ... (...,{...,$X,...},...) {...}\n"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$SINK"
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "$PATH = require('path');\n...\n"
                },
                {
                  "pattern-inside": "import $PATH from 'path';\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$PATH.join(...,$SINK,...)"
                },
                {
                  "pattern": "$PATH.resolve(...,$SINK,...)"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "focus-metavariable": "$SINK"
            },
            {
              "pattern-inside": "import 'path';\n...\n"
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "path.join(...,$SINK,...)"
                },
                {
                  "pattern-inside": "path.resolve(...,$SINK,...)"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "pattern": "$Y.replace(...)"
        },
        {
          "pattern": "$Y.indexOf(...)"
        },
        {
          "pattern": "function ... (...) {\n    ...\n    <... $Y.indexOf(...) ...>\n    ...\n}\n"
        },
        {
          "patterns": [
            {
              "pattern": "$FUNC(...)"
            },
            {
              "metavariable-regex": {
                "metavariable": "$FUNC",
                "regex": "sanitize"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.lang.security.audit.prototype-pollution.prototype-pollution-loop.prototype-pollution-loop",
      "message": "Code contains functions vulnerable to prototype pollution attacks. This allows attackers to modify JavaScript's Object prototype, affecting all objects in your application. Exploited prototype pollution can lead to security bypasses, application crashes, or remote code execution.",
      "metadata": {
        "cwe": [
          "CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes"
        ],
        "category": "security",
        "references": [
          "https://github.com/HoLyVieR/prototype-pollution-nsec18/blob/master/paper/JavaScript_prototype_pollution_attack_in_NodeJS.pdf"
        ],
        "technology": [
          "typescript"
        ],
        "owasp": [
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mass Assignment"
        ],
        "short-description": "Prototype pollution vulnerability affects all objects",
        "fix-suggestion": "Freeze the Object prototype with `Object.freeze(Object.prototype)` or use objects without prototypes via `Object.create(null)`. When merging objects from untrusted sources, use a library with prototype pollution protection or implement property name validation that rejects `__proto__` and `constructor`."
      },
      "languages": [
        "typescript",
        "javascript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$SMTH = $SMTH[$A]\n"
            },
            {
              "pattern": "$SMTH = $SMTH[$A] = ...\n"
            },
            {
              "pattern": "$SMTH = $SMTH[$A] && $Z\n"
            },
            {
              "pattern": "$SMTH = $SMTH[$A] || $Z\n"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "for(...) {\n  ...\n}\n"
            },
            {
              "pattern-inside": "while(...) {\n  ...\n}\n"
            },
            {
              "pattern-inside": "$X.forEach(function $NAME(...) {\n  ...\n})\n"
            }
          ]
        },
        {
          "pattern-not-inside": "for(var $A = $S; ...; ...) {...}\n"
        },
        {
          "pattern-not-inside": "for($A = $S; ...; ...) {...}\n"
        },
        {
          "pattern-not-inside": "$X.forEach(function $NAME($OBJ, $A,...) {...})\n"
        },
        {
          "metavariable-pattern": {
            "patterns": [
              {
                "pattern-not": "\"...\""
              },
              {
                "pattern-not": "`...${...}...`\n"
              },
              {
                "pattern-not": "($A: float)\n"
              }
            ],
            "metavariable": "$A"
          }
        }
      ]
    },
    {
      "id": "javascript.lang.security.audit.sqli.node-knex-sqli.node-knex-sqli",
      "message": "SQL injection in Knex occurs when user input is directly concatenated into SQL query strings rather than passed as parameterized values. This insecure practice allows attackers to manipulate the query structure by injecting special characters that alter its logic or add entirely new operations. Successful exploitation can lead to unauthorized data access, data manipulation, database credential theft, or even server compromise through advanced techniques like file system access.",
      "metadata": {
        "confidence": "MEDIUM",
        "references": [
          "https://knexjs.org/#Builder-fromRaw",
          "https://knexjs.org/#Builder-whereRaw",
          "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
        ],
        "category": "security",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "technology": [
          "express",
          "nodejs",
          "knex"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Knex queries with string concatenation cause injection risk",
        "fix-suggestion": "Replace string templates in Knex queries with parameterization features using question mark (`?`) placeholders or named binding parameters (`:name`). Leverage Knex's query builder methods like `.where()` and `.andWhere()` which automatically handle parameter binding. Validate user input for expected types and formats before incorporating it into database queries."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                },
                {
                  "pattern": "$REQ.files.$ANYTHING.data.toString('utf8')"
                },
                {
                  "pattern": "$REQ.files.$ANYTHING['data'].toString('utf8')"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                },
                {
                  "pattern": "files.$ANYTHING.data.toString('utf8')"
                },
                {
                  "pattern": "files.$ANYTHING['data'].toString('utf8')"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$QUERY"
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "$KNEX.fromRaw($QUERY, ...)"
                },
                {
                  "pattern-inside": "$KNEX.whereRaw($QUERY, ...)"
                },
                {
                  "pattern-inside": "$KNEX.raw($QUERY, ...)"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "require('knex')\n...\n"
                },
                {
                  "pattern-inside": "import 'knex'\n...\n"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern": "parseInt(...)"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.lang.security.audit.sqli.node-mssql-sqli.node-mssql-sqli",
      "message": "SQL injection in the mssql library happens when developers build queries by directly concatenating user input into SQL strings instead of using parameterized queries. This vulnerability allows attackers to inject SQL syntax that modifies the query's structure and behavior, potentially bypassing authentication, accessing unauthorized data, or executing administrative commands. The consequences can include complete database compromise, data theft, modification of critical records, or even server-level command execution through extended stored procedures.",
      "metadata": {
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "category": "security",
        "technology": [
          "mssql"
        ],
        "references": [
          "https://www.npmjs.com/package/mssql"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "mssql queries built with user input may lead to injection",
        "fix-suggestion": "Switch from string concatenation to parameterized queries using MSSQL's `PreparedStatement` class with defined input parameters. Alternatively, use the `Request` class with input parameters defined via the `.input()` method. Always specify parameter types explicitly (e.g., `TYPES.VarChar`) for proper escaping and type handling."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-inside": "function ... (...,$FUNC,...) {\n  ...\n}\n"
            },
            {
              "focus-metavariable": "$FUNC"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "require('mssql');\n...\n"
                },
                {
                  "pattern-inside": "import 'mssql';\n...\n"
                }
              ]
            },
            {
              "pattern-inside": "$REQ = $POOL.request(...)\n...\n"
            },
            {
              "pattern": "$REQ.query($QUERY,...)\n"
            },
            {
              "focus-metavariable": "$QUERY"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.lang.security.audit.sqli.node-mysql-sqli.node-mysql-sqli",
      "message": "MySQL SQL injection occurs when applications construct queries by concatenating unvalidated user input directly into SQL strings rather than using prepared statements. This insecure practice allows attackers to insert malicious SQL fragments that modify the query's logic, potentially extracting sensitive data or executing unauthorized database operations. The impact can include unauthorized data access, account compromise, data corruption, or even server compromise through certain MySQL configurations that permit file system operations.",
      "metadata": {
        "references": [
          "https://www.npmjs.com/package/mysql2",
          "https://www.npmjs.com/package/mysql",
          "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
        ],
        "category": "security",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "confidence": "LOW",
        "technology": [
          "mysql",
          "mysql2",
          "javascript",
          "nodejs"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "MySQL query string concatenation leads to injection vulnerability",
        "fix-suggestion": "Eliminate string concatenation in MySQL queries by using parameterized queries with placeholders (`?`). Pass values as a separate array parameter to ensure proper escaping. For named placeholders, use the format `:name` with corresponding property objects. Consider prepared statements with `.prepare()` for frequently executed queries to improve security and performance."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-inside": "function ... (..., $Y,...) {...}"
            },
            {
              "pattern": "$Y"
            },
            {
              "pattern-not-inside": "function ... (..., $Y: number,...) {...}\n"
            },
            {
              "pattern-not-inside": "$Y.query"
            },
            {
              "pattern-not-inside": "$Y.body"
            },
            {
              "pattern-not-inside": "$Y.params"
            },
            {
              "pattern-not-inside": "$Y.cookies"
            },
            {
              "pattern-not-inside": "$Y.headers"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$QUERY"
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "$POOL.query($QUERY, ...)"
                },
                {
                  "pattern-inside": "$POOL.execute($QUERY, ...)"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "import $S from \"$IMPORT\"\n...\n"
                },
                {
                  "pattern-inside": "import { ... } from \"$IMPORT\"\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from \"$IMPORT\"\n...\n"
                },
                {
                  "pattern-inside": "require(\"$IMPORT\")\n...\n"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$IMPORT",
                "regex": "(mysql|mysql2)"
              }
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern": "parseInt(...)"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.lang.security.audit.sqli.node-postgres-sqli.node-postgres-sqli",
      "message": "SQL statements are being built by concatenating user-controlled variables. This creates SQL Injection vulnerabilities that allow attackers to execute arbitrary database commands, potentially accessing, modifying, or deleting data they shouldn't have access to. Always use parameterized queries.",
      "metadata": {
        "owasp": [
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "cwe": [
          "CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes"
        ],
        "references": [
          "https://node-postgres.com/features/queries"
        ],
        "category": "security",
        "technology": [
          "node-postgres"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mass Assignment"
        ],
        "short-description": "SQL injection vulnerability in database queries",
        "fix-suggestion": "Replace string concatenation with parameterized queries using the placeholder syntax. Convert `client.query('SELECT * FROM users WHERE username = ' + username)` to `client.query('SELECT * FROM users WHERE username = $1', [username])` to ensure proper escaping and prevent SQL injection."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-inside": "function ... (...,$FUNC,...) {\n  ...\n}\n"
            },
            {
              "focus-metavariable": "$FUNC"
            },
            {
              "pattern-not-inside": "$F. ... .$SOURCE(...)\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "const { $CLIENT } = require('pg')\n ...\n"
                },
                {
                  "pattern-inside": "var { $CLIENT } = require('pg')\n ...\n"
                },
                {
                  "pattern-inside": "let { $CLIENT } = require('pg')\n ...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "$DB = new $CLIENT(...)\n...\n"
                },
                {
                  "pattern-inside": "$NEWPOOL = new $CLIENT(...)\n...\n$NEWPOOL.connect((..., $DB, ...) => {\n    ...\n})\n"
                }
              ]
            },
            {
              "pattern": "$DB.query($QUERY,...)"
            },
            {
              "focus-metavariable": "$QUERY"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.lang.security.detect-pseudorandombytes.detect-pseudoRandomBytes",
      "message": "The application uses crypto.pseudoRandomBytes which generates predictable random numbers. This is not cryptographically secure and should never be used for security purposes like token generation, encryption keys, or passwords. Predictable randomness leads to broken security.",
      "metadata": {
        "cwe": [
          "CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator (PRNG)"
        ],
        "owasp": [
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://github.com/nodesecurity/eslint-plugin-security/blob/master/rules/detect-pseudoRandomBytes.js",
        "asvs": {
          "section": "V6: Stored Cryptography Verification Requirements",
          "control_id": "6.3.1 Insecure Randomness",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v63-random-values",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "javascript"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Insecure random number generation",
        "fix-suggestion": "Replace `crypto.pseudoRandomBytes()` with `crypto.randomBytes()` for all security-sensitive operations. The secure version provides cryptographically strong random values suitable for generating tokens, keys, and other security-critical values."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "pattern": "crypto.pseudoRandomBytes"
    },
    {
      "id": "javascript.monaco-editor.security.audit.monaco-hover-htmlsupport.monaco-hover-htmlsupport",
      "message": "When the Monaco Editor is configured with HTML support in hover popups, it renders HTML content rather than displaying it as escaped text. If this rendered content includes unsanitized user input, attackers can inject malicious HTML or JavaScript code that executes when users hover over editor content. This cross-site scripting vulnerability enables attackers to steal sensitive editor content, execute unauthorized actions, or potentially gain access to the user's system through the browser.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://github.com/microsoft/monaco-editor/issues/801"
        ],
        "category": "security",
        "technology": [
          "monaco",
          "monaco-editor"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Unescaped HTML in Monaco Editor hovers allows XSS",
        "fix-suggestion": "Sanitize user-controlled content before providing it to Monaco Editor hover functionality using libraries like `DOMPurify`. Alternatively, disable HTML rendering in hover providers by setting `enableHtmlSupport: false` in the editor configuration. Consider implementing custom hover providers that only render plain text or safely sanitized markdown."
      },
      "languages": [
        "typescript",
        "javascript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "import \"monaco-editor\"\n...\n"
            },
            {
              "pattern-inside": "require(\"monaco-editor\")\n...\n"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern": "{value: $VAL, supportHtml: true}\n"
            },
            {
              "pattern": "{value: $VAL, isTrusted: true}\n"
            }
          ]
        },
        {
          "pattern-inside": "{range: $R, contents: [...]}\n"
        },
        {
          "pattern-not": "{..., value: \"...\", ...}\n"
        }
      ]
    },
    {
      "id": "javascript.node-crypto.security.aead-no-final.aead-no-final",
      "message": "Authentication tag verification is missing in authenticated encryption. Without calling the 'final' method, the integrity of the decrypted data isn't verified, allowing attackers to tamper with encrypted content. Complete the decryption process with the final step for security.",
      "metadata": {
        "cwe": [
          "CWE-310: CWE CATEGORY: Cryptographic Issues"
        ],
        "owasp": [
          "A02:2021 - Cryptographic Failures"
        ],
        "category": "security",
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "node-crypto"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "references": [
          "https://nodejs.org/api/crypto.html#deciphersetauthtagbuffer-encoding",
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Missing authentication verification in encryption",
        "fix-suggestion": "Always call the `final()` method after decryption operations with authenticated modes like GCM. Update your code to include `const plaintext = decipher.update(ciphertext, 'hex', 'utf8') + decipher.final('utf8')` to properly verify the authentication tag."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "patterns": [
        {
          "pattern": "$DECIPHER = $CRYPTO.createDecipheriv('$ALGO', ...)\n...\n$DECIPHER.update(...)\n"
        },
        {
          "pattern-not-inside": "$DECIPHER = $CRYPTO.createDecipheriv('$ALGO', ...)\n...\n$DECIPHER.final(...)\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$ALGO",
            "regex": ".*(-gcm|-ccm|-ocb|chacha20-poly1305)$"
          }
        }
      ]
    },
    {
      "id": "javascript.node-crypto.security.create-de-cipher-no-iv.create-de-cipher-no-iv",
      "message": "Deprecated crypto functions 'createCipher' and 'createDecipher' are used, which generate identical initialization vectors (IVs) for each encryption. This severely weakens encryption, especially in counter modes, allowing attackers to break the encryption if keys are reused. Always use modern methods with explicit IVs.",
      "metadata": {
        "cwe": [
          "CWE-1204: Generation of Weak Initialization Vector (IV)"
        ],
        "category": "security",
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "node-crypto"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "references": [
          "https://nodejs.org/api/crypto.html#cryptocreatecipheralgorithm-password-options",
          "https://nodejs.org/api/crypto.html#cryptocreatedecipheralgorithm-password-options"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Weak encryption with reused initialization vectors",
        "fix-suggestion": "Replace deprecated `createCipher` and `createDecipher` with `createCipheriv` and `createDecipheriv`. Generate a secure random IV with `crypto.randomBytes(16)` and pass it explicitly to these functions along with your encryption key."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$CRYPTO.createCipher(...)\n"
            },
            {
              "pattern": "$CRYPTO.createDecipher(...)\n"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.node-crypto.security.gcm-no-tag-length.gcm-no-tag-length",
      "message": "GCM decryption is missing an explicit authentication tag length. This allows attackers to forge shorter, easier-to-break authentication tags that might be accepted by your application. Always specify the expected tag length for proper security validation.",
      "metadata": {
        "cwe": [
          "CWE-310: CWE CATEGORY: Cryptographic Issues"
        ],
        "owasp": [
          "A02:2021 - Cryptographic Failures"
        ],
        "category": "security",
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "node-crypto"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "references": [
          "https://www.securesystems.de/blog/forging_ciphertexts_under_Galois_Counter_Mode_for_the_Node_js_crypto_module/",
          "https://nodejs.org/api/crypto.html#cryptocreatedecipherivalgorithm-key-iv-options",
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures/"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Missing tag length in GCM encryption mode",
        "fix-suggestion": "Specify the authentication tag length when using GCM mode by setting the `authTagLength` option. Add this parameter to your `createDecipheriv` call with `crypto.createDecipheriv('aes-256-gcm', key, iv, { authTagLength: 16 })` to prevent tag forgery attacks."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "patterns": [
        {
          "pattern": "$CRYPTO.createDecipheriv('$ALGO', $KEY, $IV)\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$ALGO",
            "regex": ".*(-gcm)$"
          }
        }
      ]
    },
    {
      "id": "javascript.node-expat.security.audit.expat-xxe.expat-xxe",
      "message": "The node-expat XML parser is vulnerable to XML External Entity (XXE) attacks when processing untrusted XML that contains external entity declarations. This vulnerability arises because the parser processes DOCTYPE declarations and resolves external entities without restrictions, allowing attackers to reference external resources or local files. Successful exploitation can lead to server-side request forgery (SSRF), sensitive file disclosure, denial of service through resource exhaustion, or information leakage across security boundaries.",
      "metadata": {
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "category": "security",
        "technology": [
          "node-expat"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A05_2021-Security_Misconfiguration"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "Unprotected node-expat parsing can enable XXE",
        "fix-suggestion": "Replace `node-expat` with an XML parser that properly mitigates XXE vulnerabilities, such as `libxmljs2` with external entity resolution disabled. If `node-expat` must be used, pre-process XML to remove DOCTYPE declarations before parsing. Implement validation to reject XML containing DOCTYPE declarations or external entity references."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "var $EXPAT = require('node-expat');\n...\nnew $EXPAT.Parser(...);\n...\n$PARSER.parse(...);\n"
            },
            {
              "pattern": "var $EXPAT = require('node-expat');\n...\nnew $EXPAT.Parser(...);\n...\n$PARSER.write(...);\n"
            },
            {
              "pattern": "require('node-expat');\n...\nnew Parser(...);\n...\n$PARSER.parse(...);\n"
            },
            {
              "pattern": "require('node-expat');\n...\nnew Parser(...);\n...\n$PARSER.write(...);\n"
            }
          ]
        },
        {
          "pattern-not": "var $EXPAT = require('node-expat');\n...\nnew $EXPAT.Parser(...);\n...\n$PARSER.parse(\"...\");\n"
        },
        {
          "pattern-not": "var $EXPAT = require('node-expat');\n...\nnew $EXPAT.Parser(...);\n...\n$PARSER.write(\"...\");\n"
        },
        {
          "pattern-not": "require('node-expat');\n...\nnew Parser(...);\n...\n$PARSER.parse(\"...\");\n"
        },
        {
          "pattern-not": "require('node-expat');\n...\nnew Parser(...);\n...\n$PARSER.write(\"...\");\n"
        },
        {
          "pattern-not": "$X = \"...\";\n...\n$PARSER.parse($X);\n"
        },
        {
          "pattern-not": "$X = \"...\";\n...\n$PARSER.write($X);"
        }
      ]
    },
    {
      "id": "javascript.passport-jwt.security.passport-hardcode.hardcoded-passport-secret",
      "message": "Hardcoding JWT authentication secrets in source code for Passport.js creates a severe security risk when code is accessible to unauthorized parties. Attackers who discover these credentials can forge valid authentication tokens, effectively impersonating legitimate users or accessing protected resources without proper authorization. This vulnerability typically leads to authentication bypass, unauthorized access to protected routes, and potential data breaches across the application.",
      "metadata": {
        "cwe": [
          "CWE-798: Use of Hard-coded Credentials"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html"
        ],
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "asvs": {
          "section": "V3: Session Management Verification Requirements",
          "control_id": "3.5.2 Static API keys or secret",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v35-token-based-session-management",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "jwt",
          "nodejs",
          "secrets"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Hard-coded Secrets"
        ],
        "short-description": "Hardcoded Passport JWT secret is insecure",
        "fix-suggestion": "Remove JWT secrets from source code and move them to environment variables accessed via `process.env.SECRET_KEY`. Utilize secure secret management services like AWS Secrets Manager or HashiCorp Vault for production environments. Use packages like `dotenv` for local development, ensuring the `.env` file is added to `.gitignore`."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "by-side-effect": true,
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "{..., clientSecret: \"...\", ...}\n"
                },
                {
                  "pattern": "{..., secretOrKey: \"...\", ...}\n"
                },
                {
                  "pattern": "{..., consumerSecret: \"...\", ...}\n"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$OBJ = {}\n...\n"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "$OBJ.clientSecret = \"...\"\n"
                        },
                        {
                          "pattern": "$OBJ.secretOrKey = \"...\"\n"
                        },
                        {
                          "pattern": "$OBJ.consumerSecret = \"...\"\n"
                        }
                      ]
                    },
                    {
                      "pattern": "$OBJ"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$SECRET = '...'\n...\n"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "{..., clientSecret: $SECRET, ...}\n"
                        },
                        {
                          "pattern": "{..., secretOrKey: $SECRET, ...}\n"
                        },
                        {
                          "pattern": "{..., consumerSecret: $SECRET, ...}\n"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$SECRET = '...'\n...\n"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$VALUE = {..., clientSecret: $SECRET, ...}\n...\n"
                        },
                        {
                          "pattern-inside": "$VALUE = {..., secretOrKey: $SECRET, ...}\n...\n"
                        },
                        {
                          "pattern-inside": "$VALUE = {..., consumerSecret: $SECRET, ...}\n...\n"
                        }
                      ]
                    },
                    {
                      "pattern": "$VALUE"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$F = require(\"$I\").Strategy\n...\n"
                },
                {
                  "pattern-inside": "$F = require(\"$I\")\n...\n"
                },
                {
                  "pattern-inside": "import { $STRAT as $F } from '$I'\n...\n"
                },
                {
                  "pattern-inside": "import $F from '$I'\n...\n"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$I",
                "regex": "(passport-.*)"
              }
            },
            {
              "pattern-inside": "new $F($VALUE,...)\n"
            },
            {
              "focus-metavariable": "$VALUE"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.phantom.security.audit.phantom-injection.phantom-injection",
      "message": "PhantomJS injection vulnerabilities occur when user-supplied URLs or content is passed to PhantomJS methods without proper validation in Express applications. Since PhantomJS operates as a full browser environment, attackers can exploit this to force the server to make unauthorized network requests to internal or external systems. The resulting Server-Side Request Forgery (SSRF) vulnerability can lead to internal network scanning, data exfiltration, service disruption, or access to restricted systems behind firewalls.",
      "metadata": {
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "category": "security",
        "technology": [
          "phantom"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "PhantomJS calls with untrusted input enable SSRF",
        "fix-suggestion": "Enforce strict validation of URLs before passing them to PhantomJS methods using libraries like `validator`. Create an allowlist of permitted domains and limit protocols to `http` and `https` only. Use `new URL()` for validation and normalization, and implement context-appropriate sanitization for other content passed to PhantomJS."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "$PHANTOM = require('phantom');\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "$PAGE.open($INPUT,...)"
            },
            {
              "pattern": "$PAGE.property(\"content\",$INPUT,...)"
            },
            {
              "pattern": "$PAGE.setContent($INPUT,...)"
            },
            {
              "pattern": "$PAGE.openUrl($INPUT,...)"
            },
            {
              "pattern": "$PAGE.evaluateJavaScript($INPUT,...)"
            }
          ]
        },
        {
          "pattern-not": "$PAGE.open(\"...\",...)"
        },
        {
          "pattern-not": "$PAGE.property(\"content\",\"...\",...)"
        },
        {
          "pattern-not": "$PAGE.setContent(\"...\",...)"
        },
        {
          "pattern-not": "$PAGE.openUrl(\"...\",...)"
        },
        {
          "pattern-not": "$PAGE.evaluateJavaScript(\"...\",...)"
        }
      ]
    },
    {
      "id": "javascript.playwright.security.audit.playwright-addinitscript-code-injection.playwright-addinitscript-code-injection",
      "message": "When untrusted data is passed to Playwright's addInitScript method, attackers can inject JavaScript that executes within the browser context controlled by the automation. This code injection vulnerability gives attackers control over the browser environment, allowing them to manipulate page content, extract sensitive data, or initiate unauthorized network requests. The impact includes potential server-side request forgery (SSRF), data exfiltration, or compromise of any systems accessible to the browser automation service.",
      "metadata": {
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "category": "security",
        "technology": [
          "playwright"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "Untrusted data in addInitScript can allow code injection",
        "fix-suggestion": "Never pass dynamic or user-controlled data to the `addInitScript` method to prevent code injection. Use `page.evaluate()` with properly serialized arguments rather than constructing dynamic scripts. Consider alternatives like `page.setExtraHTTPHeaders()` or isolated browser contexts to manage state instead of script injection."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "require('playwright');\n...\n"
        },
        {
          "pattern-not-inside": "var $INPUT = function $FNAME(...){...};\n...\n"
        },
        {
          "pattern": "$CONTEXT.addInitScript($INPUT,...)"
        },
        {
          "pattern-not": "$CONTEXT.addInitScript(\"...\",...)"
        },
        {
          "pattern-not": "$CONTEXT.addInitScript(function(...){...},...)"
        }
      ]
    },
    {
      "id": "javascript.playwright.security.audit.playwright-evaluate-arg-injection.playwright-evaluate-arg-injection",
      "message": "Playwright evaluate() method becomes vulnerable when user-supplied input is passed as arguments to the evaluated functions without proper validation. While these arguments aren't directly executed as code, they become accessible within the browser context and can be used to influence the behavior of executed JavaScript. This can lead to information disclosure, manipulation of automated processes, or server-side request forgery (SSRF) by forcing the browser to access unauthorized resources based on the attacker's input.",
      "metadata": {
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "category": "security",
        "technology": [
          "playwright"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "Evaluate method with user input risks SSRF or script injection",
        "fix-suggestion": "Implement thorough validation of user input before passing it as arguments to `evaluate()`. Create a validation function that verifies input against expected formats and types. Keep sensitive operations in the Node.js context rather than browser context, and consider using `page.exposeFunction()` for safer communication between contexts."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "require('playwright');\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "function $FUNC (...,$INPUT,...) {...}"
            },
            {
              "pattern-inside": "function (...,$INPUT,...) {...}"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern": "$PAGE.evaluate($CODE,...,<... $INPUT ...>,...)"
            },
            {
              "pattern": "$PAGE.evaluateHandle($CODE,...,<... $INPUT ...>,...)"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.playwright.security.audit.playwright-evaluate-code-injection.playwright-evaluate-code-injection",
      "message": "Playwright's evaluate() method executes JavaScript code within the browser context, creating a severe vulnerability when this code incorporates unsanitized user input. When attackers control portions of the evaluated code, they can execute arbitrary JavaScript within the browser automation environment, potentially accessing sensitive page content or making unauthorized network requests. This vulnerability typically leads to server-side request forgery (SSRF), information disclosure, or manipulation of automated workflows that rely on the browser automation.",
      "metadata": {
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "category": "security",
        "technology": [
          "playwright"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "Passing dynamic code to evaluate can lead to SSRF or injection",
        "fix-suggestion": "Avoid constructing function strings for `evaluate()` using string concatenation or template literals with user input. Use fixed function strings and pass user data as separate arguments through the second parameter. For dynamic operations, create predefined functions with conditional logic rather than dynamically generating code."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "require('playwright');\n...\n"
        },
        {
          "pattern-not-inside": "var $INPUT = function $FNAME(...){...};\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "$PAGE.evaluate($INPUT,...)"
            },
            {
              "pattern": "$PAGE.evaluateHandle($INPUT,...)"
            },
            {
              "pattern": "$PAGE.evaluateOnNewDocument($INPUT,...)"
            }
          ]
        },
        {
          "pattern-not": "$PAGE.evaluate(\"...\",...)"
        },
        {
          "pattern-not": "$PAGE.evaluate(function(...){...},...)"
        },
        {
          "pattern-not": "$PAGE.evaluateHandle(\"...\",...)"
        },
        {
          "pattern-not": "$PAGE.evaluateHandle(function(...){...},...)"
        },
        {
          "pattern-not": "$PAGE.evaluateOnNewDocument(\"...\",...)"
        },
        {
          "pattern-not": "$PAGE.evaluateOnNewDocument(function(...){...},...)"
        }
      ]
    },
    {
      "id": "javascript.playwright.security.audit.playwright-exposed-chrome-devtools.playwright-exposed-chrome-devtools",
      "message": "Exposing the Chrome DevTools Protocol without authentication allows unauthorized remote control of browser instances managed by Playwright. This misconfiguration provides attackers with full programmatic access to the browser, allowing them to monitor interactions, extract sensitive data, or execute arbitrary JavaScript. The impact includes potential data theft, session hijacking, or compromise of any systems and resources accessible through the browser automation service.",
      "metadata": {
        "owasp": [
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "category": "security",
        "technology": [
          "playwright"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Unprotected remote debugging protocol allows unauthorized access",
        "fix-suggestion": "Disable remote debugging by removing the `--remote-debugging-port` flag when launching the browser. If debugging is required, restrict access with `--remote-debugging-address=127.0.0.1` and implement network-level controls like firewall rules. Never expose debugging ports in production environments as they provide full browser control."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "require('playwright');\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern-regex": "--remote-debugging-address"
            },
            {
              "pattern-regex": "--remote-debugging-port"
            },
            {
              "pattern-regex": "--remote-debugging-socket-name"
            },
            {
              "pattern-regex": "--remote-debugging-targets"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.playwright.security.audit.playwright-goto-injection.playwright-goto-injection",
      "message": "The goto() method in Playwright creates a security vulnerability when attacker-controlled URLs are passed without proper validation or restriction. This allows attackers to direct the automated browser to malicious sites or internal network resources that should not be accessible. The resulting server-side request forgery (SSRF) vulnerability can be exploited to scan internal networks, access restricted services, exfiltrate data, or leverage the server's identity to reach normally inaccessible systems.",
      "metadata": {
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "category": "security",
        "technology": [
          "playwright"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "Unvalidated user-provided URL in goto can cause SSRF",
        "fix-suggestion": "Implement thorough URL validation before passing URLs to `goto()` using the `URL` class and an allowlist of permitted domains. Restrict protocols to only `http/https` and consider a URL proxy service for dynamic destinations. Set appropriate timeout and navigation options to limit exposure if navigation to an unexpected location occurs."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "require('playwright');\n...\n"
        },
        {
          "pattern-not-inside": "require('playwright');\n...\nvar $INPUT = \"...\";\n...\n$PAGE.goto($INPUT,...)\n"
        },
        {
          "pattern": "$PAGE.goto($INPUT,...)"
        },
        {
          "pattern-not": "$PAGE.goto(\"...\",...)"
        }
      ]
    },
    {
      "id": "javascript.playwright.security.audit.playwright-setcontent-injection.playwright-setcontent-injection",
      "message": "Playwright's setContent() method becomes vulnerable when rendering HTML content that includes unvalidated user input. Since the content is rendered in a full browser environment, attackers can inject malicious HTML or JavaScript that executes within the context of the automated browser. This can lead to server-side request forgery (SSRF) by forcing unauthorized network requests, data exfiltration, or manipulation of automated processes that depend on the browser's content.",
      "metadata": {
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "category": "security",
        "technology": [
          "playwright"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "setContent with user input allows SSRF or script injection",
        "fix-suggestion": "Sanitize HTML content before passing it to `setContent()` using libraries like `DOMPurify` with appropriate configuration. Implement Content Security Policy headers for additional protection against XSS attacks. Consider using a markdown renderer with safe defaults instead of raw HTML for user-generated content."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "require('playwright');\n...\n"
        },
        {
          "pattern-not-inside": "require('playwright');\n...\nvar $INPUT = \"...\";\n...\n$PAGE.setContent($INPUT,...)\n"
        },
        {
          "pattern": "$PAGE.setContent($INPUT,...)"
        },
        {
          "pattern-not": "$PAGE.setContent(\"...\",...)"
        }
      ]
    },
    {
      "id": "javascript.puppeteer.security.audit.puppeteer-evaluate-arg-injection.puppeteer-evaluate-arg-injection",
      "message": "When user-supplied input is passed as arguments to Puppeteer's evaluate() method, attackers can influence the behavior of JavaScript executed in the browser context. Although these inputs aren't directly executed as code, they can be used within the evaluated function to trigger unauthorized actions or network requests. This can lead to server-side request forgery (SSRF), data leakage, or manipulation of automated processes through the controlled browser environment.",
      "metadata": {
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "category": "security",
        "technology": [
          "puppeteer"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "Unsanitized user data to evaluate can cause SSRF or injection",
        "fix-suggestion": "Apply strict validation to user input before passing it as arguments to Puppeteer's `evaluate()`. Validate data types, formats, and content against expected patterns before sending to the browser context. Keep sensitive operations in the Node.js context rather than the browser to minimize exposure to potentially harmful data."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "require('puppeteer');\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "function $FUNC (...,$INPUT,...) {...}"
            },
            {
              "pattern-inside": "function (...,$INPUT,...) {...}"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern": "$PAGE.evaluate($CODE,...,<... $INPUT ...>,...)"
            },
            {
              "pattern": "$PAGE.evaluateHandle($CODE,...,<... $INPUT ...>,...)"
            },
            {
              "pattern": "$PAGE.evaluateOnNewDocument($CODE,...,<... $INPUT ...>,...)"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.puppeteer.security.audit.puppeteer-evaluate-code-injection.puppeteer-evaluate-code-injection",
      "message": "Puppeteer's evaluate() method creates a serious vulnerability when the JavaScript code string incorporates unsanitized user input. Since this code executes within a real browser environment, attackers who can influence the evaluated code can execute arbitrary JavaScript, potentially accessing sensitive page content or making unauthorized network requests. The impact includes server-side request forgery (SSRF), information disclosure, or manipulation of automated browser workflows with potential access to internal networks or services.",
      "metadata": {
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "category": "security",
        "technology": [
          "puppeteer"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "User-supplied code in Puppeteer evaluate leads to SSRF",
        "fix-suggestion": "Never construct function strings dynamically for `evaluate()` by concatenating user input. Use fixed function strings and pass user data as separate arguments through the second parameter. Create predefined functions with conditional branches rather than generating dynamic code, and consider using `page.exposeFunction()` for safer communication."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "require('puppeteer');\n...\n"
        },
        {
          "pattern-not-inside": "var $INPUT = function $FNAME(...){...};\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "$PAGE.evaluate($INPUT,...)"
            },
            {
              "pattern": "$PAGE.evaluateHandle($INPUT,...)"
            },
            {
              "pattern": "$PAGE.evaluateOnNewDocument($INPUT,...)"
            }
          ]
        },
        {
          "pattern-not": "$PAGE.evaluate(\"...\",...)"
        },
        {
          "pattern-not": "$PAGE.evaluate(function(...){...},...)"
        },
        {
          "pattern-not": "$PAGE.evaluateHandle(\"...\",...)"
        },
        {
          "pattern-not": "$PAGE.evaluateHandle(function(...){...},...)"
        },
        {
          "pattern-not": "$PAGE.evaluateOnNewDocument(\"...\",...)"
        },
        {
          "pattern-not": "$PAGE.evaluateOnNewDocument(function(...){...},...)"
        }
      ]
    },
    {
      "id": "javascript.puppeteer.security.audit.puppeteer-exposed-chrome-devtools.puppeteer-exposed-chrome-devtools",
      "message": "Exposing the Chrome DevTools Protocol endpoint without authentication allows unauthorized remote control of Puppeteer browser instances. This misconfiguration gives attackers complete programmatic access to the browser, enabling them to execute arbitrary JavaScript, extract sensitive data, or make unauthorized network requests. The impact includes potential data theft, credential harvesting, or unauthorized access to internal systems through the browser automation service's network privileges.",
      "metadata": {
        "owasp": [
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "category": "security",
        "technology": [
          "puppeteer"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Exposed DevTools protocol without auth allows remote control",
        "fix-suggestion": "Launch Puppeteer with `devtools: false` to prevent remote debugging exposure. If debugging is needed for development, restrict access to localhost using `--remote-debugging-address=127.0.0.1`. Implement network controls like firewalls to prevent external access to debugging ports and never enable these features in production."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "require('puppeteer');\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern-regex": "--remote-debugging-address"
            },
            {
              "pattern-regex": "--remote-debugging-port"
            },
            {
              "pattern-regex": "--remote-debugging-socket-name"
            },
            {
              "pattern-regex": "--remote-debugging-targets"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.puppeteer.security.audit.puppeteer-goto-injection.puppeteer-goto-injection",
      "message": "Puppeteer's goto() method creates a security risk when navigating to URLs derived from unvalidated user input. This vulnerability allows attackers to direct the server-controlled browser to malicious websites or internal network resources that should remain inaccessible. The resulting server-side request forgery (SSRF) can be exploited to probe internal networks, access restricted services, or exfiltrate data by leveraging the server's network position and identity.",
      "metadata": {
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "category": "security",
        "technology": [
          "puppeteer"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "Goto with unvalidated user URL can cause SSRF",
        "fix-suggestion": "Validate all URLs before passing them to Puppeteer's `goto()` method using the `URL` class and a whitelist of allowed domains. Limit protocols to only `http/https` and consider implementing a server-side proxy for dynamic destinations. Set appropriate timeout and navigation options to minimize impact of unexpected navigation."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "require('puppeteer');\n...\n"
        },
        {
          "pattern-not-inside": "require('puppeteer');\n...\nvar $INPUT = \"...\";\n...\n$PAGE.goto($INPUT,...)\n"
        },
        {
          "pattern": "$PAGE.goto($INPUT,...)"
        },
        {
          "pattern-not": "$PAGE.goto(\"...\",...)"
        }
      ]
    },
    {
      "id": "javascript.puppeteer.security.audit.puppeteer-setcontent-injection.puppeteer-setcontent-injection",
      "message": "Using unverified input with Puppeteer's setContent() method creates a vulnerability where malicious HTML or JavaScript is rendered in a full browser environment. When this content executes, it can force the browser to make unauthorized network requests to internal or external systems. This server-side request forgery (SSRF) vulnerability allows attackers to scan internal networks, access restricted services, or exfiltrate data by exploiting the server's network position.",
      "metadata": {
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "category": "security",
        "technology": [
          "puppeteer"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "Setting untrusted content can lead to SSRF or code injection",
        "fix-suggestion": "Sanitize HTML content before using `setContent()` with libraries like `DOMPurify` and appropriate configuration options. Implement Content Security Policy restrictions in the content being set. For user-generated content, consider safer alternatives like markdown rendering instead of raw HTML."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "require('puppeteer');\n...\n"
        },
        {
          "pattern-not-inside": "require('puppeteer');\n...\nvar $INPUT = \"...\";\n...\n"
        },
        {
          "pattern": "$PAGE.setContent($INPUT,...)"
        },
        {
          "pattern-not": "$PAGE.setContent(\"...\",...)"
        }
      ]
    },
    {
      "id": "javascript.sandbox.security.audit.sandbox-code-injection.sandbox-code-injection",
      "message": "Code injection in sandbox functions occurs when untrusted user input is executed within the isolated environment without proper validation. Despite the sandbox's isolation, attackers can exploit this vulnerability to execute arbitrary code within the constraints of the sandbox environment. This can lead to privilege escalation, sandbox escape, or access to sensitive information that was intended to be protected by the sandbox boundaries.",
      "metadata": {
        "owasp": [
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "category": "security",
        "technology": [
          "sandbox"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Running user input in sandbox can still allow code injection",
        "fix-suggestion": "Avoid executing user-controlled input in sandbox environments to prevent escape vulnerabilities. If execution is necessary, implement strict validation using a whitelist approach and run with minimal privileges in an isolated process. Consider configuration-based approaches instead of dynamic code execution and set appropriate resource limits."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "$SANDBOX = require('sandbox');\n...\n"
        },
        {
          "pattern-not-inside": "$CODE = \"...\";\n...\n"
        },
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-inside": "$S = new $SANDBOX(...);\n...\n"
                },
                {
                  "pattern": "$S.run($CODE,...);"
                }
              ]
            },
            {
              "pattern": "new $SANDBOX(...).run($CODE,...);\n"
            }
          ]
        },
        {
          "pattern-not-inside": "$S = new $SANDBOX(...);\n...\n$S.run(\"...\",...);\n"
        },
        {
          "pattern-not-inside": "new $SANDBOX(...).run(\"...\",...);"
        }
      ]
    },
    {
      "id": "javascript.sax.security.audit.sax-xxe.sax-xxe",
      "message": "XML External Entity (XXE) vulnerabilities in the sax library arise when custom DTD entities from untrusted sources are processed without restrictions. This occurs because the parser resolves external entity references in the XML document, allowing attackers to access local files or make network requests from the server. The consequences include sensitive file disclosure, server-side request forgery, denial of service attacks, or potentially remote code execution depending on the system configuration.",
      "metadata": {
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "references": [
          "https://github.com/Leonidas-from-XIV/node-xml2js/issues/415",
          "https://github.com/isaacs/sax-js"
        ],
        "category": "security",
        "technology": [
          "sax"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "Untrusted SAX parsing can lead to XXE vulnerabilities",
        "fix-suggestion": "Configure SAX parsers to disable DTD processing and external entity resolution to prevent XXE attacks. Set the `xmlns` parameter to `true` when using the `sax` module to enable namespace processing. Consider using alternative parsers like `saxes` with safer defaults or preprocess XML to remove DOCTYPE declarations."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "require('sax');\n...\n$PARSER.ondoctype = ...;\n"
        },
        {
          "pattern": "require('sax');\n...\n$PARSER.on('doctype',...);"
        }
      ]
    },
    {
      "id": "javascript.sequelize.security.audit.sequelize-enforce-tls.sequelize-enforce-tls",
      "message": "Sequelize connections don't enforce TLS encryption for database communication. If the server has TLS disabled, Sequelize silently establishes an unencrypted connection, making your data vulnerable to interception. Always enforce TLS for database connections in production environments.",
      "metadata": {
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "references": [
          "https://node-postgres.com/features/ssl",
          "https://nodejs.org/api/tls.html#tls_class_tls_tlssocket",
          "https://nodejs.org/api/tls.html#tls_tls_createsecurecontext_options",
          "https://nodejs.org/api/tls.html#tls_tls_default_min_version"
        ],
        "category": "security",
        "technology": [
          "sequelize"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Database connections not enforcing encryption",
        "fix-suggestion": "Enable TLS enforcement in your Sequelize connection options by adding `ssl: true` to the connection configuration. For more control, use `ssl: { require: true, rejectUnauthorized: true }` to ensure secure, verified connections to your database."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern": "{\n  host: $HOST,\n  database: $DATABASE,\n  dialect: $DIALECT\n }\n"
        },
        {
          "pattern-not": "{\n  host: $HOST,\n  database: $DATABASE,\n  dialect: \"postgres\",\n  dialectOptions: {\n      ssl: true\n  }\n}\n"
        },
        {
          "pattern-not": "{\n  host: $HOST,\n  database: $DATABASE,\n  dialect: $DIALECT,\n  dialectOptions: {\n    ssl: { ... }\n  }\n}\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$DIALECT",
            "regex": "['\"](mariadb|mysql|postgres)['\"]"
          }
        }
      ]
    },
    {
      "id": "javascript.sequelize.security.audit.sequelize-tls-disabled-cert-validation.sequelize-tls-disabled-cert-validation",
      "message": "Setting rejectUnauthorized to false in Sequelize database connections disables SSL certificate validation, undermining transport layer security. This configuration bypass creates vulnerability to man-in-the-middle attacks where malicious actors can intercept, monitor, or modify data between your application and the database server. The compromise can lead to data theft, credential interception, or database manipulation without detection since the application accepts any certificate, including those from attackers.",
      "metadata": {
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://node-postgres.com/features/ssl",
          "https://nodejs.org/api/tls.html#tls_class_tls_tlssocket",
          "https://nodejs.org/api/tls.html#tls_tls_createsecurecontext_options"
        ],
        "category": "security",
        "technology": [
          "sequelize"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "TLS cert validation disabled, allowing MITM attacks",
        "fix-suggestion": "Remove any configuration with `rejectUnauthorized: false` from Sequelize database connection options. Configure proper TLS with valid certificates for database servers. For development with self-signed certificates, set up a proper certificate authority instead of disabling verification."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "patterns": [
        {
          "pattern": "{\n  host: $HOST,\n  database: $DATABASE,\n  dialect: $DIALECT,\n  dialectOptions: {\n    ssl: {\n      rejectUnauthorized: false\n    }\n  }\n }\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$DIALECT",
            "regex": "['\"](mariadb|mysql|postgres)['\"]"
          }
        }
      ]
    },
    {
      "id": "javascript.sequelize.security.audit.sequelize-weak-tls-version.sequelize-weak-tls-version",
      "message": "Sequelize is configured with outdated TLS protocol versions. TLS 1.0 and 1.1 contain known vulnerabilities and have been deprecated. Using these protocols leaves database connections vulnerable to various attacks. Always use modern TLS versions for secure communications.",
      "metadata": {
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "references": [
          "https://node-postgres.com/features/ssl",
          "https://nodejs.org/api/tls.html#tls_class_tls_tlssocket",
          "https://nodejs.org/api/tls.html#tls_tls_createsecurecontext_options",
          "https://nodejs.org/api/tls.html#tls_tls_default_min_version"
        ],
        "category": "security",
        "technology": [
          "sequelize"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Outdated TLS protocol version for database",
        "fix-suggestion": "Update your Sequelize SSL configuration to enforce TLS 1.2 or higher. In the connection options, set `dialectOptions: { ssl: { minVersion: 'TLSv1.2' } }` to ensure that only secure TLS versions are allowed for database connections."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "{\n  host: $HOST,\n  database: $DATABASE,\n  dialect: $DIALECT,\n  dialectOptions:\n    { ssl: ... }\n }\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "{\n  minVersion: 'TLSv1'\n}\n"
            },
            {
              "pattern": "{\n  minVersion: 'TLSv1.1'\n}\n"
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$DIALECT",
            "regex": "['\"](mariadb|mysql|postgres)['\"]"
          }
        }
      ]
    },
    {
      "id": "javascript.sequelize.security.audit.sequelize-injection-express.express-sequelize-injection",
      "message": "SQL injection in Express with Sequelize occurs when raw queries incorporate user input directly instead of using parameterized queries or proper ORM methods. Despite using an ORM, developers sometimes bypass its security features by constructing queries with string concatenation or interpolation involving untrusted data. This vulnerability allows attackers to manipulate query structure and execute unauthorized operations, potentially leading to data theft, authentication bypass, or complete database compromise.",
      "options": {
        "interfile": true
      },
      "metadata": {
        "interfile": true,
        "references": [
          "https://sequelize.org/docs/v6/core-concepts/raw-queries/#replacements"
        ],
        "category": "security",
        "technology": [
          "express"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "HIGH",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Express-based Sequelize query with user input fosters injection",
        "fix-suggestion": "Use Sequelize's parameterization features instead of string concatenation in queries: `sequelize.query('SELECT * FROM users WHERE status = ?', { replacements: [status] })`. For dynamic column or table references, validate names against a whitelist of allowed values. Leverage Sequelize's ORM methods which automatically handle parameter escaping."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ... ($REQ, $RES) {...}"
                },
                {
                  "pattern-inside": "function ... ($REQ, $RES, $NEXT) {...}"
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES) {...})"
                        },
                        {
                          "pattern-inside": "$APP.$METHOD(..., function $FUNC($REQ, $RES, $NEXT) {...})"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "^(get|post|put|head|delete|options)$"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$REQ.query"
                },
                {
                  "pattern": "$REQ.body"
                },
                {
                  "pattern": "$REQ.params"
                },
                {
                  "pattern": "$REQ.cookies"
                },
                {
                  "pattern": "$REQ.headers"
                },
                {
                  "pattern": "$REQ.files.$ANYTHING.data.toString('utf8')"
                },
                {
                  "pattern": "$REQ.files.$ANYTHING['data'].toString('utf8')"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response, $NEXT: NextFunction) =>\n{...}\n"
                },
                {
                  "pattern-inside": "({ $REQ }: Request,$RES: Response) => {...}\n"
                }
              ]
            },
            {
              "focus-metavariable": "$REQ"
            },
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "query"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "headers"
                },
                {
                  "pattern": "body"
                },
                {
                  "pattern": "files.$ANYTHING.data.toString('utf8')"
                },
                {
                  "pattern": "files.$ANYTHING['data'].toString('utf8')"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "sequelize.query($QUERY,...)"
                    },
                    {
                      "pattern": "$DB.sequelize.query($QUERY,...)"
                    }
                  ]
                },
                {
                  "focus-metavariable": "$QUERY"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "pattern-either": [
            {
              "pattern": "parseInt(...)"
            },
            {
              "pattern": "$FUNC. ... .hash(...)"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.serialize-javascript.security.audit.unsafe-serialize-javascript.unsafe-serialize-javascript",
      "message": "The 'serialize-javascript' library is used with the 'unsafe' parameter enabled. This bypasses HTML escaping and sanitization, creating a Cross-Site Scripting (XSS) vulnerability. Malicious JavaScript in serialized data could be executed when rendered in the browser.",
      "metadata": {
        "owasp": [
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-80: Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS)"
        ],
        "category": "security",
        "technology": [
          "serialize-javascript"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Unsafe serialization enables XSS attacks",
        "fix-suggestion": "Remove the `unsafe: true` option from calls to `serialize()`. If you need to serialize functions, use the safer options like `serialize(data, { space: 2 })` without the unsafe flag, which will properly escape HTML characters in the output."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "$S = require('serialize-javascript');\n...\n"
        },
        {
          "pattern-not-inside": "escape(...)"
        },
        {
          "pattern-not-inside": "encodeURI(...)"
        },
        {
          "pattern": "$S(..., {unsafe: true});\n"
        }
      ]
    },
    {
      "id": "javascript.shelljs.security.shelljs-exec-injection.shelljs-exec-injection",
      "message": "Command injection in ShellJS occurs when the exec() function processes commands that include unsanitized user input. Since ShellJS executes commands through the system shell, special characters in the input can be interpreted as command separators or modifiers, allowing attackers to inject additional unauthorized commands. This vulnerability can lead to remote code execution on the host system with the privileges of the application process, potentially resulting in complete system compromise.",
      "metadata": {
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "category": "security",
        "technology": [
          "shelljs"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "ShellJS exec with untrusted data can result in command injection",
        "fix-suggestion": "Avoid passing user input directly to `shelljs.exec()` to prevent command injection. Implement strict validation using a whitelist approach and leverage shelljs's built-in quote functionality for proper escaping. Consider alternatives that don't require shell execution, such as native Node.js functions."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "ERROR",
      "patterns": [
        {
          "pattern-inside": "require('shelljs');\n...\n"
        },
        {
          "pattern-not-inside": "require('shelljs');\n...\nvar $INPUT = \"...\";\n...\n"
        },
        {
          "pattern": "$SHELL.exec($INPUT,...)"
        },
        {
          "pattern-not": "$SHELL.exec(\"...\",...)"
        }
      ]
    },
    {
      "id": "javascript.thenify.security.audit.multiargs-code-execution.multiargs-code-execution",
      "message": "Code execution vulnerabilities in thenify arise when multiple dynamic arguments are passed to eval() functions within the library. When these arguments contain attacker-controlled data, malicious code can be constructed and executed during the evaluation process. The impact includes potential remote code execution, data theft, or privilege escalation within the application environment, depending on the context where the vulnerability exists.",
      "metadata": {
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "thenify"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Passing multiple dynamic arguments into eval can allow code execution",
        "fix-suggestion": "Update to the latest version of the `thenify` library that has fixed the code execution vulnerability. If updating isn't possible, avoid passing untrusted data as arguments to functions processed by thenify. Consider using alternative promise conversion utilities like `util.promisify` from Node.js core."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$THENIFY($FN, {multiArgs: ...},...)\n"
            },
            {
              "pattern": "$OPTS = {multiArgs: ...};\n...\n$THENIFY($FN,$OPTS,...);\n"
            }
          ]
        },
        {
          "pattern-not": "$THENIFY($FN, {multiArgs: false},...)\n"
        },
        {
          "pattern-not": "$OPTS = {multiArgs: false};\n...\n$THENIFY($FN,$OPTS,...)\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "$THENIFY = require('thenify');\n...\n"
            },
            {
              "pattern-inside": "import 'thenify';\n...\n"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.vm2.security.audit.vm2-code-injection.vm2-code-injection",
      "message": "Code injection in vm2 occurs when untrusted user input is executed within the virtual machine environment without proper validation or sandboxing. Despite vm2's sandboxing features, various sandbox escape techniques can be exploited if user-controlled code is directly executed. This vulnerability can lead to arbitrary code execution outside the sandbox context, potentially compromising the host system or accessing data intended to be inaccessible to the sandboxed code.",
      "metadata": {
        "owasp": [
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "category": "security",
        "technology": [
          "vm2"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "vm2 usage with untrusted data can run arbitrary code",
        "fix-suggestion": "Never run user-controlled code within `vm2` sandboxes as sandbox escape vulnerabilities are frequently discovered. If code execution is necessary, implement strict validation, run with minimal privileges in a separate process. Set appropriate timeout and memory limits and consider configuration-driven approaches instead."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "require('vm2');\n...\n"
        },
        {
          "pattern-not-inside": "$CODE = \"...\";\n...\n"
        },
        {
          "pattern-not-inside": "require('vm2');\n...\n$CODE = new VMScript(...);\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "$VM = new VM(...);\n...\n$VM.run($CODE,...);\n"
            },
            {
              "pattern": "new VM(...).run($CODE,...);\n"
            },
            {
              "pattern": "$VM = new NodeVM(...);\n...\n$VM.run($CODE,...);\n"
            },
            {
              "pattern": "new NodeVM(...).run($CODE,...);\n"
            },
            {
              "pattern": "new VMScript($CODE,...);\n"
            }
          ]
        },
        {
          "pattern-not": "$VM = new VM(...);\n...\n$VM.run(\"...\",...);\n"
        },
        {
          "pattern-not": "$VM = new NodeVM(...);\n...\n$VM.run(\"...\",...);\n"
        },
        {
          "pattern-not": "(new VM(...)).run(\"...\",...);\n"
        },
        {
          "pattern-not": "(new NodeVM(...)).run(\"...\",...);\n"
        },
        {
          "pattern-not": "new VMScript(\"...\",...);"
        }
      ]
    },
    {
      "id": "javascript.vm2.security.audit.vm2-context-injection.vm2-context-injection",
      "message": "Context injection vulnerabilities in vm2 arise when untrusted data influences the execution context of code running in the virtual machine. By manipulating the context, attackers can potentially modify object prototypes, inject malicious functions, or create conditions for sandbox escape. The consequence can be arbitrary code execution outside the intended sandbox boundaries, compromising application security despite the use of vm2's isolation mechanisms.",
      "metadata": {
        "owasp": [
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "category": "security",
        "technology": [
          "vm2"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Injecting unverified data into vm2 context risks code execution",
        "fix-suggestion": "Restrict what objects and properties are made available to the `vm2` context to prevent prototype escape vectors. Create a minimal, sanitized context with only specific values and functions needed. Avoid exposing sensitive functionality and consider using a configuration-driven system instead of executing dynamic code."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "$VM = require('vm2');\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "function (...,$INPUT,...) {\n  ...\n  new VM({sandbox: <... $INPUT ...>},...);\n  ...\n}\n"
            },
            {
              "pattern": "function (...,$INPUT,...) {\n  ...\n  $CONTEXT = <... $INPUT ...>;\n  ...\n  new VM({sandbox: <... $CONTEXT ...>},...);\n  ...\n}\n"
            },
            {
              "pattern": "function (...,$INPUT,...) {\n  ...\n  $CONTEXT = <... {$NAME:$INPUT} ...>;\n  ...\n  new VM({sandbox: <... $CONTEXT ...>},...);\n  ...\n}\n"
            },
            {
              "pattern": "function (...,$INPUT,...) {\n  ...\n  $CONTEXT = {$NAME: <... $INPUT ...>};\n  ...\n  new VM({sandbox: <... $CONTEXT ...>},...);\n  ...\n}\n"
            },
            {
              "pattern": "function (...,$INPUT,...) {\n  ...\n  $VAR = <... $INPUT ...>;\n  ...\n  $CONTEXT = {$NAME: <... $VAR ...>};\n  ...\n  new VM({sandbox: <... $CONTEXT ...>},...);\n  ...\n}\n"
            },
            {
              "pattern": "function (...,$INPUT,...) {\n  ...\n  $OPTS = {sandbox: <... $INPUT ...>};\n  ...\n  new VM($OPTS,...);\n  ...\n}\n"
            },
            {
              "pattern": "function (...,$INPUT,...) {\n  ...\n  $CONTEXT = <... $INPUT ...>;\n  ...\n  $OPTS = {sandbox: <... $CONTEXT ...>};\n  ...\n  new VM($OPTS,...);\n  ...\n}\n"
            },
            {
              "pattern": "function (...,$INPUT,...) {\n  ...\n  $CONTEXT = {$NAME: <... $INPUT ...>};\n  ...\n  $OPTS = {sandbox: <... $CONTEXT ...>};\n  ...\n  new VM($OPTS,...);\n  ...\n}\n"
            },
            {
              "pattern": "function (...,$INPUT,...) {\n  ...\n  $VAR = <... $INPUT ...>;\n  ...\n  $CONTEXT = {$NAME: <... $VAR ...>};\n  ...\n  $OPTS = {sandbox: <... $CONTEXT ...>};\n  ...\n  new VM($OPTS,...);\n  ...\n}\n"
            },
            {
              "pattern": "function $F(...,$INPUT,...) {\n  ...\n  new VM({sandbox: <... $INPUT ...>},...);\n  ...\n}\n"
            },
            {
              "pattern": "function $F(...,$INPUT,...) {\n  ...\n  $CONTEXT = <... $INPUT ...>;\n  ...\n  new VM({sandbox: <... $CONTEXT ...>},...);\n  ...\n}\n"
            },
            {
              "pattern": "function $F(...,$INPUT,...) {\n  ...\n  $CONTEXT = <... {$NAME:$INPUT} ...>;\n  ...\n  new VM({sandbox: <... $CONTEXT ...>},...);\n  ...\n}\n"
            },
            {
              "pattern": "function $F(...,$INPUT,...) {\n  ...\n  $CONTEXT = {$NAME: <... $INPUT ...>};\n  ...\n  new VM({sandbox: <... $CONTEXT ...>},...);\n  ...\n}\n"
            },
            {
              "pattern": "function $F(...,$INPUT,...) {\n  ...\n  $VAR = <... $INPUT ...>;\n  ...\n  $CONTEXT = {$NAME: <... $VAR ...>};\n  ...\n  new VM({sandbox: <... $CONTEXT ...>},...);\n  ...\n}\n"
            },
            {
              "pattern": "function $F(...,$INPUT,...) {\n  ...\n  $OPTS = {sandbox: <... $INPUT ...>};\n  ...\n  new VM($OPTS,...);\n  ...\n}\n"
            },
            {
              "pattern": "function $F(...,$INPUT,...) {\n  ...\n  $CONTEXT = <... $INPUT ...>;\n  ...\n  $OPTS = {sandbox: <... $CONTEXT ...>};\n  ...\n  new VM($OPTS,...);\n  ...\n}\n"
            },
            {
              "pattern": "function $F(...,$INPUT,...) {\n  ...\n  $CONTEXT = {$NAME: <... $INPUT ...>};\n  ...\n  $OPTS = {sandbox: <... $CONTEXT ...>};\n  ...\n  new VM($OPTS,...);\n  ...\n}\n"
            },
            {
              "pattern": "function $F(...,$INPUT,...) {\n  ...\n  $VAR = <... $INPUT ...>;\n  ...\n  $CONTEXT = {$NAME: <... $VAR ...>};\n  ...\n  $OPTS = {sandbox: <... $CONTEXT ...>};\n  ...\n  new VM($OPTS,...);\n  ...\n}\n"
            },
            {
              "pattern": "function (...,$INPUT,...) {\n  ...\n  new NodeVM({sandbox: <... $INPUT ...>},...);\n  ...\n}\n"
            },
            {
              "pattern": "function (...,$INPUT,...) {\n  ...\n  $CONTEXT = <... $INPUT ...>;\n  ...\n  new NodeVM({sandbox: <... $CONTEXT ...>},...);\n  ...\n}\n"
            },
            {
              "pattern": "function (...,$INPUT,...) {\n  ...\n  $CONTEXT = <... {$NAME:$INPUT} ...>;\n  ...\n  new NodeVM({sandbox: <... $CONTEXT ...>},...);\n  ...\n}\n"
            },
            {
              "pattern": "function (...,$INPUT,...) {\n  ...\n  $CONTEXT = {$NAME: <... $INPUT ...>};\n  ...\n  new NodeVM({sandbox: <... $CONTEXT ...>},...);\n  ...\n}\n"
            },
            {
              "pattern": "function (...,$INPUT,...) {\n  ...\n  $VAR = <... $INPUT ...>;\n  ...\n  $CONTEXT = {$NAME: <... $VAR ...>};\n  ...\n  new NodeVM({sandbox: <... $CONTEXT ...>},...);\n  ...\n}\n"
            },
            {
              "pattern": "function (...,$INPUT,...) {\n  ...\n  $OPTS = {sandbox: <... $INPUT ...>};\n  ...\n  new NodeVM($OPTS,...);\n  ...\n}\n"
            },
            {
              "pattern": "function (...,$INPUT,...) {\n  ...\n  $CONTEXT = <... $INPUT ...>;\n  ...\n  $OPTS = {sandbox: <... $CONTEXT ...>};\n  ...\n  new NodeVM($OPTS,...);\n  ...\n}\n"
            },
            {
              "pattern": "function (...,$INPUT,...) {\n  ...\n  $CONTEXT = {$NAME: <... $INPUT ...>};\n  ...\n  $OPTS = {sandbox: <... $CONTEXT ...>};\n  ...\n  new NodeVM($OPTS,...);\n  ...\n}\n"
            },
            {
              "pattern": "function (...,$INPUT,...) {\n  ...\n  $VAR = <... $INPUT ...>;\n  ...\n  $CONTEXT = {$NAME: <... $VAR ...>};\n  ...\n  $OPTS = {sandbox: <... $CONTEXT ...>};\n  ...\n  new NodeVM($OPTS,...);\n  ...\n}\n"
            },
            {
              "pattern": "function $F(...,$INPUT,...) {\n  ...\n  new NodeVM({sandbox: <... $INPUT ...>},...);\n  ...\n}\n"
            },
            {
              "pattern": "function $F(...,$INPUT,...) {\n  ...\n  $CONTEXT = <... $INPUT ...>;\n  ...\n  new NodeVM({sandbox: <... $CONTEXT ...>},...);\n  ...\n}\n"
            },
            {
              "pattern": "function $F(...,$INPUT,...) {\n  ...\n  $CONTEXT = <... {$NAME:$INPUT} ...>;\n  ...\n  new NodeVM({sandbox: <... $CONTEXT ...>},...);\n  ...\n}\n"
            },
            {
              "pattern": "function $F(...,$INPUT,...) {\n  ...\n  $CONTEXT = {$NAME: <... $INPUT ...>};\n  ...\n  new NodeVM({sandbox: <... $CONTEXT ...>},...);\n  ...\n}\n"
            },
            {
              "pattern": "function $F(...,$INPUT,...) {\n  ...\n  $VAR = <... $INPUT ...>;\n  ...\n  $CONTEXT = {$NAME: <... $VAR ...>};\n  ...\n  new NodeVM({sandbox: <... $CONTEXT ...>},...);\n  ...\n}\n"
            },
            {
              "pattern": "function $F(...,$INPUT,...) {\n  ...\n  $OPTS = {sandbox: <... $INPUT ...>};\n  ...\n  new NodeVM($OPTS,...);\n  ...\n}\n"
            },
            {
              "pattern": "function $F(...,$INPUT,...) {\n  ...\n  $CONTEXT = <... $INPUT ...>;\n  ...\n  $OPTS = {sandbox: <... $CONTEXT ...>};\n  ...\n  new NodeVM($OPTS,...);\n  ...\n}\n"
            },
            {
              "pattern": "function $F(...,$INPUT,...) {\n  ...\n  $CONTEXT = {$NAME: <... $INPUT ...>};\n  ...\n  $OPTS = {sandbox: <... $CONTEXT ...>};\n  ...\n  new NodeVM($OPTS,...);\n  ...\n}\n"
            },
            {
              "pattern": "function $F(...,$INPUT,...) {\n  ...\n  $VAR = <... $INPUT ...>;\n  ...\n  $CONTEXT = {$NAME: <... $VAR ...>};\n  ...\n  $OPTS = {sandbox: <... $CONTEXT ...>};\n  ...\n  new NodeVM($OPTS,...);\n  ...\n}"
            }
          ]
        }
      ]
    },
    {
      "id": "javascript.vue.security.audit.xss.templates.avoid-v-html.avoid-v-html",
      "message": "Cross-site scripting (XSS) vulnerabilities in Vue.js occur when the v-html directive renders untrusted user input as HTML rather than escaped text. Unlike Vue's default text interpolation which automatically escapes content, v-html bypasses this protection and directly interprets content as HTML and JavaScript. This allows attackers to inject malicious scripts that execute in users' browsers with the privileges of the application's origin, potentially leading to session hijacking, credential theft, or unauthorized actions on behalf of the victim.",
      "metadata": {
        "references": [
          "https://vuejs.org/v2/guide/syntax.html#Raw-HTML"
        ],
        "category": "security",
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "technology": [
          "vue"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "v-html with user content can cause XSS in Vue",
        "fix-suggestion": "Replace `v-html` with safer alternatives like `v-text` or mustache interpolation (`{{ }}`) which automatically escape HTML. For formatted content, consider using a markdown renderer with safe defaults or sanitize content before binding using `DOMPurify`. If dynamic content rendering is necessary, implement Vue's `scoped slots` feature for controlled content display."
      },
      "languages": [
        "regex"
      ],
      "severity": "WARNING",
      "paths": {
        "include": [
          "*.vue"
        ]
      },
      "pattern-regex": "<[^<>]*v-html="
    },
    {
      "id": "javascript.wkhtmltoimage.security.audit.wkhtmltoimage-injection.wkhtmltoimage-injection",
      "message": "Server-Side Request Forgery (SSRF) in wkhtmltoimage happens when user-controlled input influences the URL or HTML content rendered by the tool. Since wkhtmltoimage uses a full browser engine to render content, it will follow redirects, load external resources, and execute JavaScript specified in the input. This vulnerability allows attackers to make the server access internal resources, scan local networks, or exfiltrate data by exploiting the server's network position and identity.",
      "metadata": {
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "category": "security",
        "technology": [
          "wkhtmltoimage"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "wkhtmltoimage with unvalidated data can trigger SSRF",
        "fix-suggestion": "Implement strict validation for URLs or HTML content before passing to `wkhtmltoimage` and create an allowlist of permitted domains. Use sanitization libraries like `DOMPurify` for HTML content and disable JavaScript execution with the `--disable-javascript` option. Consider using static HTML templates with defined placeholder substitution instead of dynamic HTML generation."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "$WK = require('wkhtmltoimage');\n...\n"
        },
        {
          "pattern-not-inside": "var $INPUT = \"...\";\n...\n"
        },
        {
          "pattern": "$WK.generate($INPUT,...)"
        },
        {
          "pattern-not": "$WK.generate(\"...\",...)"
        }
      ]
    },
    {
      "id": "javascript.wkhtmltopdf.security.audit.wkhtmltopdf-injection.wkhtmltopdf-injection",
      "message": "SSRF vulnerabilities in wkhtmltopdf occur when the tool processes URLs or HTML content containing unvalidated user input. The rendering engine follows links, loads resources, and executes JavaScript within the context of the server, allowing attackers to make unauthorized requests to internal systems. This can lead to internal network scanning, accessing restricted services, data exfiltration, or potential remote code execution through exploitation of internal services not meant to be publicly accessible.",
      "metadata": {
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "category": "security",
        "technology": [
          "wkhtmltopdf"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "wkhtmltopdf usage with untrusted input leads to SSRF",
        "fix-suggestion": "Validate all URLs and HTML content against an allowlist before passing to `wkhtmltopdf` and sanitize HTML with `DOMPurify`. Use the `--disable-javascript` option to prevent script execution when possible. Implement template-based approaches with controlled variable substitution rather than generating dynamic HTML."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "$WK = require('wkhtmltopdf');\n...\n"
        },
        {
          "pattern-not-inside": "var $INPUT = \"...\";\n...\n"
        },
        {
          "pattern": "$WK($INPUT,...)"
        },
        {
          "pattern-not": "$WK(\"...\",...)"
        }
      ]
    },
    {
      "id": "javascript.xml2json.security.audit.xml2json-xxe.xml2json-xxe",
      "message": "XML External Entity (XXE) attacks against xml2json libraries occur when the XML parser processes DOCTYPE declarations and resolves external entities from untrusted XML inputs. This vulnerability exists because many XML parsers enable external entity resolution by default without proper restrictions. Successful exploitation can lead to sensitive file disclosure on the server, server-side request forgery (SSRF), denial of service through resource exhaustion, or in severe cases, remote code execution through additional vulnerabilities.",
      "metadata": {
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "asvs": {
          "section": "V5 Validation, Sanitization and Encoding",
          "control_id": "5.5.2 Insecue XML Deserialization",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v55-deserialization-prevention",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "xml2json"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A05_2021-Security_Misconfiguration"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "Untrusted XML data to xml2json can cause XXE",
        "fix-suggestion": "Switch to an XML parser that mitigates XXE vulnerabilities by default, or when using `xml2js`, set `explicitCharkey: true` and `xmlns: true` options. Disable DTD processing and external entity resolution in your XML parser. Consider preprocessing XML to remove `DOCTYPE` declarations and reject input containing `DOCTYPE` or `ENTITY` declarations before processing."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern": "var $XML = require('xml2json');\n...\n$XML.toJson(...);\n"
        },
        {
          "pattern-not": "var $XML = require('xml2json');\n...\n$XML.toJson(\"...\",...);\n"
        },
        {
          "pattern-not": "var $XML = require('xml2json');\n...\nvar $S = \"...\";\n...\n$XML.toJson($S,...);"
        }
      ]
    },
    {
      "id": "json.aws.security.public-s3-bucket.public-s3-bucket",
      "languages": [
        "json"
      ],
      "message": "An S3 bucket is configured with public access permissions. This exposes your data to anyone on the internet, creating privacy and security risks. Public buckets should only be used for content that is explicitly intended for public distribution.",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-264: CWE CATEGORY: Permissions, Privileges, and Access Controls"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "references": [
          "https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-control-block-public-access.html"
        ],
        "technology": [
          "aws"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "S3 bucket with public access permissions",
        "fix-suggestion": "Modify your bucket policy and ACLs to remove public access permissions. Use AWS Management Console to enable `Block Public Access` settings for the bucket, or update your infrastructure-as-code to include `block_public_acls = true` and similar settings in your bucket configuration."
      },
      "patterns": [
        {
          "pattern-inside": "$BUCKETNAME: {\n  \"Type\": \"AWS::S3::Bucket\",\n  \"Properties\": {\n  ...,\n  },\n  ...,\n}\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "\"PublicAccessBlockConfiguration\": {\n     ...,\n     \"RestrictPublicBuckets\": false,\n     ...,\n   },\n"
            },
            {
              "pattern": "\"PublicAccessBlockConfiguration\": {\n     ...,\n     \"IgnorePublicAcls\": false,\n     ...,\n   },\n"
            },
            {
              "pattern": "\"PublicAccessBlockConfiguration\": {\n     ...,\n     \"BlockPublicAcls\": false,\n     ...,\n   },\n"
            },
            {
              "pattern": "\"PublicAccessBlockConfiguration\": {\n     ...,\n     \"BlockPublicPolicy\": false,\n     ...,\n   },\n"
            }
          ]
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "json.aws.security.public-s3-policy-statement.public-s3-policy-statement",
      "pattern": "{\n  \"Effect\": \"Allow\",\n  \"Principal\": \"*\",\n  \"Resource\": [\n    ..., \"=~/arn:aws:s3.*/\", ...\n  ],\n  ...\n}\n",
      "message": "S3 bucket policy contains statements that grant public access to bucket contents. This allows anyone on the internet to access specific operations or objects in your bucket. Public access should only be enabled for content that is explicitly intended for public distribution.",
      "metadata": {
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-264: CWE CATEGORY: Permissions, Privileges, and Access Controls"
        ],
        "references": [
          "https://docs.aws.amazon.com/AmazonS3/latest/dev/WebsiteAccessPermissionsReqd.html"
        ],
        "category": "security",
        "technology": [
          "aws"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "S3 policy grants public bucket access",
        "fix-suggestion": "Revise your bucket policy to remove statements that include `\"Principal\": \"*\"` or `\"Principal\": {\"AWS\": \"*\"}`. Replace public access with specific IAM roles/users, or use AWS resource policies with conditions to limit access to authorized services and users only."
      },
      "severity": "WARNING",
      "languages": [
        "json"
      ]
    },
    {
      "id": "json.aws.security.wildcard-assume-role.wildcard-assume-role",
      "patterns": [
        {
          "pattern-inside": "\"Statement\": [...]\n"
        },
        {
          "pattern-inside": "{..., \"Effect\": \"Allow\", ..., \"Action\": \"sts:AssumeRole\", ...}\n"
        },
        {
          "pattern": "\"Principal\": {..., \"AWS\": \"*\", ...}\n"
        }
      ],
      "message": "A policy allows wildcard access to the sts:AssumeRole action. This permits anyone with your AWS account ID to assume this role, potentially gaining unintended privileges. Role assumption should be limited to specific, authorized entities.",
      "metadata": {
        "cwe": [
          "CWE-250: Execution with Unnecessary Privileges"
        ],
        "category": "security",
        "technology": [
          "aws"
        ],
        "references": [
          "https://rhinosecuritylabs.com/aws/assume-worst-aws-assume-role-enumeration/"
        ],
        "owasp": [
          "A06:2017 - Security Misconfiguration",
          "A05:2021 - Security Misconfiguration"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Overly permissive role assumption policy",
        "fix-suggestion": "Replace wildcard principals in trust policies with specific identities like `arn:aws:iam::<account_id>:role/specific-role` or `arn:aws:iam::<account_id>:user/specific-user`. Add conditions such as `aws:SourceIp` to further restrict which contexts can assume the role."
      },
      "languages": [
        "json"
      ],
      "severity": "ERROR"
    },
    {
      "id": "kotlin.gradle.security.build-gradle-password-hardcoded.build-gradle-password-hardcoded",
      "message": "Hard-coding credentials directly in build.gradle files creates significant security risks when codebase access isn't properly restricted. These credentials remain visible in version control systems, making them accessible to anyone with repository access or if the repository is accidentally made public. The exposure can lead to unauthorized access to protected resources, service compromise, or further penetration into connected systems that trust these credentials.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "category": "security",
        "subcategory": [
          "vuln"
        ],
        "cwe": [
          "CWE-798: Use of Hard-coded Credentials"
        ],
        "cwe2020-top25": true,
        "cwe2021-top25": true,
        "cwe2022-top25": true,
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "references": [
          "https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures"
        ],
        "technology": [
          "secrets"
        ],
        "vulnerability_class": [
          "Hard-coded Secrets"
        ],
        "source_rule_url": "https://semgrep.dev/playground/r/d8Ur5BA/achufistov6_personal_org.build-gradle-password-hardcoded",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "short-description": "Hardcoded credentials in build.gradle are easily exposed",
        "fix-suggestion": "Remove hardcoded credentials from `build.gradle` files and store sensitive information in environment variables accessed via `System.getenv()` or through properties with `project.findProperty()`. Use `gradle.properties` for local development (add to `.gitignore`) and configure CI/CD systems to provide properties securely. For highly sensitive data, implement a secret management service like HashiCorp Vault or AWS Secrets Manager."
      },
      "languages": [
        "kotlin"
      ],
      "options": {
        "symbolic_propagation": true
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$PASS = env[...] ?: $VALUE"
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$PASS",
            "regex": "(password|pass|passwd|loginPassword)"
          }
        },
        {
          "metavariable-pattern": {
            "language": "generic",
            "metavariable": "$VALUE",
            "patterns": [
              {
                "pattern-either": [
                  {
                    "pattern-regex": "^[A-Za-z0-9/+=]+$"
                  }
                ]
              }
            ]
          }
        }
      ],
      "paths": {
        "include": [
          "*build.gradle.kts"
        ]
      }
    },
    {
      "id": "kotlin.lang.security.anonymous-ldap-bind.anonymous-ldap-bind",
      "metadata": {
        "cwe": [
          "CWE-287: Improper Authentication"
        ],
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A07:2021 - Identification and Authentication Failures"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#LDAP_ANONYMOUS",
        "category": "security",
        "technology": [
          "kotlin"
        ],
        "references": [
          "https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Anonymous LDAP bind permits unauthorized LDAP operations",
        "fix-suggestion": "Always provide explicit credentials when creating LDAP connections and avoid empty or null parameters in `ldapAuthenticate()` calls. Configure LDAP environments to require proper authentication by disabling anonymous binds at the server level. Implement appropriate error handling for authentication failures rather than falling back to anonymous access."
      },
      "message": "Anonymous LDAP binds occur when applications connect to directory services without providing authentication credentials. This insecure practice bypasses authentication requirements, allowing anyone to perform LDAP operations according to the directory's anonymous access policy. The vulnerability can lead to unauthorized information disclosure, directory service enumeration, or in poorly configured environments, modification of directory data without proper authorization controls.",
      "severity": "WARNING",
      "pattern": "$ENV.put($CTX.SECURITY_AUTHENTICATION, \"none\")\n...\n$DCTX = InitialDirContext($ENV, ...)\n",
      "languages": [
        "kt"
      ]
    },
    {
      "id": "kotlin.lang.security.bad-hexa-conversion.bad-hexa-conversion",
      "metadata": {
        "cwe": [
          "CWE-704: Incorrect Type Conversion or Cast"
        ],
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#BAD_HEXA_CONVERSION",
        "category": "security",
        "technology": [
          "kotlin"
        ],
        "references": [
          "https://cwe.mitre.org/data/definitions/704.html"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "Hex conversion strips leading zeros",
        "fix-suggestion": "Replace `Integer.toHexString()` with `String.format(\"%02X\", byteValue)` for byte-to-hex conversion. This ensures each byte is represented as exactly two hexadecimal characters, preserving leading zeros and maintaining the full strength of hash values."
      },
      "message": "The code uses Integer.toHexString() for byte-by-byte conversion, which strips leading zeros. This weakens cryptographic hashes by introducing more collisions where different inputs produce the same output hash. Proper formatting preserves the full hash value.",
      "severity": "WARNING",
      "languages": [
        "kt"
      ],
      "pattern": "fun $METHOD(...) {\n  ...\n  val $MD: MessageDigest = ...\n  ...\n  $MD.digest(...)\n  ...\n  Integer.toHexString(...)\n}"
    },
    {
      "id": "kotlin.lang.security.command-injection-formatted-runtime-call.command-injection-formatted-runtime-call",
      "message": "Command injection in Kotlin occurs when Runtime.exec() executes commands constructed from unvalidated user input through string formatting or concatenation. Special characters in the input can be interpreted as command separators or modifiers by the operating system shell, allowing execution of arbitrary commands. This vulnerability can lead to complete system compromise at the privilege level of the application process, potentially resulting in data theft, service disruption, or unauthorized access to the host system.",
      "metadata": {
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#COMMAND_INJECTION.",
        "category": "security",
        "technology": [
          "kt"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Runtime calls with formatted strings risk command injection",
        "fix-suggestion": "Avoid building command strings using string formatting or concatenation with untrusted input. Use process builders or parameterized APIs like `ProcessBuilder` instead of direct `Runtime.exec()` calls. Validate all input against an allowlist to prevent shell metacharacter injection."
      },
      "severity": "ERROR",
      "languages": [
        "kt"
      ],
      "pattern-either": [
        {
          "pattern": "$RUNTIME.exec($X + $Y)"
        },
        {
          "pattern": "$RUNTIME.exec(String.format(...))"
        },
        {
          "pattern": "$RUNTIME.loadLibrary($X + $Y)"
        },
        {
          "pattern": "$RUNTIME.loadLibrary(String.format(...))"
        }
      ]
    },
    {
      "id": "kotlin.lang.security.cookie-missing-httponly.cookie-missing-httponly",
      "metadata": {
        "cwe": [
          "CWE-1004: Sensitive Cookie Without 'HttpOnly' Flag"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#HTTPONLY_COOKIE",
        "category": "security",
        "technology": [
          "kt"
        ],
        "references": [
          "https://owasp.org/Top10/A05_2021-Security_Misconfiguration"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cookie Security"
        ],
        "short-description": "Cookies missing HttpOnly flag expose data",
        "fix-suggestion": "Set the HttpOnly flag on all cookies containing sensitive information by calling `cookie.setHttpOnly(true)`. This prevents JavaScript from accessing the cookie value, protecting it from theft through XSS attacks even if other vulnerabilities exist."
      },
      "message": "Cookies are set without the HttpOnly flag, making them accessible to client-side JavaScript. This exposes cookie data to potential theft through Cross-Site Scripting (XSS) attacks. The HttpOnly flag helps mitigate the impact of XSS by preventing script access to cookies.",
      "severity": "WARNING",
      "languages": [
        "kt"
      ],
      "patterns": [
        {
          "pattern-not-inside": "$COOKIE.setValue(\"\")\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "$COOKIE.setHttpOnly(false)"
            },
            {
              "patterns": [
                {
                  "pattern-not-inside": "$COOKIE.setHttpOnly(...)\n...\n"
                },
                {
                  "pattern": "$RESPONSE.addCookie($COOKIE)"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "kotlin.lang.security.cookie-missing-secure-flag.cookie-missing-secure-flag",
      "metadata": {
        "cwe": [
          "CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#INSECURE_COOKIE",
        "category": "security",
        "technology": [
          "kt"
        ],
        "references": [
          "https://owasp.org/Top10/A05_2021-Security_Misconfiguration"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cookie Security"
        ],
        "short-description": "Cookies without Secure flag risk interception",
        "fix-suggestion": "Set the Secure flag on all cookies containing sensitive information by calling `cookie.setSecure(true)`. This ensures the cookie is only transmitted over HTTPS connections, protecting it from interception over plaintext HTTP."
      },
      "message": "Cookies are set without the Secure flag, allowing them to be transmitted over unencrypted HTTP connections. This exposes cookie data to interception by network attackers. The Secure flag ensures cookies are only sent over HTTPS connections.",
      "severity": "WARNING",
      "languages": [
        "kt"
      ],
      "patterns": [
        {
          "pattern-not-inside": "$COOKIE.setValue(\"\")\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "$COOKIE.setSecure(false)"
            },
            {
              "patterns": [
                {
                  "pattern-not-inside": "$COOKIE.setSecure(...)\n...\n"
                },
                {
                  "pattern": "$RESPONSE.addCookie($COOKIE)"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "kotlin.lang.security.defaulthttpclient-is-deprecated.defaulthttpclient-is-deprecated",
      "metadata": {
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#DEFAULT_HTTP_CLIENT",
        "asvs": {
          "section": "V9 Communications Verification Requirements",
          "control_id": "9.1.3 Weak TLS",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x17-V9-Communications.md#v91-client-communications-security-requirements",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "kotlin"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Deprecated HTTP client lacks TLS security",
        "fix-suggestion": "Replace `DefaultHttpClient` with `SystemDefaultHttpClient` which supports TLS 1.2 and later. For newer codebases, consider migrating to modern HTTP clients like OkHttp or the Kotlin HTTP client that support current security standards by default."
      },
      "message": "The code uses DefaultHttpClient, which is deprecated and doesn't support TLS 1.2. This creates security vulnerabilities as TLS 1.0 and 1.1 have known weaknesses. Modern TLS versions are essential for secure communications.",
      "severity": "WARNING",
      "languages": [
        "kt"
      ],
      "pattern": "DefaultHttpClient(...)",
      "fix-regex": {
        "regex": "DefaultHttpClient",
        "replacement": "SystemDefaultHttpClient"
      }
    },
    {
      "id": "kotlin.lang.security.ecb-cipher.ecb-cipher",
      "metadata": {
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#ECB_MODE",
        "category": "security",
        "technology": [
          "kotlin"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "ECB cipher mode reveals data patterns",
        "fix-suggestion": "Replace ECB mode with GCM (Galois/Counter Mode) or CBC (Cipher Block Chaining) with proper padding. Use `Cipher.getInstance(\"AES/GCM/NoPadding\")` or `Cipher.getInstance(\"AES/CBC/PKCS7Padding\")` instead of ECB mode for secure encryption."
      },
      "message": "The Electronic Codebook (ECB) encryption mode is being used. ECB encrypts identical plaintext blocks to identical ciphertext blocks, revealing patterns in the original data. This mode lacks integrity checking and is vulnerable to various attacks.",
      "severity": "WARNING",
      "languages": [
        "kt"
      ],
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "val $VAR : Cipher = $CIPHER.getInstance($MODE)\n"
            },
            {
              "pattern": "var $VAR : Cipher = $CIPHER.getInstance($MODE)\n"
            },
            {
              "pattern": "val $VAR = $CIPHER.getInstance($MODE)\n"
            },
            {
              "pattern": "var $VAR = $CIPHER.getInstance($MODE)\n"
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$MODE",
            "regex": ".*ECB.*"
          }
        }
      ]
    },
    {
      "id": "kotlin.lang.security.gcm-detection.gcm-detection",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-323: Reusing a Nonce, Key Pair in Encryption"
        ],
        "references": [
          "https://cwe.mitre.org/data/definitions/323.html"
        ],
        "technology": [
          "kotlin"
        ],
        "owasp": [
          "A02:2021 - Cryptographic Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "GCM encryption mode with potential IV reuse",
        "fix-suggestion": "Generate a new random IV for each encryption operation using `SecureRandom().nextBytes(iv)` with a 12-byte array. Never reuse IVs with the same key, and consider implementing a tracking mechanism to detect accidental IV reuse in your encryption system."
      },
      "languages": [
        "kt"
      ],
      "message": "GCM encryption is used with a risk of IV/nonce reuse. Reusing the same initialization vector with the same key completely breaks GCM security, allowing attackers to decrypt messages and forge authentication tags. Always ensure IVs are random and never reused.",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$METHOD.getInstance(\"AES/GCM/NoPadding\",...)"
            },
            {
              "pattern": "GCMParameterSpec(...)"
            }
          ]
        }
      ],
      "severity": "INFO"
    },
    {
      "id": "kotlin.lang.security.no-null-cipher.no-null-cipher",
      "pattern": "NullCipher(...)",
      "metadata": {
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#NULL_CIPHER",
        "asvs": {
          "section": "V6 Stored Cryptography Verification Requirements",
          "control_id": "6.2.5 Insecure Algorithm",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "kotlin"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "NullCipher provides no encryption",
        "fix-suggestion": "Replace `NullCipher` with a proper encryption implementation using `Cipher.getInstance(\"AES/CBC/PKCS7PADDING\")`. Always use standard, secure encryption algorithms with appropriate modes of operation instead of placeholder or testing implementations in production code."
      },
      "message": "NullCipher is being used, which doesn't actually encrypt data at all. This class performs a pass-through operation where the ciphertext is identical to the plaintext. Using NullCipher provides a false sense of security while offering no protection.",
      "severity": "WARNING",
      "languages": [
        "kt",
        "scala"
      ]
    },
    {
      "id": "kotlin.lang.security.unencrypted-socket.unencrypted-socket",
      "metadata": {
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#UNENCRYPTED_SOCKET",
        "asvs": {
          "section": "V6 Stored Cryptography Verification Requirements",
          "control_id": "6.2.5 Insecure Algorithm",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "kotlin"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Plaintext socket connection exposes data",
        "fix-suggestion": "Replace standard sockets with SSL/TLS-secured sockets. Use `SSLSocketFactory.getDefault().createSocket()` to create encrypted connections, or consider using higher-level libraries like OkHttp that implement TLS by default for secure network communications."
      },
      "message": "Plain, unencrypted socket connections are used for network communication. This transmits all data in plaintext, allowing attackers to intercept and read sensitive information. Network traffic should be encrypted in most applications to protect data confidentiality.",
      "severity": "WARNING",
      "languages": [
        "kt"
      ],
      "pattern-either": [
        {
          "pattern": "ServerSocket(...)"
        },
        {
          "pattern": "Socket(...)"
        }
      ]
    },
    {
      "id": "kotlin.lang.security.use-of-md5.use-of-md5",
      "message": "MD5 hash algorithm is used for cryptographic purposes. MD5 is fundamentally broken and vulnerable to collision attacks, making it unsuitable for security applications. Any system relying on MD5 for security properties is vulnerable to forgery and impersonation.",
      "languages": [
        "kt"
      ],
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-328: Use of Weak Hash"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#WEAK_MESSAGE_DIGEST_MD5",
        "category": "security",
        "technology": [
          "kotlin"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Hashing Algorithm"
        ],
        "short-description": "Cryptographically broken MD5 hash algorithm",
        "fix-suggestion": "Replace MD5 with secure hash algorithms like SHA-256 or SHA-3. Update your code to use `MessageDigest.getInstance(\"SHA-256\")` instead of MD5, and consider using HMAC (`HmacSHA256`) when authentication of the hash is required."
      },
      "pattern-either": [
        {
          "pattern": "java.security.MessageDigest.getInstance(\"MD5\")\n"
        },
        {
          "pattern": "org.apache.commons.codec.digest.DigestUtils.getMd5Digest()\n"
        }
      ]
    },
    {
      "id": "kotlin.lang.security.use-of-sha1.use-of-sha1",
      "message": "SHA1 is no longer considered secure for cryptographic operations due to demonstrated collision vulnerabilities. When an attacker can produce two different inputs that generate the same hash value, the integrity of your data verification is compromised. This undermines the security of any authentication or data validation system relying on these hashes.",
      "languages": [
        "kt"
      ],
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#WEAK_MESSAGE_DIGEST_SHA1",
        "asvs": {
          "section": "V6 Stored Cryptography Verification Requirements",
          "control_id": "6.2.5 Insecure Algorithm",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "kotlin"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Insecure SHA1 hash algorithm endangers cryptographic security",
        "fix-suggestion": "Replace SHA1 with more secure hashing algorithms like `SHA256`, `SHA3`, or `BLAKE2`. These modern algorithms provide stronger cryptographic protection and are resistant to known collision attacks. Use functions from standard libraries that implement these algorithms correctly."
      },
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern": "$VAR = $MD.getInstance(\"$ALGO\")\n"
            },
            {
              "metavariable-regex": {
                "metavariable": "$ALGO",
                "regex": "(SHA1|SHA-1)"
              }
            }
          ]
        },
        {
          "pattern": "$DU.getSha1Digest().digest(...)\n"
        }
      ]
    },
    {
      "id": "kotlin.lang.security.weak-rsa.use-of-weak-rsa-key",
      "message": "RSA keys shorter than 2048 bits are considered cryptographically weak according to NIST standards. Short keys can be broken through brute force attacks with modern computing resources, potentially exposing your encrypted data. Using insufficient key lengths undermines the security of your entire encryption system.",
      "languages": [
        "kt"
      ],
      "severity": "WARNING",
      "metadata": {
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#RSA_KEY_SIZE",
        "asvs": {
          "section": "V6 Stored Cryptography Verification Requirements",
          "control_id": "6.2.5 Insecure Algorithm",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms",
          "version": "4"
        },
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#algorithms"
        ],
        "category": "security",
        "technology": [
          "kotlin"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "RSA keys below 2048 bits violate security standards",
        "fix-suggestion": "Increase RSA key length to at least `2048` bits as recommended by NIST. For applications requiring higher security, consider using `3072` or `4096` bit keys. Update key generation parameters in your code to ensure all new keys meet this minimum requirement."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$KEY = $G.getInstance(\"RSA\")\n...\n$KEY.initialize($BITS)\n"
            }
          ]
        },
        {
          "metavariable-comparison": {
            "metavariable": "$BITS",
            "comparison": "$BITS < 2048"
          }
        }
      ]
    },
    {
      "id": "ocaml.lang.security.unsafe.ocamllint-unsafe",
      "pattern-either": [
        {
          "pattern": "$X.unsafe_get"
        },
        {
          "pattern": "$X.unsafe_set"
        },
        {
          "pattern": "$X.unsafe_to_string"
        },
        {
          "pattern": "$X.unsafe_of_string"
        },
        {
          "pattern": "$X.unsafe_blit"
        },
        {
          "pattern": "$X.unsafe_blit_string"
        },
        {
          "pattern": "$X.unsafe_fill"
        },
        {
          "pattern": "$X.unsafe_to_string"
        },
        {
          "pattern": "$X.unsafe_getenv"
        },
        {
          "pattern": "$X.unsafe_environment"
        },
        {
          "pattern": "$X.unsafe_chr"
        },
        {
          "pattern": "$X.unsafe_of_int"
        },
        {
          "pattern": "$X.unsafe_output"
        },
        {
          "pattern": "$X.unsafe_output_string"
        },
        {
          "pattern": "$X.unsafe_read"
        },
        {
          "pattern": "$X.unsafe_recv"
        },
        {
          "pattern": "$X.unsafe_recvfrom"
        },
        {
          "pattern": "$X.unsafe_send"
        },
        {
          "pattern": "$X.unsafe_sendto"
        },
        {
          "pattern": "$X.unsafe_set"
        },
        {
          "pattern": "$X.unsafe_set_int16"
        },
        {
          "pattern": "$X.unsafe_set_int32"
        },
        {
          "pattern": "$X.unsafe_set_int64"
        },
        {
          "pattern": "$X.unsafe_set_int8"
        },
        {
          "pattern": "$X.unsafe_set_uint16_ne"
        },
        {
          "pattern": "$X.unsafe_set_uint8"
        },
        {
          "pattern": "$X.unsafe_single_write"
        },
        {
          "pattern": "$X.unsafe_string"
        },
        {
          "pattern": "$X.unsafe_sub"
        },
        {
          "pattern": "$X.unsafe_write"
        }
      ],
      "message": "OCaml's unsafe functions bypass boundary and safety checks to improve performance but introduce security risks. Without proper bounds checking, buffer overflow and memory corruption vulnerabilities become possible. These vulnerabilities can lead to crashes, data corruption, or even code execution attacks.",
      "languages": [
        "ocaml"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "references": [
          "https://v2.ocaml.org/api/Bigarray.Array1.html#VALunsafe_get",
          "https://v2.ocaml.org/api/Bytes.html#VALunsafe_to_string"
        ],
        "technology": [
          "ocaml"
        ],
        "cwe": "CWE-242: Use of Inherently Dangerous Function (4.12)",
        "confidence": "MEDIUM",
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "subcategory": [
          "audit"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Unsafe OCaml functions bypass critical security checks",
        "fix-suggestion": "Replace calls to unsafe functions with their safe equivalents whenever possible. When using unsafe functions is unavoidable, implement your own boundary checks before calling them. Wrap unsafe operations in validation code that verifies all inputs meet expected constraints."
      }
    },
    {
      "id": "php.doctrine.security.audit.doctrine-dbal-dangerous-query.doctrine-dbal-dangerous-query",
      "languages": [
        "php"
      ],
      "message": "SQL injection in Doctrine DBAL happens when developers construct queries by directly concatenating user input into SQL strings instead of using parameterized queries. This vulnerability occurs despite using an abstraction layer because string concatenation bypasses the security features that would normally prevent injection attacks. Successful exploitation allows attackers to manipulate query logic, potentially resulting in unauthorized data access, authentication bypass, data modification, or even server compromise through advanced SQL injection techniques.",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://www.doctrine-project.org/projects/doctrine-dbal/en/current/reference/security.html",
          "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
        ],
        "technology": [
          "doctrine"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Concatenating user data in Doctrine DBAL query fosters injection",
        "fix-suggestion": "Replace string concatenation in Doctrine DBAL with parameterized queries using `executeQuery()` and placeholder parameters. Use the `Connection->quote()` method when parameter binding isn't possible to ensure proper escaping. Consider using query builders instead of direct SQL strings to maintain proper separation between code and data."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$CONNECTION->prepare($QUERY,...)"
            },
            {
              "pattern": "$CONNECTION->createQuery($QUERY,...)"
            },
            {
              "pattern": "$CONNECTION->executeQuery($QUERY,...)"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "use Doctrine\\DBAL\\Connection;\n...\n"
            },
            {
              "pattern-inside": "$CONNECTION = $SMTH->getConnection(...);\n...\n"
            }
          ]
        },
        {
          "pattern-not": "$CONNECTION->prepare(\"...\",...)"
        },
        {
          "pattern-not": "$CONNECTION->createQuery(\"...\",...)"
        },
        {
          "pattern-not": "$CONNECTION->executeQuery(\"...\",...)"
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "php.doctrine.security.audit.doctrine-orm-dangerous-query.doctrine-orm-dangerous-query",
      "languages": [
        "php"
      ],
      "message": "SQL injection vulnerabilities in Doctrine ORM arise when QueryBuilder constructs SQL queries by combining strings with unsanitized user input. Despite using an ORM framework, this practice bypasses its built-in protections against injection attacks when raw strings are used. The impact includes unauthorized data access, authentication bypass, data modification, or in severe cases, server compromise through advanced SQL injection techniques that exploit database server features.",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://www.doctrine-project.org/projects/doctrine-dbal/en/current/reference/query-builder.html#security-safely-preventing-sql-injection",
          "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
        ],
        "technology": [
          "doctrine"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Unsanitized input in Doctrine ORM queries can lead to injection",
        "fix-suggestion": "Replace string concatenation in queries with Doctrine ORM's built-in parameterized query methods like `createQuery()` with parameter binding. Use methods such as `setParameter()` to safely incorporate user input into queries. Implement query builders instead of direct DQL strings to maintain proper separation between code and data."
      },
      "mode": "taint",
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$SINK"
            },
            {
              "pattern-either": [
                {
                  "pattern": "$QUERY->add(...,$SINK,...)"
                },
                {
                  "pattern": "$QUERY->select(...,$SINK,...)"
                },
                {
                  "pattern": "$QUERY->addSelect(...,$SINK,...)"
                },
                {
                  "pattern": "$QUERY->delete(...,$SINK,...)"
                },
                {
                  "pattern": "$QUERY->update(...,$SINK,...)"
                },
                {
                  "pattern": "$QUERY->insert(...,$SINK,...)"
                },
                {
                  "pattern": "$QUERY->from(...,$SINK,...)"
                },
                {
                  "pattern": "$QUERY->join(...,$SINK,...)"
                },
                {
                  "pattern": "$QUERY->innerJoin(...,$SINK,...)"
                },
                {
                  "pattern": "$QUERY->leftJoin(...,$SINK,...)"
                },
                {
                  "pattern": "$QUERY->rightJoin(...,$SINK,...)"
                },
                {
                  "pattern": "$QUERY->where(...,$SINK,...)"
                },
                {
                  "pattern": "$QUERY->andWhere(...,$SINK,...)"
                },
                {
                  "pattern": "$QUERY->orWhere(...,$SINK,...)"
                },
                {
                  "pattern": "$QUERY->groupBy(...,$SINK,...)"
                },
                {
                  "pattern": "$QUERY->addGroupBy(...,$SINK,...)"
                },
                {
                  "pattern": "$QUERY->having(...,$SINK,...)"
                },
                {
                  "pattern": "$QUERY->andHaving(...,$SINK,...)"
                },
                {
                  "pattern": "$QUERY->orHaving(...,$SINK,...)"
                },
                {
                  "pattern": "$QUERY->orderBy(...,$SINK,...)"
                },
                {
                  "pattern": "$QUERY->addOrderBy(...,$SINK,...)"
                },
                {
                  "pattern": "$QUERY->set($SINK,...)"
                },
                {
                  "pattern": "$QUERY->setValue($SINK,...)"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "$Q = $X->createQueryBuilder();\n...\n"
                },
                {
                  "pattern-inside": "$Q = new QueryBuilder(...);\n...\n"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "sprintf(...)"
                },
                {
                  "pattern": "\"...\".$SMTH\n"
                }
              ]
            }
          ]
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "php.lang.security.assert-use.assert-use",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "$_GET"
                    },
                    {
                      "pattern": "$_POST"
                    },
                    {
                      "pattern": "$_COOKIE"
                    },
                    {
                      "pattern": "$_REQUEST"
                    },
                    {
                      "pattern": "$_SERVER"
                    }
                  ]
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern": "Route::$METHOD($ROUTENAME, function(..., $ARG, ...) { ... })\n"
                },
                {
                  "focus-metavariable": "$ARG"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "assert($SINK, ...);"
            },
            {
              "pattern-not": "assert(\"...\", ...);"
            },
            {
              "pattern": "$SINK"
            }
          ]
        }
      ],
      "message": "Using PHP's assert() function with dynamic content is equivalent to using eval() on that content. This allows an attacker to inject and execute arbitrary PHP code if they can influence the assertion condition. Such code execution vulnerabilities represent one of the most severe security risks in web applications.",
      "metadata": {
        "owasp": [
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"
        ],
        "references": [
          "https://www.php.net/manual/en/function.assert",
          "https://github.com/FloeDesignTechnologies/phpcs-security-audit/blob/master/Security/Sniffs/BadFunctions/AssertsSniff.php"
        ],
        "category": "security",
        "technology": [
          "php"
        ],
        "confidence": "HIGH",
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Assert function enables dangerous code execution",
        "fix-suggestion": "Never use `assert()` with user-supplied or dynamic input. Replace assertions with proper validation using safe comparison operators or validation functions. If you need runtime checks, use proper input validation and error handling instead of assertions."
      },
      "languages": [
        "php"
      ],
      "severity": "ERROR"
    },
    {
      "id": "php.lang.security.backticks-use.backticks-use",
      "pattern": "`...`;",
      "message": "Command injection vulnerabilities in PHP occur when backtick operators (`) execute shell commands containing unvalidated user input. Since backticks cause PHP to execute the enclosed text as a shell command and return the output, attackers can inject additional commands using shell metacharacters. This can lead to unauthorized command execution on the server with the privileges of the web application process, potentially resulting in system compromise, data theft, or service disruption.",
      "metadata": {
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "references": [
          "https://www.php.net/manual/en/language.operators.execution.php",
          "https://github.com/FloeDesignTechnologies/phpcs-security-audit/blob/master/Security/Sniffs/BadFunctions/BackticksSniff.php"
        ],
        "category": "security",
        "technology": [
          "php"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "PHP backticks with user data allow command injection",
        "fix-suggestion": "Replace backtick operators (`` ` ``) with safer alternatives like `proc_open()` that properly separate commands from parameters. Implement input validation routines to sanitize any dynamic components before execution. Consider using dedicated libraries that handle command execution securely rather than direct shell access."
      },
      "languages": [
        "php"
      ],
      "severity": "ERROR"
    },
    {
      "id": "php.lang.security.base-convert-loses-precision.base-convert-loses-precision",
      "message": "The PHP base_convert function uses 64-bit numbers internally and loses precision when converting large numbers. This makes it unsuitable for security-critical operations like generating session tokens or CSRF tokens. When used for security tokens, it creates predictable or colliding values that attackers can exploit.",
      "metadata": {
        "references": [
          "https://www.php.net/base_convert",
          "https://www.sjoerdlangkemper.nl/2017/03/15/dont-use-base-convert-on-random-tokens/"
        ],
        "category": "security",
        "technology": [
          "php"
        ],
        "cwe": [
          "CWE-190: Integer Overflow or Wraparound"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Base_convert precision loss endangers security tokens",
        "fix-suggestion": "Avoid using `base_convert()` for security-critical token generation. Use cryptographically secure random functions like `random_bytes()` followed by `bin2hex()` for token generation. Consider using the `hash_hmac()` function for generating signed tokens that resist tampering."
      },
      "languages": [
        "php"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern": "hash(...)"
        },
        {
          "pattern": "hash_hmac(...)"
        },
        {
          "pattern": "sha1(...)"
        },
        {
          "pattern": "md5(...)"
        },
        {
          "patterns": [
            {
              "pattern": "random_bytes($N)"
            },
            {
              "metavariable-comparison": {
                "metavariable": "$N",
                "comparison": "$N > 7"
              }
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern": "openssl_random_pseudo_bytes($N)"
            },
            {
              "metavariable-comparison": {
                "metavariable": "$N",
                "comparison": "$N > 7"
              }
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern": "$OBJ->get_random_bytes($N)"
            },
            {
              "metavariable-comparison": {
                "metavariable": "$N",
                "comparison": "$N > 7"
              }
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "pattern": "base_convert(...)"
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern": "substr(..., $LENGTH)"
            },
            {
              "metavariable-comparison": {
                "metavariable": "$LENGTH",
                "comparison": "$LENGTH <= 7"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "php.lang.security.curl-ssl-verifypeer-off.curl-ssl-verifypeer-off",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$ARG = $IS_VERIFIED;\n...\ncurl_setopt(..., CURLOPT_SSL_VERIFYPEER, $ARG);\n"
            },
            {
              "pattern": "curl_setopt(..., CURLOPT_SSL_VERIFYPEER, $IS_VERIFIED)"
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$IS_VERIFIED",
            "regex": "0|false|null"
          }
        }
      ],
      "message": "SSL certificate verification has been disabled in this cURL request. Disabling verification makes your application vulnerable to man-in-the-middle attacks by accepting fraudulent SSL certificates. This effectively eliminates the security benefits of using HTTPS connections.",
      "metadata": {
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "references": [
          "https://www.saotn.org/dont-turn-off-curlopt_ssl_verifypeer-fix-php-configuration/"
        ],
        "category": "security",
        "technology": [
          "php"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Disabled SSL verification enables network attacks",
        "fix-suggestion": "Enable SSL certificate verification by setting `CURLOPT_SSL_VERIFYPEER` to `true`. Configure proper certificate authority validation using `CURLOPT_CAINFO` to specify a trusted CA certificate bundle. Never disable certificate verification in production environments."
      },
      "languages": [
        "php"
      ],
      "severity": "ERROR"
    },
    {
      "id": "php.lang.security.eval-use.eval-use",
      "patterns": [
        {
          "pattern": "eval(...);"
        },
        {
          "pattern-not": "eval('...');"
        }
      ],
      "message": "Code injection through PHP's eval() function happens when it executes strings containing unvalidated user input as PHP code. Since eval() interprets and runs the provided string in the current scope, attackers can inject arbitrary PHP code that executes with the application's privileges. This critical vulnerability can lead to complete application compromise, data theft, authentication bypass, or even server compromise depending on the application's privilege level and configuration.",
      "metadata": {
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "references": [
          "https://www.php.net/manual/en/function.eval",
          "https://github.com/FloeDesignTechnologies/phpcs-security-audit/blob/master/Security/Sniffs/BadFunctions/NoEvalsSniff.php"
        ],
        "category": "security",
        "technology": [
          "php"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "eval usage can run arbitrary code with untrusted input",
        "fix-suggestion": "Eliminate all uses of `eval()` and restructure code to avoid dynamic execution of string content. For configuration or templating needs, use dedicated parsers or template engines with proper sandboxing. Consider design patterns that achieve the required flexibility without executing arbitrary code at runtime."
      },
      "languages": [
        "php"
      ],
      "severity": "ERROR"
    },
    {
      "id": "php.lang.security.exec-use.exec-use",
      "patterns": [
        {
          "pattern": "$FUNC(...);"
        },
        {
          "pattern-not": "$FUNC('...', ...);"
        },
        {
          "metavariable-regex": {
            "metavariable": "$FUNC",
            "regex": "exec|passthru|proc_open|popen|shell_exec|system|pcntl_exec"
          }
        }
      ],
      "message": "Command injection in PHP exec() functions occurs when commands are constructed using unsanitized user input. Special characters in the input can be interpreted as command separators or modifiers by the shell, allowing execution of unauthorized commands. This vulnerability can lead to system compromise at the privilege level of the web server process, potentially resulting in unauthorized data access, service disruption, or complete server takeover.",
      "metadata": {
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "references": [
          "https://github.com/FloeDesignTechnologies/phpcs-security-audit/blob/master/Security/Sniffs/BadFunctions/SystemExecFunctionsSniff.php"
        ],
        "category": "security",
        "technology": [
          "php"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "exec usage with dynamic data may enable OS command injection",
        "fix-suggestion": "Replace direct use of `exec()` with parameterized functions like `proc_open()` that separate command structure from variable inputs. Implement strict validation for any user-provided values that influence command execution. Create an allowlist of permitted commands and arguments rather than accepting arbitrary input."
      },
      "languages": [
        "php"
      ],
      "severity": "ERROR"
    },
    {
      "id": "php.lang.security.ftp-use.ftp-use",
      "patterns": [
        {
          "pattern": "$FUNC(...);"
        },
        {
          "metavariable-regex": {
            "metavariable": "$FUNC",
            "regex": "ftp_.+"
          }
        }
      ],
      "message": "The application uses FTP, which transmits data including credentials in plaintext without encryption. This exposes sensitive information to network eavesdropping attacks. Anyone with access to the network path can intercept login credentials and transferred data.",
      "metadata": {
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "references": [
          "https://www.php.net/manual/en/intro.ftp.php",
          "https://github.com/FloeDesignTechnologies/phpcs-security-audit/blob/master/Security/Sniffs/BadFunctions/FringeFunctionsSniff.php"
        ],
        "category": "security",
        "technology": [
          "php"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Unencrypted FTP exposes data to interception",
        "fix-suggestion": "Replace FTP with secure alternatives like SFTP or FTPS that encrypt connections. Use PHP's `ssh2_sftp` functions or libraries like `phpseclib` for SFTP connections. If you must use FTP temporarily, ensure it's only for non-sensitive, public data transfers."
      },
      "languages": [
        "php"
      ],
      "severity": "ERROR"
    },
    {
      "id": "php.lang.security.ldap-bind-without-password.ldap-bind-without-password",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "ldap_bind($LDAP, $DN, NULL)"
            },
            {
              "pattern": "ldap_bind($LDAP, $DN, '')"
            },
            {
              "patterns": [
                {
                  "pattern": "ldap_bind(...)"
                },
                {
                  "pattern-not": "ldap_bind($LDAP, $DN, $PASSWORD)"
                }
              ]
            }
          ]
        }
      ],
      "message": "Authentication bypass in LDAP operations happens when applications allow binding to directories without requiring a password. This insecure authentication practice removes a critical security control, potentially granting unauthorized access to directory information. The vulnerability can lead to information disclosure, directory service enumeration, or in poorly configured environments, unauthorized modification of directory data without proper authentication.",
      "metadata": {
        "references": [
          "https://www.php.net/manual/en/function.ldap-bind.php"
        ],
        "cwe": [
          "CWE-287: Improper Authentication"
        ],
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A07:2021 - Identification and Authentication Failures"
        ],
        "category": "security",
        "technology": [
          "php"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "LDAP binds without password allow unauthorized access",
        "fix-suggestion": "Always provide both username and password when calling `ldap_bind()` functions and never allow empty credential parameters. Implement proper error handling when LDAP authentication fails rather than falling back to anonymous binds. Configure your LDAP server to disable anonymous binds and enforce authenticated access only."
      },
      "languages": [
        "php"
      ],
      "severity": "WARNING"
    },
    {
      "id": "php.lang.security.mb-ereg-replace-eval.mb-ereg-replace-eval",
      "patterns": [
        {
          "pattern": "mb_ereg_replace($PATTERN, $REPL, $STR, $OPTIONS);"
        },
        {
          "pattern-not": "mb_ereg_replace($PATTERN, $REPL, $STR, \"...\");"
        }
      ],
      "message": "Code execution vulnerabilities in PHP arise when mb_ereg_replace() is used with the 'e' (eval) modifier on user-controlled patterns or replacements. This deprecated but still-functional feature evaluates the replacement string as PHP code after performing the regular expression match, allowing attackers to inject and execute arbitrary code. The impact includes potential application compromise, unauthorized data access, or even server compromise depending on the application's privilege level and configuration.",
      "metadata": {
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "references": [
          "https://www.php.net/manual/en/function.mb-ereg-replace.php",
          "https://www.php.net/manual/en/function.mb-regex-set-options.php"
        ],
        "category": "security",
        "technology": [
          "php"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "mb_ereg_replace with 'e' modifier can execute arbitrary code",
        "fix-suggestion": "Remove the `e` modifier from `mb_ereg_replace()` functions and replace with `preg_replace_callback()` for transformation logic. Implement explicit processing of matched content rather than allowing code evaluation. Validate input patterns and replacement strings to prevent injection of malicious content."
      },
      "languages": [
        "php"
      ],
      "severity": "ERROR"
    },
    {
      "id": "php.lang.security.mcrypt-use.mcrypt-use",
      "patterns": [
        {
          "pattern": "$FUNC(...);"
        },
        {
          "metavariable-regex": {
            "metavariable": "$FUNC",
            "regex": "(mcrypt_|mdecrypt_).+"
          }
        }
      ],
      "message": "The mcrypt library is deprecated and has been removed in newer PHP versions due to security concerns. It implements outdated cryptographic algorithms with known vulnerabilities. Using mcrypt puts your encrypted data at risk of being compromised.",
      "metadata": {
        "cwe": [
          "CWE-676: Use of Potentially Dangerous Function"
        ],
        "references": [
          "https://www.php.net/manual/en/intro.mcrypt.php",
          "https://github.com/FloeDesignTechnologies/phpcs-security-audit/blob/master/Security/Sniffs/BadFunctions/CryptoFunctionsSniff.php"
        ],
        "category": "security",
        "technology": [
          "php"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Dangerous Method or Function"
        ],
        "short-description": "Deprecated mcrypt library uses insecure algorithms",
        "fix-suggestion": "Replace mcrypt functions with modern alternatives from the `sodium` extension or `OpenSSL`. Use `sodium_crypto_secretbox` for symmetric encryption or OpenSSL's `openssl_encrypt` with secure algorithms like AES-256-GCM. Update your code to use currently maintained cryptographic libraries."
      },
      "languages": [
        "php"
      ],
      "severity": "ERROR"
    },
    {
      "id": "php.lang.security.md5-loose-equality.md5-loose-equality",
      "mode": "taint",
      "pattern-sinks": [
        {
          "pattern": "$VAR1 == $VAR2\n"
        },
        {
          "pattern": "$VAR1 != $VAR2\n"
        }
      ],
      "pattern-sources": [
        {
          "pattern": "$PHAR->getSignature()"
        },
        {
          "pattern": "$RARENTRY->getCrc()"
        },
        {
          "pattern": "base_convert(...)"
        },
        {
          "pattern": "bin2hex(...)"
        },
        {
          "pattern": "dechex(...)"
        },
        {
          "pattern": "hash_file(...)"
        },
        {
          "pattern": "hash_final(...)"
        },
        {
          "pattern": "hash_hmac_file(...)"
        },
        {
          "pattern": "hash_hmac(...)"
        },
        {
          "pattern": "hash_pbkdf2(...)"
        },
        {
          "pattern": "hash(...)"
        },
        {
          "pattern": "md5_file(...)"
        },
        {
          "pattern": "md5(...)"
        },
        {
          "pattern": "openssl_x509_fingerprint(...)"
        },
        {
          "pattern": "rnp_locate_key(...)"
        },
        {
          "pattern": "sha1_file(...)"
        },
        {
          "pattern": "sha1(...)"
        },
        {
          "pattern": "sodium_bin2hex(...)"
        }
      ],
      "pattern-sanitizers": [
        {
          "pattern": "strlen(...)"
        }
      ],
      "message": "Loose equality (==) is being used to compare MD5 hashes, which can lead to type juggling vulnerabilities. PHP's loose comparison may treat specially crafted string inputs as equal to their expected hash values. This can allow attackers to bypass authentication or verification checks.",
      "metadata": {
        "cwe": [
          "CWE-697: Incorrect Comparison"
        ],
        "references": [
          "https://www.php.net/manual/en/types.comparisons.php",
          "https://www.whitehatsec.com/blog/magic-hashes/"
        ],
        "category": "security",
        "technology": [
          "php"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Loose hash comparisons enable type juggling attacks",
        "fix-suggestion": "Always use strict comparison (`===`) when comparing hash values. This ensures both the value and type must match exactly. Replace all instances of `==` with `===` in hash comparison code to prevent type juggling attacks."
      },
      "languages": [
        "php"
      ],
      "severity": "ERROR"
    },
    {
      "id": "php.lang.security.md5-used-as-password.md5-used-as-password",
      "severity": "WARNING",
      "message": "MD5 is being used for password hashing, which is highly insecure. MD5 is fast to compute and vulnerable to rainbow table attacks, allowing attackers to crack passwords quickly. Modern hardware can test billions of MD5 hashes per second, making brute force attacks practical.",
      "languages": [
        "php"
      ],
      "metadata": {
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "references": [
          "https://tools.ietf.org/html/rfc6151",
          "https://crypto.stackexchange.com/questions/44151/how-does-the-flame-malware-take-advantage-of-md5-collision",
          "https://security.stackexchange.com/questions/211/how-to-securely-hash-passwords",
          "https://github.com/returntocorp/semgrep-rules/issues/1609",
          "https://www.php.net/password_hash"
        ],
        "category": "security",
        "technology": [
          "md5"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "MD5 password hashing enables rapid password cracking",
        "fix-suggestion": "Replace MD5 with secure password hashing using PHP's built-in `password_hash()` function with `PASSWORD_BCRYPT` or `PASSWORD_ARGON2ID`. These modern algorithms are specifically designed for password storage and automatically handle salting. Use `password_verify()` for checking passwords against the stored hash."
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "md5(...)"
                },
                {
                  "pattern": "hash('md5', ...)"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$FUNCTION(...)"
            },
            {
              "metavariable-regex": {
                "metavariable": "$FUNCTION",
                "regex": "(?i)(.*password.*)"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "php.lang.security.openssl-cbc-static-iv.openssl-cbc-static-iv",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "openssl_encrypt($D, $M, $K, $FLAGS, \"...\",...);"
            },
            {
              "pattern": "openssl_decrypt($D, $M, $K, $FLAGS, \"...\",...);"
            }
          ]
        },
        {
          "metavariable-comparison": {
            "metavariable": "$M",
            "comparison": "re.match(\".*-CBC\",$M)"
          }
        }
      ],
      "message": "A static initialization vector (IV) is being used with AES in CBC mode. Static IVs enable chosen-plaintext attacks because identical plaintexts will produce identical ciphertexts. This weakens encryption by making patterns in the data recognizable even when encrypted.",
      "languages": [
        "php"
      ],
      "severity": "ERROR",
      "metadata": {
        "cwe": [
          "CWE-329: Generation of Predictable IV with CBC Mode"
        ],
        "references": [
          "https://csrc.nist.gov/publications/detail/sp/800-38a/final"
        ],
        "owasp": [
          "A02:2021 - Cryptographic Failures"
        ],
        "technology": [
          "php",
          "openssl"
        ],
        "category": "security",
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Static encryption IVs compromise CBC mode security",
        "fix-suggestion": "Generate a cryptographically random IV for each encryption operation using `openssl_random_pseudo_bytes()` or `random_bytes()`. The IV should be 16 bytes for AES and must be stored alongside the ciphertext to enable decryption. Consider using GCM mode instead of CBC for better security."
      }
    },
    {
      "id": "php.lang.security.php-permissive-cors.php-permissive-cors",
      "patterns": [
        {
          "pattern": "header($VALUE,...)"
        },
        {
          "pattern-either": [
            {
              "pattern": "header(\"...\",...)"
            },
            {
              "pattern-inside": "$VALUE = \"...\";\n...\n"
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$VALUE",
            "regex": "(\\'|\\\")\\s*(Access-Control-Allow-Origin|access-control-allow-origin)\\s*:\\s*(\\*)\\s*(\\'|\\\")"
          }
        }
      ],
      "message": "The Access-Control-Allow-Origin header is set to '*', allowing any domain to make cross-origin requests. This overly permissive CORS policy removes the browser's same-origin protection. It enables malicious websites to make authenticated requests to your API with the user's credentials.",
      "metadata": {
        "references": [
          "https://developer.mozilla.org/ru/docs/Web/HTTP/Headers/Access-Control-Allow-Origin"
        ],
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "cwe": [
          "CWE-346: Origin Validation Error"
        ],
        "category": "security",
        "technology": [
          "php"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Wildcard CORS policy allows cross-site attacks",
        "fix-suggestion": "Replace wildcard (`*`) with specific allowed origins. Implement a whitelist of trusted domains in your CORS configuration and dynamically set `Access-Control-Allow-Origin` to match the requesting origin only if it's in your whitelist. Set `Access-Control-Allow-Credentials: true` only when using specific origins."
      },
      "languages": [
        "php"
      ],
      "severity": "WARNING"
    },
    {
      "id": "php.lang.security.phpinfo-use.phpinfo-use",
      "pattern": "phpinfo(...);",
      "message": "The phpinfo() function is being used, which exposes sensitive server and PHP configuration details. This information helps attackers identify vulnerabilities in your environment. It reveals installed modules, server paths, and security settings that should remain private.",
      "metadata": {
        "cwe": [
          "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor"
        ],
        "references": [
          "https://www.php.net/manual/en/function.phpinfo",
          "https://github.com/FloeDesignTechnologies/phpcs-security-audit/blob/master/Security/Sniffs/BadFunctions/PhpinfosSniff.php"
        ],
        "category": "security",
        "technology": [
          "php"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "PHPInfo function leaks sensitive configuration data",
        "fix-suggestion": "Remove all calls to `phpinfo()` from production code. If debugging is needed, restrict access to development environments only. Create a custom information page that displays only the specific configuration details developers need without revealing sensitive system information."
      },
      "languages": [
        "php"
      ],
      "severity": "ERROR"
    },
    {
      "id": "php.lang.security.tainted-exec.tainted-exec",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern": "$_REQUEST"
        },
        {
          "pattern": "$_GET"
        },
        {
          "pattern": "$_POST"
        },
        {
          "pattern": "$_COOKIE"
        }
      ],
      "pattern-sinks": [
        {
          "pattern": "exec(...)"
        },
        {
          "pattern": "system(...)"
        },
        {
          "pattern": "popen(...)"
        },
        {
          "pattern": "passthru(...)"
        },
        {
          "pattern": "shell_exec(...)"
        },
        {
          "pattern": "pcntl_exec(...)"
        },
        {
          "pattern": "proc_open(...)"
        }
      ],
      "pattern-sanitizers": [
        {
          "pattern": "escapeshellarg(...)"
        }
      ],
      "message": "Command injection in PHP system execution functions occurs when commands incorporate unsanitized user input without proper escaping. When special shell characters in the input are interpreted by the command processor, attackers can inject additional unauthorized commands. This vulnerability can lead to unauthorized command execution on the server with the same privileges as the web application process, potentially resulting in data theft, service disruption, or complete system compromise.",
      "metadata": {
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "references": [
          "https://www.stackhawk.com/blog/php-command-injection/",
          "https://brightsec.com/blog/code-injection-php/",
          "https://www.acunetix.com/websitesecurity/php-security-2/"
        ],
        "category": "security",
        "technology": [
          "php"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Executing user-supplied commands leads to injection",
        "fix-suggestion": "Replace vulnerable calls to `exec()`, `shell_exec()`, `system()`, or `passthru()` with safer alternatives that don't mix commands and data. Implement input validation with allowlists for any parameters that influence command structure. Consider redesigning functionality to avoid shell command execution entirely when possible."
      },
      "languages": [
        "php"
      ],
      "severity": "ERROR"
    },
    {
      "id": "php.lang.security.unlink-use.unlink-use",
      "patterns": [
        {
          "pattern": "unlink(...)"
        },
        {
          "pattern-not": "unlink(\"...\",...)"
        }
      ],
      "message": "Path traversal vulnerabilities with unlink() occur when the function deletes files based on paths constructed from unvalidated user input. Without proper path validation, attackers can manipulate the file path using directory traversal sequences (e.g., '../') to target critical system or application files. This can lead to unauthorized file deletion, service disruption, or in certain contexts, privilege escalation by removing security-critical files.",
      "metadata": {
        "references": [
          "https://www.php.net/manual/en/function.unlink",
          "https://owasp.org/www-project-top-ten/2017/A5_2017-Broken_Access_Control.html"
        ],
        "category": "security",
        "technology": [
          "php"
        ],
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "short-description": "Unvalidated unlink parameter can remove arbitrary files",
        "fix-suggestion": "Validate file paths before calling `unlink()` by checking for directory traversal sequences like `../` or unauthorized locations. Implement path canonicalization using `realpath()` to resolve the actual target before operations. Restrict file operations to a specific whitelisted directory structure to contain potential damage."
      },
      "languages": [
        "php"
      ],
      "severity": "WARNING"
    },
    {
      "id": "php.lang.security.unserialize-use.unserialize-use",
      "patterns": [
        {
          "pattern": "unserialize(...)"
        },
        {
          "pattern-not": "unserialize(\"...\",...)"
        }
      ],
      "message": "Remote code execution vulnerabilities in PHP unserialize() occur when the function processes serialized data from untrusted sources. During unserialization, PHP instantiates objects and calls magic methods defined in the application, which attackers can leverage to execute arbitrary code through gadget chains. This critical vulnerability can lead to complete application compromise, unauthorized data access, or even server takeover depending on the application's privileges and available gadget classes.",
      "metadata": {
        "references": [
          "https://www.php.net/manual/en/function.unserialize.php",
          "https://owasp.org/www-project-top-ten/2017/A8_2017-Insecure_Deserialization.html"
        ],
        "category": "security",
        "technology": [
          "php"
        ],
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "Unserialize on untrusted data can run malicious code",
        "fix-suggestion": "Replace `unserialize()` calls with safer alternatives like `json_decode()` for data interchange. If PHP serialization is required, implement the `allowed_classes` parameter to restrict which classes can be deserialized. Consider implementing a wrapper function that performs additional validation before deserialization occurs."
      },
      "languages": [
        "php"
      ],
      "severity": "WARNING"
    },
    {
      "id": "php.lang.security.audit.openssl-decrypt-validate.openssl-decrypt-validate",
      "patterns": [
        {
          "pattern": "openssl_decrypt(...);"
        },
        {
          "pattern-not-inside": "$DECRYPTED_STRING = openssl_decrypt(...);\n...\nif($DECRYPTED_STRING === false){\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "$DECRYPTED_STRING = openssl_decrypt(...);\n...\nif($DECRYPTED_STRING == false){\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "$DECRYPTED_STRING = openssl_decrypt(...);\n...\nif(false === $DECRYPTED_STRING){\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "$DECRYPTED_STRING = openssl_decrypt(...);\n...\nif(false == $DECRYPTED_STRING){\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "$DECRYPTED_STRING = openssl_decrypt(...);\n...\nassertTrue(false !== $DECRYPTED_STRING,...);\n"
        },
        {
          "pattern-not-inside": "$DECRYPTED_STRING = openssl_decrypt(...);\n...\nassertTrue($DECRYPTED_STRING !== false,...);\n"
        },
        {
          "pattern-not-inside": "$DECRYPTED_STRING = openssl_decrypt(...);\n...\n$REFERENCE::assertTrue(false !== $DECRYPTED_STRING,...);\n"
        },
        {
          "pattern-not-inside": "$DECRYPTED_STRING = openssl_decrypt(...);\n...\n$REFERENCE::assertTrue($DECRYPTED_STRING !== false,...);\n"
        },
        {
          "pattern-not-inside": "$DECRYPTED_STRING = openssl_decrypt(...);\n...\nassert(false !== $DECRYPTED_STRING,...);\n"
        },
        {
          "pattern-not-inside": "$DECRYPTED_STRING = openssl_decrypt(...);\n...\nassert($DECRYPTED_STRING !== false,...);\n"
        }
      ],
      "message": "The openssl_decrypt function can return false on failure, but this case isn't being handled. Without proper error checking, decryption failures might lead to undefined behavior in your application. Malformed inputs or incorrect keys can cause silent failures that compromise security.",
      "languages": [
        "php"
      ],
      "severity": "WARNING",
      "metadata": {
        "references": [
          "https://www.php.net/manual/en/function.openssl-decrypt.php"
        ],
        "cwe": [
          "CWE-252: Unchecked Return Value"
        ],
        "owasp": [
          "A02:2021 - Cryptographic Failures"
        ],
        "technology": [
          "php",
          "openssl"
        ],
        "category": "security",
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Unchecked decrypt failures risk security errors",
        "fix-suggestion": "Always check the return value of `openssl_decrypt()` using strict comparison (`===`) against `false`. Implement proper error handling for decryption failures that doesn't expose sensitive information. Consider using a try-catch pattern that handles failures gracefully without revealing cryptographic details."
      }
    },
    {
      "id": "php.lang.security.audit.sha224-hash.sha224-hash",
      "pattern-either": [
        {
          "pattern": "hash('sha224', ...);"
        },
        {
          "pattern": "hash('sha512/224', ...);"
        },
        {
          "pattern": "hash('sha3-224', ...);"
        },
        {
          "pattern": "hash_hmac('sha224', ...);"
        },
        {
          "pattern": "hash_hmac('sha512/224', ...);"
        },
        {
          "pattern": "hash_hmac('sha3-224', ...);"
        }
      ],
      "message": "SHA-224 is being used, which is a 224-bit hash function that's considered weak or deprecated in some security policies. While better than MD5 or SHA-1, it provides less security margin than stronger alternatives. Some compliance frameworks explicitly disallow its use.",
      "metadata": {
        "cwe": [
          "CWE-328: Use of Weak Hash"
        ],
        "references": [
          "https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar3.ipd.pdf",
          "https://www.cyber.gov.au/resources-business-and-government/essential-cyber-security/ism/cyber-security-guidelines/guidelines-cryptography"
        ],
        "category": "security",
        "technology": [
          "php"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Hashing Algorithm"
        ],
        "short-description": "SHA-224 fails to meet modern security standards",
        "fix-suggestion": "Upgrade to stronger hash algorithms from the SHA-2 family like `SHA-256`, `SHA-384`, or `SHA-512`. For the highest security level, consider using SHA-3 variants. Use `hash('sha256', $data)` or similar to implement these stronger algorithms in your code."
      },
      "languages": [
        "php"
      ],
      "severity": "WARNING"
    },
    {
      "id": "php.lang.security.deserialization.extract-user-data",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern-either": [
            {
              "pattern": "$_GET[...]"
            },
            {
              "pattern": "$_FILES[...]"
            },
            {
              "pattern": "$_POST[...]"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "pattern": "extract(...)"
        }
      ],
      "pattern-sanitizers": [
        {
          "pattern": "extract($VAR, EXTR_SKIP,...)"
        }
      ],
      "message": "Security vulnerabilities with PHP's extract() function arise when it creates variables directly from untrusted user input like $_GET or $_POST arrays. This function converts array keys into variable names and their values into the variables' values, allowing attackers to overwrite existing variables including ones that control application security. The impact includes variable manipulation, security bypass, or even code execution if extracted values can influence code paths that evaluate PHP code.",
      "languages": [
        "php"
      ],
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "technology": [
          "php"
        ],
        "references": [
          "https://www.php.net/manual/en/function.extract.php#refsect1-function.extract-notes"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "extract() with user data can overwrite important variables",
        "fix-suggestion": "Remove uses of `extract()` on untrusted data sources like `$_GET`, `$_POST`, or other user inputs. Access input values explicitly with proper validation and type checking before assignment. Define required variables ahead of time rather than allowing dynamic variable creation from user data."
      },
      "severity": "ERROR"
    },
    {
      "id": "php.lang.security.injection.printed-request.printed-request",
      "mode": "taint",
      "message": "Cross-site scripting (XSS) vulnerabilities occur when applications output user input directly to web pages without proper HTML encoding. When browsers render this unescaped output containing malicious HTML or JavaScript, the injected code executes in the context of the vulnerable site. This allows attackers to steal session cookies, capture credentials, perform unauthorized actions on behalf of the victim, or deliver malware through the trusted website.",
      "languages": [
        "php"
      ],
      "severity": "ERROR",
      "pattern-sources": [
        {
          "pattern": "$_REQUEST"
        },
        {
          "pattern": "$_GET"
        },
        {
          "pattern": "$_POST"
        }
      ],
      "pattern-sinks": [
        {
          "pattern": "print($...VARS);"
        }
      ],
      "pattern-sanitizers": [
        {
          "pattern": "htmlentities(...)"
        },
        {
          "pattern": "htmlspecialchars(...)"
        },
        {
          "pattern": "strip_tags(...)"
        },
        {
          "pattern": "isset(...)"
        },
        {
          "pattern": "empty(...)"
        },
        {
          "pattern": "esc_html(...)"
        },
        {
          "pattern": "esc_attr(...)"
        },
        {
          "pattern": "wp_kses(...)"
        },
        {
          "pattern": "e(...)"
        },
        {
          "pattern": "twig_escape_filter(...)"
        },
        {
          "pattern": "xss_clean(...)"
        },
        {
          "pattern": "html_escape(...)"
        },
        {
          "pattern": "Html::escape(...)"
        },
        {
          "pattern": "Xss::filter(...)"
        },
        {
          "pattern": "escapeHtml(...)"
        },
        {
          "pattern": "escapeHtml(...)"
        },
        {
          "pattern": "escapeHtmlAttr(...)"
        }
      ],
      "fix": "print(htmlentities($...VARS));",
      "metadata": {
        "technology": [
          "php"
        ],
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "category": "security",
        "references": [
          "https://www.php.net/manual/en/function.htmlentities.php",
          "https://www.php.net/manual/en/reserved.variables.request.php",
          "https://www.php.net/manual/en/reserved.variables.post.php",
          "https://www.php.net/manual/en/reserved.variables.get.php",
          "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Printing user request data without sanitization can cause XSS",
        "fix-suggestion": "Apply output encoding with `htmlspecialchars()` or similar functions before displaying any user input in HTML contexts. Use context-appropriate escaping like `json_encode()` for JavaScript contexts or `urlencode()` for URL parameters. Implement a templating engine with automatic escaping like Twig to systematically prevent XSS vulnerabilities."
      }
    },
    {
      "id": "php.lang.security.injection.tainted-callable.tainted-callable",
      "severity": "WARNING",
      "message": "User input is being used to determine which function to call, creating a remote code execution risk. An attacker who controls this input can execute arbitrary functions that exist in your application. This is a critical security vulnerability that enables complete system compromise.",
      "metadata": {
        "technology": [
          "php"
        ],
        "category": "security",
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://www.php.net/manual/en/language.types.callable.php"
        ],
        "subcategory": [
          "vuln"
        ],
        "impact": "HIGH",
        "likelihood": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "User-controlled function calls enable code execution",
        "fix-suggestion": "Never use user input to select callable functions. Replace dynamic function calls with a fixed whitelist of allowed functions using a switch statement or mapping array. Implement strict validation that ensures only explicitly allowed function names can be executed."
      },
      "languages": [
        "php"
      ],
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$_GET"
                },
                {
                  "pattern": "$_POST"
                },
                {
                  "pattern": "$_COOKIE"
                },
                {
                  "pattern": "$_REQUEST"
                },
                {
                  "pattern": "file_get_contents('php://input')"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$CALLABLE"
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "$ARRAYITERATOR->uasort($CALLABLE)"
                },
                {
                  "pattern-inside": "$ARRAYITERATOR->uksort($CALLABLE)"
                },
                {
                  "pattern-inside": "$EVENTHTTP->setCallback($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "$EVENTHTTPCONNECTION->setCloseCallback($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "$EVLOOP->fork($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "$EVLOOP->idle($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "$EVLOOP->prepare($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "$EVWATCHER->setCallback($CALLABLE)"
                },
                {
                  "pattern-inside": "$GEARMANCLIENT->setClientCallback($CALLABLE)"
                },
                {
                  "pattern-inside": "$GEARMANCLIENT->setCompleteCallback($CALLABLE)"
                },
                {
                  "pattern-inside": "$GEARMANCLIENT->setCreatedCallback($CALLABLE)"
                },
                {
                  "pattern-inside": "$GEARMANCLIENT->setDataCallback($CALLABLE)"
                },
                {
                  "pattern-inside": "$GEARMANCLIENT->setExceptionCallback($CALLABLE)"
                },
                {
                  "pattern-inside": "$GEARMANCLIENT->setFailCallback($CALLABLE)"
                },
                {
                  "pattern-inside": "$GEARMANCLIENT->setStatusCallback($CALLABLE)"
                },
                {
                  "pattern-inside": "$GEARMANCLIENT->setWarningCallback($CALLABLE)"
                },
                {
                  "pattern-inside": "$GEARMANCLIENT->setWorkloadCallback($CALLABLE)"
                },
                {
                  "pattern-inside": "$IMAGICK->setProgressMonitor($CALLABLE)"
                },
                {
                  "pattern-inside": "$OAUTHPROVIDER->consumerHandler($CALLABLE)"
                },
                {
                  "pattern-inside": "$OAUTHPROVIDER->tokenHandler($CALLABLE)"
                },
                {
                  "pattern-inside": "$PDO->sqliteCreateCollation($NAME, $CALLABLE)"
                },
                {
                  "pattern-inside": "$PDOSTATEMENT->fetchAll(PDO::FETCH_FUNC, $CALLABLE)"
                },
                {
                  "pattern-inside": "$SQLITE3->createCollation($NAME, $CALLABLE)"
                },
                {
                  "pattern-inside": "$SQLITE3->setAuthorizer($CALLABLE)"
                },
                {
                  "pattern-inside": "$ZIPARCHIVE->registerCancelCallback($CALLABLE)"
                },
                {
                  "pattern-inside": "$ZIPARCHIVE->registerProgressCallback($RATE, $CALLABLE)"
                },
                {
                  "pattern-inside": "$ZMQDEVICE->setIdleCallback($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "$ZMQDEVICE->setTimerCallback($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "apcu_entry($KEY, $CALLABLE, ...)"
                },
                {
                  "pattern-inside": "array_filter($ARRAY, $CALLABLE, ...)"
                },
                {
                  "pattern-inside": "array_map($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "array_reduce($ARRAY, $CALLABLE, ...)"
                },
                {
                  "pattern-inside": "array_walk_recursive($ARRAY, $CALLABLE, ...)"
                },
                {
                  "pattern-inside": "array_walk($ARRAY, $CALLABLE, ...)"
                },
                {
                  "pattern-inside": "call_user_func_array($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "call_user_func($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "Closure::fromCallable($CALLABLE)"
                },
                {
                  "pattern-inside": "createCollation($NAME, $CALLABLE)"
                },
                {
                  "pattern-inside": "eio_grp($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "eio_nop($PRI, $CALLABLE, ...)"
                },
                {
                  "pattern-inside": "eio_sync($PRI, $CALLABLE, ...)"
                },
                {
                  "pattern-inside": "EvPrepare::createStopped($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "fann_set_callback($ANN, $CALLABLE)"
                },
                {
                  "pattern-inside": "fdf_enum_values($FDF_DOCUMENT, $CALLABLE, ...)"
                },
                {
                  "pattern-inside": "forward_static_call_array($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "forward_static_call($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "header_register_callback($CALLABLE)"
                },
                {
                  "pattern-inside": "ibase_set_event_handler($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "IntlChar::enumCharTypes($CALLABLE)"
                },
                {
                  "pattern-inside": "iterator_apply($ITERATOR, $CALLABLE)"
                },
                {
                  "pattern-inside": "ldap_set_rebind_proc($LDAP, $CALLABLE)"
                },
                {
                  "pattern-inside": "libxml_set_external_entity_loader($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "new CallbackFilterIterator($ITERATOR, $CALLABLE)"
                },
                {
                  "pattern-inside": "new EvCheck($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "new EventHttpRequest($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "new EvFork($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "new EvIdle($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "new Fiber($CALLABLE)"
                },
                {
                  "pattern-inside": "new Memcached($PERSISTENT_ID, $CALLABLE, ...)"
                },
                {
                  "pattern-inside": "new RecursiveCallbackFilterIterator($ITERATOR, $CALLABLE)"
                },
                {
                  "pattern-inside": "new Zookeeper($HOST, $CALLABLE, ...)"
                },
                {
                  "pattern-inside": "ob_start($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "oci_register_taf_callback($CONNECTION, $CALLABLE)"
                },
                {
                  "pattern-inside": "readline_callback_handler_install($PROMPT, $CALLABLE)"
                },
                {
                  "pattern-inside": "readline_completion_function($CALLABLE)"
                },
                {
                  "pattern-inside": "register_shutdown_function($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "register_tick_function($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "rnp_ffi_set_pass_provider($FFI, $CALLABLE)"
                },
                {
                  "pattern-inside": "sapi_windows_set_ctrl_handler($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "set_error_handler($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "set_exception_handler($CALLABLE)"
                },
                {
                  "pattern-inside": "setAuthorizer($CALLABLE)"
                },
                {
                  "pattern-inside": "spl_autoload_register($CALLABLE, ...)"
                },
                {
                  "pattern-inside": "uasort($ARRAY, $CALLABLE)"
                },
                {
                  "pattern-inside": "uksort($ARRAY, $CALLABLE)"
                },
                {
                  "pattern-inside": "usort($ARRAY, $CALLABLE)"
                },
                {
                  "pattern-inside": "xml_set_character_data_handler($PARSER, $CALLABLE)"
                },
                {
                  "pattern-inside": "xml_set_default_handler($PARSER, $CALLABLE)"
                },
                {
                  "pattern-inside": "xml_set_element_handler($PARSER, $CALLABLE, $CALLABLE)"
                },
                {
                  "pattern-inside": "xml_set_notation_decl_handler($PARSER, $CALLABLE)"
                },
                {
                  "pattern-inside": "Yar_Concurrent_Client::loop($CALLABLE, ...)"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "php.lang.security.injection.tainted-exec.tainted-exec",
      "languages": [
        "php"
      ],
      "severity": "WARNING",
      "message": "User input is being passed directly to a shell command execution function. This allows attackers to inject additional commands that will be executed with the permissions of your web server. Command injection vulnerabilities are among the most dangerous as they provide direct system access.",
      "metadata": {
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "category": "security",
        "technology": [
          "php"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "subcategory": [
          "vuln"
        ],
        "impact": "HIGH",
        "likelihood": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Unsanitized shell commands enable system compromise",
        "fix-suggestion": "Never pass user input directly to functions like `exec()`, `system()`, or `shell_exec()`. Use dedicated PHP functions for specific operations instead of shell commands. If shell commands are necessary, validate inputs strictly and use `escapeshellarg()` and `escapeshellcmd()` to neutralize special characters."
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$_GET"
                },
                {
                  "pattern": "$_POST"
                },
                {
                  "pattern": "$_COOKIE"
                },
                {
                  "pattern": "$_REQUEST"
                },
                {
                  "pattern": "file_get_contents('php://input')"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "escapeshellcmd(...)"
                },
                {
                  "pattern": "escapeshellarg(...)"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "exec(...)"
                },
                {
                  "pattern": "system(...)"
                },
                {
                  "pattern": "passthru(...)"
                },
                {
                  "patterns": [
                    {
                      "pattern": "proc_open(...)"
                    },
                    {
                      "pattern-not": "proc_open([...], ...)"
                    }
                  ]
                },
                {
                  "pattern": "popen(...)"
                },
                {
                  "pattern": "expect_popen(...)"
                },
                {
                  "pattern": "shell_exec(...)"
                },
                {
                  "pattern": "`...`\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "php.lang.security.injection.tainted-filename.tainted-filename",
      "severity": "WARNING",
      "message": "Server-side request forgery (SSRF) vulnerabilities arise when applications use user-supplied input to construct filenames or paths for server operations. Without proper validation, attackers can manipulate these inputs to force the server to access internal resources or remote services. This can lead to unauthorized access to internal files, network scanning, service enumeration, or exploitation of trust relationships between the server and other internal systems.",
      "metadata": {
        "technology": [
          "php"
        ],
        "category": "security",
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "references": [
          "https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "impact": "MEDIUM",
        "likelihood": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "User-controlled filename input can lead to SSRF or file injection",
        "fix-suggestion": "Sanitize filenames from user input by removing path components and special characters before using them in functions like `file_get_contents()` or `fopen()`. Use `basename()` to strip directory traversal sequences and implement pattern validation with allowlists. Consider storing user files with server-generated names and maintaining a secure mapping to user-provided names."
      },
      "languages": [
        "php"
      ],
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$_GET"
                },
                {
                  "pattern": "$_POST"
                },
                {
                  "pattern": "$_COOKIE"
                },
                {
                  "pattern": "$_REQUEST"
                },
                {
                  "pattern": "$_SERVER"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "basename($PATH, ...)"
                },
                {
                  "pattern-inside": "linkinfo($PATH, ...)"
                },
                {
                  "pattern-inside": "readlink($PATH, ...)"
                },
                {
                  "pattern-inside": "realpath($PATH, ...)"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "opcache_compile_file($FILENAME, ...)"
                },
                {
                  "pattern-inside": "opcache_invalidate($FILENAME, ...)"
                },
                {
                  "pattern-inside": "opcache_is_script_cached($FILENAME, ...)"
                },
                {
                  "pattern-inside": "runkit7_import($FILENAME, ...)"
                },
                {
                  "pattern-inside": "readline_read_history($FILENAME, ...)"
                },
                {
                  "pattern-inside": "readline_write_history($FILENAME, ...)"
                },
                {
                  "pattern-inside": "rar_open($FILENAME, ...)"
                },
                {
                  "pattern-inside": "zip_open($FILENAME, ...)"
                },
                {
                  "pattern-inside": "gzfile($FILENAME, ...)"
                },
                {
                  "pattern-inside": "gzopen($FILENAME, ...)"
                },
                {
                  "pattern-inside": "readgzfile($FILENAME, ...)"
                },
                {
                  "pattern-inside": "hash_file($ALGO, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "hash_update_file($CONTEXT, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "pg_trace($FILENAME, ...)"
                },
                {
                  "pattern-inside": "dio_open($FILENAME, ...)"
                },
                {
                  "pattern-inside": "finfo_file($FINFO, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "mime_content_type($FILENAME, ...)"
                },
                {
                  "pattern-inside": "chgrp($FILENAME, ...)"
                },
                {
                  "pattern-inside": "chmod($FILENAME, ...)"
                },
                {
                  "pattern-inside": "chown($FILENAME, ...)"
                },
                {
                  "pattern-inside": "clearstatcache($CLEAR_REALPATH_CACHE, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "file_exists($FILENAME, ...)"
                },
                {
                  "pattern-inside": "file_get_contents($FILENAME, ...)"
                },
                {
                  "pattern-inside": "file_put_contents($FILENAME, ...)"
                },
                {
                  "pattern-inside": "file($FILENAME, ...)"
                },
                {
                  "pattern-inside": "fileatime($FILENAME, ...)"
                },
                {
                  "pattern-inside": "filectime($FILENAME, ...)"
                },
                {
                  "pattern-inside": "filegroup($FILENAME, ...)"
                },
                {
                  "pattern-inside": "fileinode($FILENAME, ...)"
                },
                {
                  "pattern-inside": "filemtime($FILENAME, ...)"
                },
                {
                  "pattern-inside": "fileowner($FILENAME, ...)"
                },
                {
                  "pattern-inside": "fileperms($FILENAME, ...)"
                },
                {
                  "pattern-inside": "filesize($FILENAME, ...)"
                },
                {
                  "pattern-inside": "filetype($FILENAME, ...)"
                },
                {
                  "pattern-inside": "fnmatch($PATTERN, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "fopen($FILENAME, ...)"
                },
                {
                  "pattern-inside": "is_dir($FILENAME, ...)"
                },
                {
                  "pattern-inside": "is_executable($FILENAME, ...)"
                },
                {
                  "pattern-inside": "is_file($FILENAME, ...)"
                },
                {
                  "pattern-inside": "is_link($FILENAME, ...)"
                },
                {
                  "pattern-inside": "is_readable($FILENAME, ...)"
                },
                {
                  "pattern-inside": "is_uploaded_file($FILENAME, ...)"
                },
                {
                  "pattern-inside": "is_writable($FILENAME, ...)"
                },
                {
                  "pattern-inside": "lchgrp($FILENAME, ...)"
                },
                {
                  "pattern-inside": "lchown($FILENAME, ...)"
                },
                {
                  "pattern-inside": "lstat($FILENAME, ...)"
                },
                {
                  "pattern-inside": "parse_ini_file($FILENAME, ...)"
                },
                {
                  "pattern-inside": "readfile($FILENAME, ...)"
                },
                {
                  "pattern-inside": "stat($FILENAME, ...)"
                },
                {
                  "pattern-inside": "touch($FILENAME, ...)"
                },
                {
                  "pattern-inside": "unlink($FILENAME, ...)"
                },
                {
                  "pattern-inside": "xattr_get($FILENAME, ...)"
                },
                {
                  "pattern-inside": "xattr_list($FILENAME, ...)"
                },
                {
                  "pattern-inside": "xattr_remove($FILENAME, ...)"
                },
                {
                  "pattern-inside": "xattr_set($FILENAME, ...)"
                },
                {
                  "pattern-inside": "xattr_supported($FILENAME, ...)"
                },
                {
                  "pattern-inside": "enchant_broker_request_pwl_dict($BROKER, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "pspell_config_personal($CONFIG, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "pspell_config_repl($CONFIG, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "pspell_new_personal($FILENAME, ...)"
                },
                {
                  "pattern-inside": "exif_imagetype($FILENAME, ...)"
                },
                {
                  "pattern-inside": "getimagesize($FILENAME, ...)"
                },
                {
                  "pattern-inside": "image2wbmp($IMAGE, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "imagecreatefromavif($FILENAME, ...)"
                },
                {
                  "pattern-inside": "imagecreatefrombmp($FILENAME, ...)"
                },
                {
                  "pattern-inside": "imagecreatefromgd2($FILENAME, ...)"
                },
                {
                  "pattern-inside": "imagecreatefromgd2part($FILENAME, ...)"
                },
                {
                  "pattern-inside": "imagecreatefromgd($FILENAME, ...)"
                },
                {
                  "pattern-inside": "imagecreatefromgif($FILENAME, ...)"
                },
                {
                  "pattern-inside": "imagecreatefromjpeg($FILENAME, ...)"
                },
                {
                  "pattern-inside": "imagecreatefrompng($FILENAME, ...)"
                },
                {
                  "pattern-inside": "imagecreatefromtga($FILENAME, ...)"
                },
                {
                  "pattern-inside": "imagecreatefromwbmp($FILENAME, ...)"
                },
                {
                  "pattern-inside": "imagecreatefromwebp($FILENAME, ...)"
                },
                {
                  "pattern-inside": "imagecreatefromxbm($FILENAME, ...)"
                },
                {
                  "pattern-inside": "imagecreatefromxpm($FILENAME, ...)"
                },
                {
                  "pattern-inside": "imageloadfont($FILENAME, ...)"
                },
                {
                  "pattern-inside": "imagexbm($IMAGE, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "iptcembed($IPTC_DATA, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "mailparse_msg_extract_part_file($MIMEMAIL, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "mailparse_msg_extract_whole_part_file($MIMEMAIL, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "mailparse_msg_parse_file($FILENAME, ...)"
                },
                {
                  "pattern-inside": "fdf_add_template($FDF_DOCUMENT, $NEWPAGE, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "fdf_get_ap($FDF_DOCUMENT, $FIELD, $FACE, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "fdf_open($FILENAME, ...)"
                },
                {
                  "pattern-inside": "fdf_save($FDF_DOCUMENT, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "fdf_set_ap($FDF_DOCUMENT, $FIELD_NAME, $FACE, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "ps_add_launchlink($PSDOC, $LLX, $LLY, $URX, $URY, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "ps_add_pdflink($PSDOC, $LLX, $LLY, $URX, $URY, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "ps_open_file($PSDOC, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "ps_open_image_file($PSDOC, $TYPE, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "posix_access($FILENAME, ...)"
                },
                {
                  "pattern-inside": "posix_mkfifo($FILENAME, ...)"
                },
                {
                  "pattern-inside": "posix_mknod($FILENAME, ...)"
                },
                {
                  "pattern-inside": "ftok($FILENAME, ...)"
                },
                {
                  "pattern-inside": "fann_cascadetrain_on_file($ANN, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "fann_read_train_from_file($FILENAME, ...)"
                },
                {
                  "pattern-inside": "fann_train_on_file($ANN, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "highlight_file($FILENAME, ...)"
                },
                {
                  "pattern-inside": "php_strip_whitespace($FILENAME, ...)"
                },
                {
                  "pattern-inside": "stream_resolve_include_path($FILENAME, ...)"
                },
                {
                  "pattern-inside": "swoole_async_read($FILENAME, ...)"
                },
                {
                  "pattern-inside": "swoole_async_readfile($FILENAME, ...)"
                },
                {
                  "pattern-inside": "swoole_async_write($FILENAME, ...)"
                },
                {
                  "pattern-inside": "swoole_async_writefile($FILENAME, ...)"
                },
                {
                  "pattern-inside": "swoole_load_module($FILENAME, ...)"
                },
                {
                  "pattern-inside": "tidy_parse_file($FILENAME, ...)"
                },
                {
                  "pattern-inside": "tidy_repair_file($FILENAME, ...)"
                },
                {
                  "pattern-inside": "get_meta_tags($FILENAME, ...)"
                },
                {
                  "pattern-inside": "yaml_emit_file($FILENAME, ...)"
                },
                {
                  "pattern-inside": "yaml_parse_file($FILENAME, ...)"
                },
                {
                  "pattern-inside": "curl_file_create($FILENAME, ...)"
                },
                {
                  "pattern-inside": "ftp_chmod($FTP, $PERMISSIONS, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "ftp_delete($FTP, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "ftp_mdtm($FTP, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "ftp_size($FTP, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "rrd_create($FILENAME, ...)"
                },
                {
                  "pattern-inside": "rrd_fetch($FILENAME, ...)"
                },
                {
                  "pattern-inside": "rrd_graph($FILENAME, ...)"
                },
                {
                  "pattern-inside": "rrd_info($FILENAME, ...)"
                },
                {
                  "pattern-inside": "rrd_last($FILENAME, ...)"
                },
                {
                  "pattern-inside": "rrd_lastupdate($FILENAME, ...)"
                },
                {
                  "pattern-inside": "rrd_tune($FILENAME, ...)"
                },
                {
                  "pattern-inside": "rrd_update($FILENAME, ...)"
                },
                {
                  "pattern-inside": "snmp_read_mib($FILENAME, ...)"
                },
                {
                  "pattern-inside": "ssh2_sftp_chmod($SFTP, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "ssh2_sftp_realpath($SFTP, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "ssh2_sftp_unlink($SFTP, $FILENAME, ...)"
                },
                {
                  "pattern-inside": "apache_lookup_uri($FILENAME, ...)"
                },
                {
                  "pattern-inside": "md5_file($FILENAME, ...)"
                },
                {
                  "pattern-inside": "sha1_file($FILENAME, ...)"
                },
                {
                  "pattern-inside": "simplexml_load_file($FILENAME, ...)"
                }
              ]
            },
            {
              "pattern": "$FILENAME"
            }
          ]
        }
      ]
    },
    {
      "id": "php.lang.security.injection.tainted-object-instantiation.tainted-object-instantiation",
      "languages": [
        "php"
      ],
      "severity": "WARNING",
      "message": "A new object is being created where the class name is based on user input. This allows attackers to instantiate any class in your application, potentially leading to remote code execution. Many classes have side effects when instantiated that can be exploited.",
      "metadata": {
        "cwe": [
          "CWE-470: Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')"
        ],
        "category": "security",
        "technology": [
          "php"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "subcategory": [
          "vuln"
        ],
        "impact": "MEDIUM",
        "likelihood": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Dynamic class instantiation enables object injection",
        "fix-suggestion": "Replace dynamic class instantiation with a whitelist approach. Create a mapping array of allowed class names and validate user input against this list. Use pattern matching or exact string comparison to ensure only authorized classes can be instantiated through user-controlled input."
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$_GET"
                },
                {
                  "pattern": "$_POST"
                },
                {
                  "pattern": "$_COOKIE"
                },
                {
                  "pattern": "$_REQUEST"
                },
                {
                  "pattern": "$_SERVER"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "new $SINK(...)"
                }
              ]
            },
            {
              "pattern": "$SINK"
            }
          ]
        }
      ]
    },
    {
      "id": "php.lang.security.injection.tainted-session.tainted-session",
      "severity": "WARNING",
      "message": "Session manipulation vulnerabilities occur when applications use user-controlled input as session identifiers or keys without proper validation. This insecure practice allows attackers to predict, hijack, or manipulate session data for unauthorized access. The impact includes session fixation attacks, authentication bypass, privilege escalation, or unauthorized access to user accounts and their associated data.",
      "metadata": {
        "technology": [
          "php"
        ],
        "category": "security",
        "cwe": [
          "CWE-284: Improper Access Control"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "references": [
          "https://en.wikipedia.org/wiki/Session_poisoning"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "impact": "MEDIUM",
        "likelihood": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "User-supplied session keys risk unauthorized session manipulation",
        "fix-suggestion": "Generate session identifiers using secure functions like `session_create_id()` instead of accepting user input for `session_id()`. Implement proper validation for any session-related user input and never allow direct session manipulation. Consider implementing additional session security measures like regenerating IDs after authentication and using the `httponly` and `secure` flags."
      },
      "languages": [
        "php"
      ],
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$_GET"
                },
                {
                  "pattern": "$_POST"
                },
                {
                  "pattern": "$_COOKIE"
                },
                {
                  "pattern": "$_REQUEST"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$A . $B"
                },
                {
                  "pattern": "bin2hex(...)"
                },
                {
                  "pattern": "crc32(...)"
                },
                {
                  "pattern": "crypt(...)"
                },
                {
                  "pattern": "filter_input(...)"
                },
                {
                  "pattern": "filter_var(...)"
                },
                {
                  "pattern": "hash(...)"
                },
                {
                  "pattern": "md5(...)"
                },
                {
                  "pattern": "preg_filter(...)"
                },
                {
                  "pattern": "preg_grep(...)"
                },
                {
                  "pattern": "preg_match_all(...)"
                },
                {
                  "pattern": "sha1(...)"
                },
                {
                  "pattern": "sprintf(...)"
                },
                {
                  "pattern": "str_contains(...)"
                },
                {
                  "pattern": "str_ends_with(...)"
                },
                {
                  "pattern": "str_starts_with(...)"
                },
                {
                  "pattern": "strcasecmp(...)"
                },
                {
                  "pattern": "strchr(...)"
                },
                {
                  "pattern": "stripos(...)"
                },
                {
                  "pattern": "stristr(...)"
                },
                {
                  "pattern": "strnatcasecmp(...)"
                },
                {
                  "pattern": "strnatcmp(...)"
                },
                {
                  "pattern": "strncmp(...)"
                },
                {
                  "pattern": "strpbrk(...)"
                },
                {
                  "pattern": "strpos(...)"
                },
                {
                  "pattern": "strripos(...)"
                },
                {
                  "pattern": "strrpos(...)"
                },
                {
                  "pattern": "strspn(...)"
                },
                {
                  "pattern": "strstr(...)"
                },
                {
                  "pattern": "strtok(...)"
                },
                {
                  "pattern": "substr_compare(...)"
                },
                {
                  "pattern": "substr_count(...)"
                },
                {
                  "pattern": "vsprintf(...)"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-inside": "$_SESSION[$KEY] = $VAL;"
            },
            {
              "pattern": "$KEY"
            }
          ]
        }
      ]
    },
    {
      "id": "php.lang.security.injection.tainted-sql-string.tainted-sql-string",
      "languages": [
        "php"
      ],
      "severity": "ERROR",
      "message": "SQL injection vulnerabilities arise when applications build database queries by directly inserting user input into SQL strings without proper parameterization. This allows attackers to inject SQL syntax that modifies the query's structure and behavior, altering its intended logic. The consequences include unauthorized data access, authentication bypass, data modification, or even server compromise through database commands that interact with the operating system.",
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/www-community/attacks/SQL_Injection"
        ],
        "category": "security",
        "technology": [
          "php"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "SQL injection risk by directly inserting untrusted input",
        "fix-suggestion": "Replace string concatenation in SQL queries with prepared statements using `PDO::prepare()` and parameter binding. Use appropriate data typing with functions like `bindParam()` to ensure secure query construction. Consider implementing an ORM like Doctrine to completely separate data handling from SQL syntax."
      },
      "mode": "taint",
      "pattern-sanitizers": [
        {
          "pattern-either": [
            {
              "pattern": "mysqli_real_escape_string(...)"
            },
            {
              "pattern": "real_escape_string(...)"
            },
            {
              "pattern": "$MYSQLI->real_escape_string(...)"
            }
          ]
        }
      ],
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$_GET"
                },
                {
                  "pattern": "$_POST"
                },
                {
                  "pattern": "$_COOKIE"
                },
                {
                  "pattern": "$_REQUEST"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern": "sprintf($SQLSTR, ...)\n"
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$SQLSTR",
                    "regex": ".*\\b(?i)(select|delete|insert|create|update|alter|drop)\\b.*"
                  }
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern": "\"...$EXPR...\"\n"
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$EXPR",
                    "regex": ".*\\b(?i)(select|delete|insert|create|update|alter|drop)\\b.*"
                  }
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern": "\"$SQLSTR\".$EXPR\n"
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$SQLSTR",
                    "regex": ".*\\b(?i)(select|delete|insert|create|update|alter|drop)\\b.*"
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "php.lang.security.injection.tainted-url-host.tainted-url-host",
      "languages": [
        "php"
      ],
      "severity": "WARNING",
      "message": "Server-Side Request Forgery (SSRF) vulnerabilities occur when applications use unvalidated user input to construct the host portion of URLs for server-initiated requests. Without proper validation, attackers can manipulate these host values to direct requests to unauthorized internal services or external malicious servers. This can lead to internal network scanning, accessing restricted services, data exfiltration, or exploitation of trust relationships between the server and other systems.",
      "metadata": {
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html"
        ],
        "category": "security",
        "technology": [
          "php"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "impact": "MEDIUM",
        "likelihood": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "Unvalidated host in URLs can cause SSRF exploitation",
        "fix-suggestion": "Implement strict validation of user-provided URLs or hostnames using allowlists before making network requests. Use the `parse_url()` function to decompose URLs and validate each component separately. Consider implementing a proxy service for external requests that enforces security policies and limits potential SSRF attack surface."
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$_GET"
                },
                {
                  "pattern": "$_POST"
                },
                {
                  "pattern": "$_COOKIE"
                },
                {
                  "pattern": "$_REQUEST"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern": "sprintf($URLSTR, ...)\n"
                },
                {
                  "metavariable-pattern": {
                    "metavariable": "$URLSTR",
                    "language": "generic",
                    "pattern": "$SCHEME://%s"
                  }
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern": "\"...{$EXPR}...\"\n"
                },
                {
                  "pattern-regex": ".*://\\{.*\n"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern": "\"...$EXPR...\"\n"
                },
                {
                  "pattern-regex": ".*://\\$.*\n"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern": "\"...\".$EXPR\n"
                },
                {
                  "pattern-regex": ".*://[\"'].*\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "php.laravel.security.laravel-api-route-sql-injection.laravel-api-route-sql-injection",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "focus-metavariable": "$ARG"
            },
            {
              "pattern-inside": "Route::$METHOD($ROUTE_NAME, function(...,$ARG,...){...})\n"
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern": "DB::raw(\"...\",[...])\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "DB::raw(...)\n"
            }
          ]
        }
      ],
      "message": "SQL injection in Laravel API routes occurs when developers bypass the framework's query builder safety by directly concatenating user input into SQL queries. Despite Laravel's built-in protections, this vulnerable practice allows attackers to manipulate query structure and logic through specially crafted inputs. The impact includes unauthorized data access, authentication bypass, data manipulation, or even server compromise through advanced SQL injection techniques that exploit database features.",
      "languages": [
        "php"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Laravel_Cheat_Sheet.md"
        ],
        "technology": [
          "php",
          "laravel"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "API route with string-concatenated SQL fosters injection",
        "fix-suggestion": "Leverage Laravel\u00e2\u20ac\u2122s query builder or Eloquent ORM with parameter binding instead of concatenating user input into SQL queries to avoid SQL injection."
      }
    },
    {
      "id": "php.laravel.security.laravel-sql-injection.laravel-sql-injection",
      "metadata": {
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "category": "security",
        "technology": [
          "laravel"
        ],
        "references": [
          "https://laravel.com/docs/8.x/queries"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "SQL injection possible through unsanitized Laravel query building",
        "fix-suggestion": "Use Laravel\u00e2\u20ac\u2122s built-in parameterization methods to separate SQL query logic from user input, ensuring that dynamic data is properly escaped."
      },
      "severity": "WARNING",
      "message": "SQL injection vulnerabilities in Laravel arise when developers construct database queries by concatenating raw user input instead of using the framework's parameterized query methods. This insecure practice bypasses Laravel's built-in SQL injection protections that would normally prevent such attacks. Successful exploitation allows attackers to extract sensitive data, bypass authentication mechanisms, modify database contents, or potentially execute commands on the database server through advanced injection techniques.",
      "languages": [
        "php"
      ],
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$_GET"
                },
                {
                  "pattern": "$_POST"
                },
                {
                  "pattern": "$_COOKIE"
                },
                {
                  "pattern": "$_REQUEST"
                },
                {
                  "pattern": "$_SERVER"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern": "$SQL"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "DB::table(...)->whereRaw($SQL, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orWhereRaw($SQL, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->groupByRaw($SQL, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->havingRaw($SQL, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orHavingRaw($SQL, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orderByRaw($SQL, ...)"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "$EXPRESSION"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "DB::table(...)->selectRaw($EXPRESSION, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->fromRaw($EXPRESSION, ...)"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "$COLUMNS"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "DB::table(...)->whereNull($COLUMNS, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orWhereNull($COLUMN)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->whereNotNull($COLUMNS, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->whereRowValues($COLUMNS, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orWhereRowValues($COLUMNS, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->find($ID, $COLUMNS)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->paginate($PERPAGE, $COLUMNS, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->simplePaginate($PERPAGE, $COLUMNS, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->cursorPaginate($PERPAGE, $COLUMNS, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->getCountForPagination($COLUMNS)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->aggregate($FUNCTION, $COLUMNS)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->numericAggregate($FUNCTION, $COLUMNS)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->insertUsing($COLUMNS, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->select($COLUMNS)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->get($COLUMNS)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->count($COLUMNS)"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "$COLUMN"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "DB::table(...)->whereIn($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orWhereIn($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->whereNotIn($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orWhereNotIn($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->whereIntegerInRaw($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orWhereIntegerInRaw($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->whereIntegerNotInRaw($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orWhereIntegerNotInRaw($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->whereBetweenColumns($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orWhereBetween($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orWhereBetweenColumns($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->whereNotBetween($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->whereNotBetweenColumns($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orWhereNotBetween($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orWhereNotBetweenColumns($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orWhereNotNull($COLUMN)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->whereDate($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orWhereDate($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->whereTime($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orWhereTime($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->whereDay($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orWhereDay($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->whereMonth($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orWhereMonth($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->whereYear($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orWhereYear($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->whereJsonContains($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orWhereJsonContains($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->whereJsonDoesntContain($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orWhereJsonDoesntContain($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->whereJsonLength($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orWhereJsonLength($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->having($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orHaving($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->havingBetween($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orderBy($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orderByDesc($COLUMN)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->latest($COLUMN)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->oldest($COLUMN)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->forPageBeforeId($PERPAGE, $LASTID, $COLUMN)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->forPageAfterId($PERPAGE, $LASTID, $COLUMN)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->value($COLUMN)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->pluck($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->implode($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->min($COLUMN)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->max($COLUMN)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->sum($COLUMN)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->avg($COLUMN)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->average($COLUMN)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->increment($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->decrement($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->where($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->orWhere($COLUMN, ...)"
                        },
                        {
                          "pattern-inside": "DB::table(...)->addSelect($COLUMN)"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "$QUERY"
                    },
                    {
                      "pattern-inside": "DB::unprepared($QUERY)"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "php.laravel.security.laravel-unsafe-validator.laravel-unsafe-validator",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "public function $F(...,Request $R,...){...}\n"
            },
            {
              "focus-metavariable": "$R"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$this->$PROPERTY\n"
                },
                {
                  "pattern": "$this->$PROPERTY->$GET\n"
                }
              ]
            },
            {
              "metavariable-pattern": {
                "metavariable": "$PROPERTY",
                "patterns": [
                  {
                    "pattern-either": [
                      {
                        "pattern": "query"
                      },
                      {
                        "pattern": "request"
                      },
                      {
                        "pattern": "headers"
                      },
                      {
                        "pattern": "cookies"
                      },
                      {
                        "pattern": "cookie"
                      },
                      {
                        "pattern": "files"
                      },
                      {
                        "pattern": "file"
                      },
                      {
                        "pattern": "allFiles"
                      },
                      {
                        "pattern": "input"
                      },
                      {
                        "pattern": "all"
                      },
                      {
                        "pattern": "post"
                      },
                      {
                        "pattern": "json"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "class $CL extends Illuminate\\Http\\Request {...}\n"
                },
                {
                  "pattern-inside": "class $CL extends Illuminate\\Foundation\\Http\\FormRequest {...}\n"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "Illuminate\\Validation\\Rule::unique(...)->ignore(...,$IGNORE,...)\n"
            },
            {
              "focus-metavariable": "$IGNORE"
            }
          ]
        }
      ],
      "message": "SQL injection vulnerabilities in Laravel validation occur when untrusted user input is passed directly to the ignore() method in validation rules. This method typically expects safe values but doesn't automatically escape or parameterize the input before using it in database queries. The resulting vulnerability allows attackers to escape the intended query context and execute arbitrary SQL commands, potentially leading to data theft, authentication bypass, or database compromise.",
      "languages": [
        "php"
      ],
      "severity": "ERROR",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "technology": [
          "php",
          "laravel"
        ],
        "references": [
          "https://laravel.com/docs/9.x/validation#rule-unique"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Using request parameter in ignore() can lead to SQL injection",
        "fix-suggestion": "Avoid passing raw user input to validation methods like ignore(); instead, validate and sanitize the input separately and use trusted data in validation rules."
      }
    },
    {
      "id": "php.symfony.security.audit.symfony-csrf-protection-disabled.symfony-csrf-protection-disabled",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$X->createForm($TYPE, $TASK, [..., 'csrf_protection' => false, ...], ...)"
            },
            {
              "pattern": "$X->prependExtensionConfig('framework', [..., 'csrf_protection' => false, ...], ...)"
            },
            {
              "pattern": "$X->loadFromExtension('framework', [..., 'csrf_protection' => false, ...], ...)"
            },
            {
              "pattern": "$X->setDefaults([..., 'csrf_protection' => false, ...], ...)"
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "$X->createForm($TYPE, $TASK, [..., 'csrf_protection' => $VAL, ...], ...)"
                    },
                    {
                      "pattern": "$X->prependExtensionConfig('framework', [..., 'csrf_protection' => $VAL, ...], ...)"
                    },
                    {
                      "pattern": "$X->loadFromExtension('framework', [..., 'csrf_protection' => $VAL, ...], ...)"
                    },
                    {
                      "pattern": "$X->setDefaults([..., 'csrf_protection' => $VAL, ...], ...)"
                    }
                  ]
                },
                {
                  "pattern-inside": "$VAL = false;\n...\n"
                }
              ]
            }
          ]
        }
      ],
      "message": "Cross-Site Request Forgery (CSRF) vulnerabilities arise when Symfony's built-in CSRF protection is explicitly disabled in application configuration. Without this protection, attackers can trick authenticated users into unknowingly submitting malicious requests that execute unintended actions. These attacks can lead to unauthorized state-changing operations, account compromise, data modification, or privileged actions performed without the user's knowledge or consent.",
      "metadata": {
        "references": [
          "https://symfony.com/doc/current/security/csrf.html"
        ],
        "cwe": [
          "CWE-352: Cross-Site Request Forgery (CSRF)"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "category": "security",
        "technology": [
          "symfony"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site Request Forgery (CSRF)"
        ],
        "short-description": "CSRF protection disabled, exposing Symfony app to forged requests",
        "fix-suggestion": "Enable CSRF protection in Symfony by configuring the security settings to require CSRF tokens for state-changing requests, rather than disabling the protection."
      },
      "languages": [
        "php"
      ],
      "severity": "WARNING"
    },
    {
      "id": "php.symfony.security.audit.symfony-non-literal-redirect.symfony-non-literal-redirect",
      "patterns": [
        {
          "pattern": "$this->redirect(...)"
        },
        {
          "pattern-not": "$this->redirect(\"...\")"
        },
        {
          "pattern-not": "$this->redirect()"
        }
      ],
      "message": "The redirect() method is accepting a non-constant URL that may contain user input. Without validation, this creates an open redirect vulnerability where users can be sent to malicious websites. Attackers can use this to conduct phishing attacks from your trusted domain.",
      "languages": [
        "php"
      ],
      "metadata": {
        "references": [
          "https://symfony.com/doc/current/controller.html#redirecting",
          "https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')"
        ],
        "category": "security",
        "technology": [
          "symfony"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Open Redirect"
        ],
        "short-description": "Unvalidated redirects enable phishing attacks",
        "fix-suggestion": "Implement strict validation of all redirect destinations using a whitelist of allowed URLs or domains. Use pattern matching to verify that redirects only go to known-safe destinations. For user-provided URLs, consider using relative paths only or implementing a confirmation page for external links."
      },
      "severity": "WARNING"
    },
    {
      "id": "php.symfony.security.audit.symfony-permissive-cors.symfony-permissive-cors",
      "patterns": [
        {
          "pattern-inside": "use Symfony\\Component\\HttpFoundation\\Response;\n...\n"
        },
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "new Symfony\\Component\\HttpFoundation\\Response($X, $Y, $HEADERS, ...)\n"
                    },
                    {
                      "pattern": "new Response($X, $Y, $HEADERS, ...)"
                    }
                  ]
                },
                {
                  "pattern-either": [
                    {
                      "pattern": "new $R($X, $Y, [$KEY => $VALUE], ...)"
                    },
                    {
                      "pattern-inside": "$HEADERS = [$KEY => $VALUE];\n...\n"
                    }
                  ]
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern": "$RES->headers->set($KEY, $VALUE)"
                }
              ]
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$KEY",
            "regex": "(\\'|\\\")\\s*(Access-Control-Allow-Origin|access-control-allow-origin)\\s*(\\'|\\\")"
          }
        },
        {
          "metavariable-regex": {
            "metavariable": "$VALUE",
            "regex": "(\\'|\\\")\\s*(\\*)\\s*(\\'|\\\")"
          }
        }
      ],
      "message": "The Access-Control-Allow-Origin header is set to '*', allowing cross-origin requests from any domain. This permissive CORS configuration weakens browser security protections against cross-site attacks. It enables malicious sites to interact with your application using the user's credentials.",
      "metadata": {
        "references": [
          "https://developer.mozilla.org/ru/docs/Web/HTTP/Headers/Access-Control-Allow-Origin"
        ],
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "cwe": [
          "CWE-346: Origin Validation Error"
        ],
        "category": "security",
        "technology": [
          "symfony"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Wildcard CORS policy bypasses security restrictions",
        "fix-suggestion": "Replace the wildcard (`*`) with a specific list of trusted domains. Implement a CORS configuration that explicitly lists allowed origins with `$response->headers->set('Access-Control-Allow-Origin', 'trusted-domain.com')`. For multiple domains, check the origin header against your whitelist before setting the response header."
      },
      "languages": [
        "php"
      ],
      "severity": "WARNING"
    },
    {
      "id": "problem-based-packs.insecure-transport.go-stdlib.bypass-tls-verification.bypass-tls-verification",
      "message": "TLS certificate verification has been explicitly disabled, allowing insecure connections. This removes protection against man-in-the-middle attacks, as any certificate will be accepted regardless of validity. Your application will connect even to servers with expired, self-signed, or fraudulent certificates.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://stackoverflow.com/questions/12122159/how-to-do-a-https-request-with-bad-certificate"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "go"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Disabled TLS verification enables MITM attacks",
        "fix-suggestion": "Remove code that disables TLS certificate verification. Don't set `InsecureSkipVerify` to `true` in TLS configurations. For development environments that need self-signed certificates, configure a local certificate authority instead of disabling verification entirely."
      },
      "languages": [
        "go"
      ],
      "pattern-either": [
        {
          "pattern": "tls.Config{..., InsecureSkipVerify: true, ...}\n"
        },
        {
          "pattern": "$CONFIG = &tls.Config{...}\n...\n$CONFIG.InsecureSkipVerify = true\n"
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.go-stdlib.disallow-old-tls-versions.disallow-old-tls-versions",
      "message": "TLS configuration uses outdated protocol versions that have known vulnerabilities. TLS versions older than 1.2 are vulnerable to attacks like POODLE and BEAST. Using these deprecated versions exposes your encrypted communications to potential interception or manipulation.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://stackoverflow.com/questions/26429751/java-http-clients-and-poodle"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "go"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Outdated TLS versions enable protocol attacks",
        "fix-suggestion": "Configure your TLS settings to require at least TLS 1.2 by setting `MinVersion` to `tls.VersionTLS12` or higher in your TLS configuration. For optimal security in newer applications, consider requiring TLS 1.3 by using `tls.VersionTLS13` as the minimum version."
      },
      "languages": [
        "go"
      ],
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "tls.Config{..., MinVersion: $TLS.$VERSION, ...}\n"
            },
            {
              "pattern": "$CONFIG = &tls.Config{...}\n...\n$CONFIG.MinVersion = $TLS.$VERSION\n"
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$VERSION",
            "regex": "(VersionTLS10|VersionTLS11|VersionSSL30)"
          }
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.go-stdlib.ftp-request.ftp-request",
      "message": "The application is making unencrypted FTP connections using the FTP package. FTP transmits all data, including credentials, in plaintext. This allows attackers with network access to capture sensitive information through passive monitoring.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://godoc.org/github.com/jlaffaye/ftp#Dial",
          "https://github.com/jlaffaye/ftp"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "ftp"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Plaintext FTP exposes credentials and data",
        "fix-suggestion": "Replace FTP with SFTP (SSH File Transfer Protocol) using packages like `github.com/pkg/sftp`. SFTP encrypts all communications including authentication credentials and file data. If backward compatibility is required, ensure FTP is only used for public, non-sensitive data."
      },
      "languages": [
        "go"
      ],
      "fix-regex": {
        "regex": "[fF][tT][pP]://",
        "replacement": "sftp://",
        "count": 1
      },
      "pattern-either": [
        {
          "pattern": "ftp.Dial(\"=~/^[fF][tT][pP]://.*/\", ...)\n"
        },
        {
          "pattern": "ftp.DialTimeout(\"=~/^[fF][tT][pP]://.*/\", ...)\n"
        },
        {
          "pattern": "ftp.Connect(\"=~/^[fF][tT][pP]://.*/\")\n"
        },
        {
          "pattern": "$URL = \"=~/^[fF][tT][pP]://.*/\"\n...\nftp.Dial($URL, ...)\n"
        },
        {
          "pattern": "$URL = \"=~/^[fF][tT][pP]://.*/\"\n...\nftp.DialTimeout($URL, ...)\n"
        },
        {
          "pattern": "$URL = \"=~/^[fF][tT][pP]://.*/\"\n...\nftp.Connect($URL)\n"
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.go-stdlib.gorequest-http-request.gorequest-http-request",
      "message": "Requests are being made to unencrypted HTTP endpoints using the gorequest library. HTTP transmits all data in plaintext, allowing network eavesdroppers to view or modify the communication. This could expose sensitive information like credentials or personal data.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://github.com/parnurzeal/gorequest"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "gorequest"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "HTTP requests expose data to network eavesdropping",
        "fix-suggestion": "Replace all HTTP URLs with HTTPS by changing `http://` to `https://` in your request URLs. Ensure the server supports HTTPS before making this change. Configure proper certificate validation in your request client to verify the server's identity."
      },
      "languages": [
        "go"
      ],
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern-inside": "$REQ = gorequest.New()\n...\n$RES = ...\n"
            },
            {
              "pattern": "$REQ.$FUNC(\"=~/[hH][tT][tT][pP]://.*/\")\n"
            },
            {
              "metavariable-regex": {
                "metavariable": "$FUNC",
                "regex": "(Get|Post|Delete|Head|Put|Patch)"
              }
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern": "gorequest.New().$FUNC(\"=~/[hH][tT][tT][pP]://.*/\")"
            },
            {
              "metavariable-regex": {
                "metavariable": "$FUNC",
                "regex": "(Get|Post|Delete|Head|Put|Patch)"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.go-stdlib.grequests-http-request.grequests-http-request",
      "message": "The application is making unencrypted HTTP requests using the grequests library. Without HTTPS, all data including authentication credentials and sensitive information is transmitted in plaintext. This allows network adversaries to intercept, view, and potentially modify the communication.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://godoc.org/github.com/levigross/grequests#DoRegularRequest",
          "https://github.com/levigross/grequests"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "grequests"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Unencrypted HTTP requests leak sensitive data",
        "fix-suggestion": "Use HTTPS instead of HTTP by changing all request URLs from `http://` to `https://`. Ensure proper TLS configuration with certificate validation enabled in your `grequests` client. For internal services, implement HTTPS with self-signed certificates or an internal certificate authority."
      },
      "languages": [
        "go"
      ],
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "grequests.$FUNC(...,\"=~/[hH][tT][tT][pP]://.*/\", ...)\n"
            },
            {
              "pattern": "$FUNC(...,\"=~/[hH][tT][tT][pP]://.*/\", ...)\n"
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$FUNC",
            "regex": "(Get|Head|Post|Put|Delete|Patch|Options|Req|DoRegularRequest)"
          }
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.go-stdlib.http-customized-request.http-customized-request",
      "message": "Using http.NewRequest with unencrypted http:// URLs exposes your application to potential eavesdropping and data manipulation. Sensitive information can be intercepted during transmission when using plaintext HTTP. Always use HTTPS URLs to ensure data is encrypted during transit.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://golang.org/pkg/net/http/#NewRequest"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "go"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Unencrypted HTTP requests using http.NewRequest",
        "fix-suggestion": "Replace all `http://` URLs with `https://` when using `http.NewRequest`. Implement TLS certificate validation to ensure secure connections. Consider using a URL validator that rejects non-HTTPS schemes for all outgoing requests."
      },
      "languages": [
        "go"
      ],
      "fix-regex": {
        "regex": "[Hh][Tt][Tt][Pp]://",
        "replacement": "https://",
        "count": 1
      },
      "pattern": "http.NewRequest(..., \"=~/[hH][tT][tT][pP]://.*/\", ...)\n"
    },
    {
      "id": "problem-based-packs.insecure-transport.go-stdlib.http-request.http-request",
      "message": "Using HTTP client functions with plaintext http:// URLs leaves your application vulnerable to traffic interception and modification. Any data transmitted, including credentials and sensitive information, can be exposed to attackers. Always use HTTPS to encrypt your communications.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://golang.org/pkg/net/http/#Get"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "go"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Insecure HTTP requests in Go HTTP client",
        "fix-suggestion": "Replace all `http://` URLs with `https://` in your HTTP client calls. Implement a URL validation function that rejects non-HTTPS schemes. Configure your application to enforce TLS for all outgoing connections."
      },
      "languages": [
        "go"
      ],
      "fix-regex": {
        "regex": "[Hh][Tt][Tt][Pp]://",
        "replacement": "https://",
        "count": 1
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "http.$FUNC(\"=~/[hH][tT][tT][pP]://.*/\", ...)\n"
            },
            {
              "patterns": [
                {
                  "pattern-inside": "$CLIENT := &http.Client{...}\n...\n"
                },
                {
                  "pattern": "client.$FUNC(\"=~/[hH][tT][tT][pP]://.*/\", ...)\n"
                }
              ]
            }
          ]
        },
        {
          "pattern-not": "http.$FUNC(\"=~/[hH][tT][tT][pP]://127.0.0.1.*/\", ...)"
        },
        {
          "pattern-not": "client.$FUNC(\"=~/[hH][tT][tT][pP]://127.0.0.1.*/\", ...)"
        },
        {
          "pattern-not": "http.$FUNC(\"=~/[hH][tT][tT][pP]://localhost.*/\", ...)"
        },
        {
          "pattern-not": "client.$FUNC(\"=~/[hH][tT][tT][pP]://localhost.*/\", ...)"
        },
        {
          "metavariable-regex": {
            "metavariable": "$FUNC",
            "regex": "(Get|Post|Head|PostForm)"
          }
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.go-stdlib.sling-http-request.sling-http-request",
      "message": "Using the Sling HTTP client library with unencrypted http:// URLs exposes sensitive data to network eavesdropping. Plaintext HTTP connections provide no protection against intercepted data or modified responses. Always use HTTPS to ensure data confidentiality and integrity.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://godoc.org/github.com/dghubble/sling#Sling.Add",
          "https://github.com/dghubble/sling"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "sling"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Insecure HTTP usage in Sling client library",
        "fix-suggestion": "Replace all `http://` URLs with `https://` when using Sling HTTP client. Implement proper TLS certificate validation to prevent man-in-the-middle attacks. Consider adding middleware that enforces HTTPS for all outgoing requests."
      },
      "languages": [
        "go"
      ],
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern-inside": "$REQ = sling.New()\n...\n$RES = ...\n"
            },
            {
              "pattern": "$REQ.$FUNC(\"=~/[hH][tT][tT][pP]://.*/\")\n"
            },
            {
              "metavariable-regex": {
                "metavariable": "$FUNC",
                "regex": "(Get|Post|Delete|Head|Put|Options|Patch|Base|Connect)"
              }
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern": "sling.New().$FUNC(\"=~/[hH][tT][tT][pP]://.*/\")"
            },
            {
              "metavariable-regex": {
                "metavariable": "$FUNC",
                "regex": "(Get|Post|Delete|Head|Put|Options|Patch|Base|Connect)"
              }
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$REQ = sling.New()\n...\n$URL = \"=~/[hH][tT][tT][pP]://.*/\"\n...\n$RES = ...\n"
            },
            {
              "pattern": "$REQ.$FUNC($URL)\n"
            },
            {
              "metavariable-regex": {
                "metavariable": "$FUNC",
                "regex": "(Get|Post|Delete|Head|Put|Options|Patch|Base|Connect)"
              }
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$URL = \"=~/[hH][tT][tT][pP]://.*/\"\n...\n$RES = ...\n"
            },
            {
              "pattern": "sling.New().$FUNC($URL)\n"
            },
            {
              "metavariable-regex": {
                "metavariable": "$FUNC",
                "regex": "(Get|Post|Delete|Head|Put|Options|Patch|Base|Connect)"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.go-stdlib.telnet-request.telnet-request",
      "message": "Your application is attempting to connect to a Telnet server, which transmits all data in plaintext. This allows attackers to easily capture sensitive information including credentials and commands. Use SSH or another encrypted protocol instead of Telnet.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://godoc.org/github.com/reiver/go-telnet"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "go-telnet"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Insecure Telnet connections in Go code",
        "fix-suggestion": "Replace Telnet connections with SSH using the `golang.org/x/crypto/ssh` package. Implement proper certificate validation when establishing connections. Avoid using any unencrypted protocols for remote access and communication."
      },
      "languages": [
        "go"
      ],
      "pattern": "telnet.DialToAndCall(...)\n"
    },
    {
      "id": "problem-based-packs.insecure-transport.java-spring.bypass-tls-verification.bypass-tls-verification",
      "message": "TLS certificate verification has been disabled in your Spring application. This allows connections to servers with invalid or malicious certificates, enabling potential man-in-the-middle attacks. Proper certificate validation is essential for secure communications.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://stackoverflow.com/questions/4072585/disabling-ssl-certificate-validation-in-spring-resttemplate",
          "https://stackoverflow.com/questions/35530558/how-to-fix-unsafe-implementation-of-x509trustmanager-in-android-app?rq=1"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "spring"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Disabled TLS certificate verification in Spring",
        "fix-suggestion": "Remove code that disables certificate validation in your Spring configuration. Use proper certificate management by configuring a `TrustManager` with valid certificates. Consider implementing certificate pinning for critical connections to prevent certificate-based attacks."
      },
      "languages": [
        "java"
      ],
      "pattern-either": [
        {
          "pattern": "new HostnameVerifier() {\n  ...\n  public boolean verify(String hostname, SSLSession session) {\n    ...\n  }\n  ...\n};\n"
        },
        {
          "pattern": "public RestTemplate restTemplate() throws KeyStoreException, NoSuchAlgorithmException, KeyManagementException {\n  ...\n  TrustStrategy $FUNCNAME = (X509Certificate[] chain, String authType) -> ...;\n  ...\n}\n"
        },
        {
          "pattern": "TrustStrategy $FUNCNAME= new TrustStrategy() {\n  ...\n  public boolean isTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n    ...\n  }\n  ...\n};\n"
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.java-spring.spring-ftp-request.spring-ftp-request",
      "message": "Your Spring application is using FTP, which transmits all data including credentials in plaintext. This allows network eavesdroppers to capture sensitive information. Use SFTP (SSH File Transfer Protocol) instead to encrypt your file transfers.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://docs.spring.io/spring-integration/api/org/springframework/integration/ftp/session/AbstractFtpSessionFactory.html#setClientMode-int-"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "spring"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Insecure FTP usage in Spring applications",
        "fix-suggestion": "Replace `ftpSessionFactory` with `sftpSessionFactory` in your Spring configuration. Update dependencies to include SSH support via the `spring-integration-sftp` module. Configure proper key-based authentication for secure file transfers."
      },
      "languages": [
        "java"
      ],
      "fix-regex": {
        "regex": "[fF][tT][pP]://",
        "replacement": "sftp://",
        "count": 1
      },
      "pattern-either": [
        {
          "pattern": "$SF = new DefaultFtpSessionFactory(...);\n...\n$SF.setHost(\"=~/^[fF][tT][pP]://.*/\");\n...\n$SF.$FUNC(...);\n"
        },
        {
          "pattern": "$SF = new DefaultFtpSessionFactory(...);\n...\nString $URL = \"=~/^[fF][tT][pP]://.*/\";\n...\n$SF.setHost($URL);\n...\n$SF.$FUNC(...);\n"
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.java-spring.spring-http-request.spring-http-request",
      "message": "Your Spring RestTemplate is making requests to unencrypted http:// URLs. This exposes all transmitted data to network eavesdropping and tampering. Always use https:// URLs to ensure encryption of data in transit.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/client/RestTemplate.html#delete-java.lang.String-java.util.Map-",
          "https://www.baeldung.com/rest-template"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "spring"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Unencrypted HTTP in Spring RestTemplate",
        "fix-suggestion": "Replace all `http://` URLs with `https://` in your RestTemplate calls. Configure your RestTemplate with proper SSL context and certificate validation. Consider implementing an interceptor that rejects non-HTTPS requests."
      },
      "languages": [
        "java"
      ],
      "fix-regex": {
        "regex": "[Hh][Tt][Tt][Pp]://",
        "replacement": "https://",
        "count": 1
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$RESTTEMP = new RestTemplate(...);\n...\n$RESTTEMP.$FUNC(\"=~/[hH][tT][tT][pP]://.*/\", ...);\n"
            },
            {
              "pattern": "$RESTTEMP = new RestTemplate(...);\n...\nString $URL = \"=~/[hH][tT][tT][pP]://.*/\";\n...\n$RESTTEMP.$FUNC($URL, ...);\n"
            },
            {
              "pattern": "$RESTTEMP = new RestTemplate(...);\n...\n$URL = new URI(..., \"=~/[hH][tT][tT][pP]://.*/\", ...);\n...\n$RESTTEMP.$FUNC($URL, ...);\n"
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$FUNC",
            "regex": "(delete|doExecute|exchange|getForEntity|getForObject|headForHeaders|optionsForAllow|patchForObject|postForEntity|postForLocation|postForObject|put)"
          }
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.java-stdlib.bypass-tls-verification.bypass-tls-verification",
      "message": "Your Java code overrides the checkServerTrusted function to disable TLS certificate verification. This creates a severe security vulnerability by allowing connections to servers with invalid certificates, enabling man-in-the-middle attacks. Always validate server certificates properly.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://riptutorial.com/java/example/16517/temporarily-disable-ssl-verification--for-testing-purposes-",
          "https://stackoverflow.com/questions/35530558/how-to-fix-unsafe-implementation-of-x509trustmanager-in-android-app?rq=1"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "java"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Custom code bypassing TLS certificate verification",
        "fix-suggestion": "Remove the custom implementation of `checkServerTrusted` that disables verification. Use the default `X509TrustManager` implementation or properly validate certificates. If testing locally, use a local CA and proper certificates rather than disabling verification."
      },
      "languages": [
        "java"
      ],
      "patterns": [
        {
          "pattern": "new X509TrustManager() {\n  ...\n  public void checkClientTrusted(X509Certificate[] certs, String authType) {...}\n  ...\n}\n"
        },
        {
          "pattern-not": "new X509TrustManager() {\n  ...\n  public void checkServerTrusted(X509Certificate[] certs, String authType) {\n    ...\n    throw new CertificateException(...);\n    ...\n  }\n  ...\n}\n"
        },
        {
          "pattern-not": "new X509TrustManager() {\n  ...\n  public void checkServerTrusted(X509Certificate[] certs, String authType) {\n    ...\n    throw new IllegalArgumentException(...);\n    ...\n  }\n  ...\n}\n"
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.java-stdlib.disallow-old-tls-versions1.disallow-old-tls-versions1",
      "message": "Your code creates SSLConnectionSocketFactories without disabling insecure SSL/TLS versions. Older protocols like SSLv2, SSLv3, and TLSv1.0 have known vulnerabilities including POODLE attacks. Always specify secure protocol versions in your SSL configuration.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://stackoverflow.com/questions/26429751/java-http-clients-and-poodle"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "java"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "SSLSocketFactory allowing insecure TLS versions",
        "fix-suggestion": "Configure your `SSLConnectionSocketFactory` to explicitly use TLS 1.2 or higher with `SSLConnectionSocketFactory.getSystemSocketFactory(\"TLSv1.2\")`. Disable older protocols by setting appropriate socket factory parameters. Update any legacy systems that might still require outdated protocols."
      },
      "languages": [
        "java"
      ],
      "patterns": [
        {
          "pattern": "new SSLConnectionSocketFactory(...);\n"
        },
        {
          "pattern-not": "new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\", \"TLSv1.3\"}, ...);\n"
        },
        {
          "pattern-not": "new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\", \"TLSv1.2\"}, ...);\n"
        },
        {
          "pattern-not": "new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.3\"}, ...);\n"
        },
        {
          "pattern-not": "new SSLConnectionSocketFactory(..., new String[] {\"TLSv1.2\"}, ...);\n"
        },
        {
          "pattern-not-inside": "(SSLConnectionSocketFactory $SF) = new SSLConnectionSocketFactory(...); ... (TlsConfig $TLSCONFIG) = TlsConfig.custom(). ... .setSupportedProtocols(TLS.V_1_2). ... .build(); ... HttpClientConnectionManager cm = $CM.create(). ... .setSSLSocketFactory($SF). ... .setDefaultTlsConfig($TLSCONFIG). ... .build();\n"
        },
        {
          "pattern-not-inside": "(SSLConnectionSocketFactory $SF) = new SSLConnectionSocketFactory(...); ... (TlsConfig $TLSCONFIG) = TlsConfig.custom(). ... .setSupportedProtocols(TLS.V_1_3). ... .build(); ... HttpClientConnectionManager cm = $CM.create(). ... .setSSLSocketFactory($SF). ... .setDefaultTlsConfig($TLSCONFIG). ... .build();\n"
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.java-stdlib.disallow-old-tls-versions2.disallow-old-tls-versions2",
      "message": "Your application is explicitly configuring client protocols to use insecure TLS/SSL versions. Protocols like SSLv3 and TLSv1.0 have known vulnerabilities that can be exploited in man-in-the-middle attacks. Always use TLS 1.2 or higher.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://stackoverflow.com/questions/26504653/is-it-possible-to-disable-sslv3-for-all-java-applications"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "java"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Client configured with outdated TLS versions",
        "fix-suggestion": "Update your client protocol configuration to use only `TLSv1.2` and `TLSv1.3`. Remove any references to `SSLv3`, `TLSv1.0`, and `TLSv1.1` from your code. Test thoroughly with updated protocols to ensure compatibility with your services."
      },
      "languages": [
        "java"
      ],
      "patterns": [
        {
          "pattern": "$VALUE. ... .setProperty(\"jdk.tls.client.protocols\", \"$PATTERNS\");"
        },
        {
          "metavariable-pattern": {
            "metavariable": "$PATTERNS",
            "language": "generic",
            "patterns": [
              {
                "pattern-either": [
                  {
                    "pattern": "TLS1"
                  },
                  {
                    "pattern-regex": "^(.*TLSv1|.*SSLv.*)$"
                  },
                  {
                    "pattern-regex": "^(.*TLSv1,.*)"
                  }
                ]
              }
            ]
          }
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.java-stdlib.ftp-request.ftp-request",
      "message": "Your application is using the FTP protocol, which sends all data including credentials in plaintext. This makes it trivial for attackers to intercept sensitive information. Use SFTP or FTPS to encrypt your file transfers.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://www.codejava.net/java-se/ftp/connect-and-login-to-a-ftp-server",
          "https://commons.apache.org/proper/commons-net/apidocs/org/apache/commons/net/ftp/FTPClient.html"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "java"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Plaintext FTP connection exposes credentials",
        "fix-suggestion": "Replace standard FTP connections with `JSch` for SFTP or Apache Commons `FTPSClient` for FTPS. Configure proper authentication and encryption settings for your chosen protocol. Ensure all credentials are transmitted only over encrypted channels."
      },
      "languages": [
        "java"
      ],
      "fix-regex": {
        "regex": "[fF][tT][pP]://",
        "replacement": "sftp://",
        "count": 1
      },
      "pattern-either": [
        {
          "pattern": "FTPClient $FTPCLIENT = new FTPClient();\n...\n$FTPCLIENT.connect(...);\n"
        },
        {
          "pattern": "URL $URL = new URL(\"=~/^[fF][tT][pP]://.*/\");\n...\nURLConnection $CONN = $URL.openConnection(...);\n"
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.java-stdlib.http-components-request.http-components-request",
      "message": "Your Apache HTTP Components client is making requests to unencrypted http:// URLs. This allows sensitive data to be intercepted in transit, potentially exposing credentials or confidential information. Always use https:// to encrypt communications.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://hc.apache.org/httpcomponents-client-ga/quickstart.html"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "java"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Apache HTTP client using plaintext connections",
        "fix-suggestion": "Replace all `http://` URLs with `https://` in your Apache HTTP Components client code. Configure proper SSL context and certificate validation with `SSLContextBuilder`. Implement request filtering to prevent unencrypted communications."
      },
      "languages": [
        "java"
      ],
      "fix-regex": {
        "regex": "[Hh][Tt][Tt][Pp]://",
        "replacement": "https://",
        "count": 1
      },
      "pattern-either": [
        {
          "pattern": "$HTTPCLIENT = HttpClients.$CREATE(...);\n...\n$HTTPREQ = new $HTTPFUNC(\"=~/[hH][tT][tT][pP]://.*/\");\n...\n$RESPONSE = $HTTPCLIENT.execute($HTTPREQ);\n"
        },
        {
          "pattern": "$HTTPCLIENT = HttpClients.$CREATE(...);\n...\n$RESPONSE = $HTTPCLIENT.execute(new $HTTPFUNC(\"=~/[hH][tT][tT][pP]://.*/\"));\n"
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.java-stdlib.httpclient-http-request.httpclient-http-request",
      "message": "Your HttpClient is sending requests to unencrypted http:// URLs. This exposes all transmitted data including credentials and sensitive information to network eavesdropping. Use https:// URLs to ensure encryption of data in transit.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://openjdk.java.net/groups/net/httpclient/intro.html"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "java"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "HttpClient making unencrypted HTTP requests",
        "fix-suggestion": "Replace all `http://` URLs with `https://` in your HttpClient requests. Configure your client with proper SSL context using `HttpClient.Builder().sslContext()`. Consider implementing a request policy that prevents unencrypted communications."
      },
      "languages": [
        "java"
      ],
      "fix-regex": {
        "regex": "[Hh][Tt][Tt][Pp]://",
        "replacement": "https://",
        "count": 1
      },
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern": "URI.create(\"=~/[hH][tT][tT][pP]://.*/\", ...)\n"
            },
            {
              "pattern-inside": "HttpClient $CLIENT = ...;\n...\nHttpRequest $REQ = ...;\n...\n$CLIENT.sendAsync(...);\n"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern": "URI.create(\"=~/[hH][tT][tT][pP]://.*/\", ...)\n"
            },
            {
              "pattern-inside": "HttpClient $CLIENT = ...;\n...\nHttpRequest $REQ = ...;\n...\n$CLIENT.send(...);\n"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern": "URI.create($URI)\n"
            },
            {
              "pattern-inside": "String $URI = \"=~/[hH][tT][tT][pP]://.*/\";\n...\nHttpClient $CLIENT = ...;\n...\nHttpRequest $REQ = ...;\n...\n$CLIENT.send(...);\n"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern": "URI.create($URI)\n"
            },
            {
              "pattern-inside": "String $URI = \"=~/[hH][tT][tT][pP]://.*/\";\n...\nHttpClient $CLIENT = ...;\n...\nHttpRequest $REQ = ...;\n...\n$CLIENT.sendAsync(...);\n"
            }
          ]
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.java-stdlib.httpget-http-request.httpget-http-request",
      "message": "Your code uses HttpGet to send requests over unencrypted HTTP. This allows sensitive information to be intercepted in transit, potentially exposing credentials or personal data. Always use HTTPS to encrypt your communications.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URLConnection.html",
          "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URL.html#openConnection()"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "java"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "HttpGet requests sent over plaintext HTTP",
        "fix-suggestion": "Replace all `http://` URLs with `https://` in your `HttpGet` requests. Configure your HTTP client with proper certificate validation. Consider implementing an interceptor that blocks non-HTTPS connections for all outgoing requests."
      },
      "languages": [
        "java"
      ],
      "fix-regex": {
        "regex": "[Hh][Tt][Tt][Pp]://",
        "replacement": "https://",
        "count": 1
      },
      "patterns": [
        {
          "pattern": "\"=~/[Hh][Tt][Tt][Pp]://.*/\"\n"
        },
        {
          "pattern-inside": "$R = new HttpGet(\"=~/[Hh][Tt][Tt][Pp]://.*/\");\n...\n$CLIENT. ... .execute($R, ...);\n"
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.java-stdlib.httpurlconnection-http-request.httpurlconnection-http-request",
      "message": "Your code is using HttpURLConnection to connect to unencrypted HTTP URLs. This exposes all transmitted data to potential interception, including sensitive information and credentials. Always use HTTPS to protect data in transit.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URLConnection.html",
          "https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URL.html#openConnection()"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "java"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "HttpURLConnection without encryption",
        "fix-suggestion": "Replace all `http://` URLs with `https://` when using `HttpURLConnection`. Cast to `HttpsURLConnection` to access SSL-specific settings and enable proper certificate validation. Implement URL validation to prevent connections to non-HTTPS resources."
      },
      "languages": [
        "java"
      ],
      "fix-regex": {
        "regex": "[Hh][Tt][Tt][Pp]://",
        "replacement": "https://",
        "count": 1
      },
      "patterns": [
        {
          "pattern": "\"=~/[Hh][Tt][Tt][Pp]://.*/\"\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "URL $URL = new URL (\"=~/[Hh][Tt][Tt][Pp]://.*/\", ...);\n...\n$CON = (HttpURLConnection) $URL.openConnection(...);\n...\n$CON.$FUNC(...);\n"
            },
            {
              "pattern-inside": "URL $URL = new URL (\"=~/[Hh][Tt][Tt][Pp]://.*/\", ...);\n...\n$CON = $URL.openConnection(...);\n...\n$CON.$FUNC(...);\n"
            }
          ]
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.java-stdlib.socket-request.socket-request",
      "message": "Your code is creating socket connections to insecure services like HTTP, Telnet, or FTP. These protocols transmit data in plaintext, allowing attackers to easily capture sensitive information. Use encrypted alternatives like HTTPS, SSH, or SFTP.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://docs.oracle.com/javase/8/docs/api/java/net/Socket.html"
        ],
        "subcategory": [
          "audit"
        ],
        "technology": [
          "java"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Insecure socket connections to plaintext services",
        "fix-suggestion": "Replace plaintext socket connections with encrypted alternatives using `SSLSocket` from `javax.net.ssl`. Update connection endpoints to use secure protocols (HTTPS, SFTP, etc.). Implement proper certificate validation for all secure connections."
      },
      "languages": [
        "java"
      ],
      "pattern-either": [
        {
          "pattern": "$SOCKET = new Socket(\"=~/[tT][eE][lL][nN][eE][tT]://.*/\", ...);\n...\n$OUT = new PrintWriter($SOCKET.getOutputStream(...), ...);\n...\n$OUT.$FUNC(...);\n"
        },
        {
          "pattern": "$SOCKET = new Socket(\"=~/^[fF][tT][pP]://.*/\", ...);\n...\n$OUT = new PrintWriter($SOCKET.getOutputStream(...), ...);\n...\n$OUT.$FUNC(...);\n"
        },
        {
          "pattern": "$SOCKET = new Socket(\"=~/[hH][tT][tT][pP]://.*/\", ...);\n...\n$OUT = new PrintWriter($SOCKET.getOutputStream(...), ...);\n...\n$OUT.$FUNC(...);\n"
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.java-stdlib.telnet-request.telnet-request",
      "message": "Your application is connecting via Telnet, which transmits all commands and data in plaintext. This allows attackers to easily capture credentials and sensitive information. Use SSH instead to encrypt your remote connections.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://commons.apache.org/proper/commons-net/javadocs/api-3.6/org/apache/commons/net/telnet/TelnetClient.html"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "java"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Insecure Telnet protocol usage",
        "fix-suggestion": "Replace Telnet connections with SSH using a library like `JSch` or `Apache MINA SSHD`. Configure proper key-based authentication and encryption settings. Remove all dependencies and code related to Telnet connections."
      },
      "languages": [
        "java"
      ],
      "pattern": "$TELNETCLIENT = new TelnetClient(...);\n...\n$TELNETCLIENT.connect(...);\n"
    },
    {
      "id": "problem-based-packs.insecure-transport.java-stdlib.tls-renegotiation.tls-renegotiation",
      "message": "Your Java application allows unsafe TLS renegotiation. This vulnerability enables man-in-the-middle attacks where an attacker can inject chosen plaintext as a prefix to an existing TLS connection. This can compromise the security of the entire connection.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://www.oracle.com/java/technologies/javase/tlsreadme.html"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "java"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Unsafe TLS renegotiation vulnerability",
        "fix-suggestion": "Set `jdk.tls.rejectClientInitiatedRenegotiation=true` in your JVM system properties. Update your JVM to a version that addresses TLS renegotiation vulnerabilities. Configure your SSL context to use only secure cipher suites and protocol versions."
      },
      "languages": [
        "java"
      ],
      "pattern": "java.lang.System.setProperty(\"sun.security.ssl.allowUnsafeRenegotiation\", true);\n"
    },
    {
      "id": "problem-based-packs.insecure-transport.java-stdlib.unirest-http-request.unirest-http-request",
      "message": "Your Unirest client is making requests to unencrypted http:// URLs. This allows sensitive data to be intercepted in transit, potentially exposing credentials and sensitive information. Always use https:// to encrypt your communications.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://kong.github.io/unirest-java/#requests"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "unirest"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Unirest client using unencrypted HTTP",
        "fix-suggestion": "Replace all `http://` URLs with `https://` in your Unirest requests. Configure Unirest with proper certificate validation using `Unirest.config().sslContext()`. Consider implementing a request interceptor that rejects non-HTTPS URLs."
      },
      "languages": [
        "java"
      ],
      "fix-regex": {
        "regex": "[Hh][Tt][Tt][Pp]://",
        "replacement": "https://",
        "count": 1
      },
      "pattern-either": [
        {
          "pattern": "Unirest.get(\"=~/[hH][tT][tT][pP]://.*/\")\n"
        },
        {
          "pattern": "Unirest.post(\"=~/[hH][tT][tT][pP]://.*/\")\n"
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.js-node.bypass-tls-verification.bypass-tls-verification",
      "message": "Your Node.js code is bypassing TLS certificate verification by setting NODE_TLS_REJECT_UNAUTHORIZED to 0 or rejectUnauthorized to false. This allows connections to servers with invalid certificates, enabling man-in-the-middle attacks. Always verify certificates properly.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://nodejs.org/api/https.html#https_https_request_options_callback",
          "https://stackoverflow.com/questions/20433287/node-js-request-cert-has-expired#answer-29397100"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "node.js"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Disabled TLS verification in Node.js",
        "fix-suggestion": "Remove any code setting `NODE_TLS_REJECT_UNAUTHORIZED=0` or `rejectUnauthorized: false`. Use proper certificate management by configuring trusted CA certificates. For development environments, use locally-trusted certificates rather than disabling verification."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "pattern-either": [
        {
          "pattern": "process.env[\"NODE_TLS_REJECT_UNAUTHORIZED\"] = 0;\n"
        },
        {
          "pattern": "{rejectUnauthorized:false}\n"
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.js-node.disallow-old-tls-versions1.disallow-old-tls-versions1",
      "message": "Your Node.js HTTPS server allows insecure TLS/SSL versions. Protocols like SSLv2, SSLv3, and TLSv1.0 have known vulnerabilities that can be exploited. Always configure your servers to use only modern, secure protocols.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://us-cert.cisa.gov/ncas/alerts/TA14-290A",
          "https://stackoverflow.com/questions/40434934/how-to-disable-the-ssl-3-0-and-tls-1-0-in-nodejs",
          "https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "node.js"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Node.js server using outdated TLS versions",
        "fix-suggestion": "Configure your HTTPS server to use only `TLSv1.2` and `TLSv1.3` by setting `minVersion: 'TLSv1.2'` in your options. Explicitly disable older protocols in your server configuration. Test thoroughly to ensure proper function with modern TLS versions."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "$CONST = require('crypto');\n...\n"
            },
            {
              "pattern-inside": "$CONST = require('constants');\n...\n"
            }
          ]
        },
        {
          "pattern-inside": "$HTTPS = require('https');\n...\n"
        },
        {
          "pattern": "$HTTPS.createServer(...).$FUNC(...);\n"
        },
        {
          "pattern-not": "$HTTPS.createServer({secureOptions: $CONST.SSL_OP_NO_TLSv1 | $CONST.SSL_OP_NO_SSLv3 | $CONST.SSL_OP_NO_SSLv2 }, ...).$FUNC(...);\n"
        },
        {
          "pattern-not": "$HTTPS.createServer({secureOptions: $CONST.SSL_OP_NO_TLSv1 | $CONST.SSL_OP_NO_SSLv2 |$CONST.SSL_OP_NO_SSLv3 }, ...).$FUNC(...);\n"
        },
        {
          "pattern-not": "$HTTPS.createServer({secureOptions: $CONST.SSL_OP_NO_SSLv2 |$CONST.SSL_OP_NO_SSLv3 |$CONST.SSL_OP_NO_TLSv1 }, ...).$FUNC(...);\n"
        },
        {
          "pattern-not": "$HTTPS.createServer({secureOptions: $CONST.SSL_OP_NO_SSLv2 |$CONST.SSL_OP_NO_TLSv1 | $CONST.SSL_OP_NO_SSLv3}, ...).$FUNC(...);\n"
        },
        {
          "pattern-not": "$HTTPS.createServer({secureOptions:$CONST.SSL_OP_NO_SSLv3 | $CONST.SSL_OP_NO_SSLv2 |$CONST.SSL_OP_NO_TLSv1}, ...).$FUNC(...);\n"
        },
        {
          "pattern-not": "$HTTPS.createServer({secureOptions:$CONST.SSL_OP_NO_SSLv3 | $CONST.SSL_OP_NO_TLSv1| $CONST.SSL_OP_NO_SSLv2}, ...).$FUNC(...);\n"
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.js-node.disallow-old-tls-versions2.disallow-old-tls-versions2",
      "message": "Your Node.js HTTPS server is configured with options that don't restrict the use of outdated TLS/SSL versions. Protocols like SSLv2, SSLv3, and TLSv1.0 have known vulnerabilities that compromise security. Always enforce modern TLS versions.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://us-cert.cisa.gov/ncas/alerts/TA14-290A",
          "https://stackoverflow.com/questions/40434934/how-to-disable-the-ssl-3-0-and-tls-1-0-in-nodejs",
          "https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "node.js"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "HTTPS server options allowing weak TLS",
        "fix-suggestion": "Set `minVersion: 'TLSv1.2'` in your HTTPS server options object. Remove any code that enables deprecated protocols like SSLv3 or TLSv1.0. Update client applications to ensure they support secure TLS versions."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "$CONST = require('crypto');\n...\n"
            },
            {
              "pattern-inside": "$CONST = require('constants');\n...\n"
            }
          ]
        },
        {
          "pattern-inside": "$HTTPS = require('https');\n...\n"
        },
        {
          "pattern": "$OPTIONS = {};\n...\n$HTTPS.createServer($OPTIONS, ...);\n"
        },
        {
          "pattern-not": "$OPTIONS = {secureOptions: $CONST.SSL_OP_NO_TLSv1 | $CONST.SSL_OP_NO_SSLv3 | $CONST.SSL_OP_NO_SSLv2};\n...\n$HTTPS.createServer($OPTIONS, ...);\n"
        },
        {
          "pattern-not": "$OPTIONS = {secureOptions: $CONST.SSL_OP_NO_TLSv1 | $CONST.SSL_OP_NO_SSLv2 | $CONST.SSL_OP_NO_SSLv3};\n...\n$HTTPS.createServer($OPTIONS, ...);\n"
        },
        {
          "pattern-not": "$OPTIONS = {secureOptions: $CONST.SSL_OP_NO_SSLv2  | $CONST.SSL_OP_NO_TLSv1 | $CONST.SSL_OP_NO_SSLv3};\n...\n$HTTPS.createServer($OPTIONS, ...);\n"
        },
        {
          "pattern-not": "$OPTIONS = {secureOptions: $CONST.SSL_OP_NO_SSLv2 | $CONST.SSL_OP_NO_SSLv3 | $CONST.SSL_OP_NO_TLSv1};\n...\n$HTTPS.createServer($OPTIONS, ...);\n"
        },
        {
          "pattern-not": "$OPTIONS = {secureOptions: $CONST.SSL_OP_NO_SSLv3 | $CONST.SSL_OP_NO_SSLv2 | $CONST.SSL_OP_NO_TLSv1};\n...\n$HTTPS.createServer($OPTIONS, ...);\n"
        },
        {
          "pattern-not": "$OPTIONS = {secureOptions: $CONST.SSL_OP_NO_SSLv3 | $CONST.SSL_OP_NO_TLSv1 | $CONST.SSL_OP_NO_SSLv2};\n...\n$HTTPS.createServer($OPTIONS, ...);\n"
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.js-node.ftp-request.ftp-request",
      "message": "Your Node.js application is using FTP without encryption. The 'secure' option is not enabled, resulting in credentials and data being transmitted in plaintext. This allows attackers to easily intercept sensitive information.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://www.npmjs.com/package/ftp",
          "https://openbase.io/js/ftp"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "node.js"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "FTP without encryption in Node.js",
        "fix-suggestion": "Enable encryption by setting `secure: true` in your FTP client options. Use SFTP instead via the `ssh2` module for better security. Ensure all credentials and sensitive data are only transmitted over encrypted connections."
      },
      "languages": [
        "javascript",
        "typescript"
      ],
      "patterns": [
        {
          "pattern-inside": "$X = require('ftp');\n...\n$C = new $X();\n...\n"
        },
        {
          "pattern-not-inside": "$OPTIONS = {secure: true};\n...\n"
        },
        {
          "pattern": "$C.connect($OPTIONS,...);\n"
        },
        {
          "pattern-not": "$C.connect({...,secure: true});\n"
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.js-node.http-request.http-request",
      "message": "Your Node.js application is making requests to unencrypted http:// URLs. This exposes all data transmitted, including potential credentials and sensitive information, to network eavesdropping. Always use https:// URLs to encrypt your communications.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://nodejs.org/api/http.html#http_http_request_options_callback"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "node.js"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Unencrypted HTTP requests in Node.js",
        "fix-suggestion": "Replace all `http://` URLs with `https://` in your Node.js request methods. Configure proper certificate validation for your HTTPS requests. Consider implementing middleware that prevents outgoing HTTP connections."
      },
      "languages": [
        "javascript"
      ],
      "patterns": [
        {
          "pattern-inside": "$HTTP = require('http');\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "$HTTP.request(\"=~/http://.*/\",...);\n"
            },
            {
              "pattern": "$HTTP.get(\"=~/http://.*/\", ...)\n"
            },
            {
              "pattern": "$VAR = new URL(\"=~/http://.*/\");\n...\n$HTTP.request($VAR, ...);\n"
            },
            {
              "pattern": "$VAR = {...,hostname: \"...\"};\n...\n$HTTP.request(..., $VAR, ...);\n"
            },
            {
              "pattern": "$HTTP.request(..., {...,hostname: \"...\"}, ...);\n"
            }
          ]
        },
        {
          "pattern-not": "$VAR = {...,protocol: \"https\"};\n...\n$HTTP.request(..., $VAR, ...);\n"
        },
        {
          "pattern-not": "$HTTP.request(..., {...,protocol: \"https\"}, ...);\n"
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.js-node.rest-http-client-support.rest-http-client-support",
      "message": "Your Node.js REST/HTTP client is making requests to unencrypted http:// URLs. This exposes all transmitted data to network eavesdropping, potentially leaking sensitive information. Always use https:// URLs to ensure encryption of data in transit.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://www.npmjs.com/package/axios",
          "https://www.npmjs.com/package/got",
          "https://www.npmjs.com/package/node-rest-client"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "node.js"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "REST clients using unencrypted HTTP",
        "fix-suggestion": "Replace all `http://` URLs with `https://` in your REST client requests (axios, got, node-rest-client). Configure proper TLS certificate validation for your client. Consider implementing a request interceptor that enforces HTTPS-only connections."
      },
      "languages": [
        "javascript"
      ],
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "$CLIENT = require('node-rest-client').Client;\n...\n$C = new $CLIENT();\n...\n"
            },
            {
              "pattern-inside": "$C = require('axios');\n...\n"
            },
            {
              "pattern-inside": "$C = require('got');\n...\n"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern": "$C.$REQ(\"=~/http://.*/\", ...)\n"
            },
            {
              "pattern": "$C(\"=~/http://.*/\", ...)\n"
            },
            {
              "pattern": "$C({...,url: \"=~/http://.*/\"})\n"
            },
            {
              "pattern": "$C.$REQ({...,url: \"=~/http://.*/\"})\n"
            }
          ]
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.js-node.telnet-request.telnet-request",
      "message": "Your Node.js application is using Telnet for remote connections. Telnet transmits all data in plaintext, including credentials and commands, making it trivial for attackers to intercept sensitive information. Use SSH instead for secure remote access.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://www.npmjs.com/package/telnet",
          "https://www.npmjs.com/package/telnet-client"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "node.js"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Telnet usage exposes plaintext credentials",
        "fix-suggestion": "Replace Telnet with SSH connections using the `ssh2` Node.js module. Configure proper key-based authentication instead of passwords when possible. Remove all Telnet-related code and dependencies from your application."
      },
      "languages": [
        "javascript"
      ],
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "$TEL = require('telnet-client');\n...\n$SERVER = new $TEL();\n...\n"
            },
            {
              "pattern-inside": "$SERVER = require('telnet');\n...\n"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern": "$SERVER.on(...)\n"
            },
            {
              "pattern": "$SERVER.connect(...)\n"
            },
            {
              "pattern": "$SERVER.createServer(...)\n"
            }
          ]
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.js-node.using-http-server.using-http-server",
      "message": "Your Node.js application is creating an HTTP server instead of HTTPS. This exposes all data transmitted between your server and clients to potential interception. Always use HTTPS servers to encrypt communications and protect sensitive data.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": [
          "A02:2021 - Cryptographic Failures",
          "A03:2017 - Sensitive Data Exposure"
        ],
        "references": [
          "https://nodejs.org/api/http.html#http_class_http_agent",
          "https://groups.google.com/g/rubyonrails-security/c/NCCsca7TEtY"
        ],
        "subcategory": [
          "audit"
        ],
        "technology": [
          "node.js"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Unencrypted HTTP server in Node.js",
        "fix-suggestion": "Replace `http.createServer()` with `https.createServer()` and provide proper SSL certificates. Configure secure TLS settings with modern protocol versions and cipher suites. Implement HSTS headers to ensure clients always use HTTPS connections."
      },
      "languages": [
        "javascript"
      ],
      "patterns": [
        {
          "pattern-inside": "$HTTP = require('http');\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "$HTTP.$FUNC(...);\n"
            },
            {
              "pattern": "new $HTTP.$FUNC2(...);\n"
            }
          ]
        },
        {
          "pattern": "$HTTP"
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.ruby-stdlib.http-client-requests.http-client-requests",
      "message": "Your Ruby code is making requests to unencrypted http:// URLs using libraries like HTTParty or RestClient. This exposes all transmitted data to network eavesdropping, potentially leaking sensitive information. Always use https:// URLs for secure communications.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://github.com/rest-client/rest-client",
          "https://github.com/jnunemaker/httparty/tree/master/docs"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "httparty",
          "rest-client"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Ruby HTTP clients using unencrypted connections",
        "fix-suggestion": "Replace all `http://` URLs with `https://` in your Ruby HTTP client requests. Configure proper SSL certificate validation in your client options. Consider implementing a request wrapper that enforces HTTPS-only connections."
      },
      "languages": [
        "ruby"
      ],
      "pattern-either": [
        {
          "pattern": "HTTParty.$PARTYVERB(\"=~/[hH][tT][tT][pP]://.*/\", ...)\n"
        },
        {
          "pattern": "$STRING = \"=~/[hH][tT][tT][pP]://.*/\"\n...\nHTTParty.$PARTYVERB($STRING, ...)\n"
        },
        {
          "pattern": "RestClient.$RESTVERB \"=~/[hH][tT][tT][pP]://.*/\", ...\n"
        },
        {
          "pattern": "RestClient::Request.execute(..., url: \"=~/[hH][tT][tT][pP]://.*/\", ...)\n"
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.ruby-stdlib.net-ftp-request.net-ftp-request",
      "message": "Your Ruby application is using the 'net/ftp' package for unencrypted file transfers. This exposes credentials and file contents to network eavesdropping. Use SFTP via the 'net/sftp' package to encrypt your file transfers.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://docs.ruby-lang.org/en/2.0.0/Net/FTP.html"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "ruby"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Plaintext FTP in Ruby net/ftp package",
        "fix-suggestion": "Replace `net/ftp` with `net/sftp` for encrypted file transfers. Configure proper key-based authentication when possible. Ensure all sensitive data is only transmitted over secure channels."
      },
      "languages": [
        "ruby"
      ],
      "pattern-either": [
        {
          "pattern": "$FTP = Net::FTP.new('...')\n...\n$FTP.login\n"
        },
        {
          "pattern": "Net::FTP.open('...') do |ftp|\n  ...\n  ftp.login\nend\n"
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.ruby-stdlib.net-http-request.net-http-request",
      "message": "Your Ruby code is making Net::HTTP requests to unencrypted http:// URLs. This exposes all transmitted data to interception by attackers, potentially leaking sensitive information. Always use https:// URLs to ensure encryption of data in transit.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://ruby-doc.org/stdlib-2.6.5/libdoc/net/http/rdoc/Net/"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "ruby"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Net::HTTP requests over plaintext HTTP",
        "fix-suggestion": "Replace all `http://` URLs with `https://` in your Net::HTTP requests. Enable SSL with `use_ssl = true` and set `verify_mode = OpenSSL::SSL::VERIFY_PEER`. Implement request validation to prevent unencrypted connections."
      },
      "languages": [
        "ruby"
      ],
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$URI = URI('=~/[hH][tT][tT][pP]://.*/')\n...\nNet::HTTP::$FUNC.new $URI\n"
            },
            {
              "pattern": "$URI = URI('=~/[hH][tT][tT][pP]://.*/')\n...\nNet::HTTP.$FUNC($URI, ...)\n"
            },
            {
              "pattern": "Net::HTTP.$FUNC(URI('=~/[hH][tT][tT][pP]://.*/'), ...)\n"
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$FUNC",
            "regex": "([gG]et|post_form|[pP]ost|get_response|get_print|Head|Patch|Put|Proppatch|Lock|Unlock|Options|Propfind|Delete|Move|Copy|Trace|Mkcol)"
          }
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.ruby-stdlib.net-telnet-request.net-telnet-request",
      "message": "Your Ruby application is using Net::Telnet for remote connections. Telnet transmits all data in plaintext, including credentials and commands, making it trivial for attackers to capture sensitive information. Use SSH instead for secure connections.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://docs.ruby-lang.org/en/2.2.0/Net/Telnet.html",
          "https://www.rubydoc.info/gems/net-ssh-telnet2/0.1.0/Net/SSH/Telnet"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "ruby"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Insecure Telnet usage in Ruby",
        "fix-suggestion": "Replace Net::Telnet with the `net-ssh` gem for encrypted connections. Configure proper key-based authentication instead of passwords when possible. Remove all Telnet-related code and dependencies from your application."
      },
      "languages": [
        "ruby"
      ],
      "pattern-either": [
        {
          "pattern": "Net::Telnet::new(...)\n"
        },
        {
          "pattern": "Net::SSH::Telnet.new(...)\n"
        }
      ]
    },
    {
      "id": "problem-based-packs.insecure-transport.ruby-stdlib.openuri-request.openuri-request",
      "message": "Your Ruby code is using OpenURI to access unencrypted http:// or ftp:// URLs. This exposes all data transmitted to potential interception, including sensitive information. Always use https:// URLs with OpenURI to ensure encryption of data in transit.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": "CWE-319: Cleartext Transmission of Sensitive Information",
        "owasp": "A03:2017 - Sensitive Data Exposure",
        "references": [
          "https://ruby-doc.org/stdlib-2.6.3/libdoc/open-uri/rdoc/OpenURI.html"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "open-uri"
        ],
        "vulnerability": "Insecure Transport",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "OpenURI accessing unencrypted resources",
        "fix-suggestion": "Replace all `http://` and `ftp://` URLs with `https://` when using OpenURI. Configure proper SSL options to validate certificates. Consider adding validation logic that rejects non-HTTPS URLs."
      },
      "languages": [
        "ruby"
      ],
      "pattern-either": [
        {
          "pattern": "URI.open('=~/[hH][tT][tT][pP]://.*/', ...)\n"
        },
        {
          "pattern": "$URI = URI.parse('=~/[hH][tT][tT][pP]://.*/', ...)\n...\n$URI.open\n"
        },
        {
          "pattern": "URI.open('=~/^[fF][tT][pP]://.*/', ...)\n"
        },
        {
          "pattern": "$URI = URI.parse('=~/^[fF][tT][pP]://.*/', ...)\n...\n$URI.open\n"
        }
      ]
    },
    {
      "id": "python.airflow.security.audit.formatted-string-bashoperator.formatted-string-bashoperator",
      "message": "Command injection in Apache Airflow occurs when BashOperator tasks execute shell commands constructed from formatted strings containing untrusted data. When special shell characters in variable values are interpreted by the command processor, attackers can inject additional commands to be executed. The vulnerability can lead to unauthorized command execution in the Airflow environment, potentially resulting in data breach, service disruption, or complete system compromise depending on the service's privilege level.",
      "metadata": {
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "airflow"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "BashOperator with f-strings can enable command injection",
        "fix-suggestion": "Avoid using untrusted input when constructing `BashOperator` command strings. Instead, implement templated commands with `parameterized variables` and validate all incoming data. This prevents command injection vulnerabilities in Airflow DAGs."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "pattern-either": [
        {
          "pattern": "airflow.operators.bash_operator.BashOperator(..., bash_command=\"...\" + $CONCAT, ...)\n"
        },
        {
          "pattern": "airflow.operators.bash_operator.BashOperator(..., bash_command=\"...\".format(...), ...)\n"
        },
        {
          "pattern": "airflow.operators.bash_operator.BashOperator(..., bash_command=f\"...\", ...)\n"
        },
        {
          "pattern": "airflow.operators.bash_operator.BashOperator(..., bash_command=\"...\" % $PARAMS, ...)\n"
        },
        {
          "pattern": "$CMD = \"...\" % $PARAMS\n...\nairflow.operators.bash_operator.BashOperator(..., bash_command=$CMD, ...)\n"
        },
        {
          "pattern": "$CMD = $STR.format(...)\n...\nairflow.operators.bash_operator.BashOperator(..., bash_command=$CMD, ...)\n"
        },
        {
          "pattern": "$CMD = f\"...\"\n...\nairflow.operators.bash_operator.BashOperator(..., bash_command=$CMD, ...)\n"
        },
        {
          "pattern": "$CMD = \"...\" + $CONCAT\n...\nairflow.operators.bash_operator.BashOperator(..., bash_command=$CMD, ...)\n"
        },
        {
          "pattern": "$CMD = \"...\"\n...\n$CMD += $CONCAT\n...\nairflow.operators.bash_operator.BashOperator(..., bash_command=$CMD, ...)\n"
        }
      ]
    },
    {
      "id": "python.aws-lambda.security.dangerous-asyncio-create-exec.dangerous-asyncio-create-exec",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "event"
            },
            {
              "pattern-inside": "def $HANDLER(event, context):\n  ...\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$CMD"
            },
            {
              "pattern-either": [
                {
                  "pattern": "asyncio.create_subprocess_exec($PROG, $CMD, ...)"
                },
                {
                  "pattern": "asyncio.create_subprocess_exec($PROG, [$CMD, ...], ...)"
                },
                {
                  "pattern": "asyncio.subprocess.create_subprocess_exec($PROG, $CMD, ...)"
                },
                {
                  "pattern": "asyncio.subprocess.create_subprocess_exec($PROG, [$CMD, ...], ...)"
                },
                {
                  "pattern": "asyncio.create_subprocess_exec($PROG, \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", $CMD, ...)"
                },
                {
                  "pattern": "asyncio.create_subprocess_exec($PROG, [\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", $CMD, ...], ...)"
                },
                {
                  "pattern": "asyncio.subprocess.create_subprocess_exec($PROG, \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", $CMD, ...)"
                },
                {
                  "pattern": "asyncio.subprocess.create_subprocess_exec($PROG, [\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", $CMD, ...], ...)"
                }
              ]
            }
          ]
        }
      ],
      "message": "Command injection vulnerabilities in AWS Lambda functions occur when asyncio.create_subprocess_exec receives arguments derived from untrusted event data. When this data contains shell metacharacters or injection sequences, it can alter the intended command execution flow despite not using a shell directly. This can lead to unauthorized command execution within the Lambda environment, potentially allowing attackers to access sensitive data, disrupt services, or pivot to other AWS resources.",
      "metadata": {
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "asvs": {
          "section": "V5: Validation, Sanitization and Encoding Verification Requirements",
          "control_id": "5.3.8 OS Command Injection",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements",
          "version": "4"
        },
        "references": [
          "https://docs.python.org/3/library/asyncio-subprocess.html#asyncio.create_subprocess_exec",
          "https://docs.python.org/3/library/shlex.html"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "asyncio subprocess with event data can cause injection",
        "fix-suggestion": "Always validate and sanitize arguments passed to `asyncio.create_subprocess_exec` in Lambda functions. Implement input validation checks for all external data used in command execution. This prevents attackers from injecting malicious commands through Lambda event data."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR"
    },
    {
      "id": "python.aws-lambda.security.dangerous-asyncio-exec.dangerous-asyncio-exec",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "event"
            },
            {
              "pattern-inside": "def $HANDLER(event, context):\n  ...\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$CMD"
            },
            {
              "pattern-either": [
                {
                  "pattern": "$LOOP.subprocess_exec($PROTOCOL, $CMD, ...)"
                },
                {
                  "pattern": "$LOOP.subprocess_exec($PROTOCOL, [$CMD, ...], ...)"
                },
                {
                  "pattern": "$LOOP.subprocess_exec($PROTOCOL, \"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", $CMD, ...)"
                },
                {
                  "pattern": "$LOOP.subprocess_exec($PROTOCOL, [\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\", \"-c\", $CMD, ...], ...)"
                }
              ]
            }
          ]
        }
      ],
      "message": "Command injection in AWS Lambda functions occurs when asyncio subprocess calls incorporate unsanitized user input from event data. Although asyncio's subprocess functions don't use a shell by default, they can still be vulnerable if attackers control the command or its arguments. This vulnerability can lead to unauthorized command execution within the Lambda environment, potentially compromising the function, accessing sensitive data, or gaining access to other AWS resources.",
      "metadata": {
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "asvs": {
          "section": "V5: Validation, Sanitization and Encoding Verification Requirements",
          "control_id": "5.3.8 OS Command Injection",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements",
          "version": "4"
        },
        "references": [
          "https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.loop.subprocess_exec",
          "https://docs.python.org/3/library/shlex.html"
        ],
        "category": "security",
        "technology": [
          "python",
          "aws-lambda"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Asyncio exec using unsanitized input triggers command injection",
        "fix-suggestion": "Never use unsanitized event data directly in `subprocess` calls within Lambda functions. Implement strict input validation and escape all user-provided data before execution. This prevents command injection attacks in serverless environments."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR"
    },
    {
      "id": "python.aws-lambda.security.dangerous-asyncio-shell.dangerous-asyncio-shell",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "event"
            },
            {
              "pattern-inside": "def $HANDLER(event, context):\n  ...\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$CMD"
            },
            {
              "pattern-either": [
                {
                  "pattern": "$LOOP.subprocess_shell($PROTOCOL, $CMD)"
                },
                {
                  "pattern": "asyncio.subprocess.create_subprocess_shell($CMD, ...)"
                },
                {
                  "pattern": "asyncio.create_subprocess_shell($CMD, ...)"
                }
              ]
            }
          ]
        }
      ],
      "message": "Command injection vulnerabilities in AWS Lambda arise when asyncio.create_subprocess_shell executes commands containing untrusted event data. Unlike exec variants, the shell version interprets special characters, allowing attackers to inject additional commands through shell metacharacters. This can lead to unauthorized command execution within the Lambda execution environment, potentially compromising function security, accessing sensitive data, or gaining broader access to AWS resources.",
      "metadata": {
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "asvs": {
          "section": "V5: Validation, Sanitization and Encoding Verification Requirements",
          "control_id": "5.3.8 OS Command Injection",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements",
          "version": "4"
        },
        "references": [
          "https://docs.python.org/3/library/asyncio-subprocess.html",
          "https://docs.python.org/3/library/shlex.html"
        ],
        "category": "security",
        "technology": [
          "python",
          "aws-lambda"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Shell-based asyncio calls with user data lead to injection",
        "fix-suggestion": "Replace direct usage of `asyncio.create_subprocess_shell` with untrusted Lambda event data. Use safer subprocess functions with proper argument separation or implement rigorous input sanitization. This prevents shell command injection in asynchronous Lambda code."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR"
    },
    {
      "id": "python.aws-lambda.security.dangerous-spawn-process.dangerous-spawn-process",
      "mode": "taint",
      "message": "Command injection in AWS Lambda functions occurs when os process execution functions incorporate unvalidated data from event sources. Special characters in this data can be interpreted as command separators or modifiers, allowing execution of arbitrary commands. This vulnerability can lead to unauthorized command execution within the Lambda environment, potentially allowing attackers to access sensitive data, disrupt services, or move laterally to other AWS resources.",
      "metadata": {
        "source-rule-url": "https://bandit.readthedocs.io/en/latest/plugins/b605_start_process_with_a_shell.html",
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "asvs": {
          "section": "V5: Validation, Sanitization and Encoding Verification Requirements",
          "control_id": "5.3.8 OS Command Injection",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "python",
          "aws-lambda"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "os spawn process from Lambda event data can run malicious commands",
        "fix-suggestion": "Implement strict sanitization for all event data before using it in process creation functions. Prefer APIs that separate command and arguments like `subprocess.run([cmd, arg1, arg2])` instead of shell string concatenation. This prevents command injection in Lambda process spawning."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "event"
            },
            {
              "pattern-inside": "def $HANDLER(event, context):\n  ...\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$CMD"
            },
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern": "os.$METHOD($MODE, $CMD, ...)"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "(spawnl|spawnle|spawnlp|spawnlpe|spawnv|spawnve|spawnvp|spawnvp|spawnvpe|posix_spawn|posix_spawnp|startfile)"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "os.$METHOD($MODE, $BASH, [\"-c\", $CMD,...],...)"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "(spawnv|spawnve|spawnvp|spawnvp|spawnvpe|posix_spawn|posix_spawnp)"
                      }
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$BASH",
                        "regex": "(.*)(sh|bash|ksh|csh|tcsh|zsh)"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "os.$METHOD($MODE, $BASH, \"-c\", $CMD,...)"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "(spawnl|spawnle|spawnlp|spawnlpe)"
                      }
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$BASH",
                        "regex": "(.*)(sh|bash|ksh|csh|tcsh|zsh)"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "python.aws-lambda.security.dangerous-subprocess-use.dangerous-subprocess-use",
      "mode": "taint",
      "message": "Command injection vulnerabilities in AWS Lambda functions arise when subprocess calls execute commands containing unvalidated event data, especially with shell=True. The shell interpreter processes special characters as command separators or modifiers, allowing attackers to inject additional commands. This can lead to unauthorized command execution within the Lambda environment, potentially compromising function security, accessing sensitive data, or gaining broader access to AWS resources.",
      "metadata": {
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "asvs": {
          "section": "V5: Validation, Sanitization and Encoding Verification Requirements",
          "control_id": "5.3.8 OS Command Injection",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements",
          "version": "4"
        },
        "references": [
          "https://docs.python.org/3/library/subprocess.html",
          "https://docs.python.org/3/library/shlex.html"
        ],
        "category": "security",
        "technology": [
          "python",
          "aws-lambda"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Subprocess usage with user data can allow OS injection",
        "fix-suggestion": "Never use `subprocess` with `shell=True` when incorporating Lambda event data. Either validate inputs rigorously or use the safer argument list form `subprocess.run([cmd, arg1, arg2])`. This prevents shell injection vulnerabilities in your serverless functions."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "event"
            },
            {
              "pattern-inside": "def $HANDLER(event, context):\n  ...\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "subprocess.$FUNC(..., shell=True, ...)"
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "pattern": "shlex.split(...)"
        },
        {
          "pattern": "pipes.quote(...)"
        },
        {
          "pattern": "shlex.quote(...)"
        }
      ]
    },
    {
      "id": "python.aws-lambda.security.dangerous-system-call.dangerous-system-call",
      "mode": "taint",
      "message": "Command injection in AWS Lambda functions occurs when os.system executes commands constructed with unvalidated event data. Since os.system runs commands through a shell, special characters in the input can be interpreted as command separators, allowing execution of arbitrary commands. This vulnerability can lead to unauthorized command execution within the Lambda environment, potentially exposing sensitive data, disrupting services, or providing access to other AWS resources.",
      "metadata": {
        "source-rule-url": "https://bandit.readthedocs.io/en/latest/plugins/b605_start_process_with_a_shell.html",
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "asvs": {
          "section": "V5: Validation, Sanitization and Encoding Verification Requirements",
          "control_id": "5.2.4 Dyanmic Code Execution Features",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v52-sanitization-and-sandboxing-requirements",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "python"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "os system call with untrusted input leads to injection",
        "fix-suggestion": "Replace `os.system()` calls with safer command execution methods like `subprocess.run()` that support parameterization. Implement strict validation for any event data used in command construction. This prevents command injection in Lambda system calls."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "event"
            },
            {
              "pattern-inside": "def $HANDLER(event, context):\n  ...\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$CMD"
            },
            {
              "pattern-either": [
                {
                  "pattern": "os.system($CMD,...)"
                },
                {
                  "pattern": "os.popen($CMD,...)"
                },
                {
                  "pattern": "os.popen2($CMD,...)"
                },
                {
                  "pattern": "os.popen3($CMD,...)"
                },
                {
                  "pattern": "os.popen4($CMD,...)"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "python.aws-lambda.security.dynamodb-filter-injection.dynamodb-filter-injection",
      "mode": "taint",
      "metadata": {
        "cwe": [
          "CWE-943: Improper Neutralization of Special Elements in Data Query Logic"
        ],
        "owasp": [
          "A01:2017 - Injection"
        ],
        "category": "security",
        "technology": [
          "python",
          "boto3",
          "aws-lambda",
          "dynamodb"
        ],
        "references": [
          "https://medium.com/appsecengineer/dynamodb-injection-1db99c2454ac"
        ],
        "subcategory": [
          "vuln"
        ],
        "impact": "MEDIUM",
        "likelihood": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "DynamoDB filter vulnerable to NoSQL injection",
        "fix-suggestion": "Avoid passing data from `event` directly to DynamoDB queries. Validate all input parameters against an expected schema or allowlist. Create separate variables for query parameters instead of using event data directly in query structures."
      },
      "message": "Your AWS Lambda function constructs DynamoDB query filters directly from user-controlled input. This can lead to NoSQL injection attacks where malicious users manipulate queries to access unauthorized data. Always validate and sanitize user input before using it in database operations.",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "event"
            },
            {
              "pattern-inside": "def $HANDLER(event, context):\n  ...\n"
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern": "{...}\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$SINK"
            },
            {
              "pattern-either": [
                {
                  "pattern": "$TABLE.scan(..., ScanFilter = $SINK, ...)"
                },
                {
                  "pattern": "$TABLE.query(..., QueryFilter = $SINK, ...)"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-inside": "$TABLE = $DB.Table(...)\n...\n"
                    },
                    {
                      "pattern-inside": "$DB = boto3.resource('dynamodb', ...)\n...\n"
                    }
                  ]
                },
                {
                  "pattern-inside": "$TABLE = boto3.client('dynamodb', ...)\n...\n"
                }
              ]
            }
          ]
        }
      ],
      "severity": "ERROR",
      "languages": [
        "python"
      ]
    },
    {
      "id": "python.aws-lambda.security.mysql-sqli.mysql-sqli",
      "languages": [
        "python"
      ],
      "message": "SQL injection in AWS Lambda functions occurs when MySQL queries are constructed by concatenating unsanitized event data directly into SQL strings. This vulnerable practice allows attackers to manipulate the query's structure and behavior by injecting special characters and SQL syntax. The impact includes unauthorized data access, authentication bypass, data modification, or potentially even server compromise through database commands that access the underlying system.",
      "mode": "taint",
      "metadata": {
        "references": [
          "https://dev.mysql.com/doc/connector-python/en/connector-python-api-mysqlcursor-execute.html",
          "https://dev.mysql.com/doc/connector-python/en/connector-python-api-mysqlcursor-executemany.html"
        ],
        "category": "security",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "technology": [
          "aws-lambda",
          "mysql"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "MySQL query with event data fosters injection risk",
        "fix-suggestion": "Replace string concatenation in MySQL queries with parameterized queries in Lambda functions. Use `cursor.execute(\"SELECT * FROM users WHERE id = %s\", [user_id])` instead of string formatting. This prevents SQL injection attacks in MySQL database operations."
      },
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$QUERY"
            },
            {
              "pattern-either": [
                {
                  "pattern": "$CURSOR.execute($QUERY,...)"
                },
                {
                  "pattern": "$CURSOR.executemany($QUERY,...)"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "import mysql\n...\n"
                },
                {
                  "pattern-inside": "import mysql.cursors\n...\n"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "event"
            },
            {
              "pattern-inside": "def $HANDLER(event, context):\n  ...\n"
            }
          ]
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.aws-lambda.security.psycopg-sqli.psycopg-sqli",
      "languages": [
        "python"
      ],
      "message": "SQL injection vulnerabilities in AWS Lambda functions arise when PostgreSQL queries with psycopg2 are built by formatting or concatenating raw event data. Instead of using parameterized queries, developers directly embed untrusted input into SQL strings, allowing query manipulation. This can lead to unauthorized data access, authentication bypass, data modification, or potentially server compromise through PostgreSQL's extended functionality.",
      "mode": "taint",
      "metadata": {
        "references": [
          "https://www.psycopg.org/docs/cursor.html#cursor.execute",
          "https://www.psycopg.org/docs/cursor.html#cursor.executemany",
          "https://www.psycopg.org/docs/cursor.html#cursor.mogrify"
        ],
        "category": "security",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "technology": [
          "aws-lambda",
          "psycopg",
          "psycopg2"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Unsanitized psycopg2 query data leads to SQL injection",
        "fix-suggestion": "Always use parameterized queries with `psycopg2` in Lambda functions. Use `cursor.execute(\"SELECT * FROM users WHERE id = %s\", [user_id])` pattern instead of string concatenation. This prevents PostgreSQL SQL injection vulnerabilities."
      },
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$QUERY"
            },
            {
              "pattern-either": [
                {
                  "pattern": "$CURSOR.execute($QUERY,...)"
                },
                {
                  "pattern": "$CURSOR.executemany($QUERY,...)"
                },
                {
                  "pattern": "$CURSOR.mogrify($QUERY,...)"
                }
              ]
            },
            {
              "pattern-inside": "import psycopg2\n...\n"
            }
          ]
        }
      ],
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "event"
            },
            {
              "pattern-inside": "def $HANDLER(event, context):\n  ...\n"
            }
          ]
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.aws-lambda.security.pymssql-sqli.pymssql-sqli",
      "languages": [
        "python"
      ],
      "message": "SQL injection in AWS Lambda functions occurs when MS SQL Server queries with pymssql are constructed by concatenating unvalidated event data. This insecure practice allows attackers to modify query logic and structure through specially crafted inputs containing SQL syntax. Successful exploitation can lead to unauthorized data access, authentication bypass, data modification, or potentially server compromise through SQL Server's extended stored procedures and system functions.",
      "mode": "taint",
      "metadata": {
        "references": [
          "https://pypi.org/project/pymssql/"
        ],
        "category": "security",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "technology": [
          "aws-lambda",
          "pymssql"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "pymssql with untrusted event data can be injected",
        "fix-suggestion": "Implement prepared statements or parameterized queries in `pymssql` Lambda database operations. Use `cursor.execute(\"SELECT * FROM users WHERE id = %s\", (user_id,))` pattern for all queries. This prevents SQL Server injection attacks."
      },
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$QUERY"
            },
            {
              "pattern": "$CURSOR.execute($QUERY,...)"
            },
            {
              "pattern-inside": "import pymssql\n...\n"
            }
          ]
        }
      ],
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "event"
            },
            {
              "pattern-inside": "def $HANDLER(event, context):\n  ...\n"
            }
          ]
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.aws-lambda.security.pymysql-sqli.pymysql-sqli",
      "languages": [
        "python"
      ],
      "message": "SQL injection vulnerabilities in AWS Lambda functions arise when MySQL queries with pymysql are built by concatenating or formatting unsanitized event data. Rather than using parameterized queries or prepared statements, developers embed untrusted input directly into SQL strings. This allows attackers to manipulate queries, potentially leading to unauthorized data access, authentication bypass, data corruption, or even server compromise through MySQL's system functions.",
      "mode": "taint",
      "metadata": {
        "references": [
          "https://pypi.org/project/PyMySQL/#id4"
        ],
        "category": "security",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "technology": [
          "aws-lambda",
          "pymysql"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "pymysql query built from event data can cause injection",
        "fix-suggestion": "Replace string formatting in MySQL queries with parameterized queries in `pymysql`. Use `cursor.execute(\"SELECT * FROM users WHERE id = %s\", (user_id,))` instead of string concatenation. This prevents SQL injection in MySQL Lambda operations."
      },
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$QUERY"
            },
            {
              "pattern": "$CURSOR.execute($QUERY,...)"
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "import pymysql\n...\n"
                },
                {
                  "pattern-inside": "import pymysql.cursors\n...\n"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "event"
            },
            {
              "pattern-inside": "def $HANDLER(event, context):\n  ...\n"
            }
          ]
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.aws-lambda.security.sqlalchemy-sqli.sqlalchemy-sqli",
      "languages": [
        "python"
      ],
      "message": "SQL injection in AWS Lambda functions occurs when developers bypass SQLAlchemy's ORM safety by using raw SQL with unvalidated event data. Despite SQLAlchemy's built-in protections, text() queries with string concatenation or unsafe formatting remain vulnerable to injection attacks. This can lead to unauthorized data access, authentication bypass, data modification, or potentially server compromise through the database engine's extended functionality.",
      "mode": "taint",
      "metadata": {
        "references": [
          "https://docs.sqlalchemy.org/en/14/core/connections.html#sqlalchemy.engine.Connection.execute"
        ],
        "category": "security",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "technology": [
          "aws-lambda",
          "sqlalchemy"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Raw SQL in SQLAlchemy with event data fosters injection",
        "fix-suggestion": "Replace raw SQL string concatenation with ORM methods or parameterized queries in `SQLAlchemy`. Use `session.query(User).filter(User.id == user_id)` or `text(\"SELECT * FROM users WHERE id = :id\").bindparams(id=user_id)`. This prevents SQL injection in Lambda ORM operations."
      },
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$QUERY"
            },
            {
              "pattern": "$CURSOR.execute($QUERY,...)"
            },
            {
              "pattern-inside": "import sqlalchemy\n...\n"
            }
          ]
        }
      ],
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "event"
            },
            {
              "pattern-inside": "def $HANDLER(event, context):\n  ...\n"
            }
          ]
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.aws-lambda.security.tainted-code-exec.tainted-code-exec",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "event"
            },
            {
              "pattern-inside": "def $HANDLER(event, context):\n  ...\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "eval($CODE, ...)"
                },
                {
                  "pattern": "exec($CODE, ...)"
                }
              ]
            }
          ]
        }
      ],
      "message": "Your AWS Lambda function uses eval() or exec() with potentially user-controlled input. This creates a severe security risk, allowing attackers to execute arbitrary code within your Lambda function's context. Never execute dynamic code from untrusted sources.",
      "metadata": {
        "cwe": [
          "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "asvs": {
          "section": "V5: Validation, Sanitization and Encoding Verification Requirements",
          "control_id": "5.2.4 Dyanmic Code Execution Features",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v52-sanitization-and-sandboxing-requirements",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "python"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Code execution from user input in Lambda",
        "fix-suggestion": "Remove all usage of `eval()` and `exec()` from your Lambda function. Implement alternative approaches like lookup tables or pattern matching for dynamic behavior. If dynamic evaluation is absolutely necessary, strictly validate input against a limited allowlist."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.aws-lambda.security.tainted-html-response.tainted-html-response",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "event"
            },
            {
              "pattern-inside": "def $HANDLER(event, context):\n  ...\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$BODY"
            },
            {
              "pattern-inside": "{..., \"headers\": {..., \"Content-Type\": \"text/html\", ...}, \"body\": $BODY, ... }\n"
            }
          ]
        }
      ],
      "message": "Cross-site scripting (XSS) vulnerabilities in AWS Lambda functions occur when HTML responses are constructed using unsanitized event data. When this unescaped content contains malicious HTML or JavaScript, it executes in users' browsers with the permissions of the application's origin. This can lead to session hijacking, credential theft, data exfiltration, or performing unauthorized actions on behalf of the victim within the web application.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "aws-lambda"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Returning unsanitized user data as HTML can cause XSS",
        "fix-suggestion": "Always escape dynamic event data before including it in HTML Lambda responses. Use proper HTML escaping functions like `html.escape()` for all user-provided content. This prevents cross-site scripting (XSS) vulnerabilities in API responses."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.aws-lambda.security.tainted-html-string.tainted-html-string",
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "message": "Cross-site scripting (XSS) vulnerabilities arise in AWS Lambda functions when HTML content is manually constructed with unsanitized event data. Without proper HTML encoding or sanitization, malicious content is rendered and executed by the browser with the application's privileges. This allows attackers to steal authentication tokens, hijack user sessions, exfiltrate sensitive data, or perform unauthorized actions on behalf of victims.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "aws-lambda"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Manually constructed HTML with user input leads to XSS",
        "fix-suggestion": "Ensure all HTML constructed from Lambda event data is properly encoded with `html.escape()`. Never include raw user input directly in HTML templates or strings. This prevents XSS vulnerabilities in Lambda-generated HTML content."
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "event"
            },
            {
              "pattern-inside": "def $HANDLER(event, context):\n  ...\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "\"$HTMLSTR\" % ..."
                        },
                        {
                          "pattern": "\"$HTMLSTR\".format(...)"
                        },
                        {
                          "pattern": "\"$HTMLSTR\" + ..."
                        },
                        {
                          "pattern": "f\"$HTMLSTR{...}...\""
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$HTML = \"$HTMLSTR\"\n...\n"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "$HTML % ..."
                        },
                        {
                          "pattern": "$HTML.format(...)"
                        },
                        {
                          "pattern": "$HTML + ..."
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "metavariable-pattern": {
                "metavariable": "$HTMLSTR",
                "language": "generic",
                "pattern": "<$TAG ..."
              }
            },
            {
              "pattern-not-inside": "print(...)\n"
            }
          ]
        }
      ]
    },
    {
      "id": "python.aws-lambda.security.tainted-pickle-deserialization.tainted-pickle-deserialization",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "event"
            },
            {
              "pattern-inside": "def $HANDLER(event, context):\n  ...\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$SINK"
            },
            {
              "pattern-either": [
                {
                  "pattern": "pickle.load($SINK,...)"
                },
                {
                  "pattern": "pickle.loads($SINK,...)"
                },
                {
                  "pattern": "_pickle.load($SINK,...)"
                },
                {
                  "pattern": "_pickle.loads($SINK,...)"
                },
                {
                  "pattern": "cPickle.load($SINK,...)"
                },
                {
                  "pattern": "cPickle.loads($SINK,...)"
                },
                {
                  "pattern": "dill.load($SINK,...)"
                },
                {
                  "pattern": "dill.loads($SINK,...)"
                },
                {
                  "pattern": "shelve.open($SINK,...)"
                }
              ]
            }
          ]
        }
      ],
      "message": "Code execution vulnerabilities in AWS Lambda functions occur when Python's pickle module deserializes data from untrusted event sources. During deserialization, pickle can instantiate arbitrary Python objects and invoke their methods, allowing attackers to execute code through carefully crafted pickle streams. This critical vulnerability can lead to complete compromise of the Lambda function, potentially allowing access to function data, AWS credentials, or other resources accessible to the function.",
      "metadata": {
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "references": [
          "https://docs.python.org/3/library/pickle.html",
          "https://davidhamann.de/2020/04/05/exploiting-python-pickle/"
        ],
        "category": "security",
        "technology": [
          "python",
          "aws-lambda"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "Insecure pickle deserialization can run attacker code",
        "fix-suggestion": "Never deserialize untrusted data with `pickle` in Lambda functions. Use secure alternatives like `json` or implement strict validation before deserialization. This prevents remote code execution through pickle deserialization vulnerabilities."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.aws-lambda.security.tainted-sql-string.tainted-sql-string",
      "languages": [
        "python"
      ],
      "message": "SQL injection vulnerabilities in AWS Lambda functions arise when database queries are constructed by directly concatenating or formatting unsanitized event data into SQL strings. This insecure practice allows attackers to inject SQL syntax that alters the query's structure and behavior beyond its intended purpose. The impact includes unauthorized data access, authentication bypass, data modification, or even server compromise through database commands that interact with the underlying system.",
      "metadata": {
        "references": [
          "https://owasp.org/www-community/attacks/SQL_Injection"
        ],
        "category": "security",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "technology": [
          "aws-lambda"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "String concatenation in SQL allows injection vulnerabilities",
        "fix-suggestion": "Replace string concatenated SQL with parameterized queries in all Lambda database code. Use prepared statements with placeholders (`?`, `%s`, `:name`) for all user-supplied values. This prevents SQL injection attacks across database operations."
      },
      "mode": "taint",
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "\"$SQLSTR\" + ...\n"
                },
                {
                  "pattern": "\"$SQLSTR\" % ...\n"
                },
                {
                  "pattern": "\"$SQLSTR\".format(...)\n"
                },
                {
                  "pattern": "f\"$SQLSTR{...}...\"\n"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$SQLSTR",
                "regex": "\\s*(?i)(select|delete|insert|create|update|alter|drop)\\b.*="
              }
            },
            {
              "pattern-not-inside": "print(...)\n"
            }
          ]
        }
      ],
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "event"
            },
            {
              "pattern-inside": "def $HANDLER(event, context):\n  ...\n"
            }
          ]
        }
      ],
      "severity": "ERROR"
    },
    {
      "id": "python.boto3.security.hardcoded-token.hardcoded-token",
      "message": "AWS credential exposure occurs when access keys, secret keys, or session tokens are hardcoded directly in application source code rather than retrieved from secure sources. These embedded credentials remain in version control history, creating security risks when code is shared, transferred, or accidentally made public. The exposure allows unauthorized access to AWS resources with the privileges associated with the credentials, potentially leading to data theft, service disruption, or cloud infrastructure compromise.",
      "metadata": {
        "cwe": [
          "CWE-798: Use of Hard-coded Credentials"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html",
          "https://bento.dev/checks/boto3/hardcoded-access-token/",
          "https://aws.amazon.com/blogs/security/what-to-do-if-you-inadvertently-expose-an-aws-access-key/"
        ],
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "category": "security",
        "technology": [
          "boto3",
          "secrets"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Hard-coded Secrets"
        ],
        "short-description": "Hardcoded AWS token easily exposed to attackers",
        "fix-suggestion": "Remove all hardcoded AWS credentials from source code immediately. Use environment variables, AWS IAM roles, or secure credential management systems like `aws-secretsmanager`. This prevents credential exposure in source code repositories and deployment packages."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern": "\"...\"\n"
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$W(...,$TOKEN=\"$VALUE\",...)"
                },
                {
                  "pattern": "$BOTO. ... .$W(...,$TOKEN=\"$VALUE\",...)"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$TOKEN",
                "regex": "(aws_session_token|aws_access_key_id|aws_secret_access_key)"
              }
            },
            {
              "metavariable-pattern": {
                "language": "generic",
                "metavariable": "$VALUE",
                "patterns": [
                  {
                    "pattern-either": [
                      {
                        "pattern-regex": "^AKI"
                      },
                      {
                        "pattern-regex": "^[A-Za-z0-9/+=]+$"
                      }
                    ]
                  }
                ]
              }
            },
            {
              "metavariable-analysis": {
                "metavariable": "$VALUE",
                "analyzer": "entropy"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "python.cryptography.security.empty-aes-key.empty-aes-key",
      "message": "Your code is using an empty or potentially empty AES encryption key. This severely weakens encryption and may allow attackers to easily decrypt sensitive data. Always use strong, non-empty keys for any cryptographic operations.",
      "patterns": [
        {
          "pattern": "AES.new(\"\",...)"
        }
      ],
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "metadata": {
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm",
          "CWE-310: Cryptographic Issues"
        ],
        "references": [
          "https://cwe.mitre.org/data/definitions/327.html",
          "https://cwe.mitre.org/data/definitions/310.html"
        ],
        "category": "security",
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "owasp": "A6:2017 misconfiguration",
        "functional-categories": [
          "crypto::search::key-length::pycrypto",
          "crypto::search::key-length::pycryptodome"
        ],
        "technology": [
          "python",
          "pycrypto",
          "pycryptodome"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Empty AES encryption key vulnerability",
        "fix-suggestion": "Generate a strong encryption key using `os.urandom()` or a cryptographic library like `secrets`. Implement validation to ensure keys meet minimum length requirements (at least 16 bytes for AES-128). Consider using a key management service for production environments."
      }
    },
    {
      "id": "python.cryptography.security.insecure-cipher-mode-ecb.insecure-cipher-mode-ecb",
      "message": "Your code uses AES in ECB (Electronic Code Book) mode, which is cryptographically weak. ECB encrypts identical plaintext blocks to identical ciphertext blocks, revealing patterns in the encrypted data. Always use a secure mode like GCM or CBC with proper initialization vectors.",
      "metadata": {
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L101",
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "bandit-code": "B305",
        "references": [
          "https://cryptography.io/en/latest/hazmat/primitives/symmetric-encryption/#insecure-modes",
          "https://crypto.stackexchange.com/questions/20941/why-shouldnt-i-use-ecb-encryption"
        ],
        "category": "security",
        "technology": [
          "cryptography"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "MEDIUM",
        "functional-categories": [
          "crypto::search::mode::cryptography"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Insecure ECB cipher mode usage",
        "fix-suggestion": "Replace ECB mode with `GCM` (Galois/Counter Mode) which provides both encryption and authentication. Ensure you generate a unique nonce/IV for each encryption operation. Consider using higher-level cryptography APIs that handle secure defaults automatically."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "pattern": "cryptography.hazmat.primitives.ciphers.modes.ECB($IV)",
      "fix": "cryptography.hazmat.primitives.ciphers.modes.GCM($IV)"
    },
    {
      "id": "python.cryptography.security.insufficient-dsa-key-size.insufficient-dsa-key-size",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "cryptography.hazmat.primitives.asymmetric.dsa.generate_private_key(..., key_size=$SIZE, ...)"
            },
            {
              "pattern": "cryptography.hazmat.primitives.asymmetric.dsa.generate_private_key($SIZE, ...)"
            }
          ]
        },
        {
          "metavariable-comparison": {
            "metavariable": "$SIZE",
            "comparison": "$SIZE < 2048"
          }
        },
        {
          "focus-metavariable": "$SIZE"
        }
      ],
      "fix": "2048\n",
      "message": "Your code uses a DSA key with insufficient key size. Short keys can be broken through brute force attacks, compromising the security of your signatures. Follow NIST recommendations by using a key size of at least 2048 bits.",
      "metadata": {
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/weak_cryptographic_key.py",
        "references": [
          "https://www.cosic.esat.kuleuven.be/ecrypt/ecrypt2/documents/D.SPA.20.pdf",
          "https://cryptography.io/en/latest/hazmat/primitives/asymmetric/dsa/",
          "https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57Pt3r1.pdf"
        ],
        "category": "security",
        "technology": [
          "cryptography"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "functional-categories": [
          "crypto::search::key-length::cryptography"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "DSA key size below security standards",
        "fix-suggestion": "Increase your DSA key size to at least `2048` bits as recommended by NIST. Update any key generation parameters in your code. Consider migrating to more modern signature algorithms like Ed25519 when possible."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.cryptography.security.insufficient-ec-key-size.insufficient-ec-key-size",
      "patterns": [
        {
          "pattern-inside": "cryptography.hazmat.primitives.asymmetric.ec.generate_private_key(...)"
        },
        {
          "pattern": "cryptography.hazmat.primitives.asymmetric.ec.$SIZE"
        },
        {
          "metavariable-pattern": {
            "metavariable": "$SIZE",
            "pattern-either": [
              {
                "pattern": "SECP192R1"
              },
              {
                "pattern": "SECT163K1"
              },
              {
                "pattern": "SECT163R2"
              }
            ]
          }
        },
        {
          "focus-metavariable": "$SIZE"
        }
      ],
      "fix": "SECP256R1\n",
      "message": "Your code uses an elliptic curve with insufficient size. Small curves offer inadequate security and can be vulnerable to various attacks. NIST recommends using curves with sizes of at least 224 bits.",
      "metadata": {
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/weak_cryptographic_key.py",
        "references": [
          "https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57Pt3r1.pdf",
          "https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ec/#elliptic-curves"
        ],
        "category": "security",
        "technology": [
          "cryptography"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "functional-categories": [
          "crypto::search::key-length::cryptography"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Elliptic curve with insufficient security",
        "fix-suggestion": "Upgrade to a stronger elliptic curve like `ec.SECP256R1` (P-256) or higher. Update any key generation and validation code to support larger curves. Consider using modern Edwards curves like Ed25519 when possible."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.cryptography.security.insufficient-rsa-key-size.insufficient-rsa-key-size",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "cryptography.hazmat.primitives.asymmetric.rsa.generate_private_key(..., key_size=$SIZE, ...)"
            },
            {
              "pattern": "cryptography.hazmat.primitives.asymmetric.rsa.generate_private_key($EXP, $SIZE, ...)"
            }
          ]
        },
        {
          "metavariable-comparison": {
            "metavariable": "$SIZE",
            "comparison": "$SIZE < 2048"
          }
        },
        {
          "focus-metavariable": "$SIZE"
        }
      ],
      "fix": "2048\n",
      "message": "Your code uses an RSA key with insufficient key size. Keys smaller than 2048 bits are vulnerable to factoring attacks with modern computing resources. Always follow NIST recommendations for key lengths.",
      "metadata": {
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/weak_cryptographic_key.py",
        "references": [
          "https://cryptography.io/en/latest/hazmat/primitives/asymmetric/rsa/",
          "https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57Pt3r1.pdf"
        ],
        "category": "security",
        "technology": [
          "cryptography"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "functional-categories": [
          "crypto::search::key-length::cryptography"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "RSA key size below security standards",
        "fix-suggestion": "Increase your RSA key size to at least `2048` bits as recommended by NIST. Update key generation parameters in your code accordingly. For long-term security, consider using `3072` or `4096` bit keys."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.cryptography.security.insecure-cipher-algorithms.insecure-cipher-algorithm-idea",
      "message": "Your code uses the IDEA cipher algorithm, which is outdated and has known weaknesses. IDEA is susceptible to attacks when using weak keys, making it unsuitable for modern security requirements. Switch to a strong algorithm like AES.",
      "metadata": {
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L98",
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "bandit-code": "B304",
        "references": [
          "https://tools.ietf.org/html/rfc5469",
          "https://cryptography.io/en/latest/hazmat/primitives/symmetric-encryption/#cryptography.hazmat.primitives.ciphers.algorithms.IDEA"
        ],
        "category": "security",
        "technology": [
          "cryptography"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "functional-categories": [
          "crypto::search::symmetric-algorithm::cryptography"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Deprecated IDEA cipher algorithm usage",
        "fix-suggestion": "Replace IDEA with AES using the `cryptography` package's `Fernet` class which implements AES-CBC with proper key management. For lower-level operations, use AES-GCM mode which provides authenticated encryption. Migrate all cryptographic code to modern, well-maintained libraries."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "patterns": [
        {
          "pattern": "cryptography.hazmat.primitives.ciphers.algorithms.$IDEA($KEY)"
        },
        {
          "metavariable-regex": {
            "metavariable": "$IDEA",
            "regex": "^(IDEA)$"
          }
        },
        {
          "focus-metavariable": "$IDEA"
        }
      ],
      "fix": "AES"
    },
    {
      "id": "python.cryptography.security.insecure-cipher-algorithms-arc4.insecure-cipher-algorithm-arc4",
      "message": "ARC4 (Alleged RC4) is a stream cipher with serious security weaknesses in its initial output stream. Using it in cryptographic operations exposes your application to potential attacks like stream ciphering vulnerabilities. Replace ARC4 with modern, secure ciphers like AES in an appropriate mode with proper key management.",
      "metadata": {
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L98",
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "bandit-code": "B304",
        "references": [
          "https://cryptography.io/en/latest/hazmat/primitives/symmetric-encryption/#weak-ciphers"
        ],
        "category": "security",
        "technology": [
          "cryptography"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "functional-categories": [
          "crypto::search::symmetric-algorithm::cryptography"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "ARC4 cipher algorithm has known security flaws",
        "fix-suggestion": "Replace ARC4 with a secure encryption method by using the `cryptography` package's `Fernet` implementation or AES with a secure mode like CBC or GCM. For Python applications, implement `AES` through the `cryptography` library with proper key management and initialization vectors."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "patterns": [
        {
          "pattern": "cryptography.hazmat.primitives.ciphers.algorithms.$ARC4($KEY)"
        },
        {
          "pattern-inside": "cryptography.hazmat.primitives.ciphers.Cipher(...)"
        },
        {
          "metavariable-regex": {
            "metavariable": "$ARC4",
            "regex": "^(ARC4)$"
          }
        },
        {
          "focus-metavariable": "$ARC4"
        }
      ],
      "fix": "AES"
    },
    {
      "id": "python.cryptography.security.insecure-cipher-algorithms-blowfish.insecure-cipher-algorithm-blowfish",
      "message": "Blowfish is a deprecated block cipher vulnerable to attacks when using weak keys. Its creator Bruce Schneier has recommended moving to newer algorithms like AES for modern applications. Using Blowfish puts your data at risk of exposure through known cryptographic weaknesses.",
      "metadata": {
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L98",
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "bandit-code": "B304",
        "references": [
          "https://cryptography.io/en/latest/hazmat/primitives/symmetric-encryption/#weak-ciphers",
          "https://tools.ietf.org/html/rfc5469"
        ],
        "category": "security",
        "technology": [
          "cryptography"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "functional-categories": [
          "crypto::search::symmetric-algorithm::cryptography"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Blowfish cipher has known vulnerabilities",
        "fix-suggestion": "Replace Blowfish with AES by using the `cryptography` package's `Fernet` implementation for automatic secure handling. If using lower-level primitives, switch to `AES` algorithm with appropriate block modes like CBC or GCM and proper key management."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "patterns": [
        {
          "pattern": "cryptography.hazmat.primitives.ciphers.algorithms.$BLOWFISH($KEY)"
        },
        {
          "metavariable-regex": {
            "metavariable": "$BLOWFISH",
            "regex": "^(Blowfish)$"
          }
        },
        {
          "focus-metavariable": "$BLOWFISH"
        }
      ],
      "fix": "AES"
    },
    {
      "id": "python.cryptography.security.insecure-hash-algorithms.insecure-hash-algorithm-sha1",
      "patterns": [
        {
          "pattern": "cryptography.hazmat.primitives.hashes.$SHA(...)"
        },
        {
          "metavariable-pattern": {
            "metavariable": "$SHA",
            "pattern": "SHA1\n"
          }
        },
        {
          "focus-metavariable": "$SHA"
        }
      ],
      "fix": "SHA256\n",
      "message": "SHA1 is no longer considered secure as it's vulnerable to collision attacks. Attackers can create different inputs that produce the same hash value, undermining integrity verification. Replace SHA1 with more secure hash functions like SHA256 or SHA3 to ensure cryptographic security.",
      "metadata": {
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59",
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "bandit-code": "B303",
        "references": [
          "https://cryptography.io/en/latest/hazmat/primitives/cryptographic-hashes/#sha-1",
          "https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html",
          "https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability",
          "http://2012.sharcs.org/slides/stevens.pdf",
          "https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html"
        ],
        "category": "security",
        "technology": [
          "cryptography"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "functional-categories": [
          "crypto::search::symmetric-algorithm::cryptography"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "SHA1 hash is vulnerable to collision attacks",
        "fix-suggestion": "Replace SHA1 with a stronger hash algorithm by using `hashlib.sha256()` or `hashlib.sha3_256()` from Python's standard library. If you need a keyed hash for verification purposes, use `hmac.new()` with SHA256 or implement PBKDF2 for password hashing."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ]
    },
    {
      "id": "python.cryptography.security.insecure-hash-algorithms-md5.insecure-hash-algorithm-md5",
      "message": "MD5 is a broken hash algorithm vulnerable to collision attacks. It should never be used for security purposes as attackers can generate different inputs with identical hashes. Replace MD5 with cryptographically secure alternatives like SHA256 or SHA3 to maintain data integrity.",
      "metadata": {
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59",
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "bandit-code": "B303",
        "references": [
          "https://cryptography.io/en/latest/hazmat/primitives/cryptographic-hashes/#md5",
          "https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html",
          "https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability",
          "http://2012.sharcs.org/slides/stevens.pdf",
          "https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html"
        ],
        "category": "security",
        "technology": [
          "cryptography"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "functional-categories": [
          "crypto::search::symmetric-algorithm::cryptography"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "MD5 hash algorithm is cryptographically broken",
        "fix-suggestion": "Replace MD5 with `hashlib.sha256()` or `hashlib.sha3_256()` from Python's standard library. For integrity checks, use SHA256 or SHA3, and for password hashing use dedicated functions like `bcrypt` or PBKDF2 with appropriate iteration counts."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "patterns": [
        {
          "pattern": "cryptography.hazmat.primitives.hashes.$MD5()"
        },
        {
          "metavariable-regex": {
            "metavariable": "$MD5",
            "regex": "^(MD5)$"
          }
        },
        {
          "focus-metavariable": "$MD5"
        }
      ],
      "fix": "SHA256"
    },
    {
      "id": "python.distributed.security.require-encryption",
      "patterns": [
        {
          "pattern": "distributed.security.Security(..., require_encryption=$VAL, ...)\n"
        },
        {
          "metavariable-pattern": {
            "metavariable": "$VAL",
            "pattern": "False\n"
          }
        },
        {
          "focus-metavariable": "$VAL"
        }
      ],
      "fix": "True\n",
      "message": "Dask distributed security context is initialized without the 'require_encryption' parameter. This may allow the security context to silently fail, establishing unencrypted connections. Always set 'require_encryption' to true to enforce encrypted communication between components.",
      "severity": "WARNING",
      "metadata": {
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "references": [
          "https://distributed.dask.org/en/latest/tls.html?highlight=require_encryption#parameters"
        ],
        "category": "security",
        "technology": [
          "distributed"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Dask connection missing encryption requirement",
        "fix-suggestion": "Set `require_encryption=True` when initializing Dask's security context to enforce encrypted connections. Modify security context creation to include this parameter explicitly, preventing fallback to unencrypted connections when encryption setup fails."
      },
      "languages": [
        "python"
      ]
    },
    {
      "id": "python.django.security.django-no-csrf-token.django-no-csrf-token",
      "patterns": [
        {
          "pattern": "<form...>...</form>"
        },
        {
          "pattern-either": [
            {
              "pattern": "<form ... method=\"$METHOD\" ...>...</form>\n"
            },
            {
              "pattern": "<form ... method='$METHOD' ...>...</form>\n"
            },
            {
              "pattern": "<form ... method=$METHOD ...>...</form>\n"
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$METHOD",
            "regex": "(?i)(post|put|delete|patch)"
          }
        },
        {
          "pattern-not-inside": "<form...>...{% csrf_token %}...</form>"
        },
        {
          "pattern-not-inside": "<form...>...{{ $VAR.csrf_token }}...</form>"
        }
      ],
      "message": "Manual forms in Django templates are missing CSRF token protection. This exposes your application to Cross-Site Request Forgery attacks where malicious sites can trick users into submitting unauthorized requests. Add the csrf_token tag to all forms to prevent CSRF vulnerabilities.",
      "languages": [
        "generic"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "cwe": "CWE-352: Cross-Site Request Forgery (CSRF)",
        "references": [
          "https://docs.djangoproject.com/en/4.2/howto/csrf/"
        ],
        "confidence": "MEDIUM",
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "subcategory": [
          "audit"
        ],
        "technology": [
          "django"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site Request Forgery (CSRF)"
        ],
        "short-description": "Django forms missing CSRF protection",
        "fix-suggestion": "Add `{% csrf_token %}` to all manually created forms in your Django templates. Ensure the middleware `django.middleware.csrf.CsrfViewMiddleware` is included in your settings, and avoid using `@csrf_exempt` decorator unless absolutely necessary."
      },
      "paths": {
        "include": [
          "*.html"
        ]
      }
    },
    {
      "id": "python.django.security.django-using-request-post-after-is-valid.django-using-request-post-after-is-valid",
      "patterns": [
        {
          "pattern-inside": "def $FUNC(request, ...):\n  ...\n"
        },
        {
          "pattern-inside": "if $FORM.is_valid():\n  ...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "request.POST[...]"
            },
            {
              "pattern": "request.POST.get(...)"
            }
          ]
        }
      ],
      "message": "Using request.POST data after form validation bypasses Django's form sanitization. This can expose your application to injection attacks or other security issues. Always use form.cleaned_data to access validated and sanitized form data after calling form.is_valid().",
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "cwe": "CWE-20: Improper Input Validation",
        "references": [
          "https://docs.djangoproject.com/en/4.2/ref/forms/api/#accessing-clean-data"
        ],
        "confidence": "MEDIUM",
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "subcategory": [
          "audit"
        ],
        "technology": [
          "django"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "Bypassing Django form sanitization",
        "fix-suggestion": "Replace `request.POST['field']` with `form.cleaned_data['field']` after calling `form.is_valid()`. Always use the validated data from the form object to ensure proper sanitization and type conversion are applied."
      }
    },
    {
      "id": "python.django.security.globals-as-template-context.globals-as-template-context",
      "languages": [
        "python"
      ],
      "message": "Using globals() as a template context in Django exposes internal Python functions to the template. This creates a server-side template injection vulnerability where attackers can execute arbitrary code. Always use explicit dictionaries or Context objects with only the required variables.",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.2/ref/settings/#templates",
          "https://docs.djangoproject.com/en/3.2/topics/templates/#django.template.backends.django.DjangoTemplates",
          "https://docs.djangoproject.com/en/3.2/ref/templates/api/#rendering-a-context"
        ],
        "technology": [
          "django"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Unsafe globals() exposing functions to templates",
        "fix-suggestion": "Replace `render(request, 'template.html', globals())` with an explicit dictionary like `render(request, 'template.html', {'var1': value1, 'var2': value2})`. Only include the specific variables needed by the template to prevent exposing internal functions."
      },
      "pattern-either": [
        {
          "pattern": "django.shortcuts.render(..., globals(...), ...)"
        },
        {
          "pattern": "django.template.Template.render(..., globals(...), ...)"
        },
        {
          "patterns": [
            {
              "pattern-inside": "$CONTEXT = globals(...)\n...\n"
            },
            {
              "pattern-either": [
                {
                  "pattern": "django.shortcuts.render(..., $CONTEXT, ...)"
                },
                {
                  "pattern": "django.template.Template.render(..., $CONTEXT, ...)"
                }
              ]
            }
          ]
        }
      ],
      "severity": "ERROR"
    },
    {
      "id": "python.django.security.hashids-with-django-secret.hashids-with-django-secret",
      "languages": [
        "python"
      ],
      "message": "Using Django's SECRET_KEY as salt for HashIDs creates a significant security risk. HashIDs are not cryptographically secure, and an attacker could recover your SECRET_KEY by observing enough HashIDs. Use a separate dedicated salt for HashIDs to prevent compromising your Django installation.",
      "metadata": {
        "category": "security",
        "subcategory": [
          "vuln"
        ],
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A02:2021 \u2013 Cryptographic Failures"
        ],
        "references": [
          "https://docs.djangoproject.com/en/4.2/ref/settings/#std-setting-SECRET_KEY",
          "http://carnage.github.io/2015/08/cryptanalysis-of-hashids"
        ],
        "technology": [
          "django"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Django SECRET_KEY exposed via HashIDs",
        "fix-suggestion": "Create a separate dedicated salt for HashIDs rather than using `settings.SECRET_KEY`. Generate a new random string in your settings file with `get_random_string()` and use that value instead, preventing attackers from extracting your main Django secret."
      },
      "pattern-either": [
        {
          "pattern": "hashids.Hashids(..., salt=django.conf.settings.SECRET_KEY, ...)"
        },
        {
          "pattern": "hashids.Hashids(django.conf.settings.SECRET_KEY, ...)"
        }
      ],
      "severity": "ERROR"
    },
    {
      "id": "python.django.security.locals-as-template-context.locals-as-template-context",
      "languages": [
        "python"
      ],
      "message": "Using locals() as a template context in Django renders exposes internal Python functions to the template. This creates a server-side template injection vulnerability allowing attackers to access sensitive data or execute arbitrary code. Always use explicit dictionaries with only the required variables.",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.2/ref/settings/#templates",
          "https://docs.djangoproject.com/en/3.2/topics/templates/#django.template.backends.django.DjangoTemplates",
          "https://docs.djangoproject.com/en/3.2/ref/templates/api/#rendering-a-context"
        ],
        "technology": [
          "django"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Unsafe locals() exposing functions to templates",
        "fix-suggestion": "Replace `render(request, 'template.html', locals())` with an explicit dictionary like `render(request, 'template.html', {'var1': value1, 'var2': value2})`. Only pass the specific variables needed by the template to prevent exposing internal functions."
      },
      "pattern-either": [
        {
          "pattern": "django.shortcuts.render(..., locals(...), ...)"
        },
        {
          "pattern": "django.template.Template.render(..., locals(...), ...)"
        },
        {
          "patterns": [
            {
              "pattern-inside": "$CONTEXT = locals(...)\n...\n"
            },
            {
              "pattern-either": [
                {
                  "pattern": "django.shortcuts.render(..., $CONTEXT, ...)"
                },
                {
                  "pattern": "django.template.Template.render(..., $CONTEXT, ...)"
                }
              ]
            }
          ]
        }
      ],
      "severity": "ERROR"
    },
    {
      "id": "python.django.security.nan-injection.nan-injection",
      "message": "Direct user input is passed to bool(), float(), or complex() type conversions without validation. This allows attackers to inject NaN (Not-a-Number) values, causing undefined behavior in comparisons and calculations. Validate user input before converting or use a different type that doesn't accept NaN.",
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-inside": "def $FUNC(request, ...):\n  ...\n"
            },
            {
              "pattern-either": [
                {
                  "pattern": "request.$PROPERTY.get(...)"
                },
                {
                  "pattern": "request.$PROPERTY[...]"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "float(...)"
                },
                {
                  "pattern": "bool(...)"
                },
                {
                  "pattern": "complex(...)"
                }
              ]
            },
            {
              "pattern-not-inside": "if $COND:\n  ...\n...\n"
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "pattern": "$ANYTHING(...)",
          "not_conflicting": true
        }
      ],
      "metadata": {
        "references": [
          "https://discuss.python.org/t/nan-breaks-min-max-and-sorting-functions-a-solution/2868",
          "https://blog.bitdiscovery.com/2021/12/python-nan-injection/"
        ],
        "category": "security",
        "cwe": [
          "CWE-704: Incorrect Type Conversion or Cast"
        ],
        "technology": [
          "django"
        ],
        "subcategory": [
          "vuln"
        ],
        "impact": "MEDIUM",
        "likelihood": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "NaN injection via unchecked type conversions",
        "fix-suggestion": "Add validation before type conversion by checking if the input string contains 'nan' (case-insensitive). Either use `isinstance()` checks, cast to a different type like `int()`, or implement guards like `if input.lower() != 'nan': value = float(input)`."
      }
    },
    {
      "id": "python.django.security.audit.avoid-insecure-deserialization.avoid-insecure-deserialization",
      "metadata": {
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "references": [
          "https://docs.python.org/3/library/pickle.html"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "Insecure deserialization methods can trigger remote code execution",
        "fix-suggestion": "Replace unsafe deserialization methods with secure alternatives in Django applications. Use `json` instead of `pickle` and always validate input data before deserialization. This prevents remote code execution through deserialization vulnerabilities."
      },
      "message": "Remote code execution vulnerabilities in Django applications arise when unsafe deserialization libraries like pickle or yaml process untrusted data. These libraries can instantiate arbitrary Python objects and execute their methods during deserialization, allowing attackers to run code through carefully crafted serialized data. This critical vulnerability can lead to complete application compromise, sensitive data exposure, or server takeover depending on the application's privilege level.",
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-inside": "def $INSIDE(..., $PARAM, ...):\n  ...\n"
                },
                {
                  "pattern-either": [
                    {
                      "pattern": "request.$REQFUNC(...)"
                    },
                    {
                      "pattern": "request.$REQFUNC.get(...)"
                    },
                    {
                      "pattern": "request.$REQFUNC[...]"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "pickle.$PICKLEFUNC(...)\n"
                    },
                    {
                      "pattern": "_pickle.$PICKLEFUNC(...)\n"
                    },
                    {
                      "pattern": "cPickle.$PICKLEFUNC(...)\n"
                    },
                    {
                      "pattern": "shelve.$PICKLEFUNC(...)\n"
                    }
                  ]
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$PICKLEFUNC",
                    "regex": "dumps|dump|load|loads"
                  }
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern": "dill.$DILLFUNC(...)"
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$DILLFUNC",
                    "regex": "dump|dump_session|dumps|load|load_session|loads"
                  }
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern": "yaml.$YAMLFUNC(...)"
                },
                {
                  "pattern-not": "yaml.$YAMLFUNC(..., Dumper=SafeDumper, ...)"
                },
                {
                  "pattern-not": "yaml.$YAMLFUNC(..., Dumper=yaml.SafeDumper, ...)"
                },
                {
                  "pattern-not": "yaml.$YAMLFUNC(..., Loader=SafeLoader, ...)"
                },
                {
                  "pattern-not": "yaml.$YAMLFUNC(..., Loader=yaml.SafeLoader, ...)"
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$YAMLFUNC",
                    "regex": "dump|dump_all|load|load_all"
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "python.django.security.audit.avoid-mark-safe.avoid-mark-safe",
      "patterns": [
        {
          "pattern-not-inside": "django.utils.html.format_html(...)"
        },
        {
          "pattern-not": "django.utils.safestring.mark_safe(\"...\")"
        },
        {
          "pattern": "django.utils.safestring.mark_safe(...)"
        }
      ],
      "message": "Cross-site scripting (XSS) vulnerabilities in Django occur when mark_safe() bypasses the framework's automatic HTML escaping for content containing untrusted user input. While Django normally escapes output to prevent XSS, mark_safe() explicitly tells Django not to escape the content, allowing any embedded HTML or JavaScript to execute in users' browsers. This can lead to session hijacking, credential theft, data exfiltration, or performing unauthorized actions on behalf of the victim.",
      "metadata": {
        "source-rule-url": "https://bandit.readthedocs.io/en/latest/plugins/b703_django_mark_safe.html",
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.0/ref/utils/#django.utils.safestring.mark_safe",
          "https://docs.djangoproject.com/en/3.0/ref/utils/#django.utils.html.format_html"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "mark_safe disables autoescaping, risking XSS if input is untrusted",
        "fix-suggestion": "Remove calls to `mark_safe()` that process user-controlled content in Django templates. Let Django's autoescaping handle HTML output by default for all dynamic content. This prevents XSS vulnerabilities in rendered templates."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.django.security.audit.custom-expression-as-sql.custom-expression-as-sql",
      "languages": [
        "python"
      ],
      "message": "SQL injection vulnerabilities in Django arise when custom SQL expressions incorporate unsanitized user input through string formatting or concatenation. Despite Django's ORM normally providing SQL injection protection, custom expressions can bypass these safeguards when improperly implemented. This allows attackers to manipulate query structure and behavior, potentially leading to unauthorized data access, authentication bypass, data modification, or even server compromise through advanced database features.",
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.0/ref/models/expressions/#django.db.models.Func.as_sql",
          "https://semgrep.dev/blog/2020/preventing-sql-injection-a-django-authors-perspective/"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Django custom SQL expression with user data is injection risk",
        "fix-suggestion": "Ensure custom SQL expressions use proper parameterization in the `as_sql()` method. Implement parameter binding rather than string concatenation for query construction. This prevents SQL injection when using custom Django ORM expressions."
      },
      "pattern": "$EXPRESSION.as_sql(...)",
      "severity": "WARNING"
    },
    {
      "id": "python.django.security.audit.extends-custom-expression.extends-custom-expression",
      "languages": [
        "python"
      ],
      "message": "SQL injection in Django can occur when custom SQL expression classes process user input without proper parameterization or escaping. By extending Django's SQL expression classes but failing to properly handle untrusted data, developers can inadvertently create injection points. The vulnerability allows attackers to manipulate query structure and behavior, potentially leading to unauthorized data access, authentication bypass, data manipulation, or even server compromise through the database.",
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.0/ref/models/expressions/#avoiding-sql-injection",
          "https://semgrep.dev/blog/2020/preventing-sql-injection-a-django-authors-perspective/"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Extending custom SQL expression can lead to injection",
        "fix-suggestion": "Update custom SQL expression classes to use proper parameter binding in Django ORM extensions. Implement strict sanitization in the `as_sql()` method for all user input. This prevents SQL injection in custom ORM components."
      },
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "class $CLASS(..., django.db.models.Func, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.expressions.Func, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.Expression, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.expressions.Expression, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.Value, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.expressions.Value, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.DurationValue, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.expressions.DurationValue, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.RawSQL, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.expressions.RawSQL, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.Star, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.expressions.Star, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.Random, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.expressions.Random, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.Col, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.expressions.Col, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.Ref, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.expressions.Ref, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.ExpressionList, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.expressions.ExpressionList, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.ExpressionWrapper, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.expressions.ExpressionWrapper, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.When, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.expressions.When, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.Case, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.expressions.Case, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.Subquery, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.expressions.Subquery, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.Exists, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.expressions.Exists, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.Window, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.expressions.Window, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.WindowFrame, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.expressions.WindowFrame, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.RowRange, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.expressions.RowRange, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.ValueRange, ...):\n    ...\n"
        },
        {
          "pattern": "class $CLASS(..., django.db.models.expressions.ValueRange, ...):\n    ...\n"
        }
      ]
    },
    {
      "id": "python.django.security.audit.unvalidated-password.unvalidated-password",
      "patterns": [
        {
          "pattern-not-inside": "if <... django.contrib.auth.password_validation.validate_password(...) ...>:\n    ...\n"
        },
        {
          "pattern-not-inside": "django.contrib.auth.password_validation.validate_password(...)\n...\n"
        },
        {
          "pattern-not-inside": "try:\n  ...\n  django.contrib.auth.password_validation.validate_password(...)\n  ...\nexcept $EX:\n  ...\n...\n"
        },
        {
          "pattern-not-inside": "try:\n  ...\n  django.contrib.auth.password_validation.validate_password(...)\n  ...\nexcept $EX as $E:\n  ...\n...\n"
        },
        {
          "pattern-not": "UserModel().set_password($X)"
        },
        {
          "pattern": "$MODEL.set_password($X)"
        }
      ],
      "fix": "if django.contrib.auth.password_validation.validate_password($X, user=$MODEL):\n    $MODEL.set_password($X)\n",
      "message": "Passwords are being set on models without proper validation. This could lead to weak passwords being accepted, compromising account security. Use Django's built-in password validation functions to ensure passwords meet security requirements before setting them.",
      "metadata": {
        "cwe": [
          "CWE-521: Weak Password Requirements"
        ],
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.0/topics/auth/passwords/#module-django.contrib.auth.password_validation"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Django model passwords set without validation",
        "fix-suggestion": "Add `django.contrib.auth.password_validation.validate_password(password)` before setting the password on your model. Include this in your form validation or model save method to enforce password strength requirements from your Django settings."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.django.security.audit.csrf-exempt.no-csrf-exempt",
      "pattern": "@django.views.decorators.csrf.csrf_exempt\ndef $R(...):\n  ...\n",
      "message": "Cross-Site Request Forgery (CSRF) vulnerabilities in Django applications arise when the @csrf_exempt decorator disables the framework's built-in CSRF protection for specific views. Without this protection, attackers can trick authenticated users into unknowingly executing unintended actions through malicious websites or links. The impact includes unauthorized state-changing operations, account takeover, data modification, or privileged actions performed without the user's knowledge or consent.",
      "metadata": {
        "cwe": [
          "CWE-352: Cross-Site Request Forgery (CSRF)"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site Request Forgery (CSRF)"
        ],
        "short-description": "CSRF exempt route can be exploited by cross-site requests",
        "fix-suggestion": "Remove `@csrf_exempt` decorators from Django views handling state-changing operations. Implement proper CSRF protection using Django's built-in `@csrf_protect` or CSRF token template tags. This prevents cross-site request forgery attacks."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.django.security.audit.django-rest-framework.missing-throttle-config.missing-throttle-config",
      "patterns": [
        {
          "pattern-not-inside": "REST_FRAMEWORK = {\n  ...,\n  \"DEFAULT_THROTTLE_RATES\": ...\n}\n"
        },
        {
          "pattern-inside": "REST_FRAMEWORK = ...\n"
        },
        {
          "pattern": "REST_FRAMEWORK"
        }
      ],
      "message": "Denial of Service vulnerabilities in Django REST Framework occur when API rate limiting is not configured through DEFAULT_THROTTLE_CLASSES and DEFAULT_THROTTLE_RATES settings. Without these protections, attackers can flood endpoints with excessive requests, consuming server resources and potentially causing service disruption. This vulnerability can lead to degraded application performance, unavailability of services, increased operational costs, or act as a distraction for other attacks targeting the compromised system.",
      "metadata": {
        "owasp": [
          "A05:2021 - Security Misconfiguration",
          "A06:2017 - Security Misconfiguration"
        ],
        "cwe": [
          "CWE-400: Uncontrolled Resource Consumption"
        ],
        "references": [
          "https://www.django-rest-framework.org/api-guide/throttling/#setting-the-throttling-policy"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Denial-of-Service (DoS)"
        ],
        "short-description": "No rate limiting in Django REST can cause DoS",
        "fix-suggestion": "Configure API rate limiting in Django REST Framework settings. Implement `DEFAULT_THROTTLE_CLASSES` and `DEFAULT_THROTTLE_RATES` in your DRF settings. This prevents denial-of-service attacks through API request flooding."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ]
    },
    {
      "id": "python.django.security.audit.query-set-extra.avoid-query-set-extra",
      "message": "SQL injection vulnerabilities in Django applications arise when the QuerySet.extra() method incorporates user input through string concatenation instead of using proper parameterization. Unlike standard Django ORM methods, extra() performs raw SQL operations that bypass the framework's SQL injection safeguards when improperly used. This allows attackers to manipulate query structure, potentially leading to unauthorized data access, authentication bypass, data modification, or even server compromise through the database.",
      "metadata": {
        "source-rule-url": "https://bandit.readthedocs.io/en/latest/plugins/b610_django_extra_used.html",
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.0/ref/models/querysets/#django.db.models.query.QuerySet.extra",
          "https://semgrep.dev/blog/2020/preventing-sql-injection-a-django-authors-perspective/"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "QuerySet.extra usage bypasses injection safeguards",
        "fix-suggestion": "Replace `QuerySet.extra()` with standard Django ORM methods for all database queries. Use `filter()`, `exclude()`, or `annotate()` with proper F expressions instead. This prevents SQL injection vulnerabilities in complex queries."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern": "$MODEL.extra(...)"
        },
        {
          "pattern-not-inside": "$MODEL.extra(select = {$KEY: \"...\"})"
        }
      ]
    },
    {
      "id": "python.django.security.audit.raw-query.avoid-raw-sql",
      "message": "SQL injection in Django occurs when raw() query methods execute SQL strings containing unsanitized user input instead of using proper parameterization. This insecure practice bypasses Django's ORM safety mechanisms that would normally prevent injection attacks. The vulnerability allows attackers to manipulate query structure and behavior, potentially leading to unauthorized data access, authentication bypass, data modification, or complete database compromise through advanced SQL techniques.",
      "metadata": {
        "source-rule-url": "https://bandit.readthedocs.io/en/latest/plugins/b611_django_rawsql_used.html",
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.0/ref/models/expressions/#raw-sql-expressions",
          "https://semgrep.dev/blog/2020/preventing-sql-injection-a-django-authors-perspective/"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Raw SQL queries with untrusted data enable injection",
        "fix-suggestion": "Replace `raw()` queries containing user input with Django ORM methods or properly parameterized raw queries. Use `Model.objects.filter()` or parameterized `raw('SELECT * FROM table WHERE id = %s', [user_id])`. This prevents SQL injection in direct database access."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$MODEL.objects.raw($QUERY, ...)"
            },
            {
              "pattern": "django.db.models.expressions.RawSQL(...)"
            }
          ]
        },
        {
          "pattern-not": "$MODEL.objects.raw(\"...\")"
        },
        {
          "pattern-not": "django.db.models.expressions.RawSQL(\"...\")"
        }
      ]
    },
    {
      "id": "python.django.security.audit.secure-cookies.django-secure-set-cookie",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "import django.http.HttpResponse\n...\n"
            },
            {
              "pattern-inside": "import django.shortcuts.render\n...\n"
            }
          ]
        },
        {
          "pattern-not-inside": "LANGUAGE_QUERY_PARAMETER = 'language'\n...\ndef set_language(request):\n    ...\n# Exclude vendored contrib/messages/storage/cookie.py\n"
        },
        {
          "pattern-not-inside": "class CookieStorage(django.contrib.messages.storage.base.BaseStorage):\n    ...\n# Exclude cookies handled by vendored middleware\n"
        },
        {
          "pattern-not": "response.set_cookie(django.conf.settings.SESSION_COOKIE_NAME, ...)"
        },
        {
          "pattern-not": "response.set_cookie(django.conf.settings.CSRF_COOKIE_NAME, ...)"
        },
        {
          "pattern-not": "response.set_cookie(django.conf.settings.LANGUAGE_COOKIE_NAME, ...)"
        },
        {
          "pattern-not": "response.set_cookie(rest_framework_jwt.settings.api_settings.JWT_AUTH_COOKIE, ...)"
        },
        {
          "pattern-not": "response.set_cookie(..., secure=$A, httponly=$B, samesite=$C, ...)"
        },
        {
          "pattern-not": "response.set_cookie(..., **$A)"
        },
        {
          "pattern": "response.set_cookie(...)"
        }
      ],
      "message": "Cookies are being set without proper security attributes. This makes them vulnerable to interception, cross-site scripting, and other attacks. Set secure=True, httpOnly=True, and samesite='Lax' when creating cookies to enhance security and prevent common web attacks.",
      "metadata": {
        "cwe": [
          "CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "asvs": {
          "section": "V3: Session Management Verification Requirements",
          "control_id": "3.4 Missing Cookie Attributes",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x12-V3-Session-management.md#v34-cookie-based-session-management",
          "version": "4"
        },
        "references": [
          "https://docs.djangoproject.com/en/3.0/ref/request-response/#django.http.HttpResponse.set_cookie",
          "https://semgrep.dev/blog/2020/bento-check-keeping-cookies-safe-in-flask/",
          "https://bento.dev/checks/flask/secure-set-cookie/"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cookie Security"
        ],
        "short-description": "Insecure cookie settings in Django response",
        "fix-suggestion": "Set security attributes when creating cookies using `response.set_cookie(name, value, secure=True, httponly=True, samesite='Lax')`. Only disable these settings explicitly when required for specific functionality, and document the security implications."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.django.security.audit.templates.debug-template-tag.debug-template-tag",
      "languages": [
        "regex"
      ],
      "severity": "WARNING",
      "message": "Debug template tags are present in Django templates. When debug mode is enabled, these tags dump sensitive information to the page that could help attackers target vulnerabilities in your application. Remove all debug tags from templates used in production.",
      "pattern-regex": "({% debug %})",
      "paths": {
        "include": [
          "*.html"
        ]
      },
      "metadata": {
        "owasp": "A06:2017 - Security Misconfiguration",
        "cwe": [
          "CWE-489: Active Debug Code"
        ],
        "references": [
          "https://docs.djangoproject.com/en/4.2/ref/templates/builtins/#debug",
          "https://stackoverflow.com/questions/2213977/django-debug-display-all-variables-of-a-page"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Active Debug Code"
        ],
        "short-description": "Debug tags leaking information in templates",
        "fix-suggestion": "Remove all instances of `{% debug %}` from your Django templates. If debugging is needed during development, use Django's logging framework or create a separate debugging template that is only included in development environments."
      }
    },
    {
      "id": "python.django.security.audit.xss.class-extends-safestring.class-extends-safestring",
      "message": "Cross-site scripting (XSS) vulnerabilities in Django arise when custom classes extend SafeString or related classes to bypass the framework's automatic HTML escaping. This practice marks content as already safe, preventing Django from applying necessary escaping even when the content includes untrusted user input. Consequently, any malicious HTML or JavaScript within the content will be rendered and executed in users' browsers, potentially leading to session hijacking, credential theft, or unauthorized actions on behalf of victims.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.1/howto/custom-template-tags/#filters-and-auto-escaping",
          "https://github.com/django/django/blob/f138e75910b1e541686c4dce3d8f467f6fc234cb/django/utils/safestring.py#L11"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Extending SafeString can bypass escaping and cause XSS",
        "fix-suggestion": "Stop extending `SafeString` for objects containing user input in Django templates. Let Django's autoescaping handle content rendering instead of bypassing XSS protections. This prevents cross-site scripting in custom template objects."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "class $CLASS(django.utils.safestring.SafeString):\n  ...\n"
        },
        {
          "pattern": "class $CLASS(django.utils.safestring.SafeText):\n  ...\n"
        },
        {
          "pattern": "class $CLASS(django.utils.safestring.SafeData):\n  ..."
        }
      ]
    },
    {
      "id": "python.django.security.audit.xss.context-autoescape-off.context-autoescape-off",
      "message": "Cross-site scripting (XSS) vulnerabilities in Django occur when template contexts disable autoescaping through the autoescape=False parameter. This configuration prevents Django from automatically encoding potentially dangerous characters in output, allowing raw HTML and JavaScript to be rendered. When this unescaped output contains user-controlled content, malicious code can execute in users' browsers, potentially leading to session hijacking, credential theft, or unauthorized actions on behalf of victims.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.1/ref/settings/#templates",
          "https://docs.djangoproject.com/en/3.1/topics/templates/#django.template.backends.django.DjangoTemplates"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "context autoescape disabled, risking XSS from user input",
        "fix-suggestion": "Remove context processor settings that disable autoescaping in Django templates. Maintain default `autoescape=True` in all template contexts and rendering calls. This prevents XSS vulnerabilities across all template rendering."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "{..., \"autoescape\": $FALSE, ...}\n"
            },
            {
              "pattern": "$D[\"autoescape\"] = $FALSE\n"
            }
          ]
        },
        {
          "metavariable-pattern": {
            "metavariable": "$FALSE",
            "pattern": "False\n"
          }
        },
        {
          "focus-metavariable": "$FALSE"
        }
      ],
      "fix": "True\n"
    },
    {
      "id": "python.django.security.audit.xss.direct-use-of-httpresponse.direct-use-of-httpresponse",
      "message": "Cross-site scripting (XSS) vulnerabilities in Django applications arise when HttpResponse is used to send HTML content directly instead of using the template system. Unlike Django's template renderer which automatically escapes output, direct HttpResponse usage provides no built-in protection against XSS attacks. This bypassing of Django's security controls allows any unsanitized user input included in the response to contain malicious HTML or JavaScript that executes in users' browsers, potentially leading to session hijacking or unauthorized actions.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.1/intro/tutorial03/#a-shortcut-render",
          "https://docs.djangoproject.com/en/3.1/topics/http/shortcuts/#render"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "HttpResponse with user data bypasses templating, can cause XSS",
        "fix-suggestion": "Replace direct `HttpResponse` with unsafe content with Django's template rendering system. Use `render()` or manually escape user input with `html.escape()` before constructing response content. This prevents XSS in HTTP responses."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-not": "django.http.$ANY(\"...\", ...)"
        },
        {
          "pattern-not": "django.http.$ANY()"
        },
        {
          "pattern-not": "django.http.$ANY(..., content=None, ...)"
        },
        {
          "pattern-not": "django.http.$ANY(status=...)"
        },
        {
          "pattern-not": "django.http.HttpResponseNotAllowed([...])"
        },
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "django.http.HttpResponse(...)"
                    },
                    {
                      "pattern": "django.http.HttpResponseBadRequest(...)"
                    },
                    {
                      "pattern": "django.http.HttpResponseNotFound(...)"
                    },
                    {
                      "pattern": "django.http.HttpResponseForbidden(...)"
                    },
                    {
                      "pattern": "django.http.HttpResponseNotAllowed(...)"
                    },
                    {
                      "pattern": "django.http.HttpResponseGone(...)"
                    },
                    {
                      "pattern": "django.http.HttpResponseServerError(...)"
                    }
                  ]
                },
                {
                  "pattern-not": "django.http.$ANY(...,content_type=$TYPE,...)"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "django.http.HttpResponse(...,content_type=$TYPE,...)"
                    },
                    {
                      "pattern": "django.http.HttpResponseBadRequest(...,content_type=$TYPE,...)"
                    },
                    {
                      "pattern": "django.http.HttpResponseNotFound(...,content_type=$TYPE,...)"
                    },
                    {
                      "pattern": "django.http.HttpResponseForbidden(...,content_type=$TYPE,...)"
                    },
                    {
                      "pattern": "django.http.HttpResponseNotAllowed(...,content_type=$TYPE,...)"
                    },
                    {
                      "pattern": "django.http.HttpResponseGone(...,content_type=$TYPE,...)"
                    },
                    {
                      "pattern": "django.http.HttpResponseServerError(...,content_type=$TYPE,...)"
                    }
                  ]
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$TYPE",
                    "regex": ".*[tT][eE][xX][tT]/[hH][tT][mM][lL].*"
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "python.django.security.audit.xss.filter-with-is-safe.filter-with-is-safe",
      "message": "Cross-site scripting (XSS) vulnerabilities in Django occur when custom template filters use the is_safe=True flag to bypass automatic HTML escaping. This configuration tells Django that the filter's output is already safe and doesn't need escaping, even if it contains user-controlled data. When this mechanism is misused with untrusted content, malicious HTML or JavaScript can execute in users' browsers, potentially leading to session hijacking, credential theft, or unauthorized actions on behalf of victims.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.1/topics/security/#cross-site-scripting-xss-protection",
          "https://docs.djangoproject.com/en/3.1/howto/custom-template-tags/#filters-and-auto-escaping",
          "https://stackoverflow.com/questions/7665512/why-use-is-safe"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "'is_safe' filter can allow unescaped malicious content",
        "fix-suggestion": "Remove `is_safe=True` from custom template filters handling user data. Let Django's autoescaping system process filter output by default for all dynamic content. This prevents XSS vulnerabilities in custom template filters."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "pattern": "@register.filter(..., is_safe=True, ...)\ndef $FILTER(...):\n  ..."
    },
    {
      "id": "python.django.security.audit.xss.formathtml-fstring-parameter.formathtml-fstring-parameter",
      "message": "Cross-site scripting (XSS) vulnerabilities in Django arise when format_html() receives a formatted f-string as its first parameter instead of a static format string. This usage pattern prevents Django from properly escaping the embedded values since they're already interpolated into the string before format_html() processes it. Consequently, any unsanitized user input within the f-string can contain malicious HTML or JavaScript that executes in users' browsers, potentially leading to session hijacking or unauthorized actions.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.2/ref/utils/#django.utils.html.format_html"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "f-string in format_html bypasses HTML escaping",
        "fix-suggestion": "Replace f-strings in `format_html()` with static format strings and separate parameters. Use `format_html(\"{}\", user_input)` instead of `format_html(f\"...{user_input}\")`. This prevents XSS in formatted HTML output."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "format_html(<... f\"...\" ...>, ...)"
        },
        {
          "pattern": "format_html(\"...\" % ..., ...)"
        },
        {
          "pattern": "format_html(\"...\".format(...), ...)"
        }
      ]
    },
    {
      "id": "python.django.security.audit.xss.global-autoescape-off.global-autoescape-off",
      "message": "Cross-site scripting (XSS) vulnerabilities in Django applications occur when global template autoescaping is disabled in the project configuration. This setting prevents Django from automatically encoding potentially dangerous characters across all templates, allowing raw HTML and JavaScript to be rendered. When templates contain user-controlled content, malicious code can execute in browsers, potentially leading to session hijacking, credential theft, or unauthorized actions on behalf of victims.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.1/ref/settings/#templates",
          "https://docs.djangoproject.com/en/3.1/topics/templates/#django.template.backends.django.DjangoTemplates"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Global autoescape off exposes all templates to XSS",
        "fix-suggestion": "Enable global autoescaping in Django template settings and configuration. Set `'autoescape': True` in template options and remove any global disabling. This prevents XSS vulnerabilities across all template rendering."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern": "{..., 'BACKEND': ..., 'OPTIONS': {..., 'autoescape': $FALSE, ...}, ...}\n"
        },
        {
          "metavariable-pattern": {
            "metavariable": "$FALSE",
            "pattern": "False\n"
          }
        },
        {
          "focus-metavariable": "$FALSE"
        }
      ],
      "fix": "True\n"
    },
    {
      "id": "python.django.security.audit.xss.html-magic-method.html-magic-method",
      "message": "Cross-site scripting (XSS) vulnerabilities in Django applications arise when custom classes implement the __html__ magic method to bypass the framework's automatic HTML escaping. This special method tells Django that the object's string representation is already safe HTML that doesn't need escaping, even when it contains user-controlled content. When this mechanism is misused with untrusted data, malicious HTML or JavaScript can execute in users' browsers, potentially leading to session hijacking or unauthorized actions on behalf of victims.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.0/_modules/django/utils/html/#conditional_escape",
          "https://gist.github.com/minusworld/7885d8a81dba3ea2d1e4b8fd3c218ef5"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "__html__ method can skip escaping, leading to XSS",
        "fix-suggestion": "Revise classes implementing `__html__()` magic method to properly sanitize user input. Either ensure thorough escaping or avoid this method for objects with untrusted content. This prevents XSS vulnerabilities in custom template-renderable objects."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "class $CLASS(...):\n  ...\n"
        },
        {
          "pattern": "def __html__(...):\n  ...\n"
        }
      ]
    },
    {
      "id": "python.django.security.audit.xss.html-safe.html-safe",
      "message": "Cross-site scripting (XSS) vulnerabilities in Django occur when the html_safe() function marks content as safe, bypassing the framework's automatic HTML escaping. This function tells Django that the content doesn't need escaping, allowing raw HTML and JavaScript to be rendered even when it contains user-controlled data. Consequently, any malicious code within the content will execute in users' browsers, potentially leading to session hijacking, credential theft, or unauthorized actions on behalf of victims.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.0/_modules/django/utils/html/#html_safe",
          "https://gist.github.com/minusworld/7885d8a81dba3ea2d1e4b8fd3c218ef5"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "html_safe bypasses escaping, can allow malicious HTML",
        "fix-suggestion": "Remove calls to `html_safe()` decorator or method for objects containing user-controlled content. Let Django's default autoescaping process all dynamic content instead. This prevents XSS in custom template classes."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "django.utils.html.html_safe(...)"
        },
        {
          "pattern": "@django.utils.html.html_safe\nclass $CLASS(...):\n  ...\n"
        }
      ]
    },
    {
      "id": "python.django.security.audit.xss.template-autoescape-off.template-autoescape-off",
      "message": "Cross-site scripting (XSS) vulnerabilities in Django templates arise when {% autoescape off %} blocks disable HTML escaping for sections of templates. This directive prevents Django from encoding potentially dangerous characters in the output within that block, allowing raw HTML and JavaScript to be rendered. When these template sections include user-controlled content, malicious code can execute in users' browsers, potentially leading to session hijacking, credential theft, or unauthorized actions on behalf of victims.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.1/ref/templates/builtins/#autoescape"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Template block without autoescape can produce unescaped XSS",
        "fix-suggestion": "Remove `{% autoescape off %}` blocks from Django templates handling user input. Keep default autoescaping enabled for all templates processing dynamic content. This prevents XSS vulnerabilities in specific template sections."
      },
      "languages": [
        "regex"
      ],
      "paths": {
        "include": [
          "*.html"
        ]
      },
      "severity": "WARNING",
      "pattern-regex": "{%\\s+autoescape\\s+off\\s+%}"
    },
    {
      "id": "python.django.security.audit.xss.template-blocktranslate-no-escape.template-blocktranslate-no-escape",
      "languages": [
        "generic"
      ],
      "severity": "INFO",
      "message": "Cross-site scripting (XSS) vulnerabilities in Django templates occur when {% blocktranslate %} tags include user-controlled content without proper escaping. Unlike regular variable interpolation, translated blocks in templates don't automatically escape HTML entities unless explicitly directed to do so. This lack of automatic protection allows malicious HTML or JavaScript within translated content to execute in users' browsers, potentially leading to session hijacking, credential theft, or unauthorized actions on behalf of victims.",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "{% blocktranslate...%}\n"
            },
            {
              "pattern": "{% blocktrans...%}\n"
            }
          ]
        },
        {
          "pattern-not-inside": "{%...filter...force_escape...%}\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n{%...endfilter...%}\n"
        }
      ],
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://edx.readthedocs.io/projects/edx-developer-guide/en/latest/preventing_xss/preventing_xss_in_django_templates.html#html-escaping-translations-in-django-templates",
          "https://docs.djangoproject.com/en/3.1/topics/i18n/translation/#internationalization-in-template-code"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "blocktranslate without escape can display malicious scripts",
        "fix-suggestion": "Modify `{% blocktranslate %}` tags to explicitly use the `escape` option for untrusted content. Use `{% blocktranslate escape=True %}` or pre-escape variables before translation. This prevents XSS in internationalized template content."
      }
    },
    {
      "id": "python.django.security.audit.xss.template-translate-as-no-escape.template-translate-as-no-escape",
      "languages": [
        "generic"
      ],
      "severity": "INFO",
      "message": "Cross-site scripting (XSS) vulnerabilities in Django templates arise when {% translate %} tags with the 'as' parameter store unescaped translated content for later use. Unlike immediate output, variables stored through this method aren't automatically HTML-escaped when eventually displayed in the template. This deferred escaping issue allows malicious HTML or JavaScript within translated content to execute in users' browsers, potentially leading to session hijacking, credential theft, or unauthorized actions on behalf of victims.",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "{% translate ... as $TRANS ... %}\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n{{ ... $TRANS ... }}\n"
            },
            {
              "pattern": "{% trans ... as $TRANS ... %}\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n{{ ... $TRANS ... }}\n"
            }
          ]
        },
        {
          "pattern-not": "{% translate ... as $TRANS ... %}\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n{{ ... $TRANS ... | ... force_escape ... }}\n"
        },
        {
          "pattern-not": "{% trans ... as $TRANS ... %}\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n{{ ... $TRANS ... | ... force_escape ... }}\n"
        },
        {
          "pattern-not": "{% translate ... as $TRANS ... %}\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n{% filter force_escape %}\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n{{ ... $TRANS ... }}\n"
        },
        {
          "pattern-not": "{% trans ... as $TRANS ... %}\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n{% filter force_escape %}\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n{{ ... $TRANS ... }}\n"
        }
      ],
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://edx.readthedocs.io/projects/edx-developer-guide/en/latest/preventing_xss/preventing_xss_in_django_templates.html#html-escaping-translations-in-django-templates",
          "https://docs.djangoproject.com/en/3.1/topics/i18n/translation/#internationalization-in-template-code"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Translations not escaped leads to possible XSS",
        "fix-suggestion": "Explicitly escape translated content stored via the `{% translate %}` tag with `as` variable. Either use `{{ var|escape }}` when outputting the variable or pre-escape content. This prevents XSS in stored translations."
      }
    },
    {
      "id": "python.django.security.audit.xss.template-var-unescaped-with-safeseq.template-var-unescaped-with-safeseq",
      "message": "Cross-site scripting (XSS) vulnerabilities in Django templates occur when the 'safeseq' filter is applied to lists containing user-controlled content. This filter marks each item in the sequence as safe HTML that doesn't need escaping, bypassing Django's automatic protection mechanisms. When these unescaped values contain malicious HTML or JavaScript, they will execute in users' browsers, potentially leading to session hijacking, credential theft, or unauthorized actions on behalf of victims.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.0/ref/templates/builtins/#safeseq"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "safeseq usage can embed unsafe content for XSS",
        "fix-suggestion": "Stop using `safeseq` filter on sequences containing user input in Django templates. Either escape each element individually or let Django's autoescaping handle the sequence. This prevents XSS in template sequence rendering."
      },
      "languages": [
        "regex"
      ],
      "paths": {
        "include": [
          "*.html"
        ]
      },
      "severity": "WARNING",
      "pattern-regex": "{{.*?\\|\\s+safeseq(\\s+}})?"
    },
    {
      "id": "python.django.security.injection.mass-assignment.mass-assignment",
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "message": "Mass assignment vulnerability detected when using request data directly. Attackers can inject additional fields that you didn't intend to modify, potentially escalating privileges or corrupting data. Explicitly assign each field individually instead of using the unpacked request dictionary.",
      "metadata": {
        "cwe": [
          "CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes"
        ],
        "owasp": [
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "owaspapi": "API6: Mass Assignment",
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Mass_Assignment_Cheat_Sheet.html"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mass Assignment"
        ],
        "short-description": "Mass assignment allowing unintended field updates",
        "fix-suggestion": "Replace `Model.objects.create(**request.POST)` with explicit field assignment like `Model.objects.create(field1=request.POST.get('field1'), field2=request.POST.get('field2'))`. Only include fields that should be editable by the user to prevent malicious modification."
      },
      "pattern-either": [
        {
          "pattern": "$MODEL.objects.create(**request.$W)"
        },
        {
          "pattern": "$OBJ.update(**request.$W)\n...\n$OBJ.save()\n"
        }
      ]
    },
    {
      "id": "python.django.security.injection.open-redirect.open-redirect",
      "message": "User input from a request is directly passed to redirect(). This creates an open redirect vulnerability where attackers can redirect users to malicious sites. Always validate redirect URLs against a whitelist or use Django's url_for() to generate safe internal redirects.",
      "metadata": {
        "cwe": [
          "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "references": [
          "https://www.djm.org.uk/posts/djangos-little-protections-word-redirect-dangers/",
          "https://github.com/django/django/blob/d1b7bd030b1db111e1a3505b1fc029ab964382cc/django/utils/http.py#L231"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Open Redirect"
        ],
        "short-description": "Open redirect vulnerability in Django view",
        "fix-suggestion": "Validate redirect URLs before using them by implementing `django.utils.http.is_safe_url()` to check destinations. Either use Django's built-in `redirect()` with named routes or validate external URLs against an allowlist of trusted domains."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "def $FUNC(...):\n  ...\n"
        },
        {
          "pattern-not-inside": "def $FUNC(...):\n  ...\n  django.utils.http.is_safe_url(...)\n  ...\n"
        },
        {
          "pattern-not-inside": "def $FUNC(...):\n  ...\n  if <... django.utils.http.is_safe_url(...) ...>:\n    ...\n"
        },
        {
          "pattern-not-inside": "def $FUNC(...):\n  ...\n  django.utils.http.url_has_allowed_host_and_scheme(...)\n  ...\n"
        },
        {
          "pattern-not-inside": "def $FUNC(...):\n  ...\n  if <... django.utils.http.url_has_allowed_host_and_scheme(...) ...>:\n    ...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "django.shortcuts.redirect(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "django.shortcuts.redirect(..., $S.format(..., request.$W.get(...), ...), ...)"
            },
            {
              "pattern": "django.shortcuts.redirect(..., $S % request.$W.get(...), ...)"
            },
            {
              "pattern": "django.shortcuts.redirect(..., f\"...{request.$W.get(...)}...\", ...)"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.shortcuts.redirect(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $DATA\n...\ndjango.shortcuts.redirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.shortcuts.redirect(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\ndjango.shortcuts.redirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.shortcuts.redirect(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR % $DATA\n...\ndjango.shortcuts.redirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.shortcuts.redirect(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.shortcuts.redirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.shortcuts.redirect(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR + $DATA\n...\ndjango.shortcuts.redirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.shortcuts.redirect(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "$A = django.shortcuts.redirect(..., $S.format(..., request.$W.get(...), ...), ...)"
            },
            {
              "pattern": "$A = django.shortcuts.redirect(..., $S % request.$W.get(...), ...)"
            },
            {
              "pattern": "$A = django.shortcuts.redirect(..., f\"...{request.$W.get(...)}...\", ...)"
            },
            {
              "pattern": "return django.shortcuts.redirect(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "return django.shortcuts.redirect(..., $S.format(..., request.$W.get(...), ...), ...)"
            },
            {
              "pattern": "return django.shortcuts.redirect(..., $S % request.$W.get(...), ...)"
            },
            {
              "pattern": "return django.shortcuts.redirect(..., f\"...{request.$W.get(...)}...\", ...)"
            },
            {
              "pattern": "django.shortcuts.redirect(..., request.$W(...), ...)"
            },
            {
              "pattern": "django.shortcuts.redirect(..., $S.format(..., request.$W(...), ...), ...)"
            },
            {
              "pattern": "django.shortcuts.redirect(..., $S % request.$W(...), ...)"
            },
            {
              "pattern": "django.shortcuts.redirect(..., f\"...{request.$W(...)}...\", ...)"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.shortcuts.redirect(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $DATA\n...\ndjango.shortcuts.redirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.shortcuts.redirect(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\ndjango.shortcuts.redirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.shortcuts.redirect(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR % $DATA\n...\ndjango.shortcuts.redirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.shortcuts.redirect(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.shortcuts.redirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.shortcuts.redirect(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR + $DATA\n...\ndjango.shortcuts.redirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.shortcuts.redirect(..., request.$W(...), ...)"
            },
            {
              "pattern": "$A = django.shortcuts.redirect(..., $S.format(..., request.$W(...), ...), ...)"
            },
            {
              "pattern": "$A = django.shortcuts.redirect(..., $S % request.$W(...), ...)"
            },
            {
              "pattern": "$A = django.shortcuts.redirect(..., f\"...{request.$W(...)}...\", ...)"
            },
            {
              "pattern": "return django.shortcuts.redirect(..., request.$W(...), ...)"
            },
            {
              "pattern": "return django.shortcuts.redirect(..., $S.format(..., request.$W(...), ...), ...)"
            },
            {
              "pattern": "return django.shortcuts.redirect(..., $S % request.$W(...), ...)"
            },
            {
              "pattern": "return django.shortcuts.redirect(..., f\"...{request.$W(...)}...\", ...)"
            },
            {
              "pattern": "django.shortcuts.redirect(..., request.$W[...], ...)"
            },
            {
              "pattern": "django.shortcuts.redirect(..., $S.format(..., request.$W[...], ...), ...)"
            },
            {
              "pattern": "django.shortcuts.redirect(..., $S % request.$W[...], ...)"
            },
            {
              "pattern": "django.shortcuts.redirect(..., f\"...{request.$W[...]}...\", ...)"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.shortcuts.redirect(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $DATA\n...\ndjango.shortcuts.redirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.shortcuts.redirect(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\ndjango.shortcuts.redirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.shortcuts.redirect(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR % $DATA\n...\ndjango.shortcuts.redirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.shortcuts.redirect(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.shortcuts.redirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.shortcuts.redirect(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR + $DATA\n...\ndjango.shortcuts.redirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.shortcuts.redirect(..., request.$W[...], ...)"
            },
            {
              "pattern": "$A = django.shortcuts.redirect(..., $S.format(..., request.$W[...], ...), ...)"
            },
            {
              "pattern": "$A = django.shortcuts.redirect(..., $S % request.$W[...], ...)"
            },
            {
              "pattern": "$A = django.shortcuts.redirect(..., f\"...{request.$W[...]}...\", ...)"
            },
            {
              "pattern": "return django.shortcuts.redirect(..., request.$W[...], ...)"
            },
            {
              "pattern": "return django.shortcuts.redirect(..., $S.format(..., request.$W[...], ...), ...)"
            },
            {
              "pattern": "return django.shortcuts.redirect(..., $S % request.$W[...], ...)"
            },
            {
              "pattern": "return django.shortcuts.redirect(..., f\"...{request.$W[...]}...\", ...)"
            },
            {
              "pattern": "django.shortcuts.redirect(..., request.$W, ...)"
            },
            {
              "pattern": "django.shortcuts.redirect(..., $S.format(..., request.$W, ...), ...)"
            },
            {
              "pattern": "django.shortcuts.redirect(..., $S % request.$W, ...)"
            },
            {
              "pattern": "django.shortcuts.redirect(..., f\"...{request.$W}...\", ...)"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.shortcuts.redirect(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $DATA\n...\ndjango.shortcuts.redirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.shortcuts.redirect(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\ndjango.shortcuts.redirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.shortcuts.redirect(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR % $DATA\n...\ndjango.shortcuts.redirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.shortcuts.redirect(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.shortcuts.redirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.shortcuts.redirect(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR + $DATA\n...\ndjango.shortcuts.redirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.shortcuts.redirect(..., request.$W, ...)"
            },
            {
              "pattern": "$A = django.shortcuts.redirect(..., $S.format(..., request.$W, ...), ...)"
            },
            {
              "pattern": "$A = django.shortcuts.redirect(..., $S % request.$W, ...)"
            },
            {
              "pattern": "$A = django.shortcuts.redirect(..., f\"...{request.$W}...\", ...)"
            },
            {
              "pattern": "return django.shortcuts.redirect(..., request.$W, ...)"
            },
            {
              "pattern": "return django.shortcuts.redirect(..., $S.format(..., request.$W, ...), ...)"
            },
            {
              "pattern": "return django.shortcuts.redirect(..., $S % request.$W, ...)"
            },
            {
              "pattern": "return django.shortcuts.redirect(..., f\"...{request.$W}...\", ...)"
            },
            {
              "pattern": "django.http.HttpResponseRedirect(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "django.http.HttpResponseRedirect(..., $S.format(..., request.$W.get(...), ...), ...)"
            },
            {
              "pattern": "django.http.HttpResponseRedirect(..., $S % request.$W.get(...), ...)"
            },
            {
              "pattern": "django.http.HttpResponseRedirect(..., f\"...{request.$W.get(...)}...\", ...)"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.http.HttpResponseRedirect(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $DATA\n...\ndjango.http.HttpResponseRedirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.http.HttpResponseRedirect(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\ndjango.http.HttpResponseRedirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.http.HttpResponseRedirect(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR % $DATA\n...\ndjango.http.HttpResponseRedirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.http.HttpResponseRedirect(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.http.HttpResponseRedirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.http.HttpResponseRedirect(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR + $DATA\n...\ndjango.http.HttpResponseRedirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.http.HttpResponseRedirect(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "$A = django.http.HttpResponseRedirect(..., $S.format(..., request.$W.get(...), ...), ...)"
            },
            {
              "pattern": "$A = django.http.HttpResponseRedirect(..., $S % request.$W.get(...), ...)"
            },
            {
              "pattern": "$A = django.http.HttpResponseRedirect(..., f\"...{request.$W.get(...)}...\", ...)"
            },
            {
              "pattern": "return django.http.HttpResponseRedirect(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "return django.http.HttpResponseRedirect(..., $S.format(..., request.$W.get(...), ...), ...)"
            },
            {
              "pattern": "return django.http.HttpResponseRedirect(..., $S % request.$W.get(...), ...)"
            },
            {
              "pattern": "return django.http.HttpResponseRedirect(..., f\"...{request.$W.get(...)}...\", ...)"
            },
            {
              "pattern": "django.http.HttpResponseRedirect(..., request.$W(...), ...)"
            },
            {
              "pattern": "django.http.HttpResponseRedirect(..., $S.format(..., request.$W(...), ...), ...)"
            },
            {
              "pattern": "django.http.HttpResponseRedirect(..., $S % request.$W(...), ...)"
            },
            {
              "pattern": "django.http.HttpResponseRedirect(..., f\"...{request.$W(...)}...\", ...)"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.http.HttpResponseRedirect(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $DATA\n...\ndjango.http.HttpResponseRedirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.http.HttpResponseRedirect(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\ndjango.http.HttpResponseRedirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.http.HttpResponseRedirect(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR % $DATA\n...\ndjango.http.HttpResponseRedirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.http.HttpResponseRedirect(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.http.HttpResponseRedirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.http.HttpResponseRedirect(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR + $DATA\n...\ndjango.http.HttpResponseRedirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.http.HttpResponseRedirect(..., request.$W(...), ...)"
            },
            {
              "pattern": "$A = django.http.HttpResponseRedirect(..., $S.format(..., request.$W(...), ...), ...)"
            },
            {
              "pattern": "$A = django.http.HttpResponseRedirect(..., $S % request.$W(...), ...)"
            },
            {
              "pattern": "$A = django.http.HttpResponseRedirect(..., f\"...{request.$W(...)}...\", ...)"
            },
            {
              "pattern": "return django.http.HttpResponseRedirect(..., request.$W(...), ...)"
            },
            {
              "pattern": "return django.http.HttpResponseRedirect(..., $S.format(..., request.$W(...), ...), ...)"
            },
            {
              "pattern": "return django.http.HttpResponseRedirect(..., $S % request.$W(...), ...)"
            },
            {
              "pattern": "return django.http.HttpResponseRedirect(..., f\"...{request.$W(...)}...\", ...)"
            },
            {
              "pattern": "django.http.HttpResponseRedirect(..., request.$W[...], ...)"
            },
            {
              "pattern": "django.http.HttpResponseRedirect(..., $S.format(..., request.$W[...], ...), ...)"
            },
            {
              "pattern": "django.http.HttpResponseRedirect(..., $S % request.$W[...], ...)"
            },
            {
              "pattern": "django.http.HttpResponseRedirect(..., f\"...{request.$W[...]}...\", ...)"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.http.HttpResponseRedirect(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $DATA\n...\ndjango.http.HttpResponseRedirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.http.HttpResponseRedirect(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\ndjango.http.HttpResponseRedirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.http.HttpResponseRedirect(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR % $DATA\n...\ndjango.http.HttpResponseRedirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.http.HttpResponseRedirect(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.http.HttpResponseRedirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.http.HttpResponseRedirect(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR + $DATA\n...\ndjango.http.HttpResponseRedirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.http.HttpResponseRedirect(..., request.$W[...], ...)"
            },
            {
              "pattern": "$A = django.http.HttpResponseRedirect(..., $S.format(..., request.$W[...], ...), ...)"
            },
            {
              "pattern": "$A = django.http.HttpResponseRedirect(..., $S % request.$W[...], ...)"
            },
            {
              "pattern": "$A = django.http.HttpResponseRedirect(..., f\"...{request.$W[...]}...\", ...)"
            },
            {
              "pattern": "return django.http.HttpResponseRedirect(..., request.$W[...], ...)"
            },
            {
              "pattern": "return django.http.HttpResponseRedirect(..., $S.format(..., request.$W[...], ...), ...)"
            },
            {
              "pattern": "return django.http.HttpResponseRedirect(..., $S % request.$W[...], ...)"
            },
            {
              "pattern": "return django.http.HttpResponseRedirect(..., f\"...{request.$W[...]}...\", ...)"
            },
            {
              "pattern": "django.http.HttpResponseRedirect(..., request.$W, ...)"
            },
            {
              "pattern": "django.http.HttpResponseRedirect(..., $S.format(..., request.$W, ...), ...)"
            },
            {
              "pattern": "django.http.HttpResponseRedirect(..., $S % request.$W, ...)"
            },
            {
              "pattern": "django.http.HttpResponseRedirect(..., f\"...{request.$W}...\", ...)"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.http.HttpResponseRedirect(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $DATA\n...\ndjango.http.HttpResponseRedirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.http.HttpResponseRedirect(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\ndjango.http.HttpResponseRedirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.http.HttpResponseRedirect(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR % $DATA\n...\ndjango.http.HttpResponseRedirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.http.HttpResponseRedirect(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.http.HttpResponseRedirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.http.HttpResponseRedirect(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR + $DATA\n...\ndjango.http.HttpResponseRedirect(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.http.HttpResponseRedirect(..., request.$W, ...)"
            },
            {
              "pattern": "$A = django.http.HttpResponseRedirect(..., $S.format(..., request.$W, ...), ...)"
            },
            {
              "pattern": "$A = django.http.HttpResponseRedirect(..., $S % request.$W, ...)"
            },
            {
              "pattern": "$A = django.http.HttpResponseRedirect(..., f\"...{request.$W}...\", ...)"
            },
            {
              "pattern": "return django.http.HttpResponseRedirect(..., request.$W, ...)"
            },
            {
              "pattern": "return django.http.HttpResponseRedirect(..., $S.format(..., request.$W, ...), ...)"
            },
            {
              "pattern": "return django.http.HttpResponseRedirect(..., $S % request.$W, ...)"
            },
            {
              "pattern": "return django.http.HttpResponseRedirect(..., f\"...{request.$W}...\", ...)"
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$W",
            "regex": "(?!get_full_path)"
          }
        }
      ]
    },
    {
      "id": "python.django.security.injection.raw-html-format.raw-html-format",
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "message": "Cross-site scripting (XSS) vulnerabilities in Django applications arise when HTML is manually constructed by concatenating strings that include unsanitized user input. This practice bypasses Django's template system and its automatic HTML escaping that would normally prevent XSS attacks. When browsers render this unescaped content containing malicious HTML or JavaScript, it executes with the privileges of the application's origin, potentially leading to session hijacking, credential theft, or unauthorized actions on behalf of victims.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.2/topics/http/shortcuts/#render",
          "https://docs.djangoproject.com/en/3.2/topics/security/#cross-site-scripting-xss-protection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Concatenating raw HTML with user data triggers XSS risk",
        "fix-suggestion": "Use Django's template system instead of manually constructing HTML strings, as it automatically applies proper HTML escaping. When programmatically generating HTML, use Django's `format_html()` function which safely handles escaping, and never concatenate user input directly into HTML strings."
      },
      "mode": "taint",
      "pattern-sanitizers": [
        {
          "pattern": "django.utils.html.escape(...)"
        }
      ],
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "request.$ANYTHING"
            },
            {
              "pattern-not": "request.build_absolute_uri"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "\"$HTMLSTR\" % ..."
                        },
                        {
                          "pattern": "\"$HTMLSTR\".format(...)"
                        },
                        {
                          "pattern": "\"$HTMLSTR\" + ..."
                        },
                        {
                          "pattern": "f\"$HTMLSTR{...}...\""
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$HTML = \"$HTMLSTR\"\n...\n"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "$HTML % ..."
                        },
                        {
                          "pattern": "$HTML.format(...)"
                        },
                        {
                          "pattern": "$HTML + ..."
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "metavariable-pattern": {
                "metavariable": "$HTMLSTR",
                "language": "generic",
                "pattern": "<$TAG ..."
              }
            }
          ]
        }
      ]
    },
    {
      "id": "python.django.security.injection.reflected-data-httpresponse.reflected-data-httpresponse",
      "message": "Cross-site scripting (XSS) vulnerabilities in Django occur when user-controlled data is directly returned via HttpResponse without proper HTML escaping. Unlike Django's template system which automatically escapes output, direct HttpResponse usage provides no built-in protection against injection attacks. When browsers render this unescaped content containing malicious HTML or JavaScript, it executes with the privileges of the application's origin, potentially leading to session hijacking, credential theft, or unauthorized actions on behalf of victims.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://django-book.readthedocs.io/en/latest/chapter20.html#cross-site-scripting-xss"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "HttpResponse with user input can reflect XSS",
        "fix-suggestion": "Use Django's `render()` function with templates instead of direct `HttpResponse` objects whenever possible. If `HttpResponse` must be used, apply `django.utils.html.escape()` to user-controlled data and set the proper `Content-Type` header when returning user-controlled data."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "def $FUNC(...):\n  ...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "django.http.HttpResponse(..., $S.format(..., request.$W.get(...), ...), ...)"
            },
            {
              "pattern": "django.http.HttpResponse(..., $S % request.$W.get(...), ...)"
            },
            {
              "pattern": "django.http.HttpResponse(..., f\"...{request.$W.get(...)}...\", ...)"
            },
            {
              "pattern": "django.http.HttpResponse(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.http.HttpResponse(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $DATA\n...\ndjango.http.HttpResponse(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.http.HttpResponse(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\ndjango.http.HttpResponse(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.http.HttpResponse(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR % $DATA\n...\ndjango.http.HttpResponse(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.http.HttpResponse(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.http.HttpResponse(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.http.HttpResponse(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR + $DATA\n...\ndjango.http.HttpResponse(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.http.HttpResponse(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "return django.http.HttpResponse(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "django.http.HttpResponse(..., $S.format(..., request.$W(...), ...), ...)"
            },
            {
              "pattern": "django.http.HttpResponse(..., $S % request.$W(...), ...)"
            },
            {
              "pattern": "django.http.HttpResponse(..., f\"...{request.$W(...)}...\", ...)"
            },
            {
              "pattern": "django.http.HttpResponse(..., request.$W(...), ...)"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.http.HttpResponse(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $DATA\n...\ndjango.http.HttpResponse(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.http.HttpResponse(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\ndjango.http.HttpResponse(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.http.HttpResponse(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR % $DATA\n...\ndjango.http.HttpResponse(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.http.HttpResponse(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.http.HttpResponse(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.http.HttpResponse(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR + $DATA\n...\ndjango.http.HttpResponse(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.http.HttpResponse(..., request.$W(...), ...)"
            },
            {
              "pattern": "return django.http.HttpResponse(..., request.$W(...), ...)"
            },
            {
              "pattern": "django.http.HttpResponse(..., $S.format(..., request.$W[...], ...), ...)"
            },
            {
              "pattern": "django.http.HttpResponse(..., $S % request.$W[...], ...)"
            },
            {
              "pattern": "django.http.HttpResponse(..., f\"...{request.$W[...]}...\", ...)"
            },
            {
              "pattern": "django.http.HttpResponse(..., request.$W[...], ...)"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.http.HttpResponse(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $DATA\n...\ndjango.http.HttpResponse(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.http.HttpResponse(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\ndjango.http.HttpResponse(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.http.HttpResponse(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR % $DATA\n...\ndjango.http.HttpResponse(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.http.HttpResponse(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.http.HttpResponse(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.http.HttpResponse(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR + $DATA\n...\ndjango.http.HttpResponse(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.http.HttpResponse(..., request.$W[...], ...)"
            },
            {
              "pattern": "return django.http.HttpResponse(..., request.$W[...], ...)"
            },
            {
              "pattern": "django.http.HttpResponse(..., $S.format(..., request.$W, ...), ...)"
            },
            {
              "pattern": "django.http.HttpResponse(..., $S % request.$W, ...)"
            },
            {
              "pattern": "django.http.HttpResponse(..., f\"...{request.$W}...\", ...)"
            },
            {
              "pattern": "django.http.HttpResponse(..., request.$W, ...)"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.http.HttpResponse(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $DATA\n...\ndjango.http.HttpResponse(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.http.HttpResponse(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\ndjango.http.HttpResponse(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.http.HttpResponse(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR % $DATA\n...\ndjango.http.HttpResponse(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.http.HttpResponse(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$A = django.http.HttpResponse(..., request.$W, ...)"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR + $DATA\n...\n$A = django.http.HttpResponse(..., $INTERM, ...)\n"
            },
            {
              "pattern": "return django.http.HttpResponse(..., request.$W, ...)"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.http.HttpResponse(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.http.HttpResponse(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR + $DATA\n...\ndjango.http.HttpResponse(..., $INTERM, ...)\n"
            }
          ]
        }
      ]
    },
    {
      "id": "python.django.security.injection.reflected-data-httpresponsebadrequest.reflected-data-httpresponsebadrequest",
      "message": "Cross-site scripting (XSS) vulnerabilities in Django applications arise when HttpResponseBadRequest reflects user input without proper HTML escaping. Despite being an error response, if the browser renders this unescaped content containing malicious HTML or JavaScript, it will execute with the privileges of the application's origin. This allows attackers to perform session hijacking, credential theft, or unauthorized actions on behalf of victims even through error responses that include reflected request data.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://django-book.readthedocs.io/en/latest/chapter20.html#cross-site-scripting-xss"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "HttpResponseBadRequest with user data can expose XSS",
        "fix-suggestion": "Apply `django.utils.html.escape()` to any user-controlled data before including it in error responses. Use Django's template system with `render()` to create error responses instead of directly constructing `HttpResponseBadRequest` objects, and set the `Content-Type` header to `'text/plain'` for error messages including user input."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "def $FUNC(...):\n  ...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "django.http.HttpResponseBadRequest(..., $S.format(..., request.$W.get(...), ...), ...)"
            },
            {
              "pattern": "django.http.HttpResponseBadRequest(..., $S % request.$W.get(...), ...)"
            },
            {
              "pattern": "django.http.HttpResponseBadRequest(..., f\"...{request.$W.get(...)}...\", ...)"
            },
            {
              "pattern": "django.http.HttpResponseBadRequest(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.http.HttpResponseBadRequest(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $DATA\n...\ndjango.http.HttpResponseBadRequest(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.http.HttpResponseBadRequest(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\ndjango.http.HttpResponseBadRequest(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.http.HttpResponseBadRequest(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR % $DATA\n...\ndjango.http.HttpResponseBadRequest(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.http.HttpResponseBadRequest(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.http.HttpResponseBadRequest(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.http.HttpResponseBadRequest(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR + $DATA\n...\ndjango.http.HttpResponseBadRequest(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.http.HttpResponseBadRequest(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "return django.http.HttpResponseBadRequest(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "django.http.HttpResponseBadRequest(..., $S.format(..., request.$W(...), ...), ...)"
            },
            {
              "pattern": "django.http.HttpResponseBadRequest(..., $S % request.$W(...), ...)"
            },
            {
              "pattern": "django.http.HttpResponseBadRequest(..., f\"...{request.$W(...)}...\", ...)"
            },
            {
              "pattern": "django.http.HttpResponseBadRequest(..., request.$W(...), ...)"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.http.HttpResponseBadRequest(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $DATA\n...\ndjango.http.HttpResponseBadRequest(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.http.HttpResponseBadRequest(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\ndjango.http.HttpResponseBadRequest(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.http.HttpResponseBadRequest(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR % $DATA\n...\ndjango.http.HttpResponseBadRequest(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.http.HttpResponseBadRequest(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.http.HttpResponseBadRequest(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.http.HttpResponseBadRequest(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR + $DATA\n...\ndjango.http.HttpResponseBadRequest(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.http.HttpResponseBadRequest(..., request.$W(...), ...)"
            },
            {
              "pattern": "return django.http.HttpResponseBadRequest(..., request.$W(...), ...)"
            },
            {
              "pattern": "django.http.HttpResponseBadRequest(..., $S.format(..., request.$W[...], ...), ...)"
            },
            {
              "pattern": "django.http.HttpResponseBadRequest(..., $S % request.$W[...], ...)"
            },
            {
              "pattern": "django.http.HttpResponseBadRequest(..., f\"...{request.$W[...]}...\", ...)"
            },
            {
              "pattern": "django.http.HttpResponseBadRequest(..., request.$W[...], ...)"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.http.HttpResponseBadRequest(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $DATA\n...\ndjango.http.HttpResponseBadRequest(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.http.HttpResponseBadRequest(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\ndjango.http.HttpResponseBadRequest(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.http.HttpResponseBadRequest(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR % $DATA\n...\ndjango.http.HttpResponseBadRequest(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.http.HttpResponseBadRequest(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.http.HttpResponseBadRequest(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.http.HttpResponseBadRequest(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR + $DATA\n...\ndjango.http.HttpResponseBadRequest(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.http.HttpResponseBadRequest(..., request.$W[...], ...)"
            },
            {
              "pattern": "return django.http.HttpResponseBadRequest(..., request.$W[...], ...)"
            },
            {
              "pattern": "django.http.HttpResponseBadRequest(..., $S.format(..., request.$W, ...), ...)"
            },
            {
              "pattern": "django.http.HttpResponseBadRequest(..., $S % request.$W, ...)"
            },
            {
              "pattern": "django.http.HttpResponseBadRequest(..., f\"...{request.$W}...\", ...)"
            },
            {
              "pattern": "django.http.HttpResponseBadRequest(..., request.$W, ...)"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.http.HttpResponseBadRequest(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $DATA\n...\ndjango.http.HttpResponseBadRequest(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.http.HttpResponseBadRequest(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\ndjango.http.HttpResponseBadRequest(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.http.HttpResponseBadRequest(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR % $DATA\n...\ndjango.http.HttpResponseBadRequest(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.http.HttpResponseBadRequest(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.http.HttpResponseBadRequest(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.http.HttpResponseBadRequest(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR + $DATA\n...\ndjango.http.HttpResponseBadRequest(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.http.HttpResponseBadRequest(..., request.$W, ...)"
            },
            {
              "pattern": "return django.http.HttpResponseBadRequest(..., request.$W, ...)"
            }
          ]
        }
      ]
    },
    {
      "id": "python.django.security.injection.request-data-fileresponse.request-data-fileresponse",
      "message": "Path traversal vulnerabilities in Django occur when FileResponse uses filenames derived from unvalidated user input. Without proper sanitization, attackers can manipulate the filename using path traversal sequences (e.g., '../') to access files outside the intended directory. This can lead to unauthorized file disclosure, potentially exposing application code, configuration files, credentials, or other sensitive system files that should not be accessible to users.",
      "metadata": {
        "cwe": [
          "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
        ],
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "references": [
          "https://django-book.readthedocs.io/en/latest/chapter20.html#cross-site-scripting-xss"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "short-description": "FileResponse with unvalidated filename can cause path traversal",
        "fix-suggestion": "Never use user-supplied input directly in file paths; instead use identifiers that map to predetermined files. Validate user input against a strict allowlist of permitted files and use `os.path.basename()` to strip any directory components from user-supplied filenames."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "def $FUNC(...):\n  ...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "django.http.FileResponse(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.http.FileResponse(..., open($DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = open($DATA, ...)\n...\ndjango.http.FileResponse(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.http.FileResponse(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "return django.http.FileResponse(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "django.http.FileResponse(..., request.$W(...), ...)"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.http.FileResponse(..., open($DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = open($DATA, ...)\n...\ndjango.http.FileResponse(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.http.FileResponse(..., request.$W(...), ...)"
            },
            {
              "pattern": "return django.http.FileResponse(..., request.$W(...), ...)"
            },
            {
              "pattern": "django.http.FileResponse(..., request.$W[...], ...)"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.http.FileResponse(..., open($DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = open($DATA, ...)\n...\ndjango.http.FileResponse(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.http.FileResponse(..., request.$W[...], ...)"
            },
            {
              "pattern": "return django.http.FileResponse(..., request.$W[...], ...)"
            },
            {
              "pattern": "django.http.FileResponse(..., request.$W, ...)"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.http.FileResponse(..., open($DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = open($DATA, ...)\n...\ndjango.http.FileResponse(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.http.FileResponse(..., request.$W, ...)"
            },
            {
              "pattern": "return django.http.FileResponse(..., request.$W, ...)"
            }
          ]
        }
      ]
    },
    {
      "id": "python.django.security.injection.request-data-write.request-data-write",
      "message": "User-controlled request data is being passed directly to file write operations. This allows attackers to manipulate file content, potentially exhausting disk space or compromising system integrity. Always sanitize and validate user input before writing to files.",
      "metadata": {
        "cwe": [
          "CWE-93: Improper Neutralization of CRLF Sequences ('CRLF Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "Unsanitized user input in file write operations",
        "fix-suggestion": "Implement strict validation for any user input before using it in file operations. Use whitelisting to only allow safe characters, sanitize the data with appropriate encoding, and enforce size limits on input to prevent resource exhaustion attacks."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "$F.write(..., request.$W.get(...), ...)"
        },
        {
          "pattern": "$DATA = request.$W.get(...)\n...\n$F.write(..., $DATA, ...)\n"
        },
        {
          "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $DATA\n...\n$F.write(..., $INTERM, ...)\n"
        },
        {
          "pattern": "$DATA = request.$W.get(...)\n...\n$F.write(..., $B.$C(..., $DATA, ...), ...)\n"
        },
        {
          "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $B.$C(..., $DATA, ...)\n...\n$F.write(..., $INTERM, ...)\n"
        },
        {
          "pattern": "$DATA = request.$W.get(...)\n...\n$F.write(..., $STR % $DATA, ...)\n"
        },
        {
          "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR % $DATA\n...\n$F.write(..., $INTERM, ...)\n"
        },
        {
          "pattern": "$DATA = request.$W.get(...)\n...\n$F.write(..., f\"...{$DATA}...\", ...)\n"
        },
        {
          "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\n$F.write(..., $INTERM, ...)\n"
        },
        {
          "pattern": "$A = $F.write(..., request.$W.get(...), ...)"
        },
        {
          "pattern": "return $F.write(..., request.$W.get(...), ...)"
        },
        {
          "pattern": "$F.write(..., request.$W(...), ...)"
        },
        {
          "pattern": "$DATA = request.$W(...)\n...\n$F.write(..., $DATA, ...)\n"
        },
        {
          "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $DATA\n...\n$F.write(..., $INTERM, ...)\n"
        },
        {
          "pattern": "$DATA = request.$W(...)\n...\n$F.write(..., $B.$C(..., $DATA, ...), ...)\n"
        },
        {
          "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $B.$C(..., $DATA, ...)\n...\n$F.write(..., $INTERM, ...)\n"
        },
        {
          "pattern": "$DATA = request.$W(...)\n...\n$F.write(..., $STR % $DATA, ...)\n"
        },
        {
          "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR % $DATA\n...\n$F.write(..., $INTERM, ...)\n"
        },
        {
          "pattern": "$DATA = request.$W(...)\n...\n$F.write(..., f\"...{$DATA}...\", ...)\n"
        },
        {
          "pattern": "$DATA = request.$W(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\n$F.write(..., $INTERM, ...)\n"
        },
        {
          "pattern": "$A = $F.write(..., request.$W(...), ...)"
        },
        {
          "pattern": "return $F.write(..., request.$W(...), ...)"
        },
        {
          "pattern": "$F.write(..., request.$W[...], ...)"
        },
        {
          "pattern": "$DATA = request.$W[...]\n...\n$F.write(..., $DATA, ...)\n"
        },
        {
          "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $DATA\n...\n$F.write(..., $INTERM, ...)\n"
        },
        {
          "pattern": "$DATA = request.$W[...]\n...\n$F.write(..., $B.$C(..., $DATA, ...), ...)\n"
        },
        {
          "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $B.$C(..., $DATA, ...)\n...\n$F.write(..., $INTERM, ...)\n"
        },
        {
          "pattern": "$DATA = request.$W[...]\n...\n$F.write(..., $STR % $DATA, ...)\n"
        },
        {
          "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR % $DATA\n...\n$F.write(..., $INTERM, ...)\n"
        },
        {
          "pattern": "$DATA = request.$W[...]\n...\n$F.write(..., f\"...{$DATA}...\", ...)\n"
        },
        {
          "pattern": "$DATA = request.$W[...]\n...\n$INTERM = f\"...{$DATA}...\"\n...\n$F.write(..., $INTERM, ...)\n"
        },
        {
          "pattern": "$A = $F.write(..., request.$W[...], ...)"
        },
        {
          "pattern": "return $F.write(..., request.$W[...], ...)"
        },
        {
          "pattern": "$F.write(..., request.$W, ...)"
        },
        {
          "pattern": "$DATA = request.$W\n...\n$F.write(..., $DATA, ...)\n"
        },
        {
          "pattern": "$DATA = request.$W\n...\n$INTERM = $DATA\n...\n$F.write(..., $INTERM, ...)\n"
        },
        {
          "pattern": "$DATA = request.$W\n...\n$F.write(..., $B.$C(..., $DATA, ...), ...)\n"
        },
        {
          "pattern": "$DATA = request.$W\n...\n$INTERM = $B.$C(..., $DATA, ...)\n...\n$F.write(..., $INTERM, ...)\n"
        },
        {
          "pattern": "$DATA = request.$W\n...\n$F.write(..., $STR % $DATA, ...)\n"
        },
        {
          "pattern": "$DATA = request.$W\n...\n$INTERM = $STR % $DATA\n...\n$F.write(..., $INTERM, ...)\n"
        },
        {
          "pattern": "$DATA = request.$W\n...\n$F.write(..., f\"...{$DATA}...\", ...)\n"
        },
        {
          "pattern": "$DATA = request.$W\n...\n$INTERM = f\"...{$DATA}...\"\n...\n$F.write(..., $INTERM, ...)\n"
        },
        {
          "pattern": "$A = $F.write(..., request.$W, ...)"
        },
        {
          "pattern": "return $F.write(..., request.$W, ...)"
        }
      ]
    },
    {
      "id": "python.django.security.injection.tainted-sql-string.tainted-sql-string",
      "message": "User input is being used to construct SQL queries through string concatenation. This creates SQL injection vulnerabilities allowing attackers to extract or modify database contents. Use Django's ORM or parameterized queries to ensure proper escaping of user input.",
      "metadata": {
        "cwe": [
          "CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes"
        ],
        "owasp": [
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.0/topics/security/#sql-injection-protection"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "subcategory": [
          "audit"
        ],
        "impact": "LOW",
        "likelihood": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mass Assignment"
        ],
        "short-description": "SQL injection via string concatenation",
        "fix-suggestion": "Replace string-concatenated SQL with Django's ORM methods or use parameterized queries with `cursor.execute('SELECT * FROM table WHERE column = %s', [user_input])`. Never embed user input directly into SQL strings with formatting or concatenation."
      },
      "severity": "ERROR",
      "languages": [
        "python"
      ],
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "request.$ANYTHING"
            },
            {
              "pattern-not": "request.build_absolute_uri"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "\"$SQLSTR\" + ...\n"
                },
                {
                  "pattern": "\"$SQLSTR\" % ...\n"
                },
                {
                  "pattern": "\"$SQLSTR\".format(...)\n"
                },
                {
                  "pattern": "f\"$SQLSTR{...}...\"\n"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$SQLSTR",
                "regex": "\\s*(?i)(select|delete|insert|create|update|alter|drop)\\b.*"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "python.django.security.injection.tainted-url-host.tainted-url-host",
      "languages": [
        "python"
      ],
      "message": "Server-Side Request Forgery (SSRF) vulnerabilities in Django applications arise when user-controlled input determines the host portion of URLs used in server-initiated HTTP requests. Without proper validation, attackers can manipulate these host values to direct requests to unauthorized internal services or external malicious servers. This can lead to internal network scanning, accessing restricted services, data exfiltration, or exploitation of trust relationships between the server and other systems.",
      "metadata": {
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "impact": "MEDIUM",
        "likelihood": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "User-controlled host in URL leads to SSRF",
        "fix-suggestion": "Implement a strict allowlist of permitted domains and IP ranges for outgoing requests. Validate all user-supplied URLs using Django's `URLValidator` before processing them, and resolve IP addresses to verify they don't point to internal networks (`127.0.0.0/8`, `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`, `fc00::/7`)."
      },
      "mode": "taint",
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern": "\"$URLSTR\" % ..."
                    },
                    {
                      "metavariable-pattern": {
                        "metavariable": "$URLSTR",
                        "language": "generic",
                        "patterns": [
                          {
                            "pattern-either": [
                              {
                                "pattern": "$SCHEME://%s"
                              },
                              {
                                "pattern": "$SCHEME://%r"
                              }
                            ]
                          }
                        ]
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "\"$URLSTR\".format(...)"
                    },
                    {
                      "metavariable-pattern": {
                        "metavariable": "$URLSTR",
                        "language": "generic",
                        "pattern": "$SCHEME:// { ... }"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "\"$URLSTR\" + ..."
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$URLSTR",
                        "regex": ".*://$"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "f\"$URLSTR{...}...\""
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$URLSTR",
                        "regex": ".*://$"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$URL = \"$URLSTR\"\n...\n"
                    },
                    {
                      "pattern": "$URL += ..."
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$URLSTR",
                        "regex": ".*://$"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "request.$ANYTHING"
            },
            {
              "pattern-not": "request.build_absolute_uri"
            }
          ]
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.django.security.injection.code.globals-misuse-code-execution.globals-misuse-code-execution",
      "message": "Request data is being used as an index to globals(). This extremely dangerous pattern allows attackers to execute arbitrary code on your system by accessing any available function. Refactor code to avoid using globals() with dynamic inputs entirely.",
      "metadata": {
        "cwe": [
          "CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://github.com/mpirnat/lets-be-bad-guys/blob/d92768fb3ade32956abd53bd6bb06e19d634a084/badguys/vulnerable/views.py#L181-L186"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Remote code execution via globals indexing",
        "fix-suggestion": "Completely refactor the code to avoid using `globals()[user_input]`. Use a dictionary with explicitly defined allowed values instead, and implement strict input validation to map only trusted input strings to predefined functions."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "def $FUNC(...):\n  ...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = globals().get($DATA, ...)\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = globals().get(\"...\" % $DATA, ...)\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = globals().get(f\"...{$DATA}...\", ...)\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = globals().get(\"...\".format(..., $DATA, ...), ...)\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = globals()[$DATA]\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = globals()[\"...\" % $DATA]\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = globals()[f\"...{$DATA}...\"]\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = globals()[\"...\".format(..., $DATA, ...)]\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = globals().get($DATA, ...)\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = globals().get(\"...\" % $DATA, ...)\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = globals().get(f\"...{$DATA}...\", ...)\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = globals().get(\"...\".format(..., $DATA, ...), ...)\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = globals()[$DATA]\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = globals()[\"...\" % $DATA]\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = globals()[f\"...{$DATA}...\"]\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = globals()[\"...\".format(..., $DATA, ...)]\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = globals().get($DATA, ...)\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = globals().get(\"...\" % $DATA, ...)\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = globals().get(f\"...{$DATA}...\", ...)\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = globals().get(\"...\".format(..., $DATA, ...), ...)\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = globals()[$DATA]\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = globals()[\"...\" % $DATA]\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = globals()[f\"...{$DATA}...\"]\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = globals()[\"...\".format(..., $DATA, ...)]\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = globals().get($DATA, ...)\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = globals().get(\"...\" % $DATA, ...)\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = globals().get(f\"...{$DATA}...\", ...)\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = globals().get(\"...\".format(..., $DATA, ...), ...)\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = globals()[$DATA]\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = globals()[\"...\" % $DATA]\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = globals()[f\"...{$DATA}...\"]\n...\n$INTERM(...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = globals()[\"...\".format(..., $DATA, ...)]\n...\n$INTERM(...)\n"
            }
          ]
        }
      ]
    },
    {
      "id": "python.django.security.injection.code.user-eval-format-string.user-eval-format-string",
      "message": "User data is being used in eval() statements via format strings. This creates a critical remote code execution vulnerability allowing attackers to run arbitrary Python code on your server. Never use eval() with any form of user input.",
      "metadata": {
        "cwe": [
          "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Remote code execution via eval with user data",
        "fix-suggestion": "Completely remove the `eval()` call and replace it with safer alternatives. Use direct data structures, parsing libraries, or function dispatch tables instead of dynamic code evaluation to achieve the required functionality without security risks."
      },
      "patterns": [
        {
          "pattern-inside": "def $F(...):\n  ...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "eval(..., $STR % request.$W.get(...), ...)"
            },
            {
              "pattern": "$V = request.$W.get(...)\n...\neval(..., $STR % $V, ...)\n"
            },
            {
              "pattern": "$V = request.$W.get(...)\n...\n$S = $STR % $V\n...\neval(..., $S, ...)\n"
            },
            {
              "pattern": "eval(..., \"...\" % request.$W(...), ...)"
            },
            {
              "pattern": "$V = request.$W(...)\n...\neval(..., $STR % $V, ...)\n"
            },
            {
              "pattern": "$V = request.$W(...)\n...\n$S = $STR % $V\n...\neval(..., $S, ...)\n"
            },
            {
              "pattern": "eval(..., $STR % request.$W[...], ...)"
            },
            {
              "pattern": "$V = request.$W[...]\n...\neval(..., $STR % $V, ...)\n"
            },
            {
              "pattern": "$V = request.$W[...]\n...\n$S = $STR % $V\n...\neval(..., $S, ...)\n"
            },
            {
              "pattern": "eval(..., $STR.format(..., request.$W.get(...), ...), ...)"
            },
            {
              "pattern": "$V = request.$W.get(...)\n...\neval(..., $STR.format(..., $V, ...), ...)\n"
            },
            {
              "pattern": "$V = request.$W.get(...)\n...\n$S = $STR.format(..., $V, ...)\n...\neval(..., $S, ...)\n"
            },
            {
              "pattern": "eval(..., $STR.format(..., request.$W(...), ...), ...)"
            },
            {
              "pattern": "$V = request.$W(...)\n...\neval(..., $STR.format(..., $V, ...), ...)\n"
            },
            {
              "pattern": "$V = request.$W(...)\n...\n$S = $STR.format(..., $V, ...)\n...\neval(..., $S, ...)\n"
            },
            {
              "pattern": "eval(..., $STR.format(..., request.$W[...], ...), ...)"
            },
            {
              "pattern": "$V = request.$W[...]\n...\neval(..., $STR.format(..., $V, ...), ...)\n"
            },
            {
              "pattern": "$V = request.$W[...]\n...\n$S = $STR.format(..., $V, ...)\n...\neval(..., $S, ...)\n"
            },
            {
              "pattern": "$V = request.$W.get(...)\n...\neval(..., f\"...{$V}...\", ...)\n"
            },
            {
              "pattern": "$V = request.$W.get(...)\n...\n$S = f\"...{$V}...\"\n...\neval(..., $S, ...)\n"
            },
            {
              "pattern": "$V = request.$W(...)\n...\neval(..., f\"...{$V}...\", ...)\n"
            },
            {
              "pattern": "$V = request.$W(...)\n...\n$S = f\"...{$V}...\"\n...\neval(..., $S, ...)\n"
            },
            {
              "pattern": "$V = request.$W[...]\n...\neval(..., f\"...{$V}...\", ...)\n"
            },
            {
              "pattern": "$V = request.$W[...]\n...\n$S = f\"...{$V}...\"\n...\neval(..., $S, ...)\n"
            }
          ]
        }
      ],
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.django.security.injection.code.user-eval.user-eval",
      "message": "User data is being passed to eval() function. This creates a critical remote code execution vulnerability as eval() executes any Python code it receives. Refactor your code to eliminate the use of eval() entirely and use safer alternatives.",
      "metadata": {
        "cwe": [
          "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html",
          "https://owasp.org/www-community/attacks/Code_Injection"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Direct eval of user input enabling code execution",
        "fix-suggestion": "Remove `eval(user_input)` entirely and replace with safer methods like direct data structures, parsing libraries, or dispatch tables. If you need to evaluate expressions, use restricted environments like `ast.literal_eval()` that only handle basic data types."
      },
      "patterns": [
        {
          "pattern-inside": "def $F(...):\n  ...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "eval(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "$V = request.$W.get(...)\n...\neval(..., $V, ...)\n"
            },
            {
              "pattern": "eval(..., request.$W(...), ...)"
            },
            {
              "pattern": "$V = request.$W(...)\n...\neval(..., $V, ...)\n"
            },
            {
              "pattern": "eval(..., request.$W[...], ...)"
            },
            {
              "pattern": "$V = request.$W[...]\n...\neval(..., $V, ...)\n"
            }
          ]
        }
      ],
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.django.security.injection.code.user-exec-format-string.user-exec-format-string",
      "message": "User data is being used in exec() statements via format strings. This creates a critical remote code execution vulnerability allowing attackers to run arbitrary Python code on your server. Never use exec() with any form of user input.",
      "metadata": {
        "cwe": [
          "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "references": [
          "https://owasp.org/www-community/attacks/Code_Injection"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Remote code execution via exec with user data",
        "fix-suggestion": "Completely remove the `exec()` call and replace it with safer alternatives. Implement explicit function calls, configuration systems, or design patterns that don't require dynamic code execution to achieve the same result without security risks."
      },
      "patterns": [
        {
          "pattern-inside": "def $F(...):\n  ...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "exec(..., $STR % request.$W.get(...), ...)"
            },
            {
              "pattern": "$V = request.$W.get(...)\n...\nexec(..., $STR % $V, ...)\n"
            },
            {
              "pattern": "$V = request.$W.get(...)\n...\n$S = $STR % $V\n...\nexec(..., $S, ...)\n"
            },
            {
              "pattern": "exec(..., \"...\" % request.$W(...), ...)"
            },
            {
              "pattern": "$V = request.$W(...)\n...\nexec(..., $STR % $V, ...)\n"
            },
            {
              "pattern": "$V = request.$W(...)\n...\n$S = $STR % $V\n...\nexec(..., $S, ...)\n"
            },
            {
              "pattern": "exec(..., $STR % request.$W[...], ...)"
            },
            {
              "pattern": "$V = request.$W[...]\n...\nexec(..., $STR % $V, ...)\n"
            },
            {
              "pattern": "$V = request.$W[...]\n...\n$S = $STR % $V\n...\nexec(..., $S, ...)\n"
            },
            {
              "pattern": "exec(..., $STR.format(..., request.$W.get(...), ...), ...)"
            },
            {
              "pattern": "$V = request.$W.get(...)\n...\nexec(..., $STR.format(..., $V, ...), ...)\n"
            },
            {
              "pattern": "$V = request.$W.get(...)\n...\n$S = $STR.format(..., $V, ...)\n...\nexec(..., $S, ...)\n"
            },
            {
              "pattern": "exec(..., $STR.format(..., request.$W(...), ...), ...)"
            },
            {
              "pattern": "$V = request.$W(...)\n...\nexec(..., $STR.format(..., $V, ...), ...)\n"
            },
            {
              "pattern": "$V = request.$W(...)\n...\n$S = $STR.format(..., $V, ...)\n...\nexec(..., $S, ...)\n"
            },
            {
              "pattern": "exec(..., $STR.format(..., request.$W[...], ...), ...)"
            },
            {
              "pattern": "$V = request.$W[...]\n...\nexec(..., $STR.format(..., $V, ...), ...)\n"
            },
            {
              "pattern": "$V = request.$W[...]\n...\n$S = $STR.format(..., $V, ...)\n...\nexec(..., $S, ...)\n"
            },
            {
              "pattern": "$V = request.$W.get(...)\n...\nexec(..., f\"...{$V}...\", ...)\n"
            },
            {
              "pattern": "$V = request.$W.get(...)\n...\n$S = f\"...{$V}...\"\n...\nexec(..., $S, ...)\n"
            },
            {
              "pattern": "$V = request.$W(...)\n...\nexec(..., f\"...{$V}...\", ...)\n"
            },
            {
              "pattern": "$V = request.$W(...)\n...\n$S = f\"...{$V}...\"\n...\nexec(..., $S, ...)\n"
            },
            {
              "pattern": "$V = request.$W[...]\n...\nexec(..., f\"...{$V}...\", ...)\n"
            },
            {
              "pattern": "$V = request.$W[...]\n...\n$S = f\"...{$V}...\"\n...\nexec(..., $S, ...)\n"
            },
            {
              "pattern": "exec(..., base64.decodestring($S.format(..., request.$W.get(...), ...), ...), ...)"
            },
            {
              "pattern": "exec(..., base64.decodestring($S % request.$W.get(...), ...), ...)"
            },
            {
              "pattern": "exec(..., base64.decodestring(f\"...{request.$W.get(...)}...\", ...), ...)"
            },
            {
              "pattern": "exec(..., base64.decodestring(request.$W.get(...), ...), ...)"
            },
            {
              "pattern": "exec(..., base64.decodestring(bytes($S.format(..., request.$W.get(...), ...), ...), ...), ...)"
            },
            {
              "pattern": "exec(..., base64.decodestring(bytes($S % request.$W.get(...), ...), ...), ...)"
            },
            {
              "pattern": "exec(..., base64.decodestring(bytes(f\"...{request.$W.get(...)}...\", ...), ...), ...)"
            },
            {
              "pattern": "exec(..., base64.decodestring(bytes(request.$W.get(...), ...), ...), ...)"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\nexec(..., base64.decodestring($DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = base64.decodestring($DATA, ...)\n...\nexec(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\nexec(..., base64.decodestring(bytes($DATA, ...), ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = base64.decodestring(bytes($DATA, ...), ...)\n...\nexec(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\nexec(..., base64.decodestring($DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = base64.decodestring($DATA, ...)\n...\nexec(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\nexec(..., base64.decodestring(bytes($DATA, ...), ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = base64.decodestring(bytes($DATA, ...), ...)\n...\nexec(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\nexec(..., base64.decodestring($DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = base64.decodestring($DATA, ...)\n...\nexec(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\nexec(..., base64.decodestring(bytes($DATA, ...), ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = base64.decodestring(bytes($DATA, ...), ...)\n...\nexec(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\nexec(..., base64.decodestring($DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = base64.decodestring($DATA, ...)\n...\nexec(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\nexec(..., base64.decodestring(bytes($DATA, ...), ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = base64.decodestring(bytes($DATA, ...), ...)\n...\nexec(..., $INTERM, ...)\n"
            }
          ]
        }
      ],
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.django.security.injection.code.user-exec.user-exec",
      "message": "User data is being passed to exec() function. This creates a critical remote code execution vulnerability as exec() executes any Python code it receives. Refactor your code to eliminate the use of exec() entirely and use safer alternatives.",
      "metadata": {
        "cwe": [
          "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "references": [
          "https://owasp.org/www-community/attacks/Code_Injection"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Direct exec of user input enabling code execution",
        "fix-suggestion": "Remove `exec(user_input)` entirely and replace with proper function dispatch or safer methods. Implement explicit control flow and function calls based on validated user input without using dynamic code execution."
      },
      "patterns": [
        {
          "pattern-inside": "def $F(...):\n  ...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "exec(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "$V = request.$W.get(...)\n...\nexec(..., $V, ...)\n"
            },
            {
              "pattern": "exec(..., request.$W(...), ...)"
            },
            {
              "pattern": "$V = request.$W(...)\n...\nexec(..., $V, ...)\n"
            },
            {
              "pattern": "exec(..., request.$W[...], ...)"
            },
            {
              "pattern": "$V = request.$W[...]\n...\nexec(..., $V, ...)\n"
            },
            {
              "pattern": "loop = asyncio.get_running_loop()\n...\nawait loop.run_in_executor(None, exec, request.$W[...])\n"
            },
            {
              "pattern": "$V = request.$W[...]\n...\nloop = asyncio.get_running_loop()\n...\nawait loop.run_in_executor(None, exec, $V)\n"
            },
            {
              "pattern": "loop = asyncio.get_running_loop()\n...\nawait loop.run_in_executor(None, exec, request.$W.get(...))\n"
            },
            {
              "pattern": "$V = request.$W.get(...)\n...\nloop = asyncio.get_running_loop()\n...\nawait loop.run_in_executor(None, exec, $V)\n"
            }
          ]
        }
      ],
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.django.security.injection.command.command-injection-os-system.command-injection-os-system",
      "message": "Command injection vulnerabilities in Django applications occur when os.system executes commands containing unsanitized user input. Since os.system runs commands through a shell, special characters in the input can be interpreted as command separators or modifiers, allowing execution of arbitrary commands. This can lead to unauthorized command execution on the server with the privileges of the web application process, potentially resulting in data theft, service disruption, or complete system compromise.",
      "metadata": {
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/www-community/attacks/Command_Injection"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Untrusted input in os.system call can run malicious commands",
        "fix-suggestion": "Replace `os.system()` calls with `subprocess.run([cmd, arg1, arg2])` using separate argument lists. Never pass unsanitized user input to command execution functions. This prevents command injection in system calls."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "patterns": [
        {
          "pattern-inside": "def $FUNC(...):\n  ...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "os.system(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "os.system(..., $S.format(..., request.$W.get(...), ...), ...)"
            },
            {
              "pattern": "os.system(..., $S % request.$W.get(...), ...)"
            },
            {
              "pattern": "os.system(..., f\"...{request.$W.get(...)}...\", ...)"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\nos.system(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $DATA\n...\nos.system(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\nos.system(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\nos.system(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\nos.system(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR % $DATA\n...\nos.system(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\nos.system(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\nos.system(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\nos.system(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR + $DATA\n...\nos.system(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = os.system(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "$A = os.system(..., $S.format(..., request.$W.get(...), ...), ...)"
            },
            {
              "pattern": "$A = os.system(..., $S % request.$W.get(...), ...)"
            },
            {
              "pattern": "$A = os.system(..., f\"...{request.$W.get(...)}...\", ...)"
            },
            {
              "pattern": "return os.system(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "return os.system(..., $S.format(..., request.$W.get(...), ...), ...)"
            },
            {
              "pattern": "return os.system(..., $S % request.$W.get(...), ...)"
            },
            {
              "pattern": "return os.system(..., f\"...{request.$W.get(...)}...\", ...)"
            },
            {
              "pattern": "os.system(..., request.$W(...), ...)"
            },
            {
              "pattern": "os.system(..., $S.format(..., request.$W(...), ...), ...)"
            },
            {
              "pattern": "os.system(..., $S % request.$W(...), ...)"
            },
            {
              "pattern": "os.system(..., f\"...{request.$W(...)}...\", ...)"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\nos.system(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $DATA\n...\nos.system(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\nos.system(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\nos.system(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\nos.system(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR % $DATA\n...\nos.system(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\nos.system(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\nos.system(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\nos.system(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR + $DATA\n...\nos.system(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = os.system(..., request.$W(...), ...)"
            },
            {
              "pattern": "$A = os.system(..., $S.format(..., request.$W(...), ...), ...)"
            },
            {
              "pattern": "$A = os.system(..., $S % request.$W(...), ...)"
            },
            {
              "pattern": "$A = os.system(..., f\"...{request.$W(...)}...\", ...)"
            },
            {
              "pattern": "return os.system(..., request.$W(...), ...)"
            },
            {
              "pattern": "return os.system(..., $S.format(..., request.$W(...), ...), ...)"
            },
            {
              "pattern": "return os.system(..., $S % request.$W(...), ...)"
            },
            {
              "pattern": "return os.system(..., f\"...{request.$W(...)}...\", ...)"
            },
            {
              "pattern": "os.system(..., request.$W[...], ...)"
            },
            {
              "pattern": "os.system(..., $S.format(..., request.$W[...], ...), ...)"
            },
            {
              "pattern": "os.system(..., $S % request.$W[...], ...)"
            },
            {
              "pattern": "os.system(..., f\"...{request.$W[...]}...\", ...)"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\nos.system(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $DATA\n...\nos.system(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\nos.system(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\nos.system(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\nos.system(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR % $DATA\n...\nos.system(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\nos.system(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = f\"...{$DATA}...\"\n...\nos.system(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\nos.system(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR + $DATA\n...\nos.system(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = os.system(..., request.$W[...], ...)"
            },
            {
              "pattern": "$A = os.system(..., $S.format(..., request.$W[...], ...), ...)"
            },
            {
              "pattern": "$A = os.system(..., $S % request.$W[...], ...)"
            },
            {
              "pattern": "$A = os.system(..., f\"...{request.$W[...]}...\", ...)"
            },
            {
              "pattern": "return os.system(..., request.$W[...], ...)"
            },
            {
              "pattern": "return os.system(..., $S.format(..., request.$W[...], ...), ...)"
            },
            {
              "pattern": "return os.system(..., $S % request.$W[...], ...)"
            },
            {
              "pattern": "return os.system(..., f\"...{request.$W[...]}...\", ...)"
            },
            {
              "pattern": "os.system(..., request.$W, ...)"
            },
            {
              "pattern": "os.system(..., $S.format(..., request.$W, ...), ...)"
            },
            {
              "pattern": "os.system(..., $S % request.$W, ...)"
            },
            {
              "pattern": "os.system(..., f\"...{request.$W}...\", ...)"
            },
            {
              "pattern": "$DATA = request.$W\n...\nos.system(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $DATA\n...\nos.system(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\nos.system(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\nos.system(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\nos.system(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR % $DATA\n...\nos.system(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\nos.system(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = f\"...{$DATA}...\"\n...\nos.system(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\nos.system(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR + $DATA\n...\nos.system(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = os.system(..., request.$W, ...)"
            },
            {
              "pattern": "$A = os.system(..., $S.format(..., request.$W, ...), ...)"
            },
            {
              "pattern": "$A = os.system(..., $S % request.$W, ...)"
            },
            {
              "pattern": "$A = os.system(..., f\"...{request.$W}...\", ...)"
            },
            {
              "pattern": "return os.system(..., request.$W, ...)"
            },
            {
              "pattern": "return os.system(..., $S.format(..., request.$W, ...), ...)"
            },
            {
              "pattern": "return os.system(..., $S % request.$W, ...)"
            },
            {
              "pattern": "return os.system(..., f\"...{request.$W}...\", ...)"
            }
          ]
        }
      ]
    },
    {
      "id": "python.django.security.injection.command.subprocess-injection.subprocess-injection",
      "languages": [
        "python"
      ],
      "mode": "taint",
      "options": {
        "symbolic_propagation": true
      },
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-inside": "def $FUNC(..., $REQUEST, ...):\n  ...\n"
            },
            {
              "focus-metavariable": "$REQUEST"
            },
            {
              "metavariable-pattern": {
                "metavariable": "$REQUEST",
                "patterns": [
                  {
                    "pattern": "request"
                  },
                  {
                    "pattern-not-inside": "request.build_absolute_uri"
                  }
                ]
              }
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern": "subprocess.$FUNC(...)"
                    },
                    {
                      "pattern-not": "subprocess.$FUNC(\"...\", ...)"
                    },
                    {
                      "pattern-not": "subprocess.$FUNC([\"...\", ...], ...)"
                    },
                    {
                      "pattern-not-inside": "$CMD = [\"...\", ...]\n...\nsubprocess.$FUNC($CMD, ...)\n"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "subprocess.$FUNC([\"$SHELL\", \"-c\", ...], ...)"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$SHELL",
                        "regex": "^(sh|bash|ksh|csh|tcsh|zsh)$"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "subprocess.$FUNC([\"$INTERPRETER\", ...], ...)"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$INTERPRETER",
                        "regex": "^(python|python\\d)$"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern": "$DICT[$KEY]"
            },
            {
              "focus-metavariable": "$KEY"
            }
          ]
        }
      ],
      "severity": "ERROR",
      "message": "Command injection in Django applications occurs when subprocess functions execute commands containing unsanitized user input, especially with shell=True. The shell interpreter processes special characters as command separators or modifiers, allowing attackers to inject additional commands. This vulnerability can lead to unauthorized command execution on the server with the privileges of the web application process, potentially resulting in data theft, service disruption, or complete system compromise.",
      "metadata": {
        "category": "security",
        "technology": [
          "flask"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "references": [
          "https://semgrep.dev/docs/cheat-sheets/python-command-injection/"
        ],
        "confidence": "HIGH",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "subprocess calls with user data risk command injection",
        "fix-suggestion": "Avoid using `shell=True` in subprocess functions and never directly incorporate user input into command strings. Pass command arguments as a list to `subprocess.run(['program', 'arg1', 'arg2'])` rather than a single string, and if user input must be included, implement strict input validation using allowlists with specific patterns."
      }
    },
    {
      "id": "python.django.security.injection.email.xss-html-email-body.xss-html-email-body",
      "message": "User-supplied data is included in HTML emails without proper sanitization. This enables cross-site scripting attacks through email clients that render HTML. Sanitize user input before including it in HTML emails to prevent attackers from injecting malicious scripts.",
      "metadata": {
        "cwe": [
          "CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://www.damonkohler.com/2008/12/email-injection.html"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "XSS vulnerability in HTML email content",
        "fix-suggestion": "Sanitize user input before including it in HTML emails using `django.utils.html.escape()` or a library like `bleach`. Consider sending plain text emails instead, or use Django's templating system with autoescaping enabled for email content."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "def $FUNC(...):\n  ...\n  $EMAIL.content_subtype = \"html\"\n  ...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "django.core.mail.EmailMessage($SUBJ, request.$W.get(...), ...)"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.core.mail.EmailMessage($SUBJ, $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $DATA\n...\ndjango.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $B.$C(..., $DATA, ...)\n...\ndjango.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR % $DATA\n...\ndjango.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.core.mail.EmailMessage($SUBJ, f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.core.mail.EmailMessage($SUBJ, request.$W.get(...), ...)"
            },
            {
              "pattern": "return django.core.mail.EmailMessage($SUBJ, request.$W.get(...), ...)"
            },
            {
              "pattern": "django.core.mail.EmailMessage($SUBJ, request.$W(...), ...)"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.core.mail.EmailMessage($SUBJ, $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $DATA\n...\ndjango.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $B.$C(..., $DATA, ...)\n...\ndjango.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR % $DATA\n...\ndjango.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.core.mail.EmailMessage($SUBJ, f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.core.mail.EmailMessage($SUBJ, request.$W(...), ...)"
            },
            {
              "pattern": "return django.core.mail.EmailMessage($SUBJ, request.$W(...), ...)"
            },
            {
              "pattern": "django.core.mail.EmailMessage($SUBJ, request.$W[...], ...)"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.core.mail.EmailMessage($SUBJ, $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $DATA\n...\ndjango.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $B.$C(..., $DATA, ...)\n...\ndjango.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR % $DATA\n...\ndjango.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.core.mail.EmailMessage($SUBJ, f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.core.mail.EmailMessage($SUBJ, request.$W[...], ...)"
            },
            {
              "pattern": "return django.core.mail.EmailMessage($SUBJ, request.$W[...], ...)"
            },
            {
              "pattern": "django.core.mail.EmailMessage($SUBJ, request.$W, ...)"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.core.mail.EmailMessage($SUBJ, $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $DATA\n...\ndjango.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.core.mail.EmailMessage($SUBJ, $B.$C(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $B.$C(..., $DATA, ...)\n...\ndjango.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.core.mail.EmailMessage($SUBJ, $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR % $DATA\n...\ndjango.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.core.mail.EmailMessage($SUBJ, f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.core.mail.EmailMessage($SUBJ, $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.core.mail.EmailMessage($SUBJ, request.$W, ...)"
            },
            {
              "pattern": "return django.core.mail.EmailMessage($SUBJ, request.$W, ...)"
            }
          ]
        }
      ]
    },
    {
      "id": "python.django.security.injection.email.xss-send-mail-html-message.xss-send-mail-html-message",
      "message": "User input is included in the html_message parameter of send_mail() without proper sanitization. This creates cross-site scripting vulnerabilities in email clients that render HTML. Always sanitize user input before including it in HTML email content.",
      "metadata": {
        "cwe": [
          "CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://www.damonkohler.com/2008/12/email-injection.html"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "XSS in Django send_mail HTML content",
        "fix-suggestion": "Sanitize user input with `django.utils.html.escape()` before inserting it into HTML email templates. Use Django's template system with autoescaping enabled, or consider implementing a whitelist approach that only allows specific HTML elements."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "def $FUNC(...):\n  ...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "django.core.mail.send_mail(..., html_message=request.$W.get(...), ...)"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.core.mail.send_mail(..., html_message=$DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $DATA\n...\ndjango.core.mail.send_mail(..., html_message=$INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.core.mail.send_mail(..., html_message=$STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\ndjango.core.mail.send_mail(..., html_message=$INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.core.mail.send_mail(..., html_message=$STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR % $DATA\n...\ndjango.core.mail.send_mail(..., html_message=$INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.core.mail.send_mail(..., html_message=f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.core.mail.send_mail(..., html_message=$INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.core.mail.send_mail(..., html_message=$STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR + $DATA\n...\ndjango.core.mail.send_mail(..., html_message=$INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.core.mail.send_mail(..., html_message=request.$W.get(...), ...)"
            },
            {
              "pattern": "return django.core.mail.send_mail(..., html_message=request.$W.get(...), ...)"
            },
            {
              "pattern": "django.core.mail.send_mail(..., html_message=request.$W(...), ...)"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.core.mail.send_mail(..., html_message=$DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $DATA\n...\ndjango.core.mail.send_mail(..., html_message=$INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.core.mail.send_mail(..., html_message=$STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\ndjango.core.mail.send_mail(..., html_message=$INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.core.mail.send_mail(..., html_message=$STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR % $DATA\n...\ndjango.core.mail.send_mail(..., html_message=$INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.core.mail.send_mail(..., html_message=f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.core.mail.send_mail(..., html_message=$INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.core.mail.send_mail(..., html_message=$STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR + $DATA\n...\ndjango.core.mail.send_mail(..., html_message=$INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.core.mail.send_mail(..., html_message=request.$W(...), ...)"
            },
            {
              "pattern": "return django.core.mail.send_mail(..., html_message=request.$W(...), ...)"
            },
            {
              "pattern": "django.core.mail.send_mail(..., html_message=request.$W[...], ...)"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.core.mail.send_mail(..., html_message=$DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $DATA\n...\ndjango.core.mail.send_mail(..., html_message=$INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.core.mail.send_mail(..., html_message=$STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\ndjango.core.mail.send_mail(..., html_message=$INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.core.mail.send_mail(..., html_message=$STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR % $DATA\n...\ndjango.core.mail.send_mail(..., html_message=$INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.core.mail.send_mail(..., html_message=f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.core.mail.send_mail(..., html_message=$INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.core.mail.send_mail(..., html_message=$STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR + $DATA\n...\ndjango.core.mail.send_mail(..., html_message=$INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.core.mail.send_mail(..., html_message=request.$W[...], ...)"
            },
            {
              "pattern": "return django.core.mail.send_mail(..., html_message=request.$W[...], ...)"
            },
            {
              "pattern": "django.core.mail.send_mail(..., html_message=request.$W, ...)"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.core.mail.send_mail(..., html_message=$DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $DATA\n...\ndjango.core.mail.send_mail(..., html_message=$INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.core.mail.send_mail(..., html_message=$STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\ndjango.core.mail.send_mail(..., html_message=$INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.core.mail.send_mail(..., html_message=$STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR % $DATA\n...\ndjango.core.mail.send_mail(..., html_message=$INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.core.mail.send_mail(..., html_message=f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.core.mail.send_mail(..., html_message=$INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.core.mail.send_mail(..., html_message=$STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR + $DATA\n...\ndjango.core.mail.send_mail(..., html_message=$INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.core.mail.send_mail(..., html_message=request.$W, ...)"
            },
            {
              "pattern": "return django.core.mail.send_mail(..., html_message=request.$W, ...)"
            }
          ]
        }
      ]
    },
    {
      "id": "python.django.security.injection.path-traversal.path-traversal-file-name.path-traversal-file-name",
      "message": "Path traversal vulnerabilities in Django applications occur when file operations use paths containing unsanitized user input. Without proper validation, attackers can manipulate the path using directory traversal sequences (e.g., '../') to access files outside the intended directory. This can lead to unauthorized file access, potentially exposing sensitive application files, configuration data, credentials, or system files that should remain inaccessible to users.",
      "metadata": {
        "cwe": [
          "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
        ],
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "references": [
          "https://owasp.org/www-community/attacks/Path_Traversal"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "short-description": "User-supplied filename can break directory boundaries",
        "fix-suggestion": "Implement strict validation of file names from user input before file operations. Use `os.path.basename()` and check for directory traversal sequences like `../`. This prevents path traversal vulnerabilities in file handling."
      },
      "patterns": [
        {
          "pattern-inside": "def $F(...):\n  ...\n"
        },
        {
          "pattern-not-inside": "def $F(...):\n  ...\n  os.path.realpath(...)\n  ...\n"
        },
        {
          "pattern-not-inside": "def $F(...):\n  ...\n  os.path.abspath(...)\n  ...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "$V = request.$W.get($X)\n...\n$FILE % ($V)\n"
            },
            {
              "pattern": "$V = request.$W[$X]\n...\n$FILE % ($V)\n"
            },
            {
              "pattern": "$V = request.$W($X)\n...\n$FILE % ($V)\n"
            },
            {
              "pattern": "$V = request.$W\n...\n$FILE % ($V)\n# match format use cases\n"
            },
            {
              "pattern": "$V = request.$W.get($X)\n...\n$FILE.format(..., $V, ...)\n"
            },
            {
              "pattern": "$V = request.$W[$X]\n...\n$FILE.format(..., $V, ...)\n"
            },
            {
              "pattern": "$V = request.$W($X)\n...\n$FILE.format(..., $V, ...)\n"
            },
            {
              "pattern": "$V = request.$W\n...\n$FILE.format(..., $V, ...)\n"
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$FILE",
            "regex": ".*\\.(log|zip|txt|csv|xml|html).*"
          }
        }
      ],
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.django.security.injection.path-traversal.path-traversal-join.path-traversal-join",
      "message": "Path traversal vulnerabilities in Django arise when os.path.join combines directory paths with unsanitized user input before file operations. Even though path.join normalizes paths, it doesn't prevent traversal outside the base directory when path components contain '../' sequences. This vulnerability can lead to unauthorized file access, potentially exposing sensitive application code, configuration files, credentials, or system files that should not be accessible to web users.",
      "metadata": {
        "cwe": [
          "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
        ],
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "references": [
          "https://owasp.org/www-community/attacks/Path_Traversal"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "short-description": "os.path.join with user input can go outside intended folder",
        "fix-suggestion": "Sanitize user input before using it in `os.path.join()` operations. Validate that paths don't contain traversal sequences and normalize with `os.path.normpath()`. This prevents directory traversal vulnerabilities."
      },
      "patterns": [
        {
          "pattern-inside": "def $F(...):\n  ...\n"
        },
        {
          "pattern-not-inside": "def $F(...):\n  ...\n  os.path.abspath(...)\n  ...\n"
        },
        {
          "pattern-not-inside": "def $F(...):\n  ...\n  os.path.realpath(...)\n  ...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "open(os.path.join(..., request.$W.get(...), ...), ...)"
            },
            {
              "pattern": "open(os.path.join(..., request.$W(...), ...), ...)"
            },
            {
              "pattern": "open(os.path.join(..., request.$W, ...), ...)"
            },
            {
              "pattern": "open(os.path.join(..., request.$W[...], ...), ...)"
            },
            {
              "pattern": "$P = os.path.join(..., request.$W.get(...), ...)\n...\nopen($P, ...)\n"
            },
            {
              "pattern": "$P = os.path.join(..., request.$W(...), ...)\n...\nopen($P, ...)\n"
            },
            {
              "pattern": "$P = os.path.join(..., request.$W, ...)\n...\nopen($P, ...)\n"
            },
            {
              "pattern": "$P = os.path.join(..., request.$W[...], ...)\n...\nopen($P, ...)\n"
            },
            {
              "pattern": "$V = request.$W.get($X)\n...\n$P = os.path.join(..., $V, ...)\n...\nopen($P, ...)\n"
            },
            {
              "pattern": "$V = request.$W($X)\n...\n$P = os.path.join(..., $V, ...)\n...\nopen($P, ...)\n"
            },
            {
              "pattern": "$V = request.$W[$X]\n...\n$P = os.path.join(..., $V, ...)\n...\nopen($P, ...)\n"
            },
            {
              "pattern": "$V = request.$W\n...\n$P = os.path.join(..., $V, ...)\n...\nopen($P, ...)\n"
            },
            {
              "pattern": "$P = request.$W.get(...)\n...\nopen(os.path.join(..., $P, ...), ...)\n"
            },
            {
              "pattern": "$P = request.$W(...)\n...\nopen(os.path.join(..., $P, ...), ...)\n"
            },
            {
              "pattern": "$P = request.$W\n...\nopen(os.path.join(..., $P, ...), ...)\n"
            },
            {
              "pattern": "$P = request.$W[...]\n...\nopen(os.path.join(..., $P, ...), ...)\n"
            }
          ]
        }
      ],
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.django.security.injection.path-traversal.path-traversal-open.path-traversal-open",
      "message": "Path traversal vulnerabilities in Django applications occur when open() functions access files using paths containing unsanitized request data. Without proper validation, attackers can manipulate these paths using directory traversal sequences (e.g., '../') to access files outside the intended directory. This can lead to unauthorized file access, potentially exposing sensitive application files, configuration data, credentials, or system files that should remain inaccessible to users.",
      "metadata": {
        "cwe": [
          "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
        ],
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "references": [
          "https://owasp.org/www-community/attacks/Path_Traversal"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "short-description": "open with untrusted path can read or overwrite arbitrary files",
        "fix-suggestion": "Implement strict path validation before using user input in `open()` calls. Use allowlists for permitted directories and `os.path.abspath()` to detect traversal attempts. This prevents unauthorized file access through path manipulation."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "def $FUNC(...):\n  ...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "open(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "open(..., $S.format(..., request.$W.get(...), ...), ...)"
            },
            {
              "pattern": "open(..., $S % request.$W.get(...), ...)"
            },
            {
              "pattern": "open(..., f\"...{request.$W.get(...)}...\", ...)"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\nopen(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $DATA\n...\nopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $DATA\n...\nwith open(..., $INTERM, ...) as $FD:\n  ...\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\nopen(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\nopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\nwith open(..., $INTERM, ...) as $FD:\n  ...\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\nopen(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR % $DATA\n...\nopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR % $DATA\n...\nwith open(..., $INTERM, ...) as $FD:\n  ...\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\nopen(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\nopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\nwith open(..., $INTERM, ...) as $FD:\n  ...\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\nopen(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR + $DATA\n...\nopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR + $DATA\n...\nwith open(..., $INTERM, ...) as $FD:\n  ...\n"
            },
            {
              "pattern": "$A = open(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "$A = open(..., $S.format(..., request.$W.get(...), ...), ...)"
            },
            {
              "pattern": "$A = open(..., $S % request.$W.get(...), ...)"
            },
            {
              "pattern": "$A = open(..., f\"...{request.$W.get(...)}...\", ...)"
            },
            {
              "pattern": "return open(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "return open(..., $S.format(..., request.$W.get(...), ...), ...)"
            },
            {
              "pattern": "return open(..., $S % request.$W.get(...), ...)"
            },
            {
              "pattern": "return open(..., f\"...{request.$W.get(...)}...\", ...)"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\nwith open(..., $DATA, ...) as $FD:\n  ...\n"
            },
            {
              "pattern": "open(..., request.$W(...), ...)"
            },
            {
              "pattern": "open(..., $S.format(..., request.$W(...), ...), ...)"
            },
            {
              "pattern": "open(..., $S % request.$W(...), ...)"
            },
            {
              "pattern": "open(..., f\"...{request.$W(...)}...\", ...)"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\nopen(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $DATA\n...\nopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $DATA\n...\nwith open(..., $INTERM, ...) as $FD:\n  ...\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\nopen(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\nopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\nwith open(..., $INTERM, ...) as $FD:\n  ...\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\nopen(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR % $DATA\n...\nopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR % $DATA\n...\nwith open(..., $INTERM, ...) as $FD:\n  ...\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\nopen(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\nopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\nwith open(..., $INTERM, ...) as $FD:\n  ...\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\nopen(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR + $DATA\n...\nopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR + $DATA\n...\nwith open(..., $INTERM, ...) as $FD:\n  ...\n"
            },
            {
              "pattern": "$A = open(..., request.$W(...), ...)"
            },
            {
              "pattern": "$A = open(..., $S.format(..., request.$W(...), ...), ...)"
            },
            {
              "pattern": "$A = open(..., $S % request.$W(...), ...)"
            },
            {
              "pattern": "$A = open(..., f\"...{request.$W(...)}...\", ...)"
            },
            {
              "pattern": "return open(..., request.$W(...), ...)"
            },
            {
              "pattern": "return open(..., $S.format(..., request.$W(...), ...), ...)"
            },
            {
              "pattern": "return open(..., $S % request.$W(...), ...)"
            },
            {
              "pattern": "return open(..., f\"...{request.$W(...)}...\", ...)"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\nwith open(..., $DATA, ...) as $FD:\n  ...\n"
            },
            {
              "pattern": "open(..., request.$W[...], ...)"
            },
            {
              "pattern": "open(..., $S.format(..., request.$W[...], ...), ...)"
            },
            {
              "pattern": "open(..., $S % request.$W[...], ...)"
            },
            {
              "pattern": "open(..., f\"...{request.$W[...]}...\", ...)"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\nopen(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $DATA\n...\nopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $DATA\n...\nwith open(..., $INTERM, ...) as $FD:\n  ...\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\nopen(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\nopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\nwith open(..., $INTERM, ...) as $FD:\n  ...\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\nopen(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR % $DATA\n...\nopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR % $DATA\n...\nwith open(..., $INTERM, ...) as $FD:\n  ...\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\nopen(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = f\"...{$DATA}...\"\n...\nopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = f\"...{$DATA}...\"\n...\nwith open(..., $INTERM, ...) as $FD:\n  ...\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\nopen(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR + $DATA\n...\nopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR + $DATA\n...\nwith open(..., $INTERM, ...) as $FD:\n  ...\n"
            },
            {
              "pattern": "$A = open(..., request.$W[...], ...)"
            },
            {
              "pattern": "$A = open(..., $S.format(..., request.$W[...], ...), ...)"
            },
            {
              "pattern": "$A = open(..., $S % request.$W[...], ...)"
            },
            {
              "pattern": "$A = open(..., f\"...{request.$W[...]}...\", ...)"
            },
            {
              "pattern": "return open(..., request.$W[...], ...)"
            },
            {
              "pattern": "return open(..., $S.format(..., request.$W[...], ...), ...)"
            },
            {
              "pattern": "return open(..., $S % request.$W[...], ...)"
            },
            {
              "pattern": "return open(..., f\"...{request.$W[...]}...\", ...)"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\nwith open(..., $DATA, ...) as $FD:\n  ...\n"
            },
            {
              "pattern": "open(..., request.$W, ...)"
            },
            {
              "pattern": "open(..., $S.format(..., request.$W, ...), ...)"
            },
            {
              "pattern": "open(..., $S % request.$W, ...)"
            },
            {
              "pattern": "open(..., f\"...{request.$W}...\", ...)"
            },
            {
              "pattern": "$DATA = request.$W\n...\nopen(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $DATA\n...\nopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $DATA\n...\nwith open(..., $INTERM, ...) as $FD:\n  ...\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\nopen(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\nopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\nwith open(..., $INTERM, ...) as $FD:\n  ...\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\nopen(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR % $DATA\n...\nopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR % $DATA\n...\nwith open(..., $INTERM, ...) as $FD:\n  ...\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\nopen(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = f\"...{$DATA}...\"\n...\nopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = f\"...{$DATA}...\"\n...\nwith open(..., $INTERM, ...) as $FD:\n  ...\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\nopen(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR + $DATA\n...\nopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR + $DATA\n...\nwith open(..., $INTERM, ...) as $FD:\n  ...\n"
            },
            {
              "pattern": "$A = open(..., request.$W, ...)"
            },
            {
              "pattern": "$A = open(..., $S.format(..., request.$W, ...), ...)"
            },
            {
              "pattern": "$A = open(..., $S % request.$W, ...)"
            },
            {
              "pattern": "$A = open(..., f\"...{request.$W}...\", ...)"
            },
            {
              "pattern": "return open(..., request.$W, ...)"
            },
            {
              "pattern": "return open(..., $S.format(..., request.$W, ...), ...)"
            },
            {
              "pattern": "return open(..., $S % request.$W, ...)"
            },
            {
              "pattern": "return open(..., f\"...{request.$W}...\", ...)"
            },
            {
              "pattern": "$DATA = request.$W\n...\nwith open(..., $DATA, ...) as $FD:\n  ...\n"
            }
          ]
        }
      ]
    },
    {
      "id": "python.django.security.injection.sql.sql-injection-using-raw.sql-injection-using-raw",
      "message": "SQL injection vulnerabilities in Django occur when raw() query methods execute SQL containing unsanitized user input instead of using query parameters. This practice bypasses Django's ORM protections that would normally prevent injection attacks through proper parameterization. Attackers can manipulate the query structure by injecting SQL syntax, potentially leading to unauthorized data access, authentication bypass, data modification, or even server compromise through advanced SQL techniques.",
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.0/topics/security/#sql-injection-protection"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Raw SQL in Django with user data fosters injection",
        "fix-suggestion": "Replace raw SQL query string concatenation with parameterized queries. Use Django ORM or parameterized `raw('SELECT * FROM table WHERE id = %s', [user_id])`. This prevents SQL injection in custom database queries."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "def $FUNC(...):\n  ...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "$MODEL.objects.raw(..., $S.format(..., request.$W.get(...), ...), ...)"
            },
            {
              "pattern": "$MODEL.objects.raw(..., $S % request.$W.get(...), ...)"
            },
            {
              "pattern": "$MODEL.objects.raw(..., f\"...{request.$W.get(...)}...\", ...)"
            },
            {
              "pattern": "$MODEL.objects.raw(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$MODEL.objects.raw(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $DATA\n...\n$MODEL.objects.raw(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$MODEL.objects.raw(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\n$MODEL.objects.raw(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$MODEL.objects.raw(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR % $DATA\n...\n$MODEL.objects.raw(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$MODEL.objects.raw(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\n$MODEL.objects.raw(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$MODEL.objects.raw(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR + $DATA\n...\n$MODEL.objects.raw(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = $MODEL.objects.raw(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "return $MODEL.objects.raw(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "$MODEL.objects.raw(..., $S.format(..., request.$W(...), ...), ...)"
            },
            {
              "pattern": "$MODEL.objects.raw(..., $S % request.$W(...), ...)"
            },
            {
              "pattern": "$MODEL.objects.raw(..., f\"...{request.$W(...)}...\", ...)"
            },
            {
              "pattern": "$MODEL.objects.raw(..., request.$W(...), ...)"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$MODEL.objects.raw(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $DATA\n...\n$MODEL.objects.raw(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$MODEL.objects.raw(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\n$MODEL.objects.raw(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$MODEL.objects.raw(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR % $DATA\n...\n$MODEL.objects.raw(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$MODEL.objects.raw(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\n$MODEL.objects.raw(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$MODEL.objects.raw(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR + $DATA\n...\n$MODEL.objects.raw(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = $MODEL.objects.raw(..., request.$W(...), ...)"
            },
            {
              "pattern": "return $MODEL.objects.raw(..., request.$W(...), ...)"
            },
            {
              "pattern": "$MODEL.objects.raw(..., $S.format(..., request.$W[...], ...), ...)"
            },
            {
              "pattern": "$MODEL.objects.raw(..., $S % request.$W[...], ...)"
            },
            {
              "pattern": "$MODEL.objects.raw(..., f\"...{request.$W[...]}...\", ...)"
            },
            {
              "pattern": "$MODEL.objects.raw(..., request.$W[...], ...)"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$MODEL.objects.raw(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $DATA\n...\n$MODEL.objects.raw(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$MODEL.objects.raw(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\n$MODEL.objects.raw(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$MODEL.objects.raw(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR % $DATA\n...\n$MODEL.objects.raw(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$MODEL.objects.raw(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = f\"...{$DATA}...\"\n...\n$MODEL.objects.raw(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$MODEL.objects.raw(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR + $DATA\n...\n$MODEL.objects.raw(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = $MODEL.objects.raw(..., request.$W[...], ...)"
            },
            {
              "pattern": "return $MODEL.objects.raw(..., request.$W[...], ...)"
            },
            {
              "pattern": "$MODEL.objects.raw(..., $S.format(..., request.$W, ...), ...)"
            },
            {
              "pattern": "$MODEL.objects.raw(..., $S % request.$W, ...)"
            },
            {
              "pattern": "$MODEL.objects.raw(..., f\"...{request.$W}...\", ...)"
            },
            {
              "pattern": "$MODEL.objects.raw(..., request.$W, ...)"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$MODEL.objects.raw(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $DATA\n...\n$MODEL.objects.raw(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$MODEL.objects.raw(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\n$MODEL.objects.raw(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$MODEL.objects.raw(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR % $DATA\n...\n$MODEL.objects.raw(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$MODEL.objects.raw(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = f\"...{$DATA}...\"\n...\n$MODEL.objects.raw(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$MODEL.objects.raw(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR + $DATA\n...\n$MODEL.objects.raw(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = $MODEL.objects.raw(..., request.$W, ...)"
            },
            {
              "pattern": "return $MODEL.objects.raw(..., request.$W, ...)"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$MODEL.objects.raw($STR % (..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$MODEL.objects.raw($STR % (..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$MODEL.objects.raw($STR % (..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$MODEL.objects.raw($STR % (..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR % (..., $DATA, ...)\n...\n$MODEL.objects.raw($INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR % (..., $DATA, ...)\n...\n$MODEL.objects.raw($INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR % (..., $DATA, ...)\n...\n$MODEL.objects.raw($INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR % (..., $DATA, ...)\n...\n$MODEL.objects.raw($INTERM, ...)\n"
            }
          ]
        }
      ]
    },
    {
      "id": "python.django.security.injection.sql.sql-injection-extra.sql-injection-using-extra-where",
      "message": "SQL injection in Django applications occurs when the QuerySet.extra() method incorporates unsanitized user input in SQL fragments. Unlike standard Django ORM methods, extra() performs raw SQL operations that don't automatically parameterize user data. This allows attackers to manipulate query structure by injecting SQL syntax, potentially leading to unauthorized data access, authentication bypass, data modification, or even server compromise through advanced SQL techniques.",
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.0/ref/models/expressions/#.objects.extra"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "QuerySet.extra with user input is injection-prone",
        "fix-suggestion": "Replace `QuerySet.extra(where=[])` containing user input with proper ORM methods. Use Django's `filter()` with Q objects or F expressions instead. This prevents SQL injection in complex query conditions."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "def $FUNC(...):\n  ...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "$MODEL.objects.extra(..., where=[..., $S.format(..., request.$W.get(...), ...), ...], ...)"
            },
            {
              "pattern": "$MODEL.objects.extra(..., where=[..., $S % request.$W.get(...), ...], ...)"
            },
            {
              "pattern": "$MODEL.objects.extra(..., where=[..., f\"...{request.$W.get(...)}...\", ...], ...)"
            },
            {
              "pattern": "$MODEL.objects.extra(..., where=[..., request.$W.get(...), ...], ...)"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$MODEL.objects.extra(..., where=[..., $DATA, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $DATA\n...\n$MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$MODEL.objects.extra(..., where=[..., $STR.format(..., $DATA, ...), ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\n$MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$MODEL.objects.extra(..., where=[..., $STR % $DATA, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR % $DATA\n...\n$MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$MODEL.objects.extra(..., where=[..., f\"...{$DATA}...\", ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\n$MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$MODEL.objects.extra(..., where=[..., $STR + $DATA, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR + $DATA\n...\n$MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)\n"
            },
            {
              "pattern": "$A = $MODEL.objects.extra(..., where=[..., request.$W.get(...), ...], ...)"
            },
            {
              "pattern": "return $MODEL.objects.extra(..., where=[..., request.$W.get(...), ...], ...)"
            },
            {
              "pattern": "$MODEL.objects.extra(..., where=[..., $S.format(..., request.$W(...), ...), ...], ...)"
            },
            {
              "pattern": "$MODEL.objects.extra(..., where=[..., $S % request.$W(...), ...], ...)"
            },
            {
              "pattern": "$MODEL.objects.extra(..., where=[..., f\"...{request.$W(...)}...\", ...], ...)"
            },
            {
              "pattern": "$MODEL.objects.extra(..., where=[..., request.$W(...), ...], ...)"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$MODEL.objects.extra(..., where=[..., $DATA, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $DATA\n...\n$MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$MODEL.objects.extra(..., where=[..., $STR.format(..., $DATA, ...), ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\n$MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$MODEL.objects.extra(..., where=[..., $STR % $DATA, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR % $DATA\n...\n$MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$MODEL.objects.extra(..., where=[..., f\"...{$DATA}...\", ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\n$MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$MODEL.objects.extra(..., where=[..., $STR + $DATA, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR + $DATA\n...\n$MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)\n"
            },
            {
              "pattern": "$A = $MODEL.objects.extra(..., where=[..., request.$W(...), ...], ...)"
            },
            {
              "pattern": "return $MODEL.objects.extra(..., where=[..., request.$W(...), ...], ...)"
            },
            {
              "pattern": "$MODEL.objects.extra(..., where=[..., $S.format(..., request.$W[...], ...), ...], ...)"
            },
            {
              "pattern": "$MODEL.objects.extra(..., where=[..., $S % request.$W[...], ...], ...)"
            },
            {
              "pattern": "$MODEL.objects.extra(..., where=[..., f\"...{request.$W[...]}...\", ...], ...)"
            },
            {
              "pattern": "$MODEL.objects.extra(..., where=[..., request.$W[...], ...], ...)"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$MODEL.objects.extra(..., where=[..., $DATA, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $DATA\n...\n$MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$MODEL.objects.extra(..., where=[..., $STR.format(..., $DATA, ...), ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\n$MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$MODEL.objects.extra(..., where=[..., $STR % $DATA, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR % $DATA\n...\n$MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$MODEL.objects.extra(..., where=[..., f\"...{$DATA}...\", ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = f\"...{$DATA}...\"\n...\n$MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$MODEL.objects.extra(..., where=[..., $STR + $DATA, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR + $DATA\n...\n$MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)\n"
            },
            {
              "pattern": "$A = $MODEL.objects.extra(..., where=[..., request.$W[...], ...], ...)"
            },
            {
              "pattern": "return $MODEL.objects.extra(..., where=[..., request.$W[...], ...], ...)"
            },
            {
              "pattern": "$MODEL.objects.extra(..., where=[..., $S.format(..., request.$W, ...), ...], ...)"
            },
            {
              "pattern": "$MODEL.objects.extra(..., where=[..., $S % request.$W, ...], ...)"
            },
            {
              "pattern": "$MODEL.objects.extra(..., where=[..., f\"...{request.$W}...\", ...], ...)"
            },
            {
              "pattern": "$MODEL.objects.extra(..., where=[..., request.$W, ...], ...)"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$MODEL.objects.extra(..., where=[..., $DATA, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $DATA\n...\n$MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$MODEL.objects.extra(..., where=[..., $STR.format(..., $DATA, ...), ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\n$MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$MODEL.objects.extra(..., where=[..., $STR % $DATA, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR % $DATA\n...\n$MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$MODEL.objects.extra(..., where=[..., f\"...{$DATA}...\", ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = f\"...{$DATA}...\"\n...\n$MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$MODEL.objects.extra(..., where=[..., $STR + $DATA, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR + $DATA\n...\n$MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)\n"
            },
            {
              "pattern": "$A = $MODEL.objects.extra(..., where=[..., request.$W, ...], ...)"
            },
            {
              "pattern": "return $MODEL.objects.extra(..., where=[..., request.$W, ...], ...)"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$MODEL.objects.extra(..., where=[..., $STR % (..., $DATA, ...), ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$MODEL.objects.extra(..., where=[..., $STR % (..., $DATA, ...), ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$MODEL.objects.extra(..., where=[..., $STR % (..., $DATA, ...), ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$MODEL.objects.extra(..., where=[..., $STR % (..., $DATA, ...), ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR % (..., $DATA, ...)\n...\n$MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR % (..., $DATA, ...)\n...\n$MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR % (..., $DATA, ...)\n...\n$MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR % (..., $DATA, ...)\n...\n$MODEL.objects.extra(..., where=[..., $INTERM, ...], ...)\n"
            }
          ]
        }
      ]
    },
    {
      "id": "python.django.security.injection.sql.sql-injection-rawsql.sql-injection-using-rawsql",
      "message": "SQL injection vulnerabilities in Django arise when RawSQL() objects incorporate unsanitized user input directly into SQL expressions. Despite being part of Django's ORM, RawSQL() doesn't automatically parameterize its inputs like standard ORM methods do. This allows attackers to manipulate query structure by injecting SQL syntax, potentially leading to unauthorized data access, authentication bypass, data modification, or even server compromise through the database.",
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.0/ref/models/expressions/#django.db.models.expressions.RawSQL"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "RawSQL in Django can be injected with malicious input",
        "fix-suggestion": "Modify `RawSQL` expressions to use parameterized queries instead of string interpolation. Use `RawSQL(\"col = %s\", [user_input])` with proper parameter binding. This prevents SQL injection in ORM annotations and aggregations."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "def $FUNC(...):\n  ...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "django.db.models.expressions.RawSQL(..., $S.format(..., request.$W.get(...), ...), ...)"
            },
            {
              "pattern": "django.db.models.expressions.RawSQL(..., $S % request.$W.get(...), ...)"
            },
            {
              "pattern": "django.db.models.expressions.RawSQL(..., f\"...{request.$W.get(...)}...\", ...)"
            },
            {
              "pattern": "django.db.models.expressions.RawSQL(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.db.models.expressions.RawSQL(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $DATA\n...\ndjango.db.models.expressions.RawSQL(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.db.models.expressions.RawSQL(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\ndjango.db.models.expressions.RawSQL(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.db.models.expressions.RawSQL(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR % $DATA\n...\ndjango.db.models.expressions.RawSQL(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.db.models.expressions.RawSQL(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.db.models.expressions.RawSQL(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.db.models.expressions.RawSQL(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR + $DATA\n...\ndjango.db.models.expressions.RawSQL(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.db.models.expressions.RawSQL(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "return django.db.models.expressions.RawSQL(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "django.db.models.expressions.RawSQL(..., $S.format(..., request.$W(...), ...), ...)"
            },
            {
              "pattern": "django.db.models.expressions.RawSQL(..., $S % request.$W(...), ...)"
            },
            {
              "pattern": "django.db.models.expressions.RawSQL(..., f\"...{request.$W(...)}...\", ...)"
            },
            {
              "pattern": "django.db.models.expressions.RawSQL(..., request.$W(...), ...)"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.db.models.expressions.RawSQL(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $DATA\n...\ndjango.db.models.expressions.RawSQL(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.db.models.expressions.RawSQL(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\ndjango.db.models.expressions.RawSQL(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.db.models.expressions.RawSQL(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR % $DATA\n...\ndjango.db.models.expressions.RawSQL(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.db.models.expressions.RawSQL(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.db.models.expressions.RawSQL(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.db.models.expressions.RawSQL(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR + $DATA\n...\ndjango.db.models.expressions.RawSQL(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.db.models.expressions.RawSQL(..., request.$W(...), ...)"
            },
            {
              "pattern": "return django.db.models.expressions.RawSQL(..., request.$W(...), ...)"
            },
            {
              "pattern": "django.db.models.expressions.RawSQL(..., $S.format(..., request.$W[...], ...), ...)"
            },
            {
              "pattern": "django.db.models.expressions.RawSQL(..., $S % request.$W[...], ...)"
            },
            {
              "pattern": "django.db.models.expressions.RawSQL(..., f\"...{request.$W[...]}...\", ...)"
            },
            {
              "pattern": "django.db.models.expressions.RawSQL(..., request.$W[...], ...)"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.db.models.expressions.RawSQL(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $DATA\n...\ndjango.db.models.expressions.RawSQL(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.db.models.expressions.RawSQL(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\ndjango.db.models.expressions.RawSQL(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.db.models.expressions.RawSQL(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR % $DATA\n...\ndjango.db.models.expressions.RawSQL(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.db.models.expressions.RawSQL(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.db.models.expressions.RawSQL(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.db.models.expressions.RawSQL(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR + $DATA\n...\ndjango.db.models.expressions.RawSQL(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.db.models.expressions.RawSQL(..., request.$W[...], ...)"
            },
            {
              "pattern": "return django.db.models.expressions.RawSQL(..., request.$W[...], ...)"
            },
            {
              "pattern": "django.db.models.expressions.RawSQL(..., $S.format(..., request.$W, ...), ...)"
            },
            {
              "pattern": "django.db.models.expressions.RawSQL(..., $S % request.$W, ...)"
            },
            {
              "pattern": "django.db.models.expressions.RawSQL(..., f\"...{request.$W}...\", ...)"
            },
            {
              "pattern": "django.db.models.expressions.RawSQL(..., request.$W, ...)"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.db.models.expressions.RawSQL(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $DATA\n...\ndjango.db.models.expressions.RawSQL(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.db.models.expressions.RawSQL(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\ndjango.db.models.expressions.RawSQL(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.db.models.expressions.RawSQL(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR % $DATA\n...\ndjango.db.models.expressions.RawSQL(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.db.models.expressions.RawSQL(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = f\"...{$DATA}...\"\n...\ndjango.db.models.expressions.RawSQL(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.db.models.expressions.RawSQL(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR + $DATA\n...\ndjango.db.models.expressions.RawSQL(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = django.db.models.expressions.RawSQL(..., request.$W, ...)"
            },
            {
              "pattern": "return django.db.models.expressions.RawSQL(..., request.$W, ...)"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\ndjango.db.models.expressions.RawSQL($STR % (..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\ndjango.db.models.expressions.RawSQL($STR % (..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\ndjango.db.models.expressions.RawSQL($STR % (..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\ndjango.db.models.expressions.RawSQL($STR % (..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR % (..., $DATA, ...)\n...\ndjango.db.models.expressions.RawSQL($INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR % (..., $DATA, ...)\n...\ndjango.db.models.expressions.RawSQL($INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR % (..., $DATA, ...)\n...\ndjango.db.models.expressions.RawSQL($INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR % (..., $DATA, ...)\n...\ndjango.db.models.expressions.RawSQL($INTERM, ...)\n"
            }
          ]
        }
      ]
    },
    {
      "id": "python.django.security.injection.sql.sql-injection-using-db-cursor-execute.sql-injection-db-cursor-execute",
      "message": "SQL injection in Django applications occurs when database cursor execute() methods run queries containing unsanitized user input instead of using parameterized queries. This low-level database access bypasses Django's ORM protections that would normally prevent injection attacks. Attackers can manipulate the query structure by injecting SQL syntax, potentially leading to unauthorized data access, authentication bypass, data modification, or even server compromise through advanced SQL techniques.",
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.0/topics/security/#sql-injection-protection"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Direct execute() calls with user data risk injection",
        "fix-suggestion": "Replace string concatenation in database cursor `execute()` calls with parameterized queries. Use `cursor.execute(\"SELECT * FROM users WHERE id = %s\", [user_id])` instead of string formatting. This prevents SQL injection in direct database cursor usage."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "def $FUNC(...):\n  ...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "$CURSOR.execute(..., $S.format(..., request.$W.get(...), ...), ...)"
            },
            {
              "pattern": "$CURSOR.execute(..., $S % request.$W.get(...), ...)"
            },
            {
              "pattern": "$CURSOR.execute(..., f\"...{request.$W.get(...)}...\", ...)"
            },
            {
              "pattern": "$CURSOR.execute(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$CURSOR.execute(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $DATA\n...\n$CURSOR.execute(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$CURSOR.execute(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\n$CURSOR.execute(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$CURSOR.execute(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR % $DATA\n...\n$CURSOR.execute(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$CURSOR.execute(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\n$CURSOR.execute(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$CURSOR.execute(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR + $DATA\n...\n$CURSOR.execute(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = $CURSOR.execute(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "return $CURSOR.execute(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "$CURSOR.execute(..., $S.format(..., request.$W(...), ...), ...)"
            },
            {
              "pattern": "$CURSOR.execute(..., $S % request.$W(...), ...)"
            },
            {
              "pattern": "$CURSOR.execute(..., f\"...{request.$W(...)}...\", ...)"
            },
            {
              "pattern": "$CURSOR.execute(..., request.$W(...), ...)"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$CURSOR.execute(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $DATA\n...\n$CURSOR.execute(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$CURSOR.execute(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\n$CURSOR.execute(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$CURSOR.execute(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR % $DATA\n...\n$CURSOR.execute(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$CURSOR.execute(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\n$CURSOR.execute(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$CURSOR.execute(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR + $DATA\n...\n$CURSOR.execute(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = $CURSOR.execute(..., request.$W(...), ...)"
            },
            {
              "pattern": "return $CURSOR.execute(..., request.$W(...), ...)"
            },
            {
              "pattern": "$CURSOR.execute(..., $S.format(..., request.$W[...], ...), ...)"
            },
            {
              "pattern": "$CURSOR.execute(..., $S % request.$W[...], ...)"
            },
            {
              "pattern": "$CURSOR.execute(..., f\"...{request.$W[...]}...\", ...)"
            },
            {
              "pattern": "$CURSOR.execute(..., request.$W[...], ...)"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$CURSOR.execute(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $DATA\n...\n$CURSOR.execute(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$CURSOR.execute(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\n$CURSOR.execute(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$CURSOR.execute(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR % $DATA\n...\n$CURSOR.execute(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$CURSOR.execute(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = f\"...{$DATA}...\"\n...\n$CURSOR.execute(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$CURSOR.execute(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR + $DATA\n...\n$CURSOR.execute(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = $CURSOR.execute(..., request.$W[...], ...)"
            },
            {
              "pattern": "return $CURSOR.execute(..., request.$W[...], ...)"
            },
            {
              "pattern": "$CURSOR.execute(..., $S.format(..., request.$W, ...), ...)"
            },
            {
              "pattern": "$CURSOR.execute(..., $S % request.$W, ...)"
            },
            {
              "pattern": "$CURSOR.execute(..., f\"...{request.$W}...\", ...)"
            },
            {
              "pattern": "$CURSOR.execute(..., request.$W, ...)"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$CURSOR.execute(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $DATA\n...\n$CURSOR.execute(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$CURSOR.execute(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\n$CURSOR.execute(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$CURSOR.execute(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR % $DATA\n...\n$CURSOR.execute(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$CURSOR.execute(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = f\"...{$DATA}...\"\n...\n$CURSOR.execute(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$CURSOR.execute(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR + $DATA\n...\n$CURSOR.execute(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = $CURSOR.execute(..., request.$W, ...)"
            },
            {
              "pattern": "return $CURSOR.execute(..., request.$W, ...)"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$CURSOR.execute($STR % (..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$CURSOR.execute($STR % (..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$CURSOR.execute($STR % (..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$CURSOR.execute($STR % (..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR % (..., $DATA, ...)\n...\n$CURSOR.execute($INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR % (..., $DATA, ...)\n...\n$CURSOR.execute($INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR % (..., $DATA, ...)\n...\n$CURSOR.execute($INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR % (..., $DATA, ...)\n...\n$CURSOR.execute($INTERM, ...)"
            }
          ]
        }
      ]
    },
    {
      "id": "python.django.security.injection.ssrf.ssrf-injection-requests.ssrf-injection-requests",
      "message": "Server-Side Request Forgery (SSRF) vulnerabilities in Django applications arise when the requests library makes HTTP requests to URLs containing unsanitized user input. Without proper validation, attackers can manipulate these URLs to direct requests to unauthorized internal services or external malicious servers. This can lead to internal network scanning, accessing restricted services, data exfiltration, or exploitation of trust relationships between the server and other systems.",
      "metadata": {
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "references": [
          "https://owasp.org/www-community/attacks/Server_Side_Request_Forgery"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "Requests library call with unvalidated user URL can cause SSRF",
        "fix-suggestion": "Implement strict URL validation before passing URLs to the `requests` library. Validate allowed domains, schemes, and ports for all user-supplied URLs. This prevents server-side request forgery vulnerabilities."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "patterns": [
        {
          "pattern-inside": "def $FUNC(...):\n  ...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "requests.$METHOD(..., $S.format(..., request.$W.get(...), ...), ...)"
            },
            {
              "pattern": "requests.$METHOD(..., $S % request.$W.get(...), ...)"
            },
            {
              "pattern": "requests.$METHOD(..., f\"...{request.$W.get(...)}...\", ...)"
            },
            {
              "pattern": "requests.$METHOD(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\nrequests.$METHOD(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $DATA\n...\nrequests.$METHOD(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\nrequests.$METHOD(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\nrequests.$METHOD(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\nrequests.$METHOD(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR % $DATA\n...\nrequests.$METHOD(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\nrequests.$METHOD(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\nrequests.$METHOD(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\nrequests.$METHOD(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR + $DATA\n...\nrequests.$METHOD(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = requests.$METHOD(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "return requests.$METHOD(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "requests.$METHOD(..., $S.format(..., request.$W(...), ...), ...)"
            },
            {
              "pattern": "requests.$METHOD(..., $S % request.$W(...), ...)"
            },
            {
              "pattern": "requests.$METHOD(..., f\"...{request.$W(...)}...\", ...)"
            },
            {
              "pattern": "requests.$METHOD(..., request.$W(...), ...)"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\nrequests.$METHOD(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $DATA\n...\nrequests.$METHOD(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\nrequests.$METHOD(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\nrequests.$METHOD(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\nrequests.$METHOD(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR % $DATA\n...\nrequests.$METHOD(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\nrequests.$METHOD(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\nrequests.$METHOD(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\nrequests.$METHOD(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR + $DATA\n...\nrequests.$METHOD(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = requests.$METHOD(..., request.$W(...), ...)"
            },
            {
              "pattern": "return requests.$METHOD(..., request.$W(...), ...)"
            },
            {
              "pattern": "requests.$METHOD(..., $S.format(..., request.$W[...], ...), ...)"
            },
            {
              "pattern": "requests.$METHOD(..., $S % request.$W[...], ...)"
            },
            {
              "pattern": "requests.$METHOD(..., f\"...{request.$W[...]}...\", ...)"
            },
            {
              "pattern": "requests.$METHOD(..., request.$W[...], ...)"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\nrequests.$METHOD(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $DATA\n...\nrequests.$METHOD(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\nrequests.$METHOD(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\nrequests.$METHOD(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\nrequests.$METHOD(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR % $DATA\n...\nrequests.$METHOD(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\nrequests.$METHOD(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = f\"...{$DATA}...\"\n...\nrequests.$METHOD(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\nrequests.$METHOD(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR + $DATA\n...\nrequests.$METHOD(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = requests.$METHOD(..., request.$W[...], ...)"
            },
            {
              "pattern": "return requests.$METHOD(..., request.$W[...], ...)"
            },
            {
              "pattern": "requests.$METHOD(..., $S.format(..., request.$W, ...), ...)"
            },
            {
              "pattern": "requests.$METHOD(..., $S % request.$W, ...)"
            },
            {
              "pattern": "requests.$METHOD(..., f\"...{request.$W}...\", ...)"
            },
            {
              "pattern": "requests.$METHOD(..., request.$W, ...)"
            },
            {
              "pattern": "$DATA = request.$W\n...\nrequests.$METHOD(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $DATA\n...\nrequests.$METHOD(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\nrequests.$METHOD(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\nrequests.$METHOD(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\nrequests.$METHOD(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR % $DATA\n...\nrequests.$METHOD(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\nrequests.$METHOD(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = f\"...{$DATA}...\"\n...\nrequests.$METHOD(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\nrequests.$METHOD(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR + $DATA\n...\nrequests.$METHOD(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = requests.$METHOD(..., request.$W, ...)"
            },
            {
              "pattern": "return requests.$METHOD(..., request.$W, ...)"
            }
          ]
        }
      ]
    },
    {
      "id": "python.django.security.injection.ssrf.ssrf-injection-urllib.ssrf-injection-urllib",
      "message": "Server-Side Request Forgery (SSRF) vulnerabilities in Django applications occur when urllib functions make HTTP requests to URLs containing unsanitized user input. Without proper validation, attackers can manipulate these URLs to direct requests to unauthorized internal resources or external malicious servers. This can lead to internal network scanning, accessing restricted services, data exfiltration, or exploitation of trust relationships between the server and other systems behind firewalls.",
      "metadata": {
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "references": [
          "https://owasp.org/www-community/attacks/Server_Side_Request_Forgery"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "urllib usage with user input can produce SSRF",
        "fix-suggestion": "Apply strict URL validation for all URLs passed to `urllib` functions. Implement allowlists for permitted domains and schemes before processing user-supplied URLs. This prevents server-side request forgery attacks."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "patterns": [
        {
          "pattern-inside": "def $FUNC(...):\n  ...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "urllib.request.urlopen(..., $S.format(..., request.$W.get(...), ...), ...)"
            },
            {
              "pattern": "urllib.request.urlopen(..., $S % request.$W.get(...), ...)"
            },
            {
              "pattern": "urllib.request.urlopen(..., f\"...{request.$W.get(...)}...\", ...)"
            },
            {
              "pattern": "urllib.request.urlopen(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\nurllib.request.urlopen(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $DATA\n...\nurllib.request.urlopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\nurllib.request.urlopen(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\nurllib.request.urlopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\nurllib.request.urlopen(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR % $DATA\n...\nurllib.request.urlopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\nurllib.request.urlopen(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\nurllib.request.urlopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\nurllib.request.urlopen(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W.get(...)\n...\n$INTERM = $STR + $DATA\n...\nurllib.request.urlopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = urllib.request.urlopen(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "return urllib.request.urlopen(..., request.$W.get(...), ...)"
            },
            {
              "pattern": "urllib.request.urlopen(..., $S.format(..., request.$W(...), ...), ...)"
            },
            {
              "pattern": "urllib.request.urlopen(..., $S % request.$W(...), ...)"
            },
            {
              "pattern": "urllib.request.urlopen(..., f\"...{request.$W(...)}...\", ...)"
            },
            {
              "pattern": "urllib.request.urlopen(..., request.$W(...), ...)"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\nurllib.request.urlopen(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $DATA\n...\nurllib.request.urlopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\nurllib.request.urlopen(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\nurllib.request.urlopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\nurllib.request.urlopen(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR % $DATA\n...\nurllib.request.urlopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\nurllib.request.urlopen(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = f\"...{$DATA}...\"\n...\nurllib.request.urlopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\nurllib.request.urlopen(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W(...)\n...\n$INTERM = $STR + $DATA\n...\nurllib.request.urlopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = urllib.request.urlopen(..., request.$W(...), ...)"
            },
            {
              "pattern": "return urllib.request.urlopen(..., request.$W(...), ...)"
            },
            {
              "pattern": "urllib.request.urlopen(..., $S.format(..., request.$W[...], ...), ...)"
            },
            {
              "pattern": "urllib.request.urlopen(..., $S % request.$W[...], ...)"
            },
            {
              "pattern": "urllib.request.urlopen(..., f\"...{request.$W[...]}...\", ...)"
            },
            {
              "pattern": "urllib.request.urlopen(..., request.$W[...], ...)"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\nurllib.request.urlopen(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $DATA\n...\nurllib.request.urlopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\nurllib.request.urlopen(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\nurllib.request.urlopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\nurllib.request.urlopen(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR % $DATA\n...\nurllib.request.urlopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\nurllib.request.urlopen(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = f\"...{$DATA}...\"\n...\nurllib.request.urlopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\nurllib.request.urlopen(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W[...]\n...\n$INTERM = $STR + $DATA\n...\nurllib.request.urlopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = urllib.request.urlopen(..., request.$W[...], ...)"
            },
            {
              "pattern": "return urllib.request.urlopen(..., request.$W[...], ...)"
            },
            {
              "pattern": "urllib.request.urlopen(..., $S.format(..., request.$W, ...), ...)"
            },
            {
              "pattern": "urllib.request.urlopen(..., $S % request.$W, ...)"
            },
            {
              "pattern": "urllib.request.urlopen(..., f\"...{request.$W}...\", ...)"
            },
            {
              "pattern": "urllib.request.urlopen(..., request.$W, ...)"
            },
            {
              "pattern": "$DATA = request.$W\n...\nurllib.request.urlopen(..., $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $DATA\n...\nurllib.request.urlopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\nurllib.request.urlopen(..., $STR.format(..., $DATA, ...), ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR.format(..., $DATA, ...)\n...\nurllib.request.urlopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\nurllib.request.urlopen(..., $STR % $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR % $DATA\n...\nurllib.request.urlopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\nurllib.request.urlopen(..., f\"...{$DATA}...\", ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = f\"...{$DATA}...\"\n...\nurllib.request.urlopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\nurllib.request.urlopen(..., $STR + $DATA, ...)\n"
            },
            {
              "pattern": "$DATA = request.$W\n...\n$INTERM = $STR + $DATA\n...\nurllib.request.urlopen(..., $INTERM, ...)\n"
            },
            {
              "pattern": "$A = urllib.request.urlopen(..., request.$W, ...)"
            },
            {
              "pattern": "return urllib.request.urlopen(..., request.$W, ...)"
            }
          ]
        }
      ]
    },
    {
      "id": "python.django.security.passwords.password-empty-string.password-empty-string",
      "message": "An empty string is being used to set a model password. This creates insecure accounts vulnerable to easy compromise. Use None or call set_unusable_password() when you need to create accounts without functional passwords.",
      "metadata": {
        "cwe": [
          "CWE-521: Weak Password Requirements"
        ],
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.0/ref/contrib/auth/#django.contrib.auth.models.User.set_password"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Empty string used as model password",
        "fix-suggestion": "Replace empty string passwords (`''`) with `None` or call `user.set_unusable_password()` when you intend to disable password login. For accounts that should have valid passwords, use Django's password validators to ensure sufficient strength."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$MODEL.set_password($EMPTY)\n...\n$MODEL.save()\n"
            },
            {
              "pattern": "$VAR = $EMPTY\n...\n$MODEL.set_password($VAR)\n...\n$MODEL.save()\n"
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$EMPTY",
            "regex": "(\\'\\'|\\\"\\\")"
          }
        }
      ],
      "languages": [
        "python"
      ],
      "severity": "ERROR"
    },
    {
      "id": "python.django.security.passwords.use-none-for-password-default.use-none-for-password-default",
      "message": "Empty string is used as a default value for passwords. This creates accounts with easily guessable passwords instead of properly disabling password authentication. Use None as the default password value or call set_unusable_password() to create secure accounts without passwords.",
      "metadata": {
        "cwe": [
          "CWE-521: Weak Password Requirements"
        ],
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "references": [
          "https://docs.djangoproject.com/en/3.0/ref/contrib/auth/#django.contrib.auth.models.User.set_password"
        ],
        "category": "security",
        "technology": [
          "django"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Empty string default for model passwords",
        "fix-suggestion": "Change default password values from empty strings (`''`) to `None` in your model definitions. If creating users programmatically without passwords, use `user.set_unusable_password()` to properly disable password authentication rather than using empty strings."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$VAR = request.$W.get($X, $EMPTY)\n...\n$MODEL.set_password($VAR)\n...\n$MODEL.save(...)\n"
            },
            {
              "pattern": "def $F(..., $VAR=$EMPTY, ...):\n  ...\n  $MODEL.set_password($VAR)\n"
            }
          ]
        },
        {
          "metavariable-pattern": {
            "metavariable": "$EMPTY",
            "pattern": "\"\""
          }
        },
        {
          "focus-metavariable": "$EMPTY"
        }
      ],
      "fix": "None\n"
    },
    {
      "id": "python.docker.security.audit.docker-arbitrary-container-run.docker-arbitrary-container-run",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "$CLIENT = docker.from_env()\n...\n"
            },
            {
              "pattern-inside": "$CLIENT = docker.DockerClient(...)\n...\n"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern": "$CLIENT.containers.run(...)\n"
            },
            {
              "pattern": "$CLIENT.containers.create(...)\n"
            }
          ]
        },
        {
          "pattern-not": "$CLIENT.containers.run(\"...\",...)\n"
        },
        {
          "pattern-not": "$CLIENT.containers.create(\"...\",...)\n"
        }
      ],
      "message": "Passing unvalidated user input to Docker container creation or execution methods creates a severe security risk. Attackers can specify malicious container images or configuration, potentially gaining host system access. This vulnerability can lead to data theft, infrastructure compromise, or resource abuse.",
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "metadata": {
        "cwe": [
          "CWE-250: Execution with Unnecessary Privileges"
        ],
        "category": "security",
        "technology": [
          "docker"
        ],
        "references": [
          "https://cwe.mitre.org/data/definitions/250.html"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Arbitrary container execution via user input",
        "fix-suggestion": "Implement strict validation for all user inputs that influence Docker operations. Create an allowlist of permitted container images and configurations. Never pass user-controlled strings directly to `run()` or `create()` methods without thorough validation against predefined security policies."
      }
    },
    {
      "id": "python.fastapi.security.wildcard-cors.wildcard-cors",
      "languages": [
        "python"
      ],
      "message": "CORS policy is set to allow any origin with wildcard '*'. This completely bypasses Same-Origin security policy, allowing any website to make cross-origin requests to your API. Restrict CORS to specific trusted origins to maintain proper security boundaries.",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern": "[..., \"*\", ...]"
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$APP.add_middleware(\n  CORSMiddleware,\n  allow_origins=$ORIGIN,\n  ...);\n"
            },
            {
              "focus-metavariable": "$ORIGIN"
            }
          ]
        }
      ],
      "severity": "WARNING",
      "metadata": {
        "cwe": [
          "CWE-942: Permissive Cross-domain Policy with Untrusted Domains"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "category": "security",
        "technology": [
          "python",
          "fastapi"
        ],
        "references": [
          "https://owasp.org/Top10/A05_2021-Security_Misconfiguration",
          "https://cwe.mitre.org/data/definitions/942.html"
        ],
        "likelihood": "HIGH",
        "impact": "LOW",
        "confidence": "MEDIUM",
        "vulnerability_class": [
          "Configuration"
        ],
        "subcategory": [
          "vuln"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "short-description": "Insecure wildcard CORS configuration",
        "fix-suggestion": "Replace wildcard CORS setting (`origins=['*']`) with an explicit list of allowed origins like `origins=['https://trusted-site.com']`. Use environment variables to manage allowed origins across different deployment environments rather than hardcoding permissive settings."
      }
    },
    {
      "id": "python.flask.caching.query-string.flask-cache-query-string",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "@app.route(\"...\")\n@cache.cached(...)\ndef $HANDLER(...):\n  ...\n  request.args.get(...)\n"
            },
            {
              "pattern": "@app.route(\"...\", methods=[..., \"POST\", ...])\n@cache.cached(...)\ndef $HANDLER(...):\n  ...\n"
            },
            {
              "pattern": "@app.route(\"...\", methods=[..., \"PUT\", ...])\n@cache.cached(...)\ndef $HANDLER(...):\n  ...\n"
            },
            {
              "pattern": "@app.route(\"...\", methods=[..., \"DELETE\", ...])\n@cache.cached(...)\ndef $HANDLER(...):\n  ...\n"
            },
            {
              "pattern": "@app.route(\"...\", methods=[..., \"PATCH\", ...])\n@cache.cached(...)\ndef $HANDLER(...):\n  ...\n"
            }
          ]
        },
        {
          "pattern-not": "@app.route(\"...\")\n@cache.cached(..., query_string=True)\ndef $HANDLER(...):\n  ...\n  request.args.get(...)\n"
        }
      ],
      "message": "Flask-caching ignores query parameters by default, potentially causing incorrect behavior when different query strings should return different responses. Without proper configuration, users might receive cached responses intended for others. Additionally, caching state-changing operations can lead to data inconsistency.",
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "metadata": {
        "category": "caching",
        "technology": [
          "flask"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Cache misconfiguration ignores query parameters",
        "fix-suggestion": "Set `query_string=True` when configuring Flask-caching to include query parameters in cache keys. Never cache state-changing HTTP methods like POST, PUT, DELETE, or PATCH. Use the `unless` parameter to exclude sensitive endpoints from caching entirely."
      }
    },
    {
      "id": "python.flask.security.dangerous-template-string.dangerous-template-string",
      "message": "Creating templates through string formatting rather than template engines bypasses security protections against injection attacks. This practice enables server-side template injection, where attackers can execute arbitrary code. It also increases vulnerability to cross-site scripting through unescaped content.",
      "metadata": {
        "cwe": [
          "CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://nvisium.com/blog/2016/03/09/exploring-ssti-in-flask-jinja2.html",
          "https://pequalsnp-team.github.io/cheatsheet/flask-jinja2-ssti"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Template injection risk through string formatting",
        "fix-suggestion": "Use Flask's template engine with `render_template()` instead of string formatting. If dynamic templates are needed, use `render_template_string()` with trusted template sources only. Never interpolate user input directly into template strings without proper escaping and validation."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "pattern-either": [
        {
          "pattern": "$V = \"...\".format(...)\n...\nflask.render_template_string($V, ...)\n"
        },
        {
          "pattern": "$V = \"...\".format(...)\n...\nreturn flask.render_template_string($V, ...), $MORE\n"
        },
        {
          "pattern": "$V = \"...\" % $S\n...\nflask.render_template_string($V, ...)\n"
        },
        {
          "pattern": "$V = \"...\" % $S\n...\nreturn flask.render_template_string($V, ...), $MORE\n"
        },
        {
          "pattern": "$V = \"...\"\n...\n$V += $O\n...\nflask.render_template_string($V, ...)\n"
        },
        {
          "pattern": "$V = \"...\"\n...\n$V += $O\n...\nreturn flask.render_template_string($V, ...), $MORE\n"
        },
        {
          "pattern": "$V = f\"...{$X}...\"\n...\nflask.render_template_string($V, ...)\n"
        },
        {
          "pattern": "$V = f\"...{$X}...\"\n...\nreturn flask.render_template_string($V, ...), $CODE\n"
        }
      ]
    },
    {
      "id": "python.flask.security.flask-api-method-string-format.flask-api-method-string-format",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "def $METHOD(...,$ARG,...):\n  ...\n  $STRING = \"...\".format(...,$ARG,...)\n  ...\n  ... = requests.$REQMETHOD($STRING,...)\n"
            },
            {
              "pattern": "def $METHOD(...,$ARG,...):\n  ...\n  ... = requests.$REQMETHOD(\"...\".format(...,$ARG,...),...)\n"
            }
          ]
        },
        {
          "pattern-inside": "class $CLASS(...):\n  method_decorators = ...\n  ...\n"
        }
      ],
      "message": "Direct string formatting of user input into HTTP requests creates security vulnerabilities like request injection, SSRF, or protocol smuggling. Attackers can manipulate these values to send malicious requests from your server. This pattern bypasses URL validation and encoding protections.",
      "severity": "ERROR",
      "languages": [
        "python"
      ],
      "metadata": {
        "cwe": [
          "CWE-134: Use of Externally-Controlled Format String"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "references": [
          "https://cwe.mitre.org/data/definitions/134.html"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "Request injection through string-formatted URLs",
        "fix-suggestion": "Use the `params` or `json` parameters in requests methods rather than formatting URLs directly. Properly encode parameters with `urllib.parse.quote()` if necessary. Validate all user inputs against an allowlist before using them in any request construction."
      }
    },
    {
      "id": "python.flask.security.hashids-with-flask-secret.hashids-with-flask-secret",
      "languages": [
        "python"
      ],
      "message": "Using Flask's secret key as a salt for HashIDs creates a serious security vulnerability. HashIDs are not cryptographically secure, allowing attackers to recover the salt by observing multiple HashIDs. This can expose your Flask secret key, compromising session security and CSRF protection.",
      "metadata": {
        "category": "security",
        "subcategory": [
          "vuln"
        ],
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A02:2021 \u2013 Cryptographic Failures"
        ],
        "references": [
          "https://flask.palletsprojects.com/en/2.2.x/config/#SECRET_KEY",
          "http://carnage.github.io/2015/08/cryptanalysis-of-hashids"
        ],
        "technology": [
          "flask"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Flask secret key exposed through HashIDs",
        "fix-suggestion": "Create a separate dedicated secret for HashIDs using `secrets.token_hex()` and store it in your configuration. Never reuse your Flask `SECRET_KEY` for HashIDs salt. Consider using more secure identifiers like UUIDs with proper access controls instead of obfuscation."
      },
      "pattern-either": [
        {
          "pattern": "hashids.Hashids(..., salt=flask.current_app.config['SECRET_KEY'], ...)"
        },
        {
          "pattern": "hashids.Hashids(flask.current_app.config['SECRET_KEY'], ...)"
        },
        {
          "patterns": [
            {
              "pattern-inside": "$APP = flask.Flask(...)\n...\n"
            },
            {
              "pattern-either": [
                {
                  "pattern": "hashids.Hashids(..., salt=$APP.config['SECRET_KEY'], ...)"
                },
                {
                  "pattern": "hashids.Hashids($APP.config['SECRET_KEY'], ...)"
                }
              ]
            }
          ]
        }
      ],
      "severity": "ERROR"
    },
    {
      "id": "python.flask.security.insecure-deserialization.insecure-deserialization",
      "metadata": {
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "references": [
          "https://docs.python.org/3/library/pickle.html"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "Flask route using insecure deserialization can run arbitrary code",
        "fix-suggestion": "Replace unsafe deserialization methods with secure alternatives or validate input data thoroughly before deserialization."
      },
      "message": "Remote code execution vulnerabilities in Flask applications occur when unsafe deserialization methods like pickle process untrusted data from incoming requests. During deserialization, these methods can instantiate arbitrary Python objects and invoke their methods, allowing attackers to execute code through carefully crafted serialized data. This critical vulnerability can lead to complete application compromise, potentially allowing unauthorized access to sensitive data, service disruption, or server takeover depending on the application's privilege level.",
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "patterns": [
        {
          "pattern-inside": "@app.route(...)\ndef $X(...):\n  ...\n"
        },
        {
          "pattern-not": "$MODULE.$FUNC(\"...\")"
        },
        {
          "pattern-not": "$MODULE.$FUNC(open(\"...\", ...))"
        },
        {
          "pattern-either": [
            {
              "pattern": "pickle.$FUNC(...)"
            },
            {
              "pattern": "_pickle.$FUNC(...)"
            },
            {
              "pattern": "cPickle.$FUNC(...)"
            },
            {
              "pattern": "dill.$FUNC(...)"
            },
            {
              "pattern": "shelve.$FUNC(...)"
            },
            {
              "pattern": "yaml.load(...)"
            }
          ]
        }
      ]
    },
    {
      "id": "python.flask.security.open-redirect.open-redirect",
      "patterns": [
        {
          "pattern-inside": "@$APP.route(...)\ndef $X(...):\n  ...\n"
        },
        {
          "pattern-not-inside": "@$APP.route(...)\ndef $X(...):\n  ...\n  if <... werkzeug.urls.url_parse($V) ...>:\n    ...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "flask.redirect(<... flask.request.$W.get(...) ...>, ...)"
            },
            {
              "pattern": "flask.redirect(<... flask.request.$W[...] ...>, ...)"
            },
            {
              "pattern": "flask.redirect(<... flask.request.$W(...) ...>, ...)"
            },
            {
              "pattern": "flask.redirect(<... flask.request.$W ...>, ...)"
            },
            {
              "pattern": "$V = flask.request.$W.get(...)\n...\nflask.redirect(<... $V ...>, ...)\n"
            },
            {
              "pattern": "$V = flask.request.$W[...]\n...\nflask.redirect(<... $V ...>, ...)\n"
            },
            {
              "pattern": "$V = flask.request.$W(...)\n...\nflask.redirect(<... $V ...>, ...)\n"
            },
            {
              "pattern": "$V = flask.request.$W\n...\nflask.redirect(<... $V ...>, ...)\n"
            }
          ]
        },
        {
          "pattern-not": "flask.redirect(flask.request.path)"
        },
        {
          "pattern-not": "flask.redirect(flask.request.path + ...)"
        },
        {
          "pattern-not": "flask.redirect(f\"{flask.request.path}...\")"
        }
      ],
      "message": "Unvalidated redirects allow attackers to create links that appear legitimate but send users to malicious sites. When user input directly influences redirect destinations, attackers can exploit your domain's trust for phishing campaigns. This vulnerability enables credential theft and social engineering attacks.",
      "metadata": {
        "cwe": [
          "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "references": [
          "https://flask-login.readthedocs.io/en/latest/#login-example",
          "https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html#dangerous-url-redirect-example-1",
          "https://docs.python.org/3/library/urllib.parse.html#url-parsing"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Open Redirect"
        ],
        "short-description": "Unvalidated redirect to user-controlled URL",
        "fix-suggestion": "Use Flask's `url_for()` to generate internal redirect URLs whenever possible. For external redirects, validate all URLs using `urllib.parse` to ensure they point to trusted domains. Implement an allowlist of permitted external domains rather than trying to block malicious ones."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR"
    },
    {
      "id": "python.flask.security.unescaped-template-extension.unescaped-template-extension",
      "message": "Cross-site scripting (XSS) vulnerabilities in Flask applications arise when templates with non-standard extensions aren't automatically HTML-escaped by Jinja2. Flask only configures autoescaping for files with .html, .htm, .xml, and .xhtml extensions, leaving other extensions vulnerable to XSS. When these unescaped templates contain user-controlled content with malicious HTML or JavaScript, it executes in users' browsers with the application's privileges, potentially leading to session hijacking or unauthorized actions.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "source-rule-url": "https://pypi.org/project/flake8-flask/",
        "references": [
          "https://flask.palletsprojects.com/en/1.1.x/templating/#jinja-setup",
          "https://semgrep.dev/blog/2020/bento-check-unescaped-template-extensions-in-flask/",
          "https://bento.dev/checks/flask/unescaped-file-extension/"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Non-HTML template extension bypasses autoescape, risking XSS",
        "fix-suggestion": "Ensure that templates with non-standard extensions are configured to `autoescape` or manually escape user input."
      },
      "patterns": [
        {
          "pattern-not": "flask.render_template(\"=~/.+\\.html$/\", ...)"
        },
        {
          "pattern-not": "flask.render_template(\"=~/.+\\.xml$/\", ...)"
        },
        {
          "pattern-not": "flask.render_template(\"=~/.+\\.htm$/\", ...)"
        },
        {
          "pattern-not": "flask.render_template(\"=~/.+\\.xhtml$/\", ...)"
        },
        {
          "pattern-not": "flask.render_template($X + \"=~/\\.html$/\", ...)"
        },
        {
          "pattern-not": "flask.render_template($X + \"=~/\\.xml$/\", ...)"
        },
        {
          "pattern-not": "flask.render_template($X + \"=~/\\.htm$/\", ...)"
        },
        {
          "pattern-not": "flask.render_template($X + \"=~/\\.xhtml$/\", ...)"
        },
        {
          "pattern-not": "flask.render_template(\"=~/.+\\.html$/\" % $X, ...)"
        },
        {
          "pattern-not": "flask.render_template(\"=~/.+\\.xml$/\" % $X, ...)"
        },
        {
          "pattern-not": "flask.render_template(\"=~/.+\\.htm$/\" % $X, ...)"
        },
        {
          "pattern-not": "flask.render_template(\"=~/.+\\.xhtml$/\" % $X, ...)"
        },
        {
          "pattern-not": "flask.render_template(\"=~/.+\\.html$/\".format(...), ...)"
        },
        {
          "pattern-not": "flask.render_template(\"=~/.+\\.xml$/\".format(...), ...)"
        },
        {
          "pattern-not": "flask.render_template(\"=~/.+\\.htm$/\".format(...), ...)"
        },
        {
          "pattern-not": "flask.render_template(\"=~/.+\\.xhtml$/\".format(...), ...)"
        },
        {
          "pattern-not": "flask.render_template($TEMPLATE)"
        },
        {
          "pattern-either": [
            {
              "pattern": "flask.render_template(\"...\", ...)"
            },
            {
              "pattern": "flask.render_template($X + \"...\", ...)"
            },
            {
              "pattern": "flask.render_template(\"...\" % $Y, ...)"
            },
            {
              "pattern": "flask.render_template(\"...\".format(...), ...)"
            }
          ]
        }
      ],
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.flask.security.audit.debug-enabled.debug-enabled",
      "patterns": [
        {
          "pattern-inside": "import flask\n...\n"
        },
        {
          "pattern": "$APP.run(..., debug=True, ...)"
        }
      ],
      "message": "Enabling debug mode in production Flask applications exposes sensitive information through detailed error pages. These pages reveal source code, configuration details, and stack traces that help attackers understand your application architecture. Debug mode also enables the interactive debugger, creating a potential code execution risk.",
      "metadata": {
        "cwe": [
          "CWE-489: Active Debug Code"
        ],
        "owasp": "A06:2017 - Security Misconfiguration",
        "references": [
          "https://labs.detectify.com/2015/10/02/how-patreon-got-hacked-publicly-exposed-werkzeug-debugger/"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Active Debug Code"
        ],
        "short-description": "Production Flask app with debug mode enabled",
        "fix-suggestion": "Remove hardcoded `debug=True` from your Flask application. Use environment variables to control debug settings with `app.debug = os.environ.get('FLASK_DEBUG', False)`. Configure a proper production WSGI server that doesn't expose detailed errors to end users."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ]
    },
    {
      "id": "python.flask.security.audit.directly-returned-format-string.directly-returned-format-string",
      "message": "This vulnerability occurs when a Flask route directly returns a string that includes user input through string formatting or concatenation. The user input doesn't get properly escaped when inserted into HTML, allowing attackers to inject malicious scripts. This can lead to cross-site scripting (XSS) attacks that could steal cookies, session tokens, or execute arbitrary JavaScript in users' browsers.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Returning dynamic format strings can allow script injection",
        "fix-suggestion": "Avoid returning formatted strings that include unsanitized user input; use template rendering with proper escaping."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-inside": "@$APP.route(...)\ndef $FUNC(..., $PARAM, ...):\n  ...\n"
                },
                {
                  "pattern": "$PARAM"
                }
              ]
            },
            {
              "pattern": "request.$FUNC.get(...)\n"
            },
            {
              "pattern": "request.$FUNC(...)\n"
            },
            {
              "pattern": "request.$FUNC[...]"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-not-inside": "return \"...\""
            },
            {
              "pattern-either": [
                {
                  "pattern": "return \"...\".format(...)"
                },
                {
                  "pattern": "return \"...\" % ..."
                },
                {
                  "pattern": "return \"...\" + ..."
                },
                {
                  "pattern": "return ... + \"...\""
                },
                {
                  "pattern": "return f\"...{...}...\""
                },
                {
                  "patterns": [
                    {
                      "pattern": "return $X"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$X = \"...\".format(...)\n...\n"
                        },
                        {
                          "pattern-inside": "$X = \"...\" % ...\n...\n"
                        },
                        {
                          "pattern-inside": "$X = \"...\" + ...\n...\n"
                        },
                        {
                          "pattern-inside": "$X = ... + \"...\"\n...\n"
                        },
                        {
                          "pattern-inside": "$X = f\"...{...}...\"\n...\n"
                        }
                      ]
                    },
                    {
                      "pattern-not-inside": "$X = \"...\"\n...\n"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "python.flask.security.audit.render-template-string.render-template-string",
      "pattern": "flask.render_template_string(...)",
      "metadata": {
        "cwe": [
          "CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://nvisium.com/blog/2016/03/09/exploring-ssti-in-flask-jinja2.html"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Template injection through string formatting",
        "fix-suggestion": "Use Flask's `render_template()` with separate template files instead of dynamic string templates. If dynamic templates are required, use `render_template_string()` with templates from trusted sources. Never incorporate user input directly into templates without proper escaping."
      },
      "message": "Using string formatting to create templates opens your application to server-side template injection vulnerabilities. If user input influences these templates, attackers can potentially execute arbitrary code. This bypasses the security protections built into Flask's template engine.",
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.flask.security.audit.secure-set-cookie.secure-set-cookie",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "$RESP = flask.make_response(...)\n...\n"
            },
            {
              "pattern-inside": "$RESP = flask.Response(...)\n...\n"
            }
          ]
        },
        {
          "pattern-not": "$RESP.set_cookie(..., secure=$A, httponly=$B, samesite=$C, ...)"
        },
        {
          "pattern-not": "$RESP.set_cookie(..., **$A)"
        },
        {
          "pattern": "$RESP.set_cookie(...)"
        }
      ],
      "message": "Insecurely configured cookies can be intercepted, stolen, or manipulated by attackers. Cookies without the secure, httponly, and samesite flags are vulnerable to various attacks including session hijacking and cross-site request forgery. Proper cookie configuration is essential for maintaining secure user sessions.",
      "metadata": {
        "cwe": [
          "CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "references": [
          "https://flask.palletsprojects.com/en/3.0.x/api/#flask.Response.set_cookie",
          "https://flask.palletsprojects.com/en/3.0.x/security/#set-cookie-options"
        ],
        "category": "security",
        "technology": [
          "python",
          "flask"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "functional-categories": [
          "web::search::cookie-config::flask"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cookie Security"
        ],
        "short-description": "Insecure cookie configuration in Flask response",
        "fix-suggestion": "Always set cookies with `secure=True`, `httponly=True`, and `samesite='Lax'` parameters in all `response.set_cookie()` calls. Configure Flask's session cookie defaults in your application config with `SESSION_COOKIE_SECURE=True`, `SESSION_COOKIE_HTTPONLY=True`, and `SESSION_COOKIE_SAMESITE='Lax'`."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.flask.security.audit.app-run-param-config.avoid_app_run_with_bad_host",
      "message": "Binding a Flask application to 0.0.0.0 makes it accessible from any network interface, potentially exposing it to the internet. This can lead to unauthorized access if proper network security is not in place. Development servers should typically only bind to localhost for security.",
      "metadata": {
        "cwe": [
          "CWE-668: Exposure of Resource to Wrong Sphere"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Flask app exposed on all network interfaces",
        "fix-suggestion": "Change the host parameter from `0.0.0.0` to `127.0.0.1` or `localhost` for development environments. Use a production WSGI server behind a proper reverse proxy for production deployments. Implement additional security layers including authentication, firewalls, and HTTPS if public exposure is necessary."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "app.run(..., host=\"0.0.0.0\", ...)"
        },
        {
          "pattern": "app.run(..., \"0.0.0.0\", ...)"
        }
      ]
    },
    {
      "id": "python.flask.security.audit.app-run-security-config.avoid_using_app_run_directly",
      "patterns": [
        {
          "pattern-not-inside": "if __name__ == '__main__':\n  ...\n"
        },
        {
          "pattern-not-inside": "def $X(...):\n  ...\n"
        },
        {
          "pattern": "app.run(...)"
        }
      ],
      "message": "Using `app.run()` directly at the module level of a Flask application can cause unexpected behavior. This code is executed when the module is imported, potentially running the server in unintended contexts. It also prevents proper configuration of production deployment options.",
      "metadata": {
        "cwe": [
          "CWE-668: Exposure of Resource to Wrong Sphere"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Unguarded Flask app.run() at module level",
        "fix-suggestion": "Wrap the `app.run()` call in an `if __name__ == '__main__':` guard to ensure it only runs when the script is executed directly. Consider using environment variables for configuration parameters. For production, use WSGI servers like Gunicorn instead of the development server."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.flask.security.audit.hardcoded-config.avoid_hardcoded_config_DEBUG",
      "message": "Hardcoding debug settings creates security risks when code moves between environments. Debug mode enables verbose error messages and interactive debugging, potentially exposing sensitive information to attackers. Configuration should adapt to deployment environments rather than being embedded in code.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "category": "security",
        "cwe": [
          "CWE-489: Active Debug Code"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "references": [
          "https://bento.dev/checks/flask/avoid-hardcoded-config/",
          "https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#builtin-configuration-values",
          "https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#environment-and-debug-features"
        ],
        "subcategory": [
          "audit"
        ],
        "technology": [
          "flask"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Active Debug Code"
        ],
        "short-description": "Hardcoded DEBUG flag in Flask configuration",
        "fix-suggestion": "Replace hardcoded `DEBUG` settings with environment variable configuration using `os.environ.get('FLASK_DEBUG', False)`. Use application factory patterns to configure Flask apps from environment values. Keep debug mode disabled by default and only enable explicitly in development environments."
      },
      "languages": [
        "python"
      ],
      "pattern-either": [
        {
          "pattern": "$M.update(DEBUG=True)"
        },
        {
          "pattern": "$M.update(DEBUG=False)"
        },
        {
          "pattern": "$M.config['DEBUG'] = True"
        },
        {
          "pattern": "$M.config['DEBUG'] = False"
        }
      ]
    },
    {
      "id": "python.flask.security.audit.hardcoded-config.avoid_hardcoded_config_ENV",
      "message": "Hardcoding the Flask environment setting prevents proper environmental isolation and adaptation. This creates deployment friction and security risks when code moves between development and production. Environment-specific configuration should be externalized for reliable deployment.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "category": "security",
        "cwe": [
          "CWE-489: Active Debug Code"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "references": [
          "https://bento.dev/checks/flask/avoid-hardcoded-config/",
          "https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#builtin-configuration-values",
          "https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#environment-and-debug-features"
        ],
        "subcategory": [
          "audit"
        ],
        "technology": [
          "flask"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Active Debug Code"
        ],
        "short-description": "Hardcoded environment setting in Flask app",
        "fix-suggestion": "Replace hardcoded `ENV` settings with environment variable configuration using `os.environ.get('FLASK_ENV', 'production')`. Use application factory patterns to configure Flask apps from environment values. Always default to 'production' for safety and explicitly set 'development' only when needed."
      },
      "languages": [
        "python"
      ],
      "pattern-either": [
        {
          "pattern": "$M.update(ENV=\"=~/^development|production$/\")"
        },
        {
          "pattern": "$M.config['ENV'] = \"=~/^development|production$/\""
        }
      ]
    },
    {
      "id": "python.flask.security.audit.hardcoded-config.avoid_hardcoded_config_SECRET_KEY",
      "message": "Hardcoding SECRET_KEY values in source code exposes critical secrets in version control and deployment packages. This key secures sessions, CSRF tokens, and other security mechanisms in Flask applications. If compromised, attackers can forge sessions and bypass security protections.",
      "severity": "ERROR",
      "metadata": {
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "category": "security",
        "cwe": [
          "CWE-489: Active Debug Code"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "references": [
          "https://bento.dev/checks/flask/avoid-hardcoded-config/",
          "https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#builtin-configuration-values",
          "https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#environment-and-debug-features"
        ],
        "subcategory": [
          "audit"
        ],
        "technology": [
          "flask"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Active Debug Code"
        ],
        "short-description": "Secret key hardcoded in Flask application",
        "fix-suggestion": "Remove hardcoded `SECRET_KEY` values and load them from environment variables with `os.environ.get('SECRET_KEY')`. Generate strong random keys using `secrets.token_hex(16)`. For development, use a local environment file (`.env`) that's excluded from version control."
      },
      "languages": [
        "python"
      ],
      "pattern-either": [
        {
          "pattern": "$M.update(SECRET_KEY=\"=~/.*/\")"
        },
        {
          "pattern": "$M.config['SECRET_KEY'] = \"=~/.*/\""
        }
      ]
    },
    {
      "id": "python.flask.security.audit.hardcoded-config.avoid_hardcoded_config_TESTING",
      "message": "Hardcoding testing configuration flags in application code creates risks when deploying to production. Testing settings may disable security features or alter application behavior in ways that weaken security. Configuration should be environment-specific and externalized.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "category": "security",
        "cwe": [
          "CWE-489: Active Debug Code"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "references": [
          "https://bento.dev/checks/flask/avoid-hardcoded-config/",
          "https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#builtin-configuration-values",
          "https://flask.palletsprojects.com/en/1.1.x/config/?highlight=configuration#environment-and-debug-features"
        ],
        "subcategory": [
          "audit"
        ],
        "technology": [
          "flask"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Active Debug Code"
        ],
        "short-description": "Hardcoded TESTING flag in Flask configuration",
        "fix-suggestion": "Replace hardcoded `TESTING` values with environment variable configuration using `os.environ.get('FLASK_TESTING', False)`. Implement separate configuration classes for different environments. Use application factories to apply the appropriate configuration based on the deployment context."
      },
      "languages": [
        "python"
      ],
      "pattern-either": [
        {
          "pattern": "$M.config['TESTING'] = True"
        },
        {
          "pattern": "$M.config['TESTING'] = False"
        },
        {
          "pattern": "$M.update(TESTING=True, ...)"
        },
        {
          "pattern": "$M.update(TESTING=False, ...)"
        }
      ]
    },
    {
      "id": "python.flask.security.audit.wtf-csrf-disabled.flask-wtf-csrf-disabled",
      "message": "This vulnerability happens when the WTF_CSRF_ENABLED setting is explicitly set to False in Flask-WTF, disabling Cross-Site Request Forgery protections. Without CSRF protection, attackers can trick authenticated users into submitting malicious requests by creating forged forms or links. These attacks can lead to unauthorized actions being performed on behalf of users, such as changing account settings, making purchases, or deleting data.",
      "options": {
        "symbolic_propagation": true
      },
      "metadata": {
        "cwe": [
          "CWE-352: Cross-Site Request Forgery (CSRF)"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "references": [
          "https://flask-wtf.readthedocs.io/en/1.2.x/csrf/"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "functional-categories": [
          "web::search::csrf-config::flask",
          "web::search::csrf-config::flask-wtf"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site Request Forgery (CSRF)"
        ],
        "short-description": "CSRF disabled in Flask-WTF, exposing forms to cross-site attacks",
        "fix-suggestion": "Enable CSRF protection in Flask-WTF by setting `WTF_CSRF_ENABLED` to `True` to secure forms against forgery."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "$APP.config[\"WTF_CSRF_ENABLED\"] = $FALSE"
                    },
                    {
                      "pattern": "$APP.config.WTF_CSRF_ENABLED = $FALSE"
                    },
                    {
                      "patterns": [
                        {
                          "pattern": "$APP.config.$UPDATE(\n  ...,\n  WTF_CSRF_ENABLED = $FALSE,\n  ...\n)\n"
                        },
                        {
                          "pattern-not-inside": "$APP.config.$UPDATE(\n    ...,\n    TESTING=True,\n    ...\n)\n"
                        },
                        {
                          "pattern-not-inside": "$APP.config.$UPDATE(\n    ...,\n    DEBUG=True,\n    ...\n)\n"
                        },
                        {
                          "metavariable-regex": {
                            "metavariable": "$UPDATE",
                            "regex": "^(update|from_mapping)$"
                          }
                        }
                      ]
                    },
                    {
                      "pattern": "$OBJ = $CLASS()\n...\n$OBJ.WTF_CSRF_ENABLED = $FALSE\n...\n$APP.config.from_object($OBJ, ...)\n"
                    },
                    {
                      "pattern": "WTF_CSRF_ENABLED = $FALSE\n...\n$APP.config.from_object(__name__)\n"
                    }
                  ]
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$FALSE",
                    "regex": "^(False)$"
                  }
                },
                {
                  "focus-metavariable": "$FALSE"
                }
              ]
            }
          ]
        }
      ],
      "fix": "True"
    },
    {
      "id": "python.flask.security.audit.xss.make-response-with-unknown-content.make-response-with-unknown-content",
      "patterns": [
        {
          "pattern": "flask.make_response(...)"
        },
        {
          "pattern-not-inside": "flask.make_response()"
        },
        {
          "pattern-not-inside": "flask.make_response(\"...\", ...)"
        },
        {
          "pattern-not-inside": "flask.make_response({\"...\": \"...\"}, ...)"
        },
        {
          "pattern-not-inside": "flask.make_response(flask.redirect(...), ...)"
        },
        {
          "pattern-not-inside": "flask.make_response(flask.render_template(...), ...)"
        },
        {
          "pattern-not-inside": "flask.make_response(flask.jsonify(...), ...)"
        },
        {
          "pattern-not-inside": "flask.make_response(json.dumps(...), ...)"
        },
        {
          "pattern-not-inside": "$X = flask.render_template(...)\n...\nflask.make_response($X, ...)\n"
        },
        {
          "pattern-not-inside": "$X = flask.jsonify(...)\n...\nflask.make_response($X, ...)\n"
        },
        {
          "pattern-not-inside": "$X = json.dumps(...)\n...\nflask.make_response($X, ...)\n"
        }
      ],
      "message": "This vulnerability occurs when flask.make_response() is used to return HTML content directly instead of using template rendering. Since make_response() doesn't automatically escape potentially dangerous content, user-controlled data can be rendered as active HTML or JavaScript. This can result in cross-site scripting (XSS) attacks where attackers execute malicious scripts in the context of other users' sessions.",
      "severity": "WARNING",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "references": [
          "https://github.com/python-security/pyt//blob/093a077bcf12d1f58ddeb2d73ddc096623985fb0/examples/vulnerable_code/XSS_assign_to_other_var.py#L11",
          "https://flask.palletsprojects.com/en/1.1.x/api/#flask.Flask.make_response",
          "https://flask.palletsprojects.com/en/1.1.x/api/#response-objects"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "make_response returning HTML bypasses escaping, can cause XSS",
        "fix-suggestion": "Use Flask's template rendering with autoescaping instead of directly constructing responses that include unescaped user input."
      },
      "languages": [
        "python"
      ]
    },
    {
      "id": "python.flask.security.injection.nan-injection.nan-injection",
      "message": "Direct conversion of user input to floating-point types allows attackers to inject NaN values. Not-a-Number values behave unpredictably in comparisons and calculations, potentially leading to security vulnerabilities. This can cause logic errors or bypass validation checks in your application.",
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern-either": [
            {
              "pattern": "flask.request.$SOMETHING.get(...)"
            },
            {
              "pattern": "flask.request.$SOMETHING[...]"
            },
            {
              "patterns": [
                {
                  "pattern-inside": "@$APP.route(...)\ndef $FUNC(..., $ROUTEVAR, ...):\n  ...\n"
                },
                {
                  "pattern": "$ROUTEVAR"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "pattern-either": [
            {
              "pattern": "float(...)"
            },
            {
              "pattern": "bool(...)"
            },
            {
              "pattern": "complex(...)"
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "not_conflicting": true,
          "pattern": "$ANYTHING(...)"
        }
      ],
      "metadata": {
        "references": [
          "https://discuss.python.org/t/nan-breaks-min-max-and-sorting-functions-a-solution/2868",
          "https://blog.bitdiscovery.com/2021/12/python-nan-injection/"
        ],
        "category": "security",
        "cwe": [
          "CWE-704: Incorrect Type Conversion or Cast"
        ],
        "technology": [
          "flask"
        ],
        "subcategory": [
          "vuln"
        ],
        "impact": "MEDIUM",
        "likelihood": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "NaN injection through unchecked numeric conversion",
        "fix-suggestion": "Validate user input before converting to numeric types by checking for 'NaN' in various capitalizations. Consider using a custom validation function that rejects problematic inputs. When possible, use integer conversion instead of floating-point to avoid NaN-related vulnerabilities entirely."
      }
    },
    {
      "id": "python.flask.security.injection.os-system-injection.os-system-injection",
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "message": "This vulnerability happens when user input is directly passed to os.system() in a Flask application without proper validation or sanitization. Attackers can inject shell metacharacters or command separators to execute arbitrary commands on the server. This can lead to complete system compromise, data theft, or service disruption.",
      "metadata": {
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/www-community/attacks/Command_Injection"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Flask route with os.system usage is command-injection risk",
        "fix-suggestion": "Do not pass user input directly to `os.system`; use safer process execution methods and validate inputs rigorously."
      },
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern": "os.system(...)"
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "@$APP.route($ROUTE, ...)\ndef $FUNC(..., $ROUTEVAR, ...):\n  ...\n  os.system(..., <... $ROUTEVAR ...>, ...)\n"
                },
                {
                  "pattern-inside": "@$APP.route($ROUTE, ...)\ndef $FUNC(..., $ROUTEVAR, ...):\n  ...\n  $INTERM = <... $ROUTEVAR ...>\n  ...\n  os.system(..., <... $INTERM ...>, ...)\n"
                }
              ]
            }
          ]
        },
        {
          "pattern": "os.system(..., <... flask.request.$W.get(...) ...>, ...)"
        },
        {
          "pattern": "os.system(..., <... flask.request.$W[...] ...>, ...)"
        },
        {
          "pattern": "os.system(..., <... flask.request.$W(...) ...>, ...)"
        },
        {
          "pattern": "os.system(..., <... flask.request.$W ...>, ...)"
        },
        {
          "patterns": [
            {
              "pattern-inside": "$INTERM = <... flask.request.$W.get(...) ...>\n...\nos.system(<... $INTERM ...>)\n"
            },
            {
              "pattern": "os.system(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$INTERM = <... flask.request.$W[...] ...>\n...\nos.system(<... $INTERM ...>)\n"
            },
            {
              "pattern": "os.system(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$INTERM = <... flask.request.$W(...) ...>\n...\nos.system(<... $INTERM ...>)\n"
            },
            {
              "pattern": "os.system(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$INTERM = <... flask.request.$W ...>\n...\nos.system(<... $INTERM ...>)\n"
            },
            {
              "pattern": "os.system(...)"
            }
          ]
        }
      ]
    },
    {
      "id": "python.flask.security.injection.path-traversal-open.path-traversal-open",
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "message": "This vulnerability occurs when a Flask application uses unsanitized user input in file paths for open() operations. Attackers can exploit this by including path traversal sequences like '../' to access files outside the intended directory. This can lead to unauthorized access to sensitive files such as configuration files, password files, or other confidential data stored on the server.",
      "metadata": {
        "cwe": [
          "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
        ],
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "references": [
          "https://owasp.org/www-community/attacks/Path_Traversal"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "short-description": "open with user-supplied path in Flask can allow traversal",
        "fix-suggestion": "Sanitize file paths in `open()` calls by validating user input and enforcing directory boundaries."
      },
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern": "open(...)"
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "@$APP.route($ROUTE, ...)\ndef $FUNC(..., $ROUTEVAR, ...):\n  ...\n  open(..., <... $ROUTEVAR ...>, ...)\n"
                },
                {
                  "pattern-inside": "@$APP.route($ROUTE, ...)\ndef $FUNC(..., $ROUTEVAR, ...):\n  ...\n  with open(..., <... $ROUTEVAR ...>, ...) as $FD:\n    ...\n"
                },
                {
                  "pattern-inside": "@$APP.route($ROUTE, ...)\ndef $FUNC(..., $ROUTEVAR, ...):\n  ...\n  $INTERM = <... $ROUTEVAR ...>\n  ...\n  open(..., <... $INTERM ...>, ...)\n"
                }
              ]
            }
          ]
        },
        {
          "pattern": "open(..., <... flask.request.$W.get(...) ...>, ...)"
        },
        {
          "pattern": "open(..., <... flask.request.$W[...] ...>, ...)"
        },
        {
          "pattern": "open(..., <... flask.request.$W(...) ...>, ...)"
        },
        {
          "pattern": "open(..., <... flask.request.$W ...>, ...)"
        },
        {
          "patterns": [
            {
              "pattern-inside": "$INTERM = <... flask.request.$W.get(...) ...>\n...\nopen(<... $INTERM ...>, ...)\n"
            },
            {
              "pattern": "open(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$INTERM = <... flask.request.$W[...] ...>\n...\nopen(<... $INTERM ...>, ...)\n"
            },
            {
              "pattern": "open(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$INTERM = <... flask.request.$W(...) ...>\n...\nopen(<... $INTERM ...>, ...)\n"
            },
            {
              "pattern": "open(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$INTERM = <... flask.request.$W ...>\n...\nopen(<... $INTERM ...>, ...)\n"
            },
            {
              "pattern": "open(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$INTERM = <... flask.request.$W.get(...) ...>\n...\nwith open(<... $INTERM ...>, ...) as $F:\n  ...\n"
            },
            {
              "pattern": "open(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$INTERM = <... flask.request.$W[...] ...>\n...\nwith open(<... $INTERM ...>, ...) as $F:\n  ...\n"
            },
            {
              "pattern": "open(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$INTERM = <... flask.request.$W(...) ...>\n...\nwith open(<... $INTERM ...>, ...) as $F:\n  ...\n"
            },
            {
              "pattern": "open(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$INTERM = <... flask.request.$W ...>\n...\nwith open(<... $INTERM ...>, ...) as $F:\n  ...\n"
            },
            {
              "pattern": "open(...)"
            }
          ]
        }
      ]
    },
    {
      "id": "python.flask.security.injection.ssrf-requests.ssrf-requests",
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "message": "This vulnerability happens when user input directly influences URLs for outgoing server requests in a Flask application. Attackers can manipulate these inputs to make the server connect to internal services or external malicious servers. The consequences include potential access to internal networks, data exfiltration, or using the server as a proxy to attack other systems.",
      "metadata": {
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "references": [
          "https://owasp.org/www-community/attacks/Server_Side_Request_Forgery"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "Requests call with unvalidated user input can do SSRF",
        "fix-suggestion": "Ensure that URLs used in outgoing server requests are validated against an allowlist to prevent SSRF vulnerabilities."
      },
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern": "requests.$FUNC(...)"
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "@$APP.$ROUTE_METHOD($ROUTE, ...)\ndef $ROUTE_FUNC(..., $ROUTEVAR, ...):\n  ...\n  requests.$FUNC(..., <... $ROUTEVAR ...>, ...)\n"
                },
                {
                  "pattern-inside": "@$APP.$ROUTE_METHOD($ROUTE, ...)\ndef $ROUTE_FUNC(..., $ROUTEVAR, ...):\n  ...\n  $INTERM = <... $ROUTEVAR ...>\n  ...\n  requests.$FUNC(..., <... $INTERM ...>, ...)\n"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$ROUTE_METHOD",
                "regex": "^(route|get|post|put|delete|patch)$"
              }
            }
          ]
        },
        {
          "pattern": "requests.$FUNC(..., <... flask.request.$W.get(...) ...>, ...)"
        },
        {
          "pattern": "requests.$FUNC(..., <... flask.request.$W[...] ...>, ...)"
        },
        {
          "pattern": "requests.$FUNC(..., <... flask.request.$W(...) ...>, ...)"
        },
        {
          "pattern": "requests.$FUNC(..., <... flask.request.$W ...>, ...)"
        },
        {
          "patterns": [
            {
              "pattern-inside": "$INTERM = <... flask.request.$W.get(...) ...>\n...\nrequests.$FUNC(<... $INTERM ...>, ...)\n"
            },
            {
              "pattern": "requests.$FUNC(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$INTERM = <... flask.request.$W[...] ...>\n...\nrequests.$FUNC(<... $INTERM ...>, ...)\n"
            },
            {
              "pattern": "requests.$FUNC(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$INTERM = <... flask.request.$W(...) ...>\n...\nrequests.$FUNC(<... $INTERM ...>, ...)\n"
            },
            {
              "pattern": "requests.$FUNC(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$INTERM = <... flask.request.$W ...>\n...\nrequests.$FUNC(<... $INTERM ...>, ...)\n"
            },
            {
              "pattern": "requests.$FUNC(...)"
            }
          ]
        }
      ]
    },
    {
      "id": "python.flask.security.injection.subprocess-injection.subprocess-injection",
      "languages": [
        "python"
      ],
      "mode": "taint",
      "options": {
        "symbolic_propagation": true
      },
      "pattern-sources": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "flask.request.form.get(...)"
                    },
                    {
                      "pattern": "flask.request.form[...]"
                    },
                    {
                      "pattern": "flask.request.args.get(...)"
                    },
                    {
                      "pattern": "flask.request.args[...]"
                    },
                    {
                      "pattern": "flask.request.values.get(...)"
                    },
                    {
                      "pattern": "flask.request.values[...]"
                    },
                    {
                      "pattern": "flask.request.cookies.get(...)"
                    },
                    {
                      "pattern": "flask.request.cookies[...]"
                    },
                    {
                      "pattern": "flask.request.stream"
                    },
                    {
                      "pattern": "flask.request.headers.get(...)"
                    },
                    {
                      "pattern": "flask.request.headers[...]"
                    },
                    {
                      "pattern": "flask.request.data"
                    },
                    {
                      "pattern": "flask.request.full_path"
                    },
                    {
                      "pattern": "flask.request.url"
                    },
                    {
                      "pattern": "flask.request.json"
                    },
                    {
                      "pattern": "flask.request.get_json()"
                    },
                    {
                      "pattern": "flask.request.view_args.get(...)"
                    },
                    {
                      "pattern": "flask.request.view_args[...]"
                    }
                  ]
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-inside": "@$APP.route($ROUTE, ...)\ndef $FUNC(..., $ROUTEVAR, ...):\n  ...\n"
                },
                {
                  "focus-metavariable": "$ROUTEVAR"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern": "subprocess.$FUNC(...)"
                    },
                    {
                      "pattern-not": "subprocess.$FUNC(\"...\", ...)"
                    },
                    {
                      "pattern-not": "subprocess.$FUNC([\"...\", ...], ...)"
                    },
                    {
                      "pattern-not-inside": "$CMD = [\"...\", ...]\n...\nsubprocess.$FUNC($CMD, ...)\n"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "subprocess.$FUNC([\"$SHELL\", \"-c\", ...], ...)"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$SHELL",
                        "regex": "^(sh|bash|ksh|csh|tcsh|zsh)$"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "subprocess.$FUNC([\"$INTERPRETER\", ...], ...)"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$INTERPRETER",
                        "regex": "^(python|python\\d)$"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern": "$DICT[$KEY]"
            },
            {
              "focus-metavariable": "$KEY"
            }
          ]
        }
      ],
      "severity": "ERROR",
      "message": "This vulnerability occurs when unsanitized user input is passed to subprocess functions in a Flask application. Attackers can inject shell metacharacters to execute arbitrary commands on the server beyond what was intended. This can lead to complete compromise of the server, data theft, or service disruption.",
      "metadata": {
        "category": "security",
        "technology": [
          "flask"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "references": [
          "https://semgrep.dev/docs/cheat-sheets/python-command-injection/"
        ],
        "confidence": "HIGH",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "User data in subprocess calls leads to command injection",
        "fix-suggestion": "Use `subprocess` functions with safe argument lists and validate all user input to prevent command injection."
      }
    },
    {
      "id": "python.flask.security.injection.tainted-sql-string.tainted-sql-string",
      "message": "Constructing SQL queries by concatenating or formatting strings with user input creates SQL injection vulnerabilities. Attackers can insert malicious SQL code to access unauthorized data, modify databases, or execute commands. SQL injection remains one of the most common and dangerous web application flaws.",
      "metadata": {
        "cwe": [
          "CWE-704: Incorrect Type Conversion or Cast"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.sqlalchemy.org/en/14/core/tutorial.html#using-textual-sql",
          "https://www.tutorialspoint.com/sqlalchemy/sqlalchemy_quick_guide.htm",
          "https://docs.sqlalchemy.org/en/14/core/tutorial.html#using-more-specific-text-with-table-expression-literal-column-and-expression-column"
        ],
        "category": "security",
        "technology": [
          "sqlalchemy",
          "flask"
        ],
        "subcategory": [
          "vuln"
        ],
        "impact": "MEDIUM",
        "likelihood": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "SQL injection through string-formatted queries",
        "fix-suggestion": "Use parameterized queries with placeholders like `cursor.execute('SELECT * FROM users WHERE id = ?', [user_id])`. Consider adopting SQLAlchemy ORM which provides automatic protection against SQL injection. Never build SQL queries through string concatenation or formatting with user input."
      },
      "severity": "ERROR",
      "languages": [
        "python"
      ],
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "flask.request.$ANYTHING"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "@$APP.route(...)\ndef $FUNC(..., $ROUTEVAR, ...):\n  ...\n"
                    },
                    {
                      "pattern": "$ROUTEVAR"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "\"$SQLSTR\" + ...\n"
                },
                {
                  "pattern": "\"$SQLSTR\" % ...\n"
                },
                {
                  "pattern": "\"$SQLSTR\".format(...)\n"
                },
                {
                  "pattern": "f\"$SQLSTR{...}...\"\n"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$SQLSTR",
                "regex": "\\s*(?i)(select|delete|insert|create|update|alter|drop)\\b.*"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "python.flask.security.injection.tainted-url-host.tainted-url-host",
      "languages": [
        "python"
      ],
      "message": "This vulnerability happens when user input is used to construct the host portion of a URL in a Flask application without validation. Attackers can manipulate this input to make the server connect to internal services or malicious external hosts. This can lead to Server-Side Request Forgery (SSRF) attacks that bypass network controls, access sensitive internal services, or exfiltrate data.",
      "metadata": {
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "impact": "MEDIUM",
        "likelihood": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "User input for host in Flask can cause SSRF",
        "fix-suggestion": "Restrict and validate user input when constructing URLs to ensure only safe hostnames are used."
      },
      "mode": "taint",
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern": "\"$URLSTR\" % ..."
                    },
                    {
                      "metavariable-pattern": {
                        "metavariable": "$URLSTR",
                        "language": "generic",
                        "patterns": [
                          {
                            "pattern-either": [
                              {
                                "pattern": "$SCHEME://%s"
                              },
                              {
                                "pattern": "$SCHEME://%r"
                              }
                            ]
                          }
                        ]
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "\"$URLSTR\".format(...)"
                    },
                    {
                      "metavariable-pattern": {
                        "metavariable": "$URLSTR",
                        "language": "generic",
                        "pattern": "$SCHEME:// { ... }"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "\"$URLSTR\" + ..."
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$URLSTR",
                        "regex": ".*://$"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "f\"$URLSTR{...}...\""
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$URLSTR",
                        "regex": ".*://$"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$URL = \"$URLSTR\"\n...\n"
                    },
                    {
                      "pattern": "$URL += ..."
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$URLSTR",
                        "regex": ".*://$"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "flask.request.$ANYTHING"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "@$APP.route(...)\ndef $FUNC(..., $ROUTEVAR, ...):\n  ...\n"
                    },
                    {
                      "pattern": "$ROUTEVAR"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.flask.security.injection.raw-html-concat.raw-html-format",
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "message": "This vulnerability occurs when HTML strings are manually built by concatenating or formatting with user input in Flask applications. Because this bypasses Flask's template autoescaping, attackers can inject malicious HTML or JavaScript code. This leads to cross-site scripting (XSS) vulnerabilities that could allow session hijacking, cookie theft, or other client-side attacks.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "references": [
          "https://flask.palletsprojects.com/en/2.0.x/security/#cross-site-scripting-xss"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Concatenating user data in HTML leads to XSS",
        "fix-suggestion": "Avoid concatenating HTML with unsanitized user input; build HTML using template rendering with automatic escaping."
      },
      "mode": "taint",
      "pattern-sanitizers": [
        {
          "pattern": "jinja2.escape(...)"
        },
        {
          "pattern": "flask.escape(...)"
        },
        {
          "patterns": [
            {
              "pattern": "flask.render_template($TPL, ...)"
            },
            {
              "metavariable-regex": {
                "metavariable": "$TPL",
                "regex": ".*\\.html"
              }
            }
          ]
        }
      ],
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "flask.request.$ANYTHING"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "@$APP.route(...)\ndef $FUNC(..., $ROUTEVAR, ...):\n  ...\n"
                    },
                    {
                      "pattern": "$ROUTEVAR"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "\"$HTMLSTR\" % ..."
                        },
                        {
                          "pattern": "\"$HTMLSTR\".format(...)"
                        },
                        {
                          "pattern": "\"$HTMLSTR\" + ..."
                        },
                        {
                          "pattern": "f\"$HTMLSTR{...}...\""
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$HTML = \"$HTMLSTR\"\n...\n"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "$HTML % ..."
                        },
                        {
                          "pattern": "$HTML.format(...)"
                        },
                        {
                          "pattern": "$HTML + ..."
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "metavariable-pattern": {
                "metavariable": "$HTMLSTR",
                "language": "generic",
                "pattern": "<$TAG ..."
              }
            }
          ]
        }
      ]
    },
    {
      "id": "python.flask.security.injection.user-eval.eval-injection",
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "message": "Passing user input to `eval()` creates a critical remote code execution vulnerability. Attackers can construct inputs that execute arbitrary Python code with your application's permissions. This vulnerability can lead to complete system compromise and data theft.",
      "metadata": {
        "cwe": [
          "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Remote code execution via eval with user input",
        "fix-suggestion": "Never use `eval()` with any user-controlled input. Replace with safer alternatives like `ast.literal_eval()` for parsing only literal expressions. For complex cases, implement a domain-specific parser or use existing libraries designed for the specific functionality you need."
      },
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern": "eval(...)"
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "@$APP.route($ROUTE, ...)\ndef $FUNC(..., $ROUTEVAR, ...):\n  ...\n  eval(..., <... $ROUTEVAR ...>, ...)\n"
                },
                {
                  "pattern-inside": "@$APP.route($ROUTE, ...)\ndef $FUNC(..., $ROUTEVAR, ...):\n  ...\n  $INTERM = <... $ROUTEVAR ...>\n  ...\n  eval(..., <... $INTERM ...>, ...)\n"
                }
              ]
            }
          ]
        },
        {
          "pattern": "eval(..., <... flask.request.$W.get(...) ...>, ...)"
        },
        {
          "pattern": "eval(..., <... flask.request.$W[...] ...>, ...)"
        },
        {
          "pattern": "eval(..., <... flask.request.$W(...) ...>, ...)"
        },
        {
          "pattern": "eval(..., <... flask.request.$W ...>, ...)"
        },
        {
          "patterns": [
            {
              "pattern-inside": "$INTERM = <... flask.request.$W.get(...) ...>\n...\neval(..., <... $INTERM ...>, ...)\n"
            },
            {
              "pattern": "eval(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$INTERM = <... flask.request.$W[...] ...>\n...\neval(..., <... $INTERM ...>, ...)\n"
            },
            {
              "pattern": "eval(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$INTERM = <... flask.request.$W(...) ...>\n...\neval(..., <... $INTERM ...>, ...)\n"
            },
            {
              "pattern": "eval(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$INTERM = <... flask.request.$W ...>\n...\neval(..., <... $INTERM ...>, ...)\n"
            },
            {
              "pattern": "eval(...)"
            }
          ]
        }
      ]
    },
    {
      "id": "python.flask.security.injection.user-exec.exec-injection",
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "message": "Allowing user input to flow into `exec()` creates a severe remote code execution vulnerability. Attackers can execute arbitrary Python code within your application context, potentially accessing sensitive data or gaining control of your server. This is one of the most dangerous security flaws.",
      "metadata": {
        "cwe": [
          "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://nedbatchelder.com/blog/201206/exec_really_is_dangerous.html"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Code injection vulnerability via exec function",
        "fix-suggestion": "Never use `exec()` with any user-controlled input. Redesign your application to eliminate dynamic code execution entirely. Consider alternatives like dispatch tables, configuration systems, or domain-specific languages that don't involve executing arbitrary code."
      },
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern": "exec(...)"
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "@$APP.route($ROUTE, ...)\ndef $FUNC(..., $ROUTEVAR, ...):\n  ...\n  exec(..., <... $ROUTEVAR ...>, ...)\n"
                },
                {
                  "pattern-inside": "@$APP.route($ROUTE, ...)\ndef $FUNC(..., $ROUTEVAR, ...):\n  ...\n  $INTERM = <... $ROUTEVAR ...>\n  ...\n  exec(..., <... $INTERM ...>, ...)\n"
                }
              ]
            }
          ]
        },
        {
          "pattern": "exec(..., <... flask.request.$W.get(...) ...>, ...)"
        },
        {
          "pattern": "exec(..., <... flask.request.$W[...] ...>, ...)"
        },
        {
          "pattern": "exec(..., <... flask.request.$W(...) ...>, ...)"
        },
        {
          "pattern": "exec(..., <... flask.request.$W ...>, ...)"
        },
        {
          "patterns": [
            {
              "pattern-inside": "$INTERM = <... flask.request.$W.get(...) ...>\n...\nexec(..., <... $INTERM ...>, ...)\n"
            },
            {
              "pattern": "exec(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$INTERM = <... flask.request.$W[...] ...>\n...\nexec(..., <... $INTERM ...>, ...)\n"
            },
            {
              "pattern": "exec(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$INTERM = <... flask.request.$W(...) ...>\n...\nexec(..., <... $INTERM ...>, ...)\n"
            },
            {
              "pattern": "exec(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$INTERM = <... flask.request.$W ...>\n...\nexec(..., <... $INTERM ...>, ...)\n"
            },
            {
              "pattern": "exec(...)"
            }
          ]
        }
      ]
    },
    {
      "id": "python.flask.security.secure-static-file-serve.avoid_send_file_without_path_sanitization",
      "patterns": [
        {
          "pattern-inside": "@app.route(...)\ndef $X(filename):\n  ...\n"
        },
        {
          "pattern": "flask.send_file(filename, ...)"
        }
      ],
      "message": "Allowing user-controlled filenames in `send_file()` creates path traversal vulnerabilities. Attackers can craft inputs containing '../' sequences to access files outside intended directories. This could expose sensitive configuration files, credentials, or system information.",
      "metadata": {
        "cwe": [
          "CWE-73: External Control of File Name or Path"
        ],
        "owasp": [
          "A04:2021 - Insecure Design"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "short-description": "Path traversal via unsanitized send_file filename",
        "fix-suggestion": "Use `flask.send_from_directory()` instead of `send_file()` when serving user-influenced files. Sanitize filenames by removing path components with `os.path.basename()`. Validate file extensions against an allowlist and verify files exist in the intended directory before serving."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.flask.security.unsanitized-input.response-contains-unsanitized-input",
      "message": "This vulnerability happens when a Flask application includes user input directly in HTTP responses without proper sanitization or escaping. Unsanitized inputs allow attackers to inject malicious HTML or JavaScript that will execute in users' browsers. This can lead to cross-site scripting (XSS) attacks that steal cookies, hijack sessions, or perform actions on behalf of victims.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://flask.palletsprojects.com/en/1.0.x/security/",
          "https://owasp.org/www-community/attacks/xss/"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Returning unsanitized user data can produce XSS in Flask",
        "fix-suggestion": "Ensure all user input included in HTTP responses is properly sanitized or escaped to prevent XSS vulnerabilities."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "$X = flask.request.args.get(...)\n...\nflask.make_response(\"...\".format($X))\n"
        },
        {
          "pattern": "$X = flask.request.args.get(...)\n...\nflask.make_response(f\"...{$X}...\")\n"
        },
        {
          "pattern": "$X = flask.request.args.get(...)\n...\nflask.make_response(f\"...{$X}\")\n"
        },
        {
          "pattern": "$X = flask.request.args.get(...)\n...\nflask.make_response(f\"{$X}...\")\n"
        }
      ]
    },
    {
      "id": "python.flask.security.xss.audit.direct-use-of-jinja2.direct-use-of-jinja2",
      "message": "This vulnerability occurs when Jinja2 templates are rendered directly rather than through Flask's render_template() function. Direct use of Jinja2 can bypass Flask's autoescaping protection for HTML output. This can lead to cross-site scripting (XSS) vulnerabilities if user input ends up in templates without proper escaping.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://jinja.palletsprojects.com/en/2.11.x/api/#basics"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Direct Jinja2 usage can skip escaping, allowing XSS",
        "fix-suggestion": "Render templates using Flask's `render_template` function to leverage Jinja2's autoescaping, avoiding direct use of Jinja2."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "jinja2.Environment(...)"
        },
        {
          "pattern": "jinja2.Template.render(...)"
        },
        {
          "patterns": [
            {
              "pattern-inside": "$TEMPLATE = $ENV.get_template(...)\n...\n"
            },
            {
              "pattern": "$TEMPLATE.render(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$TEMPLATE = jinja2.Template(...)\n...\n"
            },
            {
              "pattern": "$TEMPLATE.render(...)"
            }
          ]
        }
      ]
    },
    {
      "id": "python.flask.security.xss.audit.explicit-unescape-with-markup.explicit-unescape-with-markup",
      "message": "This vulnerability happens when the Markup() function is used to explicitly mark content as safe, bypassing normal HTML escaping in Flask. When this function is used with user-controlled input, attackers can inject malicious HTML or JavaScript. This can result in cross-site scripting (XSS) attacks that execute arbitrary code in users' browsers.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://tedboy.github.io/flask/generated/generated/flask.Markup.html"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Markup with untrusted data can cause script injection",
        "fix-suggestion": "Avoid using `Markup()` to bypass escaping on user input; only mark static, trusted content as safe."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "flask.Markup.unescape(...)"
        },
        {
          "pattern": "$MARKUPOBJ.unescape()"
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "flask.Markup($Q)"
                },
                {
                  "pattern": "markupsafe.Markup($Q)"
                }
              ]
            },
            {
              "metavariable-pattern": {
                "metavariable": "$Q",
                "patterns": [
                  {
                    "pattern-not": "\"...\""
                  }
                ]
              }
            }
          ]
        }
      ]
    },
    {
      "id": "python.flask.security.xss.audit.template-autoescape-off.template-autoescape-off",
      "message": "This vulnerability occurs when autoescaping is explicitly disabled in Flask templates using {% autoescape false %} blocks. Without autoescaping, any user input rendered in these blocks will not have special characters converted to their HTML entities. This allows attackers to inject malicious scripts in templates, leading to cross-site scripting (XSS) vulnerabilities.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://flask.palletsprojects.com/en/1.1.x/templating/#controlling-autoescaping",
          "https://flask.palletsprojects.com/en/1.1.x/templating/#jinja-setup"
        ],
        "category": "security",
        "technology": [
          "flask"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Autoescape disabled in template block leads to raw HTML injection",
        "fix-suggestion": "Remove any `{% autoescape false %}` blocks in templates to ensure that all dynamic content is automatically escaped."
      },
      "languages": [
        "regex"
      ],
      "paths": {
        "include": [
          "*.html"
        ]
      },
      "severity": "WARNING",
      "pattern-regex": "{%\\s*autoescape\\s+false\\s*%}"
    },
    {
      "id": "python.jwt.security.unverified-jwt-decode.unverified-jwt-decode",
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern": "jwt.decode(..., options={..., \"verify_signature\": $BOOL, ...}, ...)\n"
                },
                {
                  "metavariable-pattern": {
                    "metavariable": "$BOOL",
                    "pattern": "False\n"
                  }
                },
                {
                  "focus-metavariable": "$BOOL"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern": "$OPTS = {..., \"verify_signature\": $BOOL, ...}\n...\njwt.decode(..., options=$OPTS, ...)\n"
                },
                {
                  "metavariable-pattern": {
                    "metavariable": "$BOOL",
                    "pattern": "False\n"
                  }
                },
                {
                  "focus-metavariable": "$BOOL"
                }
              ]
            }
          ]
        }
      ],
      "message": "This vulnerability happens when JWT tokens are decoded with verify=False, which disables signature verification. Without verification, attackers can tamper with token contents and forge valid-looking tokens with arbitrary data. This can lead to authentication bypass, privilege escalation, or impersonation of other users.",
      "metadata": {
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A07:2021 - Identification and Authentication Failures"
        ],
        "cwe": [
          "CWE-287: Improper Authentication"
        ],
        "references": [
          "https://github.com/we45/Vulnerable-Flask-App/blob/752ee16087c0bfb79073f68802d907569a1f0df7/app/app.py#L96"
        ],
        "category": "security",
        "technology": [
          "jwt"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Decoding JWT without signature verification is insecure",
        "fix-suggestion": "Enable JWT signature verification instead of using `verify=False` to ensure token integrity and prevent tampering."
      },
      "fix": "True\n",
      "severity": "ERROR",
      "languages": [
        "python"
      ]
    },
    {
      "id": "python.jwt.security.audit.jwt-exposed-data.jwt-python-exposed-data",
      "message": "When passing data directly to JWT encoding functions, sensitive information might be inadvertently exposed in the token payload. JWT tokens aren't encrypted by default, only signed, making any included data readable by anyone with access to the token. Carefully review all objects passed to JWT encoding to ensure no secrets or credentials are included.",
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A04:2021 - Insecure Design"
        ],
        "cwe": [
          "CWE-522: Insufficiently Protected Credentials"
        ],
        "source-rule-url": "https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/",
        "category": "security",
        "technology": [
          "jwt"
        ],
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Sensitive data exposure in JWT token payload",
        "fix-suggestion": "Audit all data passed to `jwt.encode()` and explicitly select only the necessary fields to include in tokens. Create a whitelist approach where you manually build a dictionary with only required claims rather than passing entire objects. Consider implementing a dedicated function that filters sensitive fields before encoding."
      },
      "languages": [
        "python"
      ],
      "patterns": [
        {
          "pattern-inside": "def $FUNC(...,$INPUT,...):\n  ...\n"
        },
        {
          "pattern": "jwt.encode($INPUT,...)"
        }
      ]
    },
    {
      "id": "python.jwt.security.jwt-exposed-credentials.jwt-python-exposed-credentials",
      "languages": [
        "python"
      ],
      "metadata": {
        "cwe": [
          "CWE-522: Insufficiently Protected Credentials"
        ],
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A04:2021 - Insecure Design"
        ],
        "source-rule-url": "https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/",
        "references": [
          "https://cwe.mitre.org/data/definitions/522.html"
        ],
        "category": "security",
        "technology": [
          "jwt"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Password exposed in JWT token payload",
        "fix-suggestion": "Remove any password fields from data passed to `jwt.encode()`. Store authentication states or session identifiers in tokens instead of actual credentials. If you need to maintain user authentication status, use a unique session identifier or token reference that can be invalidated server-side."
      },
      "message": "Passwords included in JWT token payloads are easily accessible since JWTs are only signed, not encrypted. Anyone with the token can decode its contents and extract the password, compromising user credentials. Passwords should never be stored in JWT tokens regardless of your authentication flow.",
      "pattern-either": [
        {
          "pattern": "jwt.encode({...,\"password\":$P,...},...)\n"
        },
        {
          "pattern": "$PAYLOAD = {...,\"password\":$P,...}\n...\njwt.encode($PAYLOAD,...)\n"
        }
      ],
      "severity": "ERROR"
    },
    {
      "id": "python.jwt.security.jwt-hardcode.jwt-python-hardcoded-secret",
      "message": "JWT tokens are secured using a secret key that, if hardcoded in your source code, presents a serious security vulnerability. Anyone with access to your code can extract this secret and forge valid tokens, effectively bypassing your authentication. This is a classic case of insufficiently protected credentials that compromises your entire JWT authentication system.",
      "metadata": {
        "cwe": [
          "CWE-522: Insufficiently Protected Credentials"
        ],
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A04:2021 - Insecure Design"
        ],
        "references": [
          "https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/"
        ],
        "category": "security",
        "technology": [
          "jwt"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Hardcoded JWT secret compromises token security",
        "fix-suggestion": "Move JWT secrets from code to environment variables using `os.environ.get('JWT_SECRET')` or a secure configuration system. Implement secret rotation procedures to periodically update the key. Consider using asymmetric key pairs with `RS256` algorithm where the private signing key can be kept more secure than a symmetric secret."
      },
      "patterns": [
        {
          "pattern": "jwt.encode($X, $SECRET, ...)\n"
        },
        {
          "focus-metavariable": "$SECRET"
        },
        {
          "pattern": "\"...\"\n"
        }
      ],
      "languages": [
        "python"
      ],
      "severity": "ERROR"
    },
    {
      "id": "python.jwt.security.jwt-none-alg.jwt-python-none-alg",
      "message": "Using the 'none' algorithm for JWT tokens completely bypasses signature verification. This allows attackers to forge tokens with arbitrary claims that will be automatically verified as valid. Always use a secure algorithm like 'HS256' instead of explicitly specifying 'none', which offers no security whatsoever.",
      "metadata": {
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/",
        "category": "security",
        "technology": [
          "jwt"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "JWT 'none' algorithm bypasses signature verification",
        "fix-suggestion": "Replace `algorithm='none'` with a secure algorithm like `algorithm='HS256'` in your JWT encoding calls. Explicitly verify algorithm types during token verification with `jwt.decode(token, secret, algorithms=['HS256'])` to prevent algorithm switching attacks. Never accept tokens using the 'none' algorithm in production environments."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "pattern-either": [
        {
          "pattern": "jwt.encode(...,algorithm=\"none\",...)\n"
        },
        {
          "pattern": "jwt.decode(...,algorithms=[...,\"none\",...],...)"
        }
      ]
    },
    {
      "id": "python.lang.security.dangerous-globals-use.dangerous-globals-use",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "globals().get(...)"
            },
            {
              "pattern": "locals().get(...)"
            },
            {
              "pattern": "globals()[...]"
            },
            {
              "pattern": "locals()[...]"
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "$G = globals()\n...\n"
                    },
                    {
                      "pattern-inside": "$G = locals()\n...\n"
                    }
                  ]
                },
                {
                  "pattern-either": [
                    {
                      "pattern": "$G.get(...)"
                    },
                    {
                      "pattern": "$G[...]"
                    }
                  ]
                }
              ]
            },
            {
              "pattern": "$FUNC.__globals__[...]"
            }
          ]
        },
        {
          "pattern-not": "globals().get(\"...\")"
        },
        {
          "pattern-not": "locals().get(\"...\")"
        },
        {
          "pattern-not": "globals()[\"...\"]"
        },
        {
          "pattern-not": "locals()[\"...\"]"
        },
        {
          "pattern-not": "$G.get(\"...\")"
        },
        {
          "pattern-not": "$G.get[\"...\"]"
        },
        {
          "pattern-not": "$G[\"...\"]"
        },
        {
          "pattern-not": "$FUNC.__globals__[\"...\"]"
        },
        {
          "pattern-not-inside": "globals()[...] = ..."
        },
        {
          "pattern-not-inside": "locals()[...] = ..."
        },
        {
          "pattern-not-inside": "$G[...] = ..."
        },
        {
          "pattern-not-inside": "$FUNC.__globals__[...] = ..."
        }
      ],
      "message": "Using non-static data as an index to access the globals() dictionary creates a critical remote code execution vulnerability. This allows attackers to access arbitrary global variables and potentially execute malicious code. This pattern effectively creates an eval-like vulnerability that grants attackers complete control over your application.",
      "metadata": {
        "cwe": [
          "CWE-96: Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://github.com/mpirnat/lets-be-bad-guys/blob/d92768fb3ade32956abd53bd6bb06e19d634a084/badguys/vulnerable/views.py#L181-L186"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Arbitrary globals() access enables code execution",
        "fix-suggestion": "Replace `globals()[variable]` with a controlled dictionary lookup like `my_safe_dict.get(variable)`. Implement proper validation of all inputs used as dictionary keys. Consider restructuring your code to avoid dynamic variable access patterns entirely, using dispatch tables or class-based approaches instead."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ]
    },
    {
      "id": "python.lang.security.dangerous-os-exec.dangerous-os-exec",
      "mode": "taint",
      "options": {
        "symbolic_propagation": true
      },
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "flask.request.form.get(...)"
                        },
                        {
                          "pattern": "flask.request.form[...]"
                        },
                        {
                          "pattern": "flask.request.args.get(...)"
                        },
                        {
                          "pattern": "flask.request.args[...]"
                        },
                        {
                          "pattern": "flask.request.values.get(...)"
                        },
                        {
                          "pattern": "flask.request.values[...]"
                        },
                        {
                          "pattern": "flask.request.cookies.get(...)"
                        },
                        {
                          "pattern": "flask.request.cookies[...]"
                        },
                        {
                          "pattern": "flask.request.stream"
                        },
                        {
                          "pattern": "flask.request.headers.get(...)"
                        },
                        {
                          "pattern": "flask.request.headers[...]"
                        },
                        {
                          "pattern": "flask.request.data"
                        },
                        {
                          "pattern": "flask.request.full_path"
                        },
                        {
                          "pattern": "flask.request.url"
                        },
                        {
                          "pattern": "flask.request.json"
                        },
                        {
                          "pattern": "flask.request.get_json()"
                        },
                        {
                          "pattern": "flask.request.view_args.get(...)"
                        },
                        {
                          "pattern": "flask.request.view_args[...]"
                        },
                        {
                          "patterns": [
                            {
                              "pattern-inside": "@$APP.route(...)\ndef $FUNC(..., $ROUTEVAR, ...):\n  ...\n"
                            },
                            {
                              "focus-metavariable": "$ROUTEVAR"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "def $FUNC(request, ...):\n  ...\n"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "request.$PROPERTY.get(...)"
                        },
                        {
                          "pattern": "request.$PROPERTY[...]"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "@rest_framework.decorators.api_view(...)\ndef $FUNC($REQ, ...):\n  ...\n"
                        },
                        {
                          "patterns": [
                            {
                              "pattern-either": [
                                {
                                  "pattern-inside": "class $VIEW(..., rest_framework.views.APIView, ...):\n  ...\n"
                                },
                                {
                                  "pattern-inside": "class $VIEW(..., rest_framework.generics.GenericAPIView, ...):\n  ...                              \n"
                                }
                              ]
                            },
                            {
                              "pattern-inside": "def $METHOD(self, $REQ, ...):\n  ...\n"
                            },
                            {
                              "metavariable-regex": {
                                "metavariable": "$METHOD",
                                "regex": "(get|post|put|patch|delete|head)"
                              }
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "$REQ.POST.get(...)"
                        },
                        {
                          "pattern": "$REQ.POST[...]"
                        },
                        {
                          "pattern": "$REQ.FILES.get(...)"
                        },
                        {
                          "pattern": "$REQ.FILES[...]"
                        },
                        {
                          "pattern": "$REQ.DATA.get(...)"
                        },
                        {
                          "pattern": "$REQ.DATA[...]"
                        },
                        {
                          "pattern": "$REQ.QUERY_PARAMS.get(...)"
                        },
                        {
                          "pattern": "$REQ.QUERY_PARAMS[...]"
                        },
                        {
                          "pattern": "$REQ.data.get(...)"
                        },
                        {
                          "pattern": "$REQ.data[...]"
                        },
                        {
                          "pattern": "$REQ.query_params.get(...)"
                        },
                        {
                          "pattern": "$REQ.query_params[...]"
                        },
                        {
                          "pattern": "$REQ.content_type"
                        },
                        {
                          "pattern": "$REQ.content_type"
                        },
                        {
                          "pattern": "$REQ.stream"
                        },
                        {
                          "pattern": "$REQ.stream"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "class $SERVER(..., http.server.BaseHTTPRequestHandler, ...):\n  ...\n"
                        },
                        {
                          "pattern-inside": "class $SERVER(..., http.server.StreamRequestHandler, ...):\n  ...\n"
                        },
                        {
                          "pattern-inside": "class $SERVER(..., http.server.DatagramRequestHandler, ...):\n  ...\n"
                        }
                      ]
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "self.requestline"
                        },
                        {
                          "pattern": "self.path"
                        },
                        {
                          "pattern": "self.headers[...]"
                        },
                        {
                          "pattern": "self.headers.get(...)"
                        },
                        {
                          "pattern": "self.rfile"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "@pyramid.view.view_config( ... )\ndef $VIEW($REQ):\n  ...\n"
                    },
                    {
                      "pattern": "$REQ.$ANYTHING"
                    },
                    {
                      "pattern-not": "$REQ.dbsession"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-not": "os.$METHOD(\"...\", ...)"
                    },
                    {
                      "pattern": "os.$METHOD(...)"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "(execl|execle|execlp|execlpe|execv|execve|execvp|execvpe)"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-not": "os.$METHOD(\"...\", [$PATH,\"...\",\"...\",...],...)"
                    },
                    {
                      "pattern-inside": "os.$METHOD($BASH,[$PATH,\"-c\",$CMD,...],...)"
                    },
                    {
                      "pattern": "$CMD"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "(execv|execve|execvp|execvpe)"
                      }
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$BASH",
                        "regex": "(.*)(sh|bash|ksh|csh|tcsh|zsh)"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-not": "os.$METHOD(\"...\", $PATH, \"...\", \"...\",...)"
                    },
                    {
                      "pattern-inside": "os.$METHOD($BASH, $PATH, \"-c\", $CMD,...)"
                    },
                    {
                      "pattern": "$CMD"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "(execl|execle|execlp|execlpe)"
                      }
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$BASH",
                        "regex": "(.*)(sh|bash|ksh|csh|tcsh|zsh)"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "message": "This vulnerability occurs when user-provided input is passed to os.exec* functions without proper validation or sanitization. Attackers can inject shell metacharacters to execute arbitrary commands with the privileges of the application. This can lead to complete system compromise, data theft, or service disruption.",
      "metadata": {
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://semgrep.dev/docs/cheat-sheets/python-command-injection/"
        ],
        "asvs": {
          "section": "V5: Validation, Sanitization and Encoding Verification Requirements",
          "control_id": "5.3.8 OS Command Injection",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements",
          "version": "4"
        },
        "confidence": "MEDIUM",
        "category": "security",
        "technology": [
          "python"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Spawning processes with user input can cause code execution",
        "fix-suggestion": "Avoid using `os.exec*` functions with untrusted input; validate and sanitize inputs or use safer alternatives that separate command and arguments."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR"
    },
    {
      "id": "python.lang.security.dangerous-spawn-process.dangerous-spawn-process",
      "mode": "taint",
      "options": {
        "symbolic_propagation": true
      },
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "flask.request.form.get(...)"
                        },
                        {
                          "pattern": "flask.request.form[...]"
                        },
                        {
                          "pattern": "flask.request.args.get(...)"
                        },
                        {
                          "pattern": "flask.request.args[...]"
                        },
                        {
                          "pattern": "flask.request.values.get(...)"
                        },
                        {
                          "pattern": "flask.request.values[...]"
                        },
                        {
                          "pattern": "flask.request.cookies.get(...)"
                        },
                        {
                          "pattern": "flask.request.cookies[...]"
                        },
                        {
                          "pattern": "flask.request.stream"
                        },
                        {
                          "pattern": "flask.request.headers.get(...)"
                        },
                        {
                          "pattern": "flask.request.headers[...]"
                        },
                        {
                          "pattern": "flask.request.data"
                        },
                        {
                          "pattern": "flask.request.full_path"
                        },
                        {
                          "pattern": "flask.request.url"
                        },
                        {
                          "pattern": "flask.request.json"
                        },
                        {
                          "pattern": "flask.request.get_json()"
                        },
                        {
                          "pattern": "flask.request.view_args.get(...)"
                        },
                        {
                          "pattern": "flask.request.view_args[...]"
                        },
                        {
                          "patterns": [
                            {
                              "pattern-inside": "@$APP.route(...)\ndef $FUNC(..., $ROUTEVAR, ...):\n  ...\n"
                            },
                            {
                              "pattern": "$ROUTEVAR"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "def $FUNC(request, ...):\n  ...\n"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "request.$PROPERTY.get(...)"
                        },
                        {
                          "pattern": "request.$PROPERTY[...]"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "@rest_framework.decorators.api_view(...)\ndef $FUNC($REQ, ...):\n  ...\n"
                        },
                        {
                          "patterns": [
                            {
                              "pattern-either": [
                                {
                                  "pattern-inside": "class $VIEW(..., rest_framework.views.APIView, ...):\n  ...\n"
                                },
                                {
                                  "pattern-inside": "class $VIEW(..., rest_framework.generics.GenericAPIView, ...):\n  ...                              \n"
                                }
                              ]
                            },
                            {
                              "pattern-inside": "def $METHOD(self, $REQ, ...):\n  ...\n"
                            },
                            {
                              "metavariable-regex": {
                                "metavariable": "$METHOD",
                                "regex": "(get|post|put|patch|delete|head)"
                              }
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "$REQ.POST.get(...)"
                        },
                        {
                          "pattern": "$REQ.POST[...]"
                        },
                        {
                          "pattern": "$REQ.FILES.get(...)"
                        },
                        {
                          "pattern": "$REQ.FILES[...]"
                        },
                        {
                          "pattern": "$REQ.DATA.get(...)"
                        },
                        {
                          "pattern": "$REQ.DATA[...]"
                        },
                        {
                          "pattern": "$REQ.QUERY_PARAMS.get(...)"
                        },
                        {
                          "pattern": "$REQ.QUERY_PARAMS[...]"
                        },
                        {
                          "pattern": "$REQ.data.get(...)"
                        },
                        {
                          "pattern": "$REQ.data[...]"
                        },
                        {
                          "pattern": "$REQ.query_params.get(...)"
                        },
                        {
                          "pattern": "$REQ.query_params[...]"
                        },
                        {
                          "pattern": "$REQ.content_type"
                        },
                        {
                          "pattern": "$REQ.content_type"
                        },
                        {
                          "pattern": "$REQ.stream"
                        },
                        {
                          "pattern": "$REQ.stream"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "class $SERVER(..., http.server.BaseHTTPRequestHandler, ...):\n  ...\n"
                        },
                        {
                          "pattern-inside": "class $SERVER(..., http.server.StreamRequestHandler, ...):\n  ...\n"
                        },
                        {
                          "pattern-inside": "class $SERVER(..., http.server.DatagramRequestHandler, ...):\n  ...\n"
                        }
                      ]
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "self.requestline"
                        },
                        {
                          "pattern": "self.path"
                        },
                        {
                          "pattern": "self.headers[...]"
                        },
                        {
                          "pattern": "self.headers.get(...)"
                        },
                        {
                          "pattern": "self.rfile"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "@pyramid.view.view_config( ... )\ndef $VIEW($REQ):\n  ...\n"
                    },
                    {
                      "pattern": "$REQ.$ANYTHING"
                    },
                    {
                      "pattern-not": "$REQ.dbsession"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "os.environ['$ANYTHING']"
                        },
                        {
                          "pattern": "os.environ.get('$FOO', ...)"
                        },
                        {
                          "pattern": "os.environb['$ANYTHING']"
                        },
                        {
                          "pattern": "os.environb.get('$FOO', ...)"
                        },
                        {
                          "pattern": "os.getenv('$ANYTHING', ...)"
                        },
                        {
                          "pattern": "os.getenvb('$ANYTHING', ...)"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "patterns": [
                            {
                              "pattern-either": [
                                {
                                  "pattern": "sys.argv[...]"
                                },
                                {
                                  "pattern": "sys.orig_argv[...]"
                                }
                              ]
                            }
                          ]
                        },
                        {
                          "patterns": [
                            {
                              "pattern-inside": "$PARSER = argparse.ArgumentParser(...)\n...\n"
                            },
                            {
                              "pattern-inside": "$ARGS = $PARSER.parse_args()\n"
                            },
                            {
                              "pattern": "<... $ARGS ...>"
                            }
                          ]
                        },
                        {
                          "patterns": [
                            {
                              "pattern-inside": "$PARSER = optparse.OptionParser(...)\n...\n"
                            },
                            {
                              "pattern-inside": "$ARGS = $PARSER.parse_args()\n"
                            },
                            {
                              "pattern": "<... $ARGS ...>"
                            }
                          ]
                        },
                        {
                          "patterns": [
                            {
                              "pattern-either": [
                                {
                                  "pattern-inside": "$OPTS, $ARGS = getopt.getopt(...)\n...\n"
                                },
                                {
                                  "pattern-inside": "$OPTS, $ARGS = getopt.gnu_getopt(...)\n...\n"
                                }
                              ]
                            },
                            {
                              "pattern-either": [
                                {
                                  "patterns": [
                                    {
                                      "pattern-inside": "for $O, $A in $OPTS:\n  ...\n"
                                    },
                                    {
                                      "pattern": "$A"
                                    }
                                  ]
                                },
                                {
                                  "pattern": "$ARGS"
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-not": "os.$METHOD($MODE, \"...\", ...)"
                    },
                    {
                      "pattern-inside": "os.$METHOD($MODE, $CMD, ...)"
                    },
                    {
                      "pattern": "$CMD"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "(spawnl|spawnle|spawnlp|spawnlpe|spawnv|spawnve|spawnvp|spawnvp|spawnvpe|posix_spawn|posix_spawnp|startfile)"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-not": "os.$METHOD($MODE, \"...\", [\"...\",\"...\",...], ...)"
                    },
                    {
                      "pattern-inside": "os.$METHOD($MODE, $BASH, [\"-c\",$CMD,...],...)"
                    },
                    {
                      "pattern": "$CMD"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "(spawnv|spawnve|spawnvp|spawnvp|spawnvpe|posix_spawn|posix_spawnp)"
                      }
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$BASH",
                        "regex": "(.*)(sh|bash|ksh|csh|tcsh|zsh)"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-not": "os.$METHOD($MODE, \"...\", \"...\", \"...\", ...)"
                    },
                    {
                      "pattern-inside": "os.$METHOD($MODE, $BASH, \"-c\", $CMD,...)"
                    },
                    {
                      "pattern": "$CMD"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$METHOD",
                        "regex": "(spawnl|spawnle|spawnlp|spawnlpe)"
                      }
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$BASH",
                        "regex": "(.*)(sh|bash|ksh|csh|tcsh|zsh)"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "message": "This vulnerability happens when user-controlled data influences process creation functions without proper validation. Attackers can manipulate this input to execute unintended commands or inject additional command arguments. This can lead to arbitrary command execution on the server with the application's privileges.",
      "metadata": {
        "source-rule-url": "https://bandit.readthedocs.io/en/latest/plugins/b605_start_process_with_a_shell.html",
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://semgrep.dev/docs/cheat-sheets/python-command-injection/"
        ],
        "asvs": {
          "section": "V5: Validation, Sanitization and Encoding Verification Requirements",
          "control_id": "5.3.8 OS Command Injection",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "python"
        ],
        "confidence": "MEDIUM",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Process spawn from untrusted data leads to injection",
        "fix-suggestion": "Use fixed argument lists for process creation functions, rigorously validate any user-supplied data to prevent injection attacks."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR"
    },
    {
      "id": "python.lang.security.dangerous-subinterpreters-run-string.dangerous-subinterpreters-run-string",
      "mode": "taint",
      "options": {
        "symbolic_propagation": true
      },
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "flask.request.form.get(...)"
                        },
                        {
                          "pattern": "flask.request.form[...]"
                        },
                        {
                          "pattern": "flask.request.args.get(...)"
                        },
                        {
                          "pattern": "flask.request.args[...]"
                        },
                        {
                          "pattern": "flask.request.values.get(...)"
                        },
                        {
                          "pattern": "flask.request.values[...]"
                        },
                        {
                          "pattern": "flask.request.cookies.get(...)"
                        },
                        {
                          "pattern": "flask.request.cookies[...]"
                        },
                        {
                          "pattern": "flask.request.stream"
                        },
                        {
                          "pattern": "flask.request.headers.get(...)"
                        },
                        {
                          "pattern": "flask.request.headers[...]"
                        },
                        {
                          "pattern": "flask.request.data"
                        },
                        {
                          "pattern": "flask.request.full_path"
                        },
                        {
                          "pattern": "flask.request.url"
                        },
                        {
                          "pattern": "flask.request.json"
                        },
                        {
                          "pattern": "flask.request.get_json()"
                        },
                        {
                          "pattern": "flask.request.view_args.get(...)"
                        },
                        {
                          "pattern": "flask.request.view_args[...]"
                        },
                        {
                          "patterns": [
                            {
                              "pattern-inside": "@$APP.route(...)\ndef $FUNC(..., $ROUTEVAR, ...):\n  ...\n"
                            },
                            {
                              "focus-metavariable": "$ROUTEVAR"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "def $FUNC(request, ...):\n  ...\n"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "request.$PROPERTY.get(...)"
                        },
                        {
                          "pattern": "request.$PROPERTY[...]"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "@rest_framework.decorators.api_view(...)\ndef $FUNC($REQ, ...):\n  ...\n"
                        },
                        {
                          "patterns": [
                            {
                              "pattern-either": [
                                {
                                  "pattern-inside": "class $VIEW(..., rest_framework.views.APIView, ...):\n  ...\n"
                                },
                                {
                                  "pattern-inside": "class $VIEW(..., rest_framework.generics.GenericAPIView, ...):\n  ...                              \n"
                                }
                              ]
                            },
                            {
                              "pattern-inside": "def $METHOD(self, $REQ, ...):\n  ...\n"
                            },
                            {
                              "metavariable-regex": {
                                "metavariable": "$METHOD",
                                "regex": "(get|post|put|patch|delete|head)"
                              }
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "$REQ.POST.get(...)"
                        },
                        {
                          "pattern": "$REQ.POST[...]"
                        },
                        {
                          "pattern": "$REQ.FILES.get(...)"
                        },
                        {
                          "pattern": "$REQ.FILES[...]"
                        },
                        {
                          "pattern": "$REQ.DATA.get(...)"
                        },
                        {
                          "pattern": "$REQ.DATA[...]"
                        },
                        {
                          "pattern": "$REQ.QUERY_PARAMS.get(...)"
                        },
                        {
                          "pattern": "$REQ.QUERY_PARAMS[...]"
                        },
                        {
                          "pattern": "$REQ.data.get(...)"
                        },
                        {
                          "pattern": "$REQ.data[...]"
                        },
                        {
                          "pattern": "$REQ.query_params.get(...)"
                        },
                        {
                          "pattern": "$REQ.query_params[...]"
                        },
                        {
                          "pattern": "$REQ.content_type"
                        },
                        {
                          "pattern": "$REQ.content_type"
                        },
                        {
                          "pattern": "$REQ.stream"
                        },
                        {
                          "pattern": "$REQ.stream"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "class $SERVER(..., http.server.BaseHTTPRequestHandler, ...):\n  ...\n"
                        },
                        {
                          "pattern-inside": "class $SERVER(..., http.server.StreamRequestHandler, ...):\n  ...\n"
                        },
                        {
                          "pattern-inside": "class $SERVER(..., http.server.DatagramRequestHandler, ...):\n  ...\n"
                        }
                      ]
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "self.requestline"
                        },
                        {
                          "pattern": "self.path"
                        },
                        {
                          "pattern": "self.headers[...]"
                        },
                        {
                          "pattern": "self.headers.get(...)"
                        },
                        {
                          "pattern": "self.rfile"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "@pyramid.view.view_config( ... )\ndef $VIEW($REQ):\n  ...\n"
                    },
                    {
                      "pattern": "$REQ.$ANYTHING"
                    },
                    {
                      "pattern-not": "$REQ.dbsession"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "_xxsubinterpreters.run_string($ID, $PAYLOAD, ...)\n"
            },
            {
              "pattern-not": "_xxsubinterpreters.run_string($ID, \"...\", ...)\n"
            },
            {
              "focus-metavariable": "$PAYLOAD"
            }
          ]
        }
      ],
      "message": "Passing user-controlled data to the run_string method in subinterpreters allows arbitrary Python code execution. This effectively gives attackers the ability to run any code they want in your application's context. User input should never be passed to functions that can execute code dynamically.",
      "metadata": {
        "cwe": [
          "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://bugs.python.org/issue43472",
          "https://semgrep.dev/docs/cheat-sheets/python-command-injection/"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "confidence": "MEDIUM",
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "User input in subinterpreters enables code execution",
        "fix-suggestion": "Never pass user-controlled input to `run_string()` in any form. Create a restricted interface that only allows specific predefined operations. If dynamic code execution is necessary, implement a sandboxed environment with strict validation and restricted capabilities."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ]
    },
    {
      "id": "python.lang.security.dangerous-subprocess-use.dangerous-subprocess-use",
      "mode": "taint",
      "options": {
        "symbolic_propagation": true
      },
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "flask.request.form.get(...)"
                        },
                        {
                          "pattern": "flask.request.form[...]"
                        },
                        {
                          "pattern": "flask.request.args.get(...)"
                        },
                        {
                          "pattern": "flask.request.args[...]"
                        },
                        {
                          "pattern": "flask.request.values.get(...)"
                        },
                        {
                          "pattern": "flask.request.values[...]"
                        },
                        {
                          "pattern": "flask.request.cookies.get(...)"
                        },
                        {
                          "pattern": "flask.request.cookies[...]"
                        },
                        {
                          "pattern": "flask.request.stream"
                        },
                        {
                          "pattern": "flask.request.headers.get(...)"
                        },
                        {
                          "pattern": "flask.request.headers[...]"
                        },
                        {
                          "pattern": "flask.request.data"
                        },
                        {
                          "pattern": "flask.request.full_path"
                        },
                        {
                          "pattern": "flask.request.url"
                        },
                        {
                          "pattern": "flask.request.json"
                        },
                        {
                          "pattern": "flask.request.get_json()"
                        },
                        {
                          "pattern": "flask.request.view_args.get(...)"
                        },
                        {
                          "pattern": "flask.request.view_args[...]"
                        },
                        {
                          "patterns": [
                            {
                              "pattern-inside": "@$APP.route(...)\ndef $FUNC(..., $ROUTEVAR, ...):\n  ...\n"
                            },
                            {
                              "focus-metavariable": "$ROUTEVAR"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "def $FUNC(request, ...):\n  ...\n"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "request.$PROPERTY.get(...)"
                        },
                        {
                          "pattern": "request.$PROPERTY[...]"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "@rest_framework.decorators.api_view(...)\ndef $FUNC($REQ, ...):\n  ...\n"
                        },
                        {
                          "patterns": [
                            {
                              "pattern-either": [
                                {
                                  "pattern-inside": "class $VIEW(..., rest_framework.views.APIView, ...):\n  ...\n"
                                },
                                {
                                  "pattern-inside": "class $VIEW(..., rest_framework.generics.GenericAPIView, ...):\n  ...                              \n"
                                }
                              ]
                            },
                            {
                              "pattern-inside": "def $METHOD(self, $REQ, ...):\n  ...\n"
                            },
                            {
                              "metavariable-regex": {
                                "metavariable": "$METHOD",
                                "regex": "(get|post|put|patch|delete|head)"
                              }
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "$REQ.POST.get(...)"
                        },
                        {
                          "pattern": "$REQ.POST[...]"
                        },
                        {
                          "pattern": "$REQ.FILES.get(...)"
                        },
                        {
                          "pattern": "$REQ.FILES[...]"
                        },
                        {
                          "pattern": "$REQ.DATA.get(...)"
                        },
                        {
                          "pattern": "$REQ.DATA[...]"
                        },
                        {
                          "pattern": "$REQ.QUERY_PARAMS.get(...)"
                        },
                        {
                          "pattern": "$REQ.QUERY_PARAMS[...]"
                        },
                        {
                          "pattern": "$REQ.data.get(...)"
                        },
                        {
                          "pattern": "$REQ.data[...]"
                        },
                        {
                          "pattern": "$REQ.query_params.get(...)"
                        },
                        {
                          "pattern": "$REQ.query_params[...]"
                        },
                        {
                          "pattern": "$REQ.content_type"
                        },
                        {
                          "pattern": "$REQ.content_type"
                        },
                        {
                          "pattern": "$REQ.stream"
                        },
                        {
                          "pattern": "$REQ.stream"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "class $SERVER(..., http.server.BaseHTTPRequestHandler, ...):\n  ...\n"
                        },
                        {
                          "pattern-inside": "class $SERVER(..., http.server.StreamRequestHandler, ...):\n  ...\n"
                        },
                        {
                          "pattern-inside": "class $SERVER(..., http.server.DatagramRequestHandler, ...):\n  ...\n"
                        }
                      ]
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "self.requestline"
                        },
                        {
                          "pattern": "self.path"
                        },
                        {
                          "pattern": "self.headers[...]"
                        },
                        {
                          "pattern": "self.headers.get(...)"
                        },
                        {
                          "pattern": "self.rfile"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "@pyramid.view.view_config( ... )\ndef $VIEW($REQ):\n  ...\n"
                    },
                    {
                      "pattern": "$REQ.$ANYTHING"
                    },
                    {
                      "pattern-not": "$REQ.dbsession"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-not": "subprocess.$FUNC(\"...\", ...)"
                    },
                    {
                      "pattern-not": "subprocess.$FUNC([\"...\",...], ...)"
                    },
                    {
                      "pattern-not": "subprocess.$FUNC((\"...\",...), ...)"
                    },
                    {
                      "pattern-not": "subprocess.CalledProcessError(...)"
                    },
                    {
                      "pattern-not": "subprocess.SubprocessError(...)"
                    },
                    {
                      "pattern": "subprocess.$FUNC($CMD, ...)"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-not": "subprocess.$FUNC(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",\"...\",...)"
                    },
                    {
                      "pattern": "subprocess.$FUNC(\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\", $CMD)"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-not": "subprocess.$FUNC([\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",\"...\",...],...)"
                    },
                    {
                      "pattern-not": "subprocess.$FUNC((\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\",\"...\",...),...)"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "subprocess.$FUNC([\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\", $CMD], ...)"
                        },
                        {
                          "pattern": "subprocess.$FUNC((\"=~/(sh|bash|ksh|csh|tcsh|zsh)/\",\"-c\", $CMD), ...)"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-not": "subprocess.$FUNC(\"=~/(python)/\",\"...\",...)"
                    },
                    {
                      "pattern": "subprocess.$FUNC(\"=~/(python)/\", $CMD)"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-not": "subprocess.$FUNC([\"=~/(python)/\",\"...\",...],...)"
                    },
                    {
                      "pattern-not": "subprocess.$FUNC((\"=~/(python)/\",\"...\",...),...)"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "subprocess.$FUNC([\"=~/(python)/\", $CMD],...)"
                        },
                        {
                          "pattern": "subprocess.$FUNC((\"=~/(python)/\", $CMD),...)"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "focus-metavariable": "$CMD"
            }
          ]
        }
      ],
      "message": "This vulnerability occurs when subprocess functions are used with user-controlled data, especially with shell=True. Attackers can include shell metacharacters or command separators to execute additional commands beyond what was intended. This can result in arbitrary command execution, system compromise, or unauthorized access to sensitive data.",
      "metadata": {
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "asvs": {
          "section": "V5: Validation, Sanitization and Encoding Verification Requirements",
          "control_id": "5.3.8 OS Command Injection",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v53-output-encoding-and-injection-prevention-requirements",
          "version": "4"
        },
        "references": [
          "https://stackoverflow.com/questions/3172470/actual-meaning-of-shell-true-in-subprocess",
          "https://docs.python.org/3/library/subprocess.html",
          "https://docs.python.org/3/library/shlex.html",
          "https://semgrep.dev/docs/cheat-sheets/python-command-injection/"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "confidence": "MEDIUM",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "subprocess calls with user data are injection-prone",
        "fix-suggestion": "Avoid subprocess calls with `shell=True`; use a fixed argument list and ensure all dynamic input is properly sanitized."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR"
    },
    {
      "id": "python.lang.security.dangerous-system-call.dangerous-system-call",
      "mode": "taint",
      "options": {
        "symbolic_propagation": true
      },
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "flask.request.form.get(...)"
                        },
                        {
                          "pattern": "flask.request.form[...]"
                        },
                        {
                          "pattern": "flask.request.args.get(...)"
                        },
                        {
                          "pattern": "flask.request.args[...]"
                        },
                        {
                          "pattern": "flask.request.values.get(...)"
                        },
                        {
                          "pattern": "flask.request.values[...]"
                        },
                        {
                          "pattern": "flask.request.cookies.get(...)"
                        },
                        {
                          "pattern": "flask.request.cookies[...]"
                        },
                        {
                          "pattern": "flask.request.stream"
                        },
                        {
                          "pattern": "flask.request.headers.get(...)"
                        },
                        {
                          "pattern": "flask.request.headers[...]"
                        },
                        {
                          "pattern": "flask.request.data"
                        },
                        {
                          "pattern": "flask.request.full_path"
                        },
                        {
                          "pattern": "flask.request.url"
                        },
                        {
                          "pattern": "flask.request.json"
                        },
                        {
                          "pattern": "flask.request.get_json()"
                        },
                        {
                          "pattern": "flask.request.view_args.get(...)"
                        },
                        {
                          "pattern": "flask.request.view_args[...]"
                        },
                        {
                          "patterns": [
                            {
                              "pattern-inside": "@$APP.route(...)\ndef $FUNC(..., $ROUTEVAR, ...):\n  ...\n"
                            },
                            {
                              "focus-metavariable": "$ROUTEVAR"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "def $FUNC(request, ...):\n  ...\n"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "request.$PROPERTY.get(...)"
                        },
                        {
                          "pattern": "request.$PROPERTY[...]"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "@rest_framework.decorators.api_view(...)\ndef $FUNC($REQ, ...):\n  ...\n"
                        },
                        {
                          "patterns": [
                            {
                              "pattern-either": [
                                {
                                  "pattern-inside": "class $VIEW(..., rest_framework.views.APIView, ...):\n  ...\n"
                                },
                                {
                                  "pattern-inside": "class $VIEW(..., rest_framework.generics.GenericAPIView, ...):\n  ...                              \n"
                                }
                              ]
                            },
                            {
                              "pattern-inside": "def $METHOD(self, $REQ, ...):\n  ...\n"
                            },
                            {
                              "metavariable-regex": {
                                "metavariable": "$METHOD",
                                "regex": "(get|post|put|patch|delete|head)"
                              }
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "$REQ.POST.get(...)"
                        },
                        {
                          "pattern": "$REQ.POST[...]"
                        },
                        {
                          "pattern": "$REQ.FILES.get(...)"
                        },
                        {
                          "pattern": "$REQ.FILES[...]"
                        },
                        {
                          "pattern": "$REQ.DATA.get(...)"
                        },
                        {
                          "pattern": "$REQ.DATA[...]"
                        },
                        {
                          "pattern": "$REQ.QUERY_PARAMS.get(...)"
                        },
                        {
                          "pattern": "$REQ.QUERY_PARAMS[...]"
                        },
                        {
                          "pattern": "$REQ.data.get(...)"
                        },
                        {
                          "pattern": "$REQ.data[...]"
                        },
                        {
                          "pattern": "$REQ.query_params.get(...)"
                        },
                        {
                          "pattern": "$REQ.query_params[...]"
                        },
                        {
                          "pattern": "$REQ.content_type"
                        },
                        {
                          "pattern": "$REQ.content_type"
                        },
                        {
                          "pattern": "$REQ.stream"
                        },
                        {
                          "pattern": "$REQ.stream"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "class $SERVER(..., http.server.BaseHTTPRequestHandler, ...):\n  ...\n"
                        },
                        {
                          "pattern-inside": "class $SERVER(..., http.server.StreamRequestHandler, ...):\n  ...\n"
                        },
                        {
                          "pattern-inside": "class $SERVER(..., http.server.DatagramRequestHandler, ...):\n  ...\n"
                        }
                      ]
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "self.requestline"
                        },
                        {
                          "pattern": "self.path"
                        },
                        {
                          "pattern": "self.headers[...]"
                        },
                        {
                          "pattern": "self.headers.get(...)"
                        },
                        {
                          "pattern": "self.rfile"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "@pyramid.view.view_config( ... )\ndef $VIEW($REQ):\n  ...\n"
                    },
                    {
                      "pattern": "$REQ.$ANYTHING"
                    },
                    {
                      "pattern-not": "$REQ.dbsession"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-not": "os.$W(\"...\", ...)"
            },
            {
              "pattern-either": [
                {
                  "pattern": "os.system(...)"
                },
                {
                  "pattern": "getattr(os, \"system\")(...)"
                },
                {
                  "pattern": "__import__(\"os\").system(...)"
                },
                {
                  "pattern": "getattr(__import__(\"os\"), \"system\")(...)"
                },
                {
                  "pattern": "$X = __import__(\"os\")\n...\n$X.system(...)\n"
                },
                {
                  "pattern": "$X = __import__(\"os\")\n...\ngetattr($X, \"system\")(...)\n"
                },
                {
                  "pattern": "$X = getattr(os, \"system\")\n...\n$X(...)\n"
                },
                {
                  "pattern": "$X = __import__(\"os\")\n...\n$Y = getattr($X, \"system\")\n...\n$Y(...)\n"
                },
                {
                  "pattern": "os.popen(...)"
                },
                {
                  "pattern": "os.popen2(...)"
                },
                {
                  "pattern": "os.popen3(...)"
                },
                {
                  "pattern": "os.popen4(...)"
                }
              ]
            }
          ]
        }
      ],
      "message": "This vulnerability happens when user input is passed directly to os.system() without proper validation or sanitization. Attackers can inject shell metacharacters to execute arbitrary commands on the system with the application's privileges. This can lead to full system compromise, data theft, or service disruption.",
      "metadata": {
        "source-rule-url": "https://bandit.readthedocs.io/en/latest/plugins/b605_start_process_with_a_shell.html",
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://semgrep.dev/docs/cheat-sheets/python-command-injection/"
        ],
        "asvs": {
          "section": "V5: Validation, Sanitization and Encoding Verification Requirements",
          "control_id": "5.2.4 Dyanmic Code Execution Features",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v52-sanitization-and-sandboxing-requirements",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "python"
        ],
        "confidence": "MEDIUM",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "os.system with user input can run malicious commands",
        "fix-suggestion": "Do not pass untrusted input to `os.system`; use safer execution methods and escape all user-supplied data to prevent command injection."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR"
    },
    {
      "id": "python.lang.security.dangerous-testcapi-run-in-subinterp.dangerous-testcapi-run-in-subinterp",
      "mode": "taint",
      "options": {
        "symbolic_propagation": true
      },
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "flask.request.form.get(...)"
                        },
                        {
                          "pattern": "flask.request.form[...]"
                        },
                        {
                          "pattern": "flask.request.args.get(...)"
                        },
                        {
                          "pattern": "flask.request.args[...]"
                        },
                        {
                          "pattern": "flask.request.values.get(...)"
                        },
                        {
                          "pattern": "flask.request.values[...]"
                        },
                        {
                          "pattern": "flask.request.cookies.get(...)"
                        },
                        {
                          "pattern": "flask.request.cookies[...]"
                        },
                        {
                          "pattern": "flask.request.stream"
                        },
                        {
                          "pattern": "flask.request.headers.get(...)"
                        },
                        {
                          "pattern": "flask.request.headers[...]"
                        },
                        {
                          "pattern": "flask.request.data"
                        },
                        {
                          "pattern": "flask.request.full_path"
                        },
                        {
                          "pattern": "flask.request.url"
                        },
                        {
                          "pattern": "flask.request.json"
                        },
                        {
                          "pattern": "flask.request.get_json()"
                        },
                        {
                          "pattern": "flask.request.view_args.get(...)"
                        },
                        {
                          "pattern": "flask.request.view_args[...]"
                        },
                        {
                          "patterns": [
                            {
                              "pattern-inside": "@$APP.route(...)\ndef $FUNC(..., $ROUTEVAR, ...):\n  ...\n"
                            },
                            {
                              "focus-metavariable": "$ROUTEVAR"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "def $FUNC(request, ...):\n  ...\n"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "request.$PROPERTY.get(...)"
                        },
                        {
                          "pattern": "request.$PROPERTY[...]"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "@rest_framework.decorators.api_view(...)\ndef $FUNC($REQ, ...):\n  ...\n"
                        },
                        {
                          "patterns": [
                            {
                              "pattern-either": [
                                {
                                  "pattern-inside": "class $VIEW(..., rest_framework.views.APIView, ...):\n  ...\n"
                                },
                                {
                                  "pattern-inside": "class $VIEW(..., rest_framework.generics.GenericAPIView, ...):\n  ...                              \n"
                                }
                              ]
                            },
                            {
                              "pattern-inside": "def $METHOD(self, $REQ, ...):\n  ...\n"
                            },
                            {
                              "metavariable-regex": {
                                "metavariable": "$METHOD",
                                "regex": "(get|post|put|patch|delete|head)"
                              }
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "$REQ.POST.get(...)"
                        },
                        {
                          "pattern": "$REQ.POST[...]"
                        },
                        {
                          "pattern": "$REQ.FILES.get(...)"
                        },
                        {
                          "pattern": "$REQ.FILES[...]"
                        },
                        {
                          "pattern": "$REQ.DATA.get(...)"
                        },
                        {
                          "pattern": "$REQ.DATA[...]"
                        },
                        {
                          "pattern": "$REQ.QUERY_PARAMS.get(...)"
                        },
                        {
                          "pattern": "$REQ.QUERY_PARAMS[...]"
                        },
                        {
                          "pattern": "$REQ.data.get(...)"
                        },
                        {
                          "pattern": "$REQ.data[...]"
                        },
                        {
                          "pattern": "$REQ.query_params.get(...)"
                        },
                        {
                          "pattern": "$REQ.query_params[...]"
                        },
                        {
                          "pattern": "$REQ.content_type"
                        },
                        {
                          "pattern": "$REQ.content_type"
                        },
                        {
                          "pattern": "$REQ.stream"
                        },
                        {
                          "pattern": "$REQ.stream"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "class $SERVER(..., http.server.BaseHTTPRequestHandler, ...):\n  ...\n"
                        },
                        {
                          "pattern-inside": "class $SERVER(..., http.server.StreamRequestHandler, ...):\n  ...\n"
                        },
                        {
                          "pattern-inside": "class $SERVER(..., http.server.DatagramRequestHandler, ...):\n  ...\n"
                        }
                      ]
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "self.requestline"
                        },
                        {
                          "pattern": "self.path"
                        },
                        {
                          "pattern": "self.headers[...]"
                        },
                        {
                          "pattern": "self.headers.get(...)"
                        },
                        {
                          "pattern": "self.rfile"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "@pyramid.view.view_config( ... )\ndef $VIEW($REQ):\n  ...\n"
                    },
                    {
                      "pattern": "$REQ.$ANYTHING"
                    },
                    {
                      "pattern-not": "$REQ.dbsession"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "_testcapi.run_in_subinterp($PAYLOAD, ...)\n"
                },
                {
                  "pattern": "test.support.run_in_subinterp($PAYLOAD, ...)\n"
                }
              ]
            },
            {
              "focus-metavariable": "$PAYLOAD"
            },
            {
              "pattern-not": "_testcapi.run_in_subinterp(\"...\", ...)\n"
            },
            {
              "pattern-not": "test.support.run_in_subinterp(\"...\", ...)\n"
            }
          ]
        }
      ],
      "message": "Passing user-controlled content to run_in_subinterp allows attackers to execute arbitrary Python code. This creates a critical remote code execution vulnerability that gives attackers full control over your application. Never allow user input to reach code execution functions.",
      "metadata": {
        "cwe": [
          "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://semgrep.dev/docs/cheat-sheets/python-command-injection/"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "confidence": "MEDIUM",
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "User input in run_in_subinterp enables code execution",
        "fix-suggestion": "Remove all instances where user input reaches `run_in_subinterp()`. Replace with predefined code templates where only safe parameters can be injected. If you need to execute dynamic code, implement rigorous validation and use a sandboxed environment with minimal privileges."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ]
    },
    {
      "id": "python.lang.security.insecure-hash-function.insecure-hash-function",
      "message": "MD4 and MD5 hash functions have known vulnerabilities that make them unsuitable for security purposes. These algorithms can be easily broken using collision attacks, allowing attackers to create different inputs with identical hashes. Always use secure alternatives like SHA-256 for cryptographic applications.",
      "metadata": {
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/hashlib_new_insecure_functions.py",
        "asvs": {
          "section": "V6 Stored Cryptography Verification Requirements",
          "control_id": "6.2.2 Insecure Custom Algorithm",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms",
          "version": "4"
        },
        "references": [
          "https://tools.ietf.org/html/rfc6151",
          "https://crypto.stackexchange.com/questions/44151/how-does-the-flame-malware-take-advantage-of-md5-collision",
          "https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Insecure MD4/MD5 hash functions are vulnerable",
        "fix-suggestion": "Replace `hashlib.md5()` or `hashlib.md4()` with `hashlib.sha256()` or another secure hashing algorithm. Update any hash verification code to use the new algorithm. For password hashing specifically, use dedicated password hashing functions like `bcrypt` or `argon2` that provide additional security features."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "hashlib.new(\"=~/[M|m][D|d][4|5]/\", ...)"
        },
        {
          "pattern": "hashlib.new(..., name=\"=~/[M|m][D|d][4|5]/\", ...)"
        }
      ]
    },
    {
      "id": "python.lang.security.insecure-uuid-version.insecure-uuid-version",
      "patterns": [
        {
          "pattern": "uuid.uuid1(...)"
        }
      ],
      "message": "UUID version 1 uses system information including MAC address and timestamp to generate IDs. This predictability creates security risks as attackers can potentially deduce other UUIDs in sequence, known as the sandwich attack. For secure random identifiers, UUID version 4 provides better randomness and security.",
      "metadata": {
        "references": [
          "https://www.landh.tech/blog/20230811-sandwich-attack/"
        ],
        "cwe": [
          "CWE-330: Use of Insufficiently Random Values"
        ],
        "owasp": [
          "A02:2021 - Cryptographic Failures"
        ],
        "asvs": {
          "section": "V6 Stored Cryptography Verification Requirements",
          "control_id": "6.3.2 Insecure UUID Generation",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v63-random-values",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "python"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Predictable UUID v1 leaks system information",
        "fix-suggestion": "Replace `uuid.uuid1()` with `uuid.uuid4()` to generate UUIDs with better randomness. Ensure any dependencies on UUID ordering or timestamp features are refactored. If deterministic IDs are needed, consider alternative approaches like namespaced UUIDs (`uuid.uuid5()`) with a secure namespace."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "fix-regex": {
        "regex": "uuid1",
        "replacement": "uuid4"
      }
    },
    {
      "id": "python.lang.security.unverified-ssl-context.unverified-ssl-context",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "ssl._create_unverified_context(...)"
            },
            {
              "pattern": "ssl._create_default_https_context = ssl._create_unverified_context"
            }
          ]
        }
      ],
      "fix-regex": {
        "regex": "_create_unverified_context",
        "replacement": "create_default_context"
      },
      "message": "Creating an SSL context without certificate verification disables all TLS protections against man-in-the-middle attacks. This makes your connections vulnerable to interception, potentially exposing sensitive data or enabling credential theft. Always use proper certificate verification in production environments.",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A07:2021 - Identification and Authentication Failures"
        ],
        "cwe": [
          "CWE-295: Improper Certificate Validation"
        ],
        "references": [
          "https://docs.python.org/3/library/ssl.html#ssl-security",
          "https://docs.python.org/3/library/http.client.html#http.client.HTTPSConnection"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Unverified SSL context enables network attacks",
        "fix-suggestion": "Replace custom SSL context creation with `ssl.create_default_context()` which properly verifies certificates. Remove code that sets `check_hostname=False` or `verify_mode=ssl.CERT_NONE`. If certificate verification fails in development, fix the root cause rather than disabling verification."
      },
      "severity": "ERROR",
      "languages": [
        "python"
      ]
    },
    {
      "id": "python.lang.security.use-defused-xml-parse.use-defused-xml-parse",
      "metadata": {
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "references": [
          "https://docs.python.org/3/library/xml.html",
          "https://github.com/tiran/defusedxml",
          "https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "Builtin XML parser allows XXE, use defusedxml",
        "fix-suggestion": "Switch to `defusedxml` libraries for parsing XML to disable external entity processing and mitigate XXE attacks."
      },
      "message": "This vulnerability occurs when Python's built-in XML libraries are used to parse untrusted XML without disabling external entity processing. Attackers can exploit XXE (XML External Entity) vulnerabilities by crafting malicious XML documents that reference external entities. This can lead to server-side request forgery, local file disclosure, denial of service, or other attacks.",
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "patterns": [
        {
          "pattern": "xml.etree.ElementTree.parse($...ARGS)"
        },
        {
          "pattern-not": "xml.etree.ElementTree.parse(\"...\")"
        }
      ],
      "fix": "defusedxml.etree.ElementTree.parse($...ARGS)"
    },
    {
      "id": "python.lang.security.use-defused-xmlrpc.use-defused-xmlrpc",
      "pattern-either": [
        {
          "pattern": "import xmlrpclib"
        },
        {
          "pattern": "import SimpleXMLRPCServer"
        },
        {
          "pattern": "import xmlrpc"
        }
      ],
      "message": "Standard XML-RPC libraries are vulnerable to XML attacks including XML External Entity (XXE) injection. These vulnerabilities can lead to server-side request forgery, local file disclosure, or denial of service. Using the defusedxml package provides protection against these common XML parsing vulnerabilities.",
      "metadata": {
        "cwe": [
          "CWE-776: Improper Restriction of Recursive Entity References in DTDs ('XML Entity Expansion')"
        ],
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/07f84cb5f5e7c1055e6feaa0fe93afa471de0ac3/bandit/blacklists/imports.py#L160",
        "references": [
          "https://pypi.org/project/defusedxml/",
          "https://docs.python.org/3/library/xml.html#xml-vulnerabilities"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "Standard XML-RPC vulnerable to XXE attacks",
        "fix-suggestion": "Replace standard `xmlrpc` with `defusedxml.xmlrpc` by installing the `defusedxml` package. Update imports to use the secure version and ensure all XML parsing uses the protected implementation. Verify that no custom XML parsing bypasses these protections."
      },
      "severity": "ERROR",
      "languages": [
        "python"
      ]
    },
    {
      "id": "python.lang.security.audit.dangerous-annotations-usage.dangerous-annotations-usage",
      "patterns": [
        {
          "pattern": "$C.__annotations__[$NAME] = $X\n"
        },
        {
          "pattern-not": "$C.__annotations__[$NAME] = \"...\"\n"
        },
        {
          "pattern-not": "$C.__annotations__[$NAME] = typing.$Y\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$X",
            "regex": "(?!(int|float|complex|list|tuple|range|str|bytes|bytearray|memoryview|set|frozenset|dict))"
          }
        }
      ],
      "message": "Type annotations processed by typing.get_type_hints are evaluated in global and local namespaces. If attackers can inject arbitrary values into annotations that reach this function, they could execute malicious code. Ensure all annotation values are validated before processing.",
      "severity": "INFO",
      "metadata": {
        "cwe": [
          "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "category": "security",
        "references": [
          "https://docs.python.org/3/library/typing.html#typing.get_type_hints"
        ],
        "technology": [
          "python"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Type annotations evaluation enables code execution",
        "fix-suggestion": "Validate all string-based annotations before passing to `typing.get_type_hints()`. Consider using string literals instead of dynamic values for annotations. If possible, leverage static type checking tools that don't require runtime evaluation of annotations."
      },
      "languages": [
        "python"
      ]
    },
    {
      "id": "python.lang.security.audit.dynamic-urllib-use-detected.dynamic-urllib-use-detected",
      "patterns": [
        {
          "pattern-not": "urllib.$W(\"...\")"
        },
        {
          "pattern-not": "urllib.request.$W(\"...\")"
        },
        {
          "pattern-not": "$OPENER.$W(\"...\")"
        },
        {
          "pattern-either": [
            {
              "pattern": "urllib.urlopen(...)"
            },
            {
              "pattern": "urllib.request.urlopen(...)"
            },
            {
              "pattern": "urllib.urlretrieve(...)"
            },
            {
              "pattern": "urllib.request.urlretrieve(...)"
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "$OPENER = urllib.URLopener(...)\n...\n"
                    },
                    {
                      "pattern-inside": "$OPENER = urllib.request.URLopener(...)\n...\n"
                    },
                    {
                      "pattern-inside": "$OPENER = urllib.FancyURLopener(...)\n...\n"
                    },
                    {
                      "pattern-inside": "$OPENER = urllib.request.FancyURLopener(...)\n...\n"
                    }
                  ]
                },
                {
                  "pattern-either": [
                    {
                      "pattern": "$OPENER.open(...)"
                    },
                    {
                      "pattern": "$OPENER.retrieve(...)"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "message": "Using dynamic or user-controlled values with urllib is dangerous because urllib supports the 'file://' scheme. This could allow attackers to read arbitrary files from your filesystem by manipulating the URL. Always validate URLs before processing or switch to safer libraries.",
      "metadata": {
        "cwe": [
          "CWE-939: Improper Authorization in Handler for Custom URL Scheme"
        ],
        "owasp": "A01:2017 - Injection",
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/blacklists/calls.py#L163",
        "bandit-code": "B310",
        "asvs": {
          "section": "V5: Validation, Sanitization and Encoding Verification Requirements",
          "control_id": "5.2.4 Dynamic Code Execution Features",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v52-sanitization-and-sandboxing-requirements",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "python"
        ],
        "references": [
          "https://cwe.mitre.org/data/definitions/939.html"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Dynamic urllib enables local file access",
        "fix-suggestion": "Validate all URLs used with `urllib` to ensure they use only allowed schemes like `http://` or `https://`. Consider switching to the `requests` library which doesn't support `file://` URLs by default. Implement a URL validation function that rejects potentially dangerous schemes."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.lang.security.audit.eval-detected.eval-detected",
      "patterns": [
        {
          "pattern-not": "eval(f\"\")"
        },
        {
          "pattern-not": "eval(\"...\")"
        },
        {
          "pattern": "eval(...)"
        }
      ],
      "message": "The eval() function executes arbitrary Python code and is extremely dangerous when processing external input. If an attacker can control data passed to eval(), they can execute any code with the same privileges as your application. Avoid eval() whenever possible and never use it with untrusted data.",
      "metadata": {
        "source-rule-url": "https://bandit.readthedocs.io/en/latest/blacklists/blacklist_calls.html#b307-eval",
        "cwe": [
          "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "asvs": {
          "section": "V5: Validation, Sanitization and Encoding Verification Requirements",
          "control_id": "5.2.4 Dyanmic Code Execution Features",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v52-sanitization-and-sandboxing-requirements",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "python"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Eval function enables arbitrary code execution",
        "fix-suggestion": "Remove all uses of `eval()` and replace with safer alternatives. For mathematical expressions, use a specialized library like `sympy` or `ast.literal_eval()` for safe evaluation. If dynamic behavior is needed, implement a restricted function dispatch using a dictionary mapping of allowed operations."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.lang.security.audit.exec-detected.exec-detected",
      "patterns": [
        {
          "pattern-not": "exec(\"...\")"
        },
        {
          "pattern": "exec(...)"
        }
      ],
      "message": "The exec() function executes arbitrary Python code and poses a severe security risk when used with external input. If attackers can influence data passed to exec(), they can execute malicious code with your application's privileges. Avoid exec() whenever possible and never use it with untrusted data.",
      "metadata": {
        "source-rule-url": "https://bandit.readthedocs.io/en/latest/plugins/b102_exec_used.html",
        "cwe": [
          "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "asvs": {
          "section": "V5: Validation, Sanitization and Encoding Verification Requirements",
          "control_id": "5.2.4 Dyanmic Code Execution Features",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x13-V5-Validation-Sanitization-Encoding.md#v52-sanitization-and-sandboxing-requirements",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "python"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Exec function enables arbitrary code execution",
        "fix-suggestion": "Replace all uses of `exec()` with safer alternatives like templating languages or configuration systems. Implement a restricted interface that only allows specific predefined operations. If dynamic code execution is necessary, create a sandboxed environment with minimal privileges."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.lang.security.audit.formatted-sql-query.formatted-sql-query",
      "message": "This vulnerability happens when SQL queries are constructed using string formatting or concatenation with user input. Attackers can inject special SQL syntax that changes the query structure to perform unauthorized database operations. This can lead to data theft, data manipulation, authentication bypass, or complete database compromise.",
      "metadata": {
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "references": [
          "https://stackoverflow.com/questions/775296/mysql-parameterized-queries"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Formatted SQL with user input is injection risk",
        "fix-suggestion": "Replace formatted SQL queries with parameterized queries to separate query logic from user input."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "pattern-either": [
        {
          "pattern": "$DB.execute(\"...\" % ...)"
        },
        {
          "pattern": "$DB.execute(\"...\".format(...))"
        },
        {
          "pattern": "$DB.execute(f\"...\")"
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$SQL = \"...\" % ...\n...\n"
                },
                {
                  "pattern-inside": "$SQL = \"...\".format(...)\n...\n"
                },
                {
                  "pattern-inside": "$SQL = f\"...{$X}...\"\n...\n"
                }
              ]
            },
            {
              "pattern": "$DB.execute($SQL)"
            }
          ]
        }
      ]
    },
    {
      "id": "python.lang.security.audit.hardcoded-password-default-argument.hardcoded-password-default-argument",
      "message": "This vulnerability occurs when passwords or secrets are hardcoded as default function arguments in the source code. These credentials can be discovered through code repository access, decompilation, or when distributed in client-side code. This can lead to unauthorized access to systems or services using the hardcoded credentials.",
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern": "def $FUNC(..., password=\"...\", ...):\n  ...\n"
        },
        {
          "pattern-not": "def $FUNC(..., password=\"\", ...):\n  ...\n"
        }
      ],
      "metadata": {
        "cwe": [
          "CWE-798: Use of Hard-coded Credentials"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "references": [
          "https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Hard-coded Secrets"
        ],
        "short-description": "Insecure default password argument easily discovered",
        "fix-suggestion": "Remove hardcoded passwords from default arguments; load sensitive credentials from secure configuration or environment variables."
      }
    },
    {
      "id": "python.lang.security.audit.httpsconnection-detected.httpsconnection-detected",
      "message": "The HTTPSConnection API has evolved significantly across Python versions with varying default security settings. Particularly, Python 3 versions before 3.4.3 don't verify SSL certificates by default, leaving connections vulnerable to man-in-the-middle attacks. Ensure you're using the correct security configurations for your Python version.",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A07:2021 - Identification and Authentication Failures"
        ],
        "cwe": [
          "CWE-295: Improper Certificate Validation"
        ],
        "references": [
          "https://docs.python.org/3/library/http.client.html#http.client.HTTPSConnection"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "HTTPSConnection has version-dependent security defaults",
        "fix-suggestion": "Explicitly set `context=ssl.create_default_context()` when creating `HTTPSConnection` objects. Verify your Python version and ensure certificate verification is enabled. Consider migrating to the `requests` library which provides more consistent security behavior across Python versions."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "pattern-either": [
        {
          "pattern": "httplib.HTTPSConnection(...)"
        },
        {
          "pattern": "http.client.HTTPSConnection(...)"
        },
        {
          "pattern": "six.moves.http_client.HTTPSConnection(...)"
        }
      ]
    },
    {
      "id": "python.lang.security.audit.insecure-file-permissions.insecure-file-permissions",
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-276: Incorrect Default Permissions"
        ],
        "technology": [
          "python"
        ],
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Overly permissive file mode allows unauthorized access",
        "fix-suggestion": "Set strict file permissions when creating files to limit access and prevent unauthorized modifications."
      },
      "message": "This vulnerability happens when files are created with overly permissive access rights, allowing more users to read or write them than necessary. Attackers with access to the system can read sensitive information from these files or modify them to inject malicious code. This can lead to information disclosure, privilege escalation, or code execution.",
      "patterns": [
        {
          "pattern-inside": "os.$METHOD(...)"
        },
        {
          "metavariable-pattern": {
            "metavariable": "$METHOD",
            "patterns": [
              {
                "pattern-either": [
                  {
                    "pattern": "chmod"
                  },
                  {
                    "pattern": "lchmod"
                  },
                  {
                    "pattern": "fchmod"
                  }
                ]
              }
            ]
          }
        },
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern": "os.$METHOD($FILE, $BITS, ...)"
                },
                {
                  "metavariable-comparison": {
                    "metavariable": "$BITS",
                    "comparison": "$BITS >= 0o650 and $BITS < 0o100000"
                  }
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern": "os.$METHOD($FILE, $BITS)"
                },
                {
                  "metavariable-comparison": {
                    "metavariable": "$BITS",
                    "comparison": "$BITS >= 0o100650"
                  }
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern": "os.$METHOD($FILE, $BITS, ...)"
                },
                {
                  "metavariable-pattern": {
                    "metavariable": "$BITS",
                    "patterns": [
                      {
                        "pattern-either": [
                          {
                            "pattern": "<... stat.S_IWGRP ...>"
                          },
                          {
                            "pattern": "<... stat.S_IXGRP ...>"
                          },
                          {
                            "pattern": "<... stat.S_IWOTH ...>"
                          },
                          {
                            "pattern": "<... stat.S_IXOTH ...>"
                          },
                          {
                            "pattern": "<... stat.S_IRWXO ...>"
                          },
                          {
                            "pattern": "<... stat.S_IRWXG ...>"
                          }
                        ]
                      }
                    ]
                  }
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern": "os.$METHOD($FILE, $EXPR | $MOD, ...)"
                },
                {
                  "metavariable-comparison": {
                    "metavariable": "$MOD",
                    "comparison": "$MOD == 0o111"
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "python.lang.security.audit.mako-templates-detected.mako-templates-detected",
      "pattern": "mako.template.Template(...)",
      "message": "This vulnerability occurs because Mako templates don't automatically escape HTML output by default unlike some other template engines. Without explicit escaping, user input rendered in templates can contain malicious HTML or JavaScript code. This can lead to cross-site scripting (XSS) vulnerabilities that allow attackers to steal session cookies or execute arbitrary code in users' browsers.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/mako_templates.py",
        "references": [
          "https://docs.makotemplates.org/en/latest/syntax.html#expression-escaping",
          "https://jinja.palletsprojects.com/en/2.11.x/intro/#"
        ],
        "category": "security",
        "technology": [
          "mako"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Mako templates require manual HTML escaping to prevent XSS",
        "fix-suggestion": "Configure Mako templates to automatically escape HTML output or sanitize user input before rendering."
      },
      "languages": [
        "python"
      ],
      "severity": "INFO"
    },
    {
      "id": "python.lang.security.audit.md5-used-as-password.md5-used-as-password",
      "severity": "WARNING",
      "message": "MD5 is cryptographically broken and unsuitable for password storage. Password hashes created with MD5 can be cracked quickly using modern hardware, putting user credentials at risk. Always use specialized password hashing functions that incorporate salting and key stretching.",
      "languages": [
        "python"
      ],
      "metadata": {
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "references": [
          "https://tools.ietf.org/html/rfc6151",
          "https://crypto.stackexchange.com/questions/44151/how-does-the-flame-malware-take-advantage-of-md5-collision",
          "https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html",
          "https://security.stackexchange.com/questions/211/how-to-securely-hash-passwords",
          "https://github.com/returntocorp/semgrep-rules/issues/1609",
          "https://docs.python.org/3/library/hashlib.html#hashlib.scrypt"
        ],
        "category": "security",
        "technology": [
          "pycryptodome",
          "hashlib",
          "md5"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "LOW",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "MD5 password hashing is easily cracked",
        "fix-suggestion": "Replace `hashlib.md5()` with `hashlib.scrypt()` for password hashing. Add proper salt generation using `os.urandom()`. For a complete solution, consider using established password hashing libraries like `bcrypt` or `argon2-cffi` which handle salting and security parameters automatically."
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "hashlib.md5"
                },
                {
                  "pattern": "hashlib.new(..., name=\"MD5\", ...)"
                },
                {
                  "pattern": "Cryptodome.Hash.MD5"
                },
                {
                  "pattern": "Crypto.Hash.MD5"
                },
                {
                  "pattern": "cryptography.hazmat.primitives.hashes.MD5"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$FUNCTION(...)"
            },
            {
              "metavariable-regex": {
                "metavariable": "$FUNCTION",
                "regex": "(?i)(.*password.*)"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "python.lang.security.audit.non-literal-import.non-literal-import",
      "patterns": [
        {
          "pattern": "importlib.import_module($NAME, ...)\n"
        },
        {
          "pattern-not": "importlib.import_module(\"...\", ...)\n"
        }
      ],
      "message": "Using untrusted user input with importlib.import_module() creates a serious security vulnerability. Attackers can potentially load malicious modules or access sensitive modules in your application. Always validate module names against an allowlist before importing dynamically.",
      "metadata": {
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-706: Use of Incorrectly-Resolved Name or Reference"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Dynamic imports enable loading arbitrary modules",
        "fix-suggestion": "Create a whitelist of allowed module names and validate all inputs to `importlib.import_module()`. Use a dictionary mapping of allowed modules to functions instead of dynamic imports. Consider a plugin architecture with strict validation if dynamic loading is necessary."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.lang.security.audit.paramiko-implicit-trust-host-key.paramiko-implicit-trust-host-key",
      "patterns": [
        {
          "pattern-inside": "$CLIENT = paramiko.client.SSHClient(...)\n...\n$CLIENT.set_missing_host_key_policy(...)\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "paramiko.client.AutoAddPolicy"
            },
            {
              "pattern": "paramiko.client.WarningPolicy"
            }
          ]
        }
      ],
      "message": "This Paramiko SSH configuration implicitly trusts any server host key, creating a man-in-the-middle vulnerability. Without proper host key verification, attackers can intercept SSH connections by impersonating the target server. Always verify host keys to maintain the security of SSH connections.",
      "metadata": {
        "cwe": [
          "CWE-322: Key Exchange without Entity Authentication"
        ],
        "owasp": [
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/ssh_no_host_key_verification.py",
        "references": [
          "http://docs.paramiko.org/en/stable/api/client.html#paramiko.client.AutoAddPolicy"
        ],
        "category": "security",
        "technology": [
          "paramiko"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Paramiko trusts any SSH host key",
        "fix-suggestion": "Replace `AutoAddPolicy` with `RejectPolicy` and implement proper host key verification. Use `load_system_host_keys()` to load known keys from the system. Create a custom policy that verifies keys against your known hosts if more control is needed."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.lang.security.audit.python-reverse-shell.python-reverse-shell",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "pty.spawn(\"$BINPATH\",...)"
            },
            {
              "pattern": "subprocess.call([\"$BINPATH\",...],...)"
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$BINPATH",
            "regex": "/bin/.*?sh\\b"
          }
        },
        {
          "pattern-inside": "import socket\n...\n$S = socket.socket(...)\n...\n$S.connect(($IP,$PORT),...)\n...\n"
        }
      ],
      "message": "A reverse shell pattern was detected that creates a connection back to a potentially malicious server. This code provides command execution capabilities to the remote server, giving complete control over the local system. Reverse shells are commonly used in attacks and should be carefully reviewed.",
      "metadata": {
        "cwe": [
          "CWE-553: Command Shell in Externally Accessible Directory"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "references": [
          "https://cwe.mitre.org/data/definitions/553.html"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Reverse shell grants remote command execution",
        "fix-suggestion": "Remove the reverse shell code entirely if it's not required for legitimate purposes. If remote execution is needed, implement a secure API with proper authentication, authorization, and input validation. Consider using established remote management tools rather than custom shell implementations."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.lang.security.audit.sha224-hash.sha224-hash",
      "message": "SHA-224 is a 224-bit hash function that may be disallowed by some security policies. While not cryptographically broken like MD5 or SHA-1, many organizations require stronger hash functions for compliance reasons. Consider using SHA-384 or stronger hash functions to ensure security policy compliance.",
      "metadata": {
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "references": [
          "https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar3.ipd.pdf",
          "https://www.cyber.gov.au/resources-business-and-government/essential-cyber-security/ism/cyber-security-guidelines/guidelines-cryptography"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "SHA-224 hash function below security standards",
        "fix-suggestion": "Replace `hashlib.sha224()` with `hashlib.sha384()` or `hashlib.sha512()` for improved security margin. Update any hash verification code to use the new algorithm. For cryptographic applications, ensure the hash function meets your specific security policy requirements."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "pattern-either": [
        {
          "pattern": "hashlib.sha224(...)"
        },
        {
          "pattern": "hashlib.sha3_224(...)"
        }
      ]
    },
    {
      "id": "python.lang.security.audit.ssl-wrap-socket-is-deprecated.ssl-wrap-socket-is-deprecated",
      "pattern": "ssl.wrap_socket(...)",
      "message": "The ssl.wrap_socket() function is deprecated and creates insecure SSL connections. It doesn't implement Server Name Indication (SNI) or hostname verification, leaving connections vulnerable to man-in-the-middle attacks. Use ssl.SSLContext to create properly configured secure connections.",
      "metadata": {
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "references": [
          "https://docs.python.org/3/library/ssl.html#ssl.wrap_socket",
          "https://docs.python.org/3/library/ssl.html#ssl.SSLContext.wrap_socket"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Deprecated ssl.wrap_socket lacks security features",
        "fix-suggestion": "Replace `ssl.wrap_socket()` with `context = ssl.create_default_context()` followed by `context.wrap_socket(sock, server_hostname=host)`. This enables proper certificate verification including hostname checking. Ensure SNI support by always providing the `server_hostname` parameter."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.lang.security.audit.subprocess-shell-true.subprocess-shell-true",
      "patterns": [
        {
          "pattern": "subprocess.$FUNC(..., shell=$TRUE, ...)"
        },
        {
          "metavariable-pattern": {
            "metavariable": "$TRUE",
            "pattern": "True \n"
          }
        },
        {
          "pattern-not": "subprocess.$FUNC(\"...\", shell=True, ...)"
        },
        {
          "focus-metavariable": "$TRUE"
        }
      ],
      "message": "This vulnerability happens when subprocess functions are called with shell=True, which spawns a shell to interpret the command. When combined with user input, attackers can inject shell metacharacters to execute additional commands. This can lead to arbitrary command execution on the server with the application's privileges.",
      "fix": "False\n",
      "metadata": {
        "source-rule-url": "https://bandit.readthedocs.io/en/latest/plugins/b602_subprocess_popen_with_shell_equals_true.html",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "references": [
          "https://stackoverflow.com/questions/3172470/actual-meaning-of-shell-true-in-subprocess",
          "https://docs.python.org/3/library/subprocess.html"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "secure default"
        ],
        "likelihood": "HIGH",
        "impact": "LOW",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "subprocess with shell=True simplifies malicious injection",
        "fix-suggestion": "Avoid using `shell=True` in subprocess calls with user input; use fixed argument lists and sanitize dynamic data."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR"
    },
    {
      "id": "python.lang.security.audit.system-wildcard-detected.system-wildcard-detected",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "os.system(\"...\")"
            },
            {
              "pattern-inside": "os.popen(\"...\")"
            },
            {
              "pattern-inside": "os.popen2(\"...\")"
            },
            {
              "pattern-inside": "os.popen3(\"...\")"
            },
            {
              "pattern-inside": "os.popen4(\"...\")"
            },
            {
              "pattern-inside": "subprocess.$W(..., shell=True, ...)"
            }
          ]
        },
        {
          "pattern-regex": "(tar|chmod|chown|rsync)(.*?)\\*"
        }
      ],
      "message": "Using shell wildcards in system calls can lead to command injection vulnerabilities. If attackers can create files with special characters in their names (like '-e sh script.sh'), these filenames can be interpreted as command flags when the wildcard expands. Always sanitize inputs and avoid shell wildcards with system calls.",
      "metadata": {
        "cwe": [
          "CWE-155: Improper Neutralization of Wildcards or Matching Symbols"
        ],
        "owasp": "A01:2017 - Injection",
        "source-url-open": "https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/injection_wildcard.py",
        "references": [
          "https://www.defensecode.com/public/DefenseCode_Unix_WildCards_Gone_Wild.txt"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "Shell wildcards in system calls enable injection",
        "fix-suggestion": "Replace shell wildcards (`*`, `?`) in system calls with explicit file listing using `os.listdir()` or `glob.glob()`. Process filenames individually rather than passing wildcards to shell commands. Use `subprocess` module with `shell=False` when executing external commands to prevent shell expansion."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.lang.security.audit.telnetlib.telnetlib",
      "pattern": "telnetlib.$ANYTHING(...)",
      "message": "Telnet transmits all data including credentials in plaintext, making it vulnerable to eavesdropping and credential theft. Anyone with network access can intercept and read telnet communications, compromising security. Use SSH instead which provides encryption for all transmitted data.",
      "metadata": {
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L208",
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "bandit-code": "B312",
        "references": [
          "https://docs.python.org/3/library/telnetlib.html"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Telnet transmits credentials in plaintext",
        "fix-suggestion": "Replace `telnetlib` with `paramiko` or another SSH library for secure remote connections. Ensure proper key verification is implemented in your SSH implementation. If you must connect to legacy telnet services, use a secure tunnel or VPN to protect the connection."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ]
    },
    {
      "id": "python.lang.security.audit.weak-ssl-version.weak-ssl-version",
      "message": "TLS versions below 1.2 are vulnerable to various attacks and have been deprecated. Using these older versions exposes your connections to known security issues like POODLE and BEAST attacks. Always use TLS 1.2 or higher for secure communications.",
      "metadata": {
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/insecure_ssl_tls.py#L30",
        "asvs": {
          "section": "V9 Communications Verification Requirements",
          "control_id": "9.1.3 Weak TLS",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x17-V9-Communications.md#v91-client-communications-security-requirements",
          "version": "4"
        },
        "references": [
          "https://tools.ietf.org/html/rfc7568",
          "https://tools.ietf.org/id/draft-ietf-tls-oldversions-deprecate-02.html",
          "https://docs.python.org/3/library/ssl.html#ssl.PROTOCOL_TLSv1_2"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Weak TLS version vulnerable to attacks",
        "fix-suggestion": "Replace deprecated constants like `ssl.PROTOCOL_TLSv1` with `ssl.PROTOCOL_TLS_CLIENT` or `ssl.PROTOCOL_TLSv1_2`. Set minimum version with `context.minimum_version = ssl.TLSVersion.TLSv1_2`. Use `ssl.create_default_context()` where possible as it configures secure defaults automatically."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "ssl.PROTOCOL_SSLv2"
        },
        {
          "pattern": "ssl.PROTOCOL_SSLv3"
        },
        {
          "pattern": "ssl.PROTOCOL_TLSv1"
        },
        {
          "pattern": "ssl.PROTOCOL_TLSv1_1"
        },
        {
          "pattern": "pyOpenSSL.SSL.SSLv2_METHOD"
        },
        {
          "pattern": "pyOpenSSL.SSL.SSLv23_METHOD"
        },
        {
          "pattern": "pyOpenSSL.SSL.SSLv3_METHOD"
        },
        {
          "pattern": "pyOpenSSL.SSL.TLSv1_METHOD"
        },
        {
          "pattern": "pyOpenSSL.SSL.TLSv1_1_METHOD"
        }
      ]
    },
    {
      "id": "python.lang.security.audit.conn_recv.multiprocessing-recv",
      "languages": [
        "python"
      ],
      "message": "This vulnerability occurs because Connection.recv() in multiprocessing automatically unpickles data, which can execute arbitrary code. Attackers who can send data to this connection can craft malicious pickle payloads. This can lead to arbitrary code execution with the privileges of the receiving process.",
      "metadata": {
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "references": [
          "https://docs.python.org/3/library/multiprocessing.html?highlight=security#multiprocessing.connection.Connection"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "multiprocessing recv auto-unpickles data from untrusted source",
        "fix-suggestion": "Do not unpickle data received over multiprocessing connections; use safer data exchange mechanisms or validate the source of the data."
      },
      "pattern-either": [
        {
          "pattern": "multiprocessing.connection.Connection.recv(...)"
        },
        {
          "pattern": "multiprocessing.connection.Client.recv(...)"
        },
        {
          "pattern": "$C = multiprocessing.connection.Client(...)\n...\n$C.recv(...)\n"
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.lang.security.audit.insecure-transport.ftplib.use-ftp-tls.use-ftp-tls",
      "patterns": [
        {
          "pattern": "ftplib.FTP(...)"
        },
        {
          "pattern-not": "ftplib.FTP_TLS(...)"
        }
      ],
      "fix-regex": {
        "regex": "FTP(.*)\\)",
        "replacement": "FTP_TLS\\1, context=ssl.create_default_context())"
      },
      "message": "The standard FTP protocol transmits all data including credentials in plaintext. This allows attackers with network access to intercept and steal sensitive information. Always use FTP_TLS instead which encrypts the connection, protecting credentials and transferred data.",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "references": [
          "https://docs.python.org/3/library/ftplib.html#ftplib.FTP_TLS"
        ],
        "category": "security",
        "technology": [
          "ftplib"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "FTP sends credentials in plaintext",
        "fix-suggestion": "Replace `ftplib.FTP()` with `ftplib.FTP_TLS()` to enable encryption. Call `ftps.auth()` after connecting to enable TLS encryption. Consider using more modern secure file transfer protocols like SFTP (via the `paramiko` library) if supported by your server."
      },
      "severity": "INFO",
      "languages": [
        "python"
      ]
    },
    {
      "id": "python.lang.security.audit.insecure-transport.requests.request-session-http-in-with-context.request-session-http-in-with-context",
      "options": {
        "symbolic_propagation": true
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "\"$URL\"\n"
            },
            {
              "metavariable-pattern": {
                "metavariable": "$URL",
                "language": "regex",
                "patterns": [
                  {
                    "pattern-regex": "http://"
                  },
                  {
                    "pattern-not-regex": ".*://localhost"
                  },
                  {
                    "pattern-not-regex": ".*://127\\.0\\.0\\.1"
                  }
                ]
              }
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-inside": "with requests.Session(...) as $SESSION:\n  ...\n"
            },
            {
              "pattern-either": [
                {
                  "pattern": "$SESSION.$W($SINK, ...)"
                },
                {
                  "pattern": "$SESSION.request($METHOD, $SINK, ...)"
                }
              ]
            },
            {
              "focus-metavariable": "$SINK"
            }
          ]
        }
      ],
      "fix-regex": {
        "regex": "[Hh][Tt][Tt][Pp]://",
        "replacement": "https://",
        "count": 1
      },
      "message": "HTTP requests transmit data in plaintext, exposing sensitive information to network eavesdropping. Anyone with access to the network path can intercept unencrypted HTTP traffic. Use HTTPS instead to ensure encryption of all data in transit.",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "asvs": {
          "section": "V9 Communications Verification Requirements",
          "control_id": "9.2.1 Weak TLS",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x17-V9-Communications.md#v92-server-communications-security-requirements",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "requests"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "HTTP requests expose data in plaintext",
        "fix-suggestion": "Change all URLs from `http://` to `https://` in your requests. Implement redirect validation if your application follows redirects. Add certificate verification with `verify=True` (the default) when making HTTPS requests, and never disable this in production."
      },
      "languages": [
        "python"
      ],
      "severity": "INFO"
    },
    {
      "id": "python.lang.security.audit.insecure-transport.requests.request-session-with-http.request-session-with-http",
      "options": {
        "symbolic_propagation": true
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "\"$URL\"\n"
            },
            {
              "metavariable-pattern": {
                "metavariable": "$URL",
                "language": "regex",
                "patterns": [
                  {
                    "pattern-regex": "http://"
                  },
                  {
                    "pattern-not-regex": ".*://localhost"
                  },
                  {
                    "pattern-not-regex": ".*://127\\.0\\.0\\.1"
                  }
                ]
              }
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "requests.Session(...).$W($SINK, ...)"
                },
                {
                  "pattern": "requests.Session(...).request($METHOD, $SINK, ...)"
                }
              ]
            },
            {
              "focus-metavariable": "$SINK"
            }
          ]
        }
      ],
      "fix-regex": {
        "regex": "[Hh][Tt][Tt][Pp]://",
        "replacement": "https://",
        "count": 1
      },
      "message": "HTTP requests transmit data in plaintext, exposing sensitive information to network eavesdropping. Anyone with access to the network path can intercept unencrypted HTTP traffic. Use HTTPS instead to ensure encryption of all data in transit.",
      "languages": [
        "python"
      ],
      "severity": "INFO",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "asvs": {
          "section": "V9 Communications Verification Requirements",
          "control_id": "9.1.1 Weak TLS",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x17-V9-Communications.md#v92-server-communications-security-requirements",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "requests"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "HTTP requests expose data in plaintext",
        "fix-suggestion": "Replace all `http://` URLs with `https://` in your request session. Configure your application to validate redirects. Consider implementing an HTTP-to-HTTPS redirect in your server configuration while ensuring your client code uses HTTPS directly."
      }
    },
    {
      "id": "python.lang.security.audit.insecure-transport.requests.request-with-http.request-with-http",
      "fix-regex": {
        "regex": "[Hh][Tt][Tt][Pp]://",
        "replacement": "https://",
        "count": 1
      },
      "message": "HTTP requests transmit data in plaintext, exposing sensitive information to network eavesdropping. Attackers with network access can intercept unencrypted HTTP traffic and extract credentials, tokens, or other sensitive data. Use HTTPS instead to ensure encryption of all data in transit.",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "asvs": {
          "section": "V9 Communications Verification Requirements",
          "control_id": "9.1.1 Weak TLS",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x17-V9-Communications.md#v92-server-communications-security-requirements",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "requests"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "HTTP requests expose data in plaintext",
        "fix-suggestion": "Replace all `http://` URLs with `https://` in your requests. Enforce HTTPS usage through application configuration or middleware. Consider implementing HTTP Strict Transport Security (HSTS) on your servers to prevent clients from using insecure connections."
      },
      "languages": [
        "python"
      ],
      "severity": "INFO",
      "options": {
        "symbolic_propagation": true
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "\"$URL\"\n"
            },
            {
              "metavariable-pattern": {
                "metavariable": "$URL",
                "language": "regex",
                "patterns": [
                  {
                    "pattern-regex": "http://"
                  },
                  {
                    "pattern-not-regex": ".*://localhost"
                  },
                  {
                    "pattern-not-regex": ".*://127\\.0\\.0\\.1"
                  }
                ]
              }
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "requests.$W($SINK, ...)"
                },
                {
                  "pattern": "requests.request($METHOD, $SINK, ...)"
                },
                {
                  "pattern": "requests.Request($METHOD, $SINK, ...)"
                }
              ]
            },
            {
              "focus-metavariable": "$SINK"
            }
          ]
        }
      ]
    },
    {
      "id": "python.lang.security.audit.insecure-transport.ssl.no-set-ciphers.no-set-ciphers",
      "pattern": "$CONTEXT.set_ciphers(...)",
      "message": "The set_ciphers() method can weaken SSL security if misconfigured. The default cipher suite in the ssl module is carefully selected for security, and custom configurations often inadvertently reduce security. Only use set_ciphers() when you have specific, well-understood requirements.",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "asvs": {
          "section": "V9 Communications Verification Requirements",
          "control_id": "9.1.3 Weak TLS",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x17-V9-Communications.md#v91-client-communications-security-requirements",
          "version": "4"
        },
        "references": [
          "https://docs.python.org/3/library/ssl.html#cipher-selection",
          "https://docs.python.org/3/library/ssl.html#ssl.SSLContext.set_ciphers"
        ],
        "category": "security",
        "technology": [
          "ssl"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Custom SSL ciphers may weaken security",
        "fix-suggestion": "Remove calls to `set_ciphers()` and rely on the default cipher configuration. If cipher customization is necessary, consult current best practices and security standards. Use `ssl.create_default_context()` to get a preconfigured context with secure defaults."
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.lang.security.audit.insecure-transport.urllib.insecure-openerdirector-open-ftp.insecure-openerdirector-open-ftp",
      "message": "Using 'OpenerDirector.open(...)' with 'ftp://' creates an unsecured transmission channel where all information is sent without encryption. This exposes sensitive data to interception by attackers monitoring network traffic. Consider using encrypted protocols like SFTP for secure file transfers instead.",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "references": [
          "https://docs.python.org/3/library/urllib.request.html#urllib.request.OpenerDirector.open"
        ],
        "category": "security",
        "technology": [
          "urllib"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Unencrypted FTP usage in OpenerDirector.open",
        "fix-suggestion": "Replace FTP with encrypted alternatives like SFTP by using libraries such as `paramiko` or `pysftp`. Since `urllib` doesn't support SFTP natively, switch to a library that provides secure file transfer capabilities. Always encrypt sensitive data in transit to prevent eavesdropping."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "pattern-either": [
        {
          "pattern": "urllib.request.OpenerDirector(...).open(\"=~/^[Ff][Tt][Pp]://.*/\", ...)"
        },
        {
          "patterns": [
            {
              "pattern-inside": "$OPENERDIRECTOR = urllib.request.OpenerDirector(...)\n...\n"
            },
            {
              "pattern": "$OPENERDIRECTOR.open(\"=~/^[Ff][Tt][Pp]://.*/\", ...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$OPENERDIRECTOR = urllib.request.OpenerDirector(...)\n...\n"
            },
            {
              "pattern": "$URL = \"=~/^[Ff][Tt][Pp]://.*/\"\n...\n$OPENERDIRECTOR.open($URL, ...)\n"
            }
          ]
        },
        {
          "pattern": "$URL = \"=~/^[Ff][Tt][Pp]://.*/\"\n...\nurllib.request.OpenerDirector(...).open($URL, ...)\n"
        },
        {
          "patterns": [
            {
              "pattern-inside": "def $FUNC(..., $URL = \"=~/^[Ff][Tt][Pp]://.*/\", ...):\n  ...\n"
            },
            {
              "pattern-either": [
                {
                  "pattern": "urllib.request.OpenerDirector(...).open($URL, ...)"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$OPENERDIRECTOR = urllib.request.OpenerDirector(...)\n...\n"
                    },
                    {
                      "pattern": "$OPENERDIRECTOR.open($URL, ...)"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "python.lang.security.audit.insecure-transport.urllib.insecure-openerdirector-open.insecure-openerdirector-open",
      "message": "Using 'OpenerDirector.open(...)' with 'http://' creates an unsecured transmission channel where data is transmitted in plaintext. This makes your application vulnerable to eavesdropping, especially when sending sensitive information. Use 'https://' instead to encrypt the communication channel.",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "references": [
          "https://docs.python.org/3/library/urllib.request.html#urllib.request.OpenerDirector.open"
        ],
        "category": "security",
        "technology": [
          "urllib"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Unencrypted HTTP usage in OpenerDirector.open",
        "fix-suggestion": "Replace `http://` URLs with `https://` URLs in all `OpenerDirector.open()` calls. Always use HTTPS for all API requests and data transmissions to ensure encryption of data in transit. Consider implementing certificate validation to prevent man-in-the-middle attacks."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "fix-regex": {
        "regex": "[Hh][Tt][Tt][Pp]://",
        "replacement": "https://",
        "count": 1
      },
      "pattern-either": [
        {
          "pattern": "urllib.request.OpenerDirector(...).open(\"=~/[Hh][Tt][Tt][Pp]://.*/\", ...)"
        },
        {
          "patterns": [
            {
              "pattern-inside": "$OPENERDIRECTOR = urllib.request.OpenerDirector(...)\n...\n"
            },
            {
              "pattern": "$OPENERDIRECTOR.open(\"=~/[Hh][Tt][Tt][Pp]://.*/\", ...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$OPENERDIRECTOR = urllib.request.OpenerDirector(...)\n...\n"
            },
            {
              "pattern": "$URL = \"=~/[Hh][Tt][Tt][Pp]://.*/\"\n...\n$OPENERDIRECTOR.open($URL, ...)\n"
            }
          ]
        },
        {
          "pattern": "$URL = \"=~/[Hh][Tt][Tt][Pp]://.*/\"\n...\nurllib.request.OpenerDirector(...).open($URL, ...)\n"
        },
        {
          "patterns": [
            {
              "pattern-inside": "def $FUNC(..., $URL = \"=~/[Hh][Tt][Tt][Pp]://.*/\", ...):\n  ...\n"
            },
            {
              "pattern-either": [
                {
                  "pattern": "urllib.request.OpenerDirector(...).open($URL, ...)"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$OPENERDIRECTOR = urllib.request.OpenerDirector(...)\n...\n"
                    },
                    {
                      "pattern": "$OPENERDIRECTOR.open($URL, ...)"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "python.lang.security.audit.insecure-transport.urllib.insecure-request-object-ftp.insecure-request-object-ftp",
      "message": "Creating a 'urllib.request.Request()' object with 'ftp://' exposes your application to security risks as data is transmitted without encryption. Attackers can intercept and access sensitive information sent over this connection. Consider using encrypted protocols for file transfers.",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "references": [
          "https://docs.python.org/3/library/urllib.request.html#urllib.request.Request"
        ],
        "category": "security",
        "technology": [
          "urllib"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Unencrypted FTP in urllib Request object",
        "fix-suggestion": "Replace FTP with SFTP by using secure libraries like `paramiko` or `pysftp` instead of `urllib`. If file transfer is required, implement proper encryption to protect sensitive data during transmission. Always validate and sanitize both source and destination paths."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "pattern-either": [
        {
          "pattern": "urllib.request.Request(\"=~/^[Ff][Tt][Pp]://.*/\", ...)"
        },
        {
          "pattern": "$URL = \"=~/^[Ff][Tt][Pp]://.*/\"\n...\nurllib.request.Request($URL, ...)\n"
        },
        {
          "pattern": "def $FUNC(..., $URL = \"=~/^[Ff][Tt][Pp]://.*/\", ...):\n  ...\n  urllib.request.Request($URL, ...)"
        }
      ]
    },
    {
      "id": "python.lang.security.audit.insecure-transport.urllib.insecure-request-object.insecure-request-object",
      "message": "Creating a 'urllib.request.Request()' object with 'http://' exposes your application to security risks as data is transmitted in plaintext. This allows attackers to intercept and view sensitive information during transmission. Use 'https://' instead to encrypt the connection.",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "references": [
          "https://docs.python.org/3/library/urllib.request.html#urllib.request.Request"
        ],
        "category": "security",
        "technology": [
          "urllib"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Insecure HTTP in urllib Request object",
        "fix-suggestion": "Replace all `http://` URLs with `https://` URLs in your `urllib.request.Request()` calls. Ensure proper certificate validation is implemented to verify the identity of remote servers. Consider using a modern HTTP library like `requests` with built-in security features."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "fix-regex": {
        "regex": "[Hh][Tt][Tt][Pp]://",
        "replacement": "https://",
        "count": 1
      },
      "pattern-either": [
        {
          "pattern": "urllib.request.Request(\"=~/[Hh][Tt][Tt][Pp]://.*/\", ...)"
        },
        {
          "pattern": "$URL = \"=~/[Hh][Tt][Tt][Pp]://.*/\"\n...\nurllib.request.Request($URL, ...)\n"
        },
        {
          "pattern": "def $FUNC(..., $URL = \"=~/[Hh][Tt][Tt][Pp]://.*/\", ...):\n  ...\n  urllib.request.Request($URL, ...)\n"
        }
      ]
    },
    {
      "id": "python.lang.security.audit.insecure-transport.urllib.insecure-urlopen-ftp.insecure-urlopen-ftp",
      "message": "Using 'urllib.urlopen()' with 'ftp://' creates an unencrypted connection that may expose sensitive data to network eavesdropping. FTP transmits credentials and file contents in plaintext, making them vulnerable to interception. Consider using an encrypted alternative like SFTP.",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "references": [
          "https://docs.python.org/3/library/urllib.request.html#urllib.request.urlopen"
        ],
        "category": "security",
        "technology": [
          "urllib"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Insecure FTP connection in urllib.urlopen",
        "fix-suggestion": "Replace unencrypted FTP with SFTP by using secure libraries like `paramiko` or `pysftp`. Since `urllib` doesn't support SFTP natively, switch to a library that implements secure file transfer protocols. Always encrypt data during transmission to prevent unauthorized access."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "pattern-either": [
        {
          "pattern": "urllib.request.urlopen(\"=~/^[Ff][Tt][Pp]://.*/\", ...)"
        },
        {
          "pattern": "$URL = \"=~/^[Ff][Tt][Pp]://.*/\"\n...\nurllib.request.urlopen($URL, ...)\n"
        },
        {
          "pattern": "def $FUNC(..., $URL = \"=~/^[Ff][Tt][Pp]://.*/\", ...):\n  ...\n  urllib.request.urlopen($URL, ...)"
        }
      ]
    },
    {
      "id": "python.lang.security.audit.insecure-transport.urllib.insecure-urlopen.insecure-urlopen",
      "message": "Using 'urllib.urlopen()' with 'http://' creates an unencrypted connection that transmits data in plaintext. This allows attackers to intercept and read sensitive information during transmission. Use 'https://' instead to ensure data is encrypted during transport.",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "references": [
          "https://docs.python.org/3/library/urllib.request.html#urllib.request.urlopen"
        ],
        "category": "security",
        "technology": [
          "urllib"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Insecure HTTP connection in urllib.urlopen",
        "fix-suggestion": "Replace all `http://` URLs with `https://` URLs in your `urllib.urlopen()` calls. If using Python 3, consider migrating to the modern `urllib.request` module with proper TLS configuration. Implement certificate validation to prevent man-in-the-middle attacks."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "fix-regex": {
        "regex": "[Hh][Tt][Tt][Pp]://",
        "replacement": "https://"
      },
      "pattern-either": [
        {
          "pattern": "urllib.request.urlopen(\"=~/[Hh][Tt][Tt][Pp]://.*/\", ...)"
        },
        {
          "pattern": "$URL = \"=~/[Hh][Tt][Tt][Pp]://.*/\"\n...\nurllib.request.urlopen($URL, ...)\n"
        },
        {
          "pattern": "def $FUNC(..., $URL = \"=~/[Hh][Tt][Tt][Pp]://.*/\", ...):\n  ...\n  urllib.request.urlopen($URL, ...)\n"
        }
      ]
    },
    {
      "id": "python.lang.security.audit.insecure-transport.urllib.insecure-urlopener-open-ftp.insecure-urlopener-open-ftp",
      "message": "Using 'URLopener.open(...)' with 'ftp://' exposes your application to security risks due to unencrypted data transmission. FTP sends all data including credentials in plaintext, making it susceptible to network sniffing attacks. Use secure alternatives like SFTP instead.",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "references": [
          "https://docs.python.org/3/library/urllib.request.html#urllib.request.URLopener.open"
        ],
        "category": "security",
        "technology": [
          "urllib"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Unencrypted FTP in URLopener.open",
        "fix-suggestion": "Switch from FTP to SFTP by using secure libraries like `paramiko` or `pysftp`. Since `urllib` doesn't natively support encrypted file transfer protocols, migrate to a library that implements secure alternatives. Always encrypt credentials and sensitive data during transmission."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "pattern-either": [
        {
          "pattern": "urllib.request.URLopener(...).open(\"=~/[Ff][Tt][Pp]://.*/\", ...)"
        },
        {
          "patterns": [
            {
              "pattern-inside": "$OPENERDIRECTOR = urllib.request.URLopener(...)\n...\n"
            },
            {
              "pattern": "$OPENERDIRECTOR.open(\"=~/[Ff][Tt][Pp]://.*/\", ...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$OPENERDIRECTOR = urllib.request.URLopener(...)\n...\n"
            },
            {
              "pattern": "$URL = \"=~/[Ff][Tt][Pp]://.*/\"\n...\n$OPENERDIRECTOR.open($URL, ...)\n"
            }
          ]
        },
        {
          "pattern": "$URL = \"=~/[Ff][Tt][Pp]://.*/\"\n...\nurllib.request.URLopener(...).open($URL, ...)\n"
        },
        {
          "patterns": [
            {
              "pattern-inside": "def $FUNC(..., $URL = \"=~/[Ff][Tt][Pp]://.*/\", ...):\n  ...\n"
            },
            {
              "pattern-either": [
                {
                  "pattern": "urllib.request.URLopener(...).open($URL, ...)"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$OPENERDIRECTOR = urllib.request.URLopener(...)\n...\n"
                    },
                    {
                      "pattern": "$OPENERDIRECTOR.open($URL, ...)"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "python.lang.security.audit.insecure-transport.urllib.insecure-urlopener-open.insecure-urlopener-open",
      "message": "Using 'URLopener.open(...)' with 'http://' creates an unsecured channel where data is transmitted in plaintext. This allows attackers to eavesdrop on communications and potentially intercept sensitive information. Use 'https://' instead to encrypt your connection.",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "references": [
          "https://docs.python.org/3/library/urllib.request.html#urllib.request.URLopener.open"
        ],
        "category": "security",
        "technology": [
          "urllib"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Insecure HTTP in URLopener.open method",
        "fix-suggestion": "Replace all `http://` URLs with `https://` URLs in your `URLopener.open()` calls. Consider migrating to a modern HTTP library like `requests` that provides better security defaults. Implement proper certificate validation to prevent security bypasses."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "fix-regex": {
        "regex": "[Hh][Tt][Tt][Pp]://",
        "replacement": "https://",
        "count": 1
      },
      "pattern-either": [
        {
          "pattern": "urllib.request.URLopener(...).open(\"=~/[Hh][Tt][Tt][Pp]://.*/\", ...)"
        },
        {
          "patterns": [
            {
              "pattern-inside": "$OPENERDIRECTOR = urllib.request.URLopener(...)\n...\n"
            },
            {
              "pattern": "$OPENERDIRECTOR.open(\"=~/[Hh][Tt][Tt][Pp]://.*/\", ...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$OPENERDIRECTOR = urllib.request.URLopener(...)\n...\n"
            },
            {
              "pattern": "$URL = \"=~/[Hh][Tt][Tt][Pp]://.*/\"\n...\n$OPENERDIRECTOR.open($URL, ...)\n"
            }
          ]
        },
        {
          "pattern": "$URL = \"=~/[Hh][Tt][Tt][Pp]://.*/\"\n...\nurllib.request.URLopener(...).open($URL, ...)\n"
        },
        {
          "patterns": [
            {
              "pattern-inside": "def $FUNC(..., $URL = \"=~/[Hh][Tt][Tt][Pp]://.*/\", ...):\n  ...\n"
            },
            {
              "pattern-either": [
                {
                  "pattern": "urllib.request.URLopener(...).open($URL, ...)"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$OPENERDIRECTOR = urllib.request.URLopener(...)\n...\n"
                    },
                    {
                      "pattern": "$OPENERDIRECTOR.open($URL, ...)"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "python.lang.security.audit.insecure-transport.urllib.insecure-urlopener-retrieve-ftp.insecure-urlopener-retrieve-ftp",
      "message": "Using 'URLopener.retrieve(...)' with 'ftp://' creates an unsecured channel where data is transferred without encryption. This makes your file transfers vulnerable to interception and eavesdropping. Use secure file transfer protocols that implement encryption instead.",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "references": [
          "https://docs.python.org/3/library/urllib.request.html#urllib.request.URLopener.retrieve"
        ],
        "category": "security",
        "technology": [
          "urllib"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Unencrypted FTP in URLopener.retrieve",
        "fix-suggestion": "Replace FTP with secure alternatives like SFTP by using libraries such as `paramiko` or `pysftp`. Since `urllib` doesn't support encrypted file transfer natively, consider migrating to a dedicated secure file transfer library. Always validate server certificates when establishing secure connections."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "pattern-either": [
        {
          "pattern": "urllib.request.URLopener(...).retrieve(\"=~/[Ff][Tt][Pp]://.*/\", ...)"
        },
        {
          "patterns": [
            {
              "pattern-inside": "$OPENERDIRECTOR = urllib.request.URLopener(...)\n...\n"
            },
            {
              "pattern": "$OPENERDIRECTOR.retrieve(\"=~/[Ff][Tt][Pp]://.*/\", ...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$OPENERDIRECTOR = urllib.request.URLopener(...)\n...\n"
            },
            {
              "pattern": "$URL = \"=~/[Ff][Tt][Pp]://.*/\"\n...\n$OPENERDIRECTOR.retrieve($URL, ...)\n"
            }
          ]
        },
        {
          "pattern": "$URL = \"=~/[Ff][Tt][Pp]://.*/\"\n...\nurllib.request.URLopener(...).retrieve($URL, ...)\n"
        },
        {
          "patterns": [
            {
              "pattern-inside": "def $FUNC(..., $URL = \"=~/[Ff][Tt][Pp]://.*/\", ...):\n  ...\n"
            },
            {
              "pattern-either": [
                {
                  "pattern": "urllib.request.URLopener(...).retrieve($URL, ...)"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$OPENERDIRECTOR = urllib.request.URLopener(...)\n...\n"
                    },
                    {
                      "pattern": "$OPENERDIRECTOR.retrieve($URL, ...)"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "python.lang.security.audit.insecure-transport.urllib.insecure-urlopener-retrieve.insecure-urlopener-retrieve",
      "message": "Using 'URLopener.retrieve(...)' with 'http://' creates an unsecured channel where data is transmitted in plaintext. This exposes your application to eavesdropping and data interception attacks. Use 'https://' to encrypt your connection and protect sensitive data.",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "references": [
          "https://docs.python.org/3/library/urllib.request.html#urllib.request.URLopener.retrieve"
        ],
        "category": "security",
        "technology": [
          "urllib"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Insecure HTTP in URLopener.retrieve method",
        "fix-suggestion": "Replace all `http://` URLs with `https://` URLs in your `URLopener.retrieve()` calls. Consider switching to modern libraries like `requests` that provide better security defaults. Implement proper certificate validation to prevent man-in-the-middle attacks."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "fix-regex": {
        "regex": "[Hh][Tt][Tt][Pp]://",
        "replacement": "https://",
        "count": 1
      },
      "pattern-either": [
        {
          "pattern": "urllib.request.URLopener(...).retrieve(\"=~/[Hh][Tt][Tt][Pp]://.*/\", ...)"
        },
        {
          "patterns": [
            {
              "pattern-inside": "$OPENERDIRECTOR = urllib.request.URLopener(...)\n...\n"
            },
            {
              "pattern": "$OPENERDIRECTOR.retrieve(\"=~/[Hh][Tt][Tt][Pp]://.*/\", ...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$OPENERDIRECTOR = urllib.request.URLopener(...)\n...\n"
            },
            {
              "pattern": "$URL = \"=~/[Hh][Tt][Tt][Pp]://.*/\"\n...\n$OPENERDIRECTOR.retrieve($URL, ...)\n"
            }
          ]
        },
        {
          "pattern": "$URL = \"=~/[Hh][Tt][Tt][Pp]://.*/\"\n...\nurllib.request.URLopener(...).retrieve($URL, ...)\n"
        },
        {
          "patterns": [
            {
              "pattern-inside": "def $FUNC(..., $URL = \"=~/[Hh][Tt][Tt][Pp]://.*/\", ...):\n  ...\n"
            },
            {
              "pattern-either": [
                {
                  "pattern": "urllib.request.URLopener(...).retrieve($URL, ...)"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$OPENERDIRECTOR = urllib.request.URLopener(...)\n...\n"
                    },
                    {
                      "pattern": "$OPENERDIRECTOR.retrieve($URL, ...)"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "python.lang.security.audit.insecure-transport.urllib.insecure-urlretrieve-ftp.insecure-urlretrieve-ftp",
      "message": "Using 'urllib.urlretrieve()' with 'ftp://' creates an unsecured communication channel where file data is transmitted without encryption. This exposes sensitive file content to network sniffing attacks. Use secure file transfer protocols with encryption instead.",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "references": [
          "https://docs.python.org/3/library/urllib.request.html#urllib.request.urlretrieve"
        ],
        "category": "security",
        "technology": [
          "urllib"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Insecure FTP connection in urllib.urlretrieve",
        "fix-suggestion": "Replace FTP with SFTP by using libraries like `paramiko` or `pysftp` that implement secure file transfer. Since `urllib` doesn't support SFTP, migrate to a library designed for secure transfers. Always encrypt sensitive file data during transmission."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "pattern-either": [
        {
          "pattern": "urllib.request.urlretrieve(\"=~/^[Ff][Tt][Pp]://.*/\", ...)"
        },
        {
          "pattern": "$URL = \"=~/^[Ff][Tt][Pp]://.*/\"\n...\nurllib.request.urlretrieve($URL, ...)\n"
        },
        {
          "pattern": "def $FUNC(..., $URL = \"=~/^[Ff][Tt][Pp]://.*/\", ...):\n  ...\n  urllib.request.urlretrieve($URL, ...)"
        }
      ]
    },
    {
      "id": "python.lang.security.audit.insecure-transport.urllib.insecure-urlretrieve.insecure-urlretrieve",
      "message": "Using 'urllib.urlretrieve()' with 'http://' creates an unsecured connection where data is transmitted in plaintext. This makes sensitive information vulnerable to interception by attackers monitoring network traffic. Use 'https://' instead to ensure data encryption.",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "references": [
          "https://docs.python.org/3/library/urllib.request.html#urllib.request.urlretrieve"
        ],
        "category": "security",
        "technology": [
          "urllib"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Insecure HTTP in urllib.urlretrieve function",
        "fix-suggestion": "Replace all `http://` URLs with `https://` URLs in your `urllib.urlretrieve()` calls. Consider migrating to more secure libraries like `requests` that handle certificate validation properly. Implement content verification to ensure downloaded files haven't been tampered with."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "fix-regex": {
        "regex": "[Hh][Tt][Tt][Pp]://",
        "replacement": "https://"
      },
      "pattern-either": [
        {
          "pattern": "urllib.request.urlretrieve(\"=~/[Hh][Tt][Tt][Pp]://.*/\", ...)"
        },
        {
          "pattern": "$URL = \"=~/[Hh][Tt][Tt][Pp]://.*/\"\n...\nurllib.request.urlretrieve($URL, ...)\n"
        },
        {
          "pattern": "def $FUNC(..., $URL = \"=~/[Hh][Tt][Tt][Pp]://.*/\", ...):\n  ...\n  urllib.request.urlretrieve($URL, ...)\n"
        }
      ]
    },
    {
      "id": "python.lang.security.audit.logging.listeneval.listen-eval",
      "languages": [
        "python"
      ],
      "message": "Using the logging 'listen()' function with eval() creates a security risk. Because the logging configuration is processed through eval(), untrusted code could potentially execute on your system. This vulnerability could allow attackers to run arbitrary code if they can influence the logging configuration.",
      "metadata": {
        "cwe": [
          "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.python.org/3/library/logging.config.html?highlight=security#logging.config.listen"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Remote code execution risk in logging.listen()",
        "fix-suggestion": "Always use the `verify` argument in `logging.listen()` by setting it to `True` to prevent unrecognized configurations. This parameter validates logging configurations before processing them. Consider using alternative logging setups that don't rely on dynamic configuration loading."
      },
      "severity": "WARNING",
      "pattern": "logging.config.listen(...)"
    },
    {
      "id": "python.lang.security.audit.logging.logger-credential-leak.python-logger-credential-disclosure",
      "patterns": [
        {
          "pattern": "$LOGGER_OBJ.$LOGGER_CALL($FORMAT_STRING,...)\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$LOGGER_OBJ",
            "regex": "(?i)(_logger|logger|self.logger|log)"
          }
        },
        {
          "metavariable-regex": {
            "metavariable": "$LOGGER_CALL",
            "regex": "(debug|info|warn|warning|error|exception|critical)"
          }
        },
        {
          "metavariable-regex": {
            "metavariable": "$FORMAT_STRING",
            "regex": "(?i).*(api.key|secret|credential|token|password).*\\%s.*"
          }
        }
      ],
      "message": "Sensitive credentials are being logged through a Python logger call. This can expose secrets to log files, monitoring systems, or other unauthorized parties who have access to logs. Hardcoded secrets in log messages create significant security risks when logs are shared or viewed.",
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "metadata": {
        "cwe": [
          "CWE-532: Insertion of Sensitive Information into Log File"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "owasp": [
          "A09:2021 - Security Logging and Monitoring Failures"
        ],
        "references": [
          "https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Credentials exposed through Python logger",
        "fix-suggestion": "Remove all sensitive information like passwords, tokens, and API keys from log messages. Use placeholders like `[REDACTED]` or log message patterns that exclude sensitive data. Implement a logging filter that automatically sanitizes sensitive information before it's written to logs."
      }
    },
    {
      "id": "python.lang.security.audit.marshal.marshal-usage",
      "languages": [
        "python"
      ],
      "message": "This vulnerability happens when the marshal module is used to deserialize data from untrusted sources. The marshal format is not secure against maliciously constructed data and can lead to arbitrary code execution or memory corruption. This can result in complete application compromise or denial of service.",
      "metadata": {
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "references": [
          "https://docs.python.org/3/library/marshal.html?highlight=security"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "marshal untrusted data can run arbitrary code",
        "fix-suggestion": "Avoid using the `marshal` module to deserialize untrusted data; opt for secure serialization formats that do not execute arbitrary code."
      },
      "pattern-either": [
        {
          "pattern": "marshal.dump(...)"
        },
        {
          "pattern": "marshal.dumps(...)"
        },
        {
          "pattern": "marshal.load(...)"
        },
        {
          "pattern": "marshal.loads(...)"
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.lang.security.audit.network.disabled-cert-validation.disabled-cert-validation",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "urllib3.PoolManager(..., cert_reqs=$REQS, ...)"
            },
            {
              "pattern": "urllib3.ProxyManager(..., cert_reqs=$REQS, ...)"
            },
            {
              "pattern": "urllib3.HTTPSConnectionPool(..., cert_reqs=$REQS, ...)"
            },
            {
              "pattern": "urllib3.connectionpool.HTTPSConnectionPool(..., cert_reqs=$REQS, ...)"
            },
            {
              "pattern": "urllib3.connection_from_url(..., cert_reqs=$REQS, ...)"
            },
            {
              "pattern": "urllib3.proxy_from_url(..., cert_reqs=$REQS, ...)"
            },
            {
              "pattern": "$CONTEXT.wrap_socket(..., cert_reqs=$REQS, ...)"
            },
            {
              "pattern": "ssl.wrap_socket(..., cert_reqs=$REQS, ...)"
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$REQS",
            "regex": "(NONE|CERT_NONE|CERT_OPTIONAL|ssl\\.CERT_NONE|ssl\\.CERT_OPTIONAL|\\'NONE\\'|\\\"NONE\\\"|\\'OPTIONAL\\'|\\\"OPTIONAL\\\")"
          }
        }
      ],
      "message": "Certificate verification has been explicitly disabled in your code. This creates a significant security vulnerability as it allows connections to servers with invalid or malicious SSL certificates. Without certificate validation, your application is vulnerable to man-in-the-middle attacks.",
      "metadata": {
        "cwe": [
          "CWE-295: Improper Certificate Validation"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A07:2021 - Identification and Authentication Failures"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "references": [
          "https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "TLS certificate verification explicitly disabled",
        "fix-suggestion": "Remove code that disables certificate verification such as setting `verify=False` in requests or similar parameters. Always validate SSL certificates when making secure connections to ensure authenticity of remote servers. If testing locally, use proper testing certificates rather than disabling verification."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR"
    },
    {
      "id": "python.lang.security.audit.network.http-not-https-connection.http-not-https-connection",
      "message": "Your code uses HTTPConnectionPool instead of HTTPSConnectionPool. This results in all data being transmitted in plaintext without encryption, making it vulnerable to eavesdropping and interception. Sensitive information can be easily exposed when using unencrypted HTTP connections.",
      "metadata": {
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "references": [
          "https://urllib3.readthedocs.io/en/1.2.1/pools.html#urllib3.connectionpool.HTTPSConnectionPool"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Unencrypted HTTP connection pool usage",
        "fix-suggestion": "Replace `HTTPConnectionPool` with `HTTPSConnectionPool` in all your connection code. Ensure proper certificate validation is implemented when establishing HTTPS connections. Consider using higher-level libraries like `requests` that default to secure connections."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "pattern-either": [
        {
          "pattern": "urllib3.HTTPConnectionPool(...)"
        },
        {
          "pattern": "urllib3.connectionpool.HTTPConnectionPool(...)"
        }
      ]
    },
    {
      "id": "python.lang.security.audit.network.bind.avoid-bind-to-all-interfaces",
      "message": "Your socket is bound to 0.0.0.0 or an empty string, which makes it listen on all network interfaces. This could unexpectedly expose your service publicly, creating security risks. Services intended only for local access should bind to specific interfaces instead.",
      "metadata": {
        "cwe": [
          "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Socket binding to all network interfaces",
        "fix-suggestion": "Replace `0.0.0.0` or empty string bindings with specific IP addresses like `127.0.0.1` for localhost-only services. Use environment variables or configuration files to make binding addresses configurable per deployment. Implement network-level access controls as an additional security layer."
      },
      "languages": [
        "python"
      ],
      "severity": "INFO",
      "pattern-either": [
        {
          "pattern": "$S = socket.socket(...)\n...\n$S.bind((\"0.0.0.0\", ...))\n"
        },
        {
          "pattern": "$S = socket.socket(...)\n...\n$S.bind((\"::\", ...))\n"
        },
        {
          "pattern": "$S = socket.socket(...)\n...\n$S.bind((\"\", ...))\n"
        }
      ]
    },
    {
      "id": "python.lang.security.audit.paramiko.paramiko-exec-command.paramiko-exec-command",
      "patterns": [
        {
          "pattern-inside": "$CLIENT = paramiko.client.SSHClient(...)\n...\n"
        },
        {
          "pattern": "$CLIENT.exec_command(...)"
        },
        {
          "pattern-not": "$CLIENT.exec_command(\"...\", ...)"
        }
      ],
      "message": "This vulnerability occurs when Paramiko is configured with an SSL context that doesn't verify certificates. Without proper certificate validation, attackers can perform man-in-the-middle attacks against SSH connections. This can lead to credential theft, session hijacking, or data interception.",
      "metadata": {
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/plugins/injection_paramiko.py",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "references": [
          "http://docs.paramiko.org/en/stable/api/client.html#paramiko.client.SSHClient.exec_command",
          "https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/plugins/injection_paramiko.py"
        ],
        "category": "security",
        "technology": [
          "paramiko"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Insecure Paramiko SSL context or direct exec can be hijacked",
        "fix-suggestion": "Configure Paramiko with a proper SSL context to verify certificates and prevent man-in-the-middle attacks."
      },
      "severity": "ERROR",
      "languages": [
        "python"
      ]
    },
    {
      "id": "python.lang.security.audit.sqli.aiopg-sqli.aiopg-sqli",
      "languages": [
        "python"
      ],
      "message": "This vulnerability happens when SQL queries in aiopg are built by concatenating user input without proper parameterization. Attackers can inject SQL syntax that alters the query structure to perform unauthorized operations. This can lead to data theft, unauthorized data modification, or authentication bypass.",
      "metadata": {
        "references": [
          "https://github.com/aio-libs/aiopg"
        ],
        "category": "security",
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "technology": [
          "aiopg"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "aiopg SQL with concatenation is vulnerable to injection",
        "fix-suggestion": "Use parameterized queries with `aiopg` to bind user input safely and prevent SQL injection."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern": "$CUR.$METHOD(...,$QUERY,...)"
                },
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "$QUERY = $X + $Y\n...\n"
                    },
                    {
                      "pattern-inside": "$QUERY += $X\n...\n"
                    },
                    {
                      "pattern-inside": "$QUERY = '...'.format(...)\n...\n"
                    },
                    {
                      "pattern-inside": "$QUERY = '...' % (...)\n...\n"
                    },
                    {
                      "pattern-inside": "$QUERY = f'...{$USERINPUT}...'\n...\n"
                    }
                  ]
                },
                {
                  "pattern-not-inside": "$QUERY += \"...\"\n...\n"
                },
                {
                  "pattern-not-inside": "$QUERY = \"...\" + \"...\"\n...\n"
                },
                {
                  "pattern-not-inside": "$QUERY = '...'.format()\n...\n"
                },
                {
                  "pattern-not-inside": "$QUERY = '...' % ()\n...\n"
                }
              ]
            },
            {
              "pattern": "$CUR.$METHOD(..., $X + $Y, ...)"
            },
            {
              "pattern": "$CUR.$METHOD(..., '...'.format(...), ...)"
            },
            {
              "pattern": "$CUR.$METHOD(..., '...' % (...), ...)"
            },
            {
              "pattern": "$CUR.$METHOD(..., f'...{$USERINPUT}...', ...)"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "$CONN = await aiopg.connect(...)\n...\n$CUR = await $CONN.cursor(...)\n...\n"
            },
            {
              "pattern-inside": "$POOL = await aiopg.create_pool(...)\n...\nasync with $POOL.acquire(...) as $CONN:\n  ...\n  async with $CONN.cursor(...) as $CUR:\n    ...\n"
            },
            {
              "pattern-inside": "$POOL = await aiopg.create_pool(...)\n...\nwith (await $POOL.cursor(...)) as $CUR:\n  ...\n"
            },
            {
              "pattern-inside": "$POOL = await aiopg.create_pool(...)\n...\nasync with $POOL as $CONN:\n  ...\n  $CUR = await $CONN.cursor(...)\n  ...\n"
            },
            {
              "pattern-inside": "$POOL = await aiopg.create_pool(...)\n...\nasync with $POOL.cursor(...) as $CUR:\n  ...\n"
            }
          ]
        },
        {
          "pattern-not": "$CUR.$METHOD(..., \"...\" + \"...\", ...)"
        },
        {
          "pattern-not": "$CUR.$METHOD(..., '...'.format(), ...)"
        },
        {
          "pattern-not": "$CUR.$METHOD(..., '...'%(), ...)"
        },
        {
          "metavariable-regex": {
            "metavariable": "$METHOD",
            "regex": "^(execute)$"
          }
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.lang.security.audit.sqli.asyncpg-sqli.asyncpg-sqli",
      "languages": [
        "python"
      ],
      "message": "This vulnerability occurs when asyncpg SQL queries are constructed using string concatenation with user input instead of parameters. Attackers can inject special SQL syntax that changes the intended query structure. This can result in unauthorized data access, data manipulation, or authentication bypass.",
      "metadata": {
        "references": [
          "https://github.com/MagicStack/asyncpg",
          "https://magicstack.github.io/asyncpg/current/"
        ],
        "category": "security",
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "technology": [
          "asyncpg"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "asyncpg queries built from user data risk SQL injection",
        "fix-suggestion": "Implement parameterized query techniques with `asyncpg` to ensure that user-supplied data is handled safely."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern": "$CONN.$METHOD(...,$QUERY,...)"
                },
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "$QUERY = $X + $Y\n...\n"
                    },
                    {
                      "pattern-inside": "$QUERY += $X\n...\n"
                    },
                    {
                      "pattern-inside": "$QUERY = '...'.format(...)\n...\n"
                    },
                    {
                      "pattern-inside": "$QUERY = '...' % (...)\n...\n"
                    },
                    {
                      "pattern-inside": "$QUERY = f'...{$USERINPUT}...'\n...\n"
                    }
                  ]
                },
                {
                  "pattern-not-inside": "$QUERY += \"...\"\n...\n"
                },
                {
                  "pattern-not-inside": "$QUERY = \"...\" + \"...\"\n...\n"
                },
                {
                  "pattern-not-inside": "$QUERY = '...'.format()\n...\n"
                },
                {
                  "pattern-not-inside": "$QUERY = '...' % ()\n...\n"
                }
              ]
            },
            {
              "pattern": "$CONN.$METHOD(..., $X + $Y, ...)"
            },
            {
              "pattern": "$CONN.$METHOD(..., $Y.format(...), ...)"
            },
            {
              "pattern": "$CONN.$METHOD(..., '...'.format(...), ...)"
            },
            {
              "pattern": "$CONN.$METHOD(..., '...' % (...), ...)"
            },
            {
              "pattern": "$CONN.$METHOD(..., f'...{$USERINPUT}...', ...)"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "$CONN = await asyncpg.connect(...)\n...\n"
            },
            {
              "pattern-inside": "async with asyncpg.create_pool(...) as $CONN:\n    ...\n"
            },
            {
              "pattern-inside": "async with $POOL.acquire(...) as $CONN:\n    ...\n"
            },
            {
              "pattern-inside": "$CONN = await $POOL.acquire(...)\n...\n"
            },
            {
              "pattern-inside": "def $FUNCNAME(..., $CONN: Connection, ...):\n    ...\n"
            },
            {
              "pattern-inside": "def $FUNCNAME(..., $CONN: asyncpg.Connection, ...):\n    ...\n"
            }
          ]
        },
        {
          "pattern-not": "$CONN.$METHOD(..., \"...\" + \"...\", ...)"
        },
        {
          "pattern-not": "$CONN.$METHOD(..., '...'.format(), ...)"
        },
        {
          "pattern-not": "$CONN.$METHOD(..., '...'%(), ...)"
        },
        {
          "metavariable-regex": {
            "metavariable": "$METHOD",
            "regex": "^(fetch|fetchrow|fetchval|execute|executemany|prepare|cursor|copyfromquery)$"
          }
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.lang.security.audit.sqli.pg8000-sqli.pg8000-sqli",
      "languages": [
        "python"
      ],
      "message": "This vulnerability happens when pg8000 SQL queries include user input through string concatenation rather than parameterized queries. Attackers can inject SQL syntax that alters the query structure to perform unauthorized database operations. This can lead to data theft, data manipulation, or even complete database compromise.",
      "metadata": {
        "references": [
          "https://github.com/tlocke/pg8000"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "category": "security",
        "technology": [
          "pg8000"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "pg8000 with unsanitized user input fosters injection",
        "fix-suggestion": "Implement parameterized queries with `pg8000` to separate SQL logic from untrusted input and prevent injection attacks."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern": "$CONN.$METHOD(...,$QUERY,...)"
                },
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "$QUERY = $X + $Y\n...\n"
                    },
                    {
                      "pattern-inside": "$QUERY += $X\n...\n"
                    },
                    {
                      "pattern-inside": "$QUERY = '...'.format(...)\n...\n"
                    },
                    {
                      "pattern-inside": "$QUERY = '...' % (...)\n...\n"
                    },
                    {
                      "pattern-inside": "$QUERY = f'...{$USERINPUT}...'\n...\n"
                    }
                  ]
                },
                {
                  "pattern-not-inside": "$QUERY += \"...\"\n...\n"
                },
                {
                  "pattern-not-inside": "$QUERY = \"...\" + \"...\"\n...\n"
                },
                {
                  "pattern-not-inside": "$QUERY = '...'.format()\n...\n"
                },
                {
                  "pattern-not-inside": "$QUERY = '...' % ()\n...\n"
                }
              ]
            },
            {
              "pattern": "$CONN.$METHOD(..., $X + $Y, ...)"
            },
            {
              "pattern": "$CONN.$METHOD(..., '...'.format(...), ...)"
            },
            {
              "pattern": "$CONN.$METHOD(..., '...' % (...), ...)"
            },
            {
              "pattern": "$CONN.$METHOD(..., f'...{$USERINPUT}...', ...)"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "$CONN = pg8000.native.Connection(...)\n...\n"
            },
            {
              "pattern-inside": "$CONN = pg8000.dhapi.connect(...)\n...\n"
            },
            {
              "pattern-inside": "$CONN1 = pg8000.connect(...)\n...\n$CONN = $CONN1.cursor(...)\n...\n"
            },
            {
              "pattern-inside": "$CONN = pg8000.connect(...)\n...\n"
            }
          ]
        },
        {
          "pattern-not": "$CONN.$METHOD(..., \"...\" + \"...\", ...)"
        },
        {
          "pattern-not": "$CONN.$METHOD(..., '...'.format(), ...)"
        },
        {
          "pattern-not": "$CONN.$METHOD(..., '...'%(), ...)"
        },
        {
          "metavariable-regex": {
            "metavariable": "$METHOD",
            "regex": "^(run|execute|executemany|prepare)$"
          }
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.lang.security.audit.sqli.psycopg-sqli.psycopg-sqli",
      "languages": [
        "python"
      ],
      "message": "This vulnerability occurs when psycopg2 SQL queries are built by concatenating user input rather than using parameterized queries. Attackers can inject SQL commands that change the query's intended behavior to access or modify unauthorized data. This can result in data theft, authentication bypass, or database corruption.",
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "references": [
          "https://www.psycopg.org/docs/sql.html"
        ],
        "category": "security",
        "technology": [
          "psycopg"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "psycopg2 query built from user input is injection risk",
        "fix-suggestion": "Utilize psycopg2's parameterized queries to securely bind user input and prevent SQL injection vulnerabilities."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern": "$CUR.$METHOD(...,$QUERY,...)"
                },
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "$QUERY = $X + $Y\n...\n"
                    },
                    {
                      "pattern-inside": "$QUERY += $X\n...\n"
                    },
                    {
                      "pattern-inside": "$QUERY = '...'.format(...)\n...\n"
                    },
                    {
                      "pattern-inside": "$QUERY = '...' % (...)\n...\n"
                    },
                    {
                      "pattern-inside": "$QUERY = f'...{$USERINPUT}...'\n...\n"
                    }
                  ]
                },
                {
                  "pattern-not-inside": "$QUERY += \"...\"\n...\n"
                },
                {
                  "pattern-not-inside": "$QUERY = \"...\" + \"...\"\n...\n"
                },
                {
                  "pattern-not-inside": "$QUERY = '...'.format()\n...\n"
                },
                {
                  "pattern-not-inside": "$QUERY = '...' % ()\n...\n"
                }
              ]
            },
            {
              "pattern": "$CUR.$METHOD(..., $X + $Y, ...)"
            },
            {
              "pattern": "$CUR.$METHOD(..., '...'.format(...), ...)"
            },
            {
              "pattern": "$CUR.$METHOD(..., '...' % (...), ...)"
            },
            {
              "pattern": "$CUR.$METHOD(..., f'...{$USERINPUT}...', ...)"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "$CONN = psycopg2.connect(...)\n...\n$CUR = $CONN.cursor(...)\n...\n"
            },
            {
              "pattern-inside": "$CONN = psycopg2.connect(...)\n...\nwith $CONN.cursor(...) as $CUR:\n  ...\n"
            }
          ]
        },
        {
          "pattern-not": "$CUR.$METHOD(..., \"...\" + \"...\", ...)"
        },
        {
          "pattern-not": "$CUR.$METHOD(..., '...'.format(), ...)"
        },
        {
          "pattern-not": "$CUR.$METHOD(..., '...'%(), ...)"
        },
        {
          "metavariable-regex": {
            "metavariable": "$METHOD",
            "regex": "^(execute|executemany|mogrify)$"
          }
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.lang.security.dangerous-code-run.dangerous-interactive-code-run",
      "mode": "taint",
      "options": {
        "symbolic_propagation": true
      },
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "flask.request.form.get(...)"
                        },
                        {
                          "pattern": "flask.request.form[...]"
                        },
                        {
                          "pattern": "flask.request.args.get(...)"
                        },
                        {
                          "pattern": "flask.request.args[...]"
                        },
                        {
                          "pattern": "flask.request.values.get(...)"
                        },
                        {
                          "pattern": "flask.request.values[...]"
                        },
                        {
                          "pattern": "flask.request.cookies.get(...)"
                        },
                        {
                          "pattern": "flask.request.cookies[...]"
                        },
                        {
                          "pattern": "flask.request.stream"
                        },
                        {
                          "pattern": "flask.request.headers.get(...)"
                        },
                        {
                          "pattern": "flask.request.headers[...]"
                        },
                        {
                          "pattern": "flask.request.data"
                        },
                        {
                          "pattern": "flask.request.full_path"
                        },
                        {
                          "pattern": "flask.request.url"
                        },
                        {
                          "pattern": "flask.request.json"
                        },
                        {
                          "pattern": "flask.request.get_json()"
                        },
                        {
                          "pattern": "flask.request.view_args.get(...)"
                        },
                        {
                          "pattern": "flask.request.view_args[...]"
                        },
                        {
                          "patterns": [
                            {
                              "pattern-inside": "@$APP.route(...)\ndef $FUNC(..., $ROUTEVAR, ...):\n  ...\n"
                            },
                            {
                              "focus-metavariable": "$ROUTEVAR"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "def $FUNC(request, ...):\n  ...\n"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "request.$PROPERTY.get(...)"
                        },
                        {
                          "pattern": "request.$PROPERTY[...]"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "@rest_framework.decorators.api_view(...)\ndef $FUNC($REQ, ...):\n  ...\n"
                        },
                        {
                          "patterns": [
                            {
                              "pattern-either": [
                                {
                                  "pattern-inside": "class $VIEW(..., rest_framework.views.APIView, ...):\n  ...\n"
                                },
                                {
                                  "pattern-inside": "class $VIEW(..., rest_framework.generics.GenericAPIView, ...):\n  ...                              \n"
                                }
                              ]
                            },
                            {
                              "pattern-inside": "def $METHOD(self, $REQ, ...):\n  ...\n"
                            },
                            {
                              "metavariable-regex": {
                                "metavariable": "$METHOD",
                                "regex": "(get|post|put|patch|delete|head)"
                              }
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "$REQ.POST.get(...)"
                        },
                        {
                          "pattern": "$REQ.POST[...]"
                        },
                        {
                          "pattern": "$REQ.FILES.get(...)"
                        },
                        {
                          "pattern": "$REQ.FILES[...]"
                        },
                        {
                          "pattern": "$REQ.DATA.get(...)"
                        },
                        {
                          "pattern": "$REQ.DATA[...]"
                        },
                        {
                          "pattern": "$REQ.QUERY_PARAMS.get(...)"
                        },
                        {
                          "pattern": "$REQ.QUERY_PARAMS[...]"
                        },
                        {
                          "pattern": "$REQ.data.get(...)"
                        },
                        {
                          "pattern": "$REQ.data[...]"
                        },
                        {
                          "pattern": "$REQ.query_params.get(...)"
                        },
                        {
                          "pattern": "$REQ.query_params[...]"
                        },
                        {
                          "pattern": "$REQ.content_type"
                        },
                        {
                          "pattern": "$REQ.content_type"
                        },
                        {
                          "pattern": "$REQ.stream"
                        },
                        {
                          "pattern": "$REQ.stream"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "class $SERVER(..., http.server.BaseHTTPRequestHandler, ...):\n  ...\n"
                        },
                        {
                          "pattern-inside": "class $SERVER(..., http.server.StreamRequestHandler, ...):\n  ...\n"
                        },
                        {
                          "pattern-inside": "class $SERVER(..., http.server.DatagramRequestHandler, ...):\n  ...\n"
                        }
                      ]
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern": "self.requestline"
                        },
                        {
                          "pattern": "self.path"
                        },
                        {
                          "pattern": "self.headers[...]"
                        },
                        {
                          "pattern": "self.headers.get(...)"
                        },
                        {
                          "pattern": "self.rfile"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "@pyramid.view.view_config( ... )\ndef $VIEW($REQ):\n  ...\n"
                    },
                    {
                      "pattern": "$REQ.$ANYTHING"
                    },
                    {
                      "pattern-not": "$REQ.dbsession"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$X = code.InteractiveConsole(...)\n...\n"
                },
                {
                  "pattern-inside": "$X = code.InteractiveInterpreter(...)\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$X.push($PAYLOAD,...)\n"
                },
                {
                  "pattern": "$X.runsource($PAYLOAD,...)\n"
                },
                {
                  "pattern": "$X.runcode(code.compile_command($PAYLOAD),...)\n"
                },
                {
                  "pattern": "$PL = code.compile_command($PAYLOAD,...)\n...\n$X.runcode($PL,...)\n"
                }
              ]
            },
            {
              "focus-metavariable": "$PAYLOAD"
            },
            {
              "pattern-not": "$X.push(\"...\",...)\n"
            },
            {
              "pattern-not": "$X.runsource(\"...\",...)\n"
            },
            {
              "pattern-not": "$X.runcode(code.compile_command(\"...\"),...)\n"
            },
            {
              "pattern-not": "$PL = code.compile_command(\"...\",...)\n...\n$X.runcode($PL,...)\n"
            }
          ]
        }
      ],
      "message": "User-controlled data is being passed to InteractiveConsole or InteractiveInterpreter methods. This is extremely dangerous as it allows execution of arbitrary Python code. If external data can reach these interpreter functions, attackers could run malicious code with the privileges of your application.",
      "metadata": {
        "cwe": [
          "CWE-95: Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://semgrep.dev/docs/cheat-sheets/python-command-injection/"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "confidence": "MEDIUM",
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "User data executing in Python interpreter",
        "fix-suggestion": "Never pass user-controlled input to `InteractiveConsole` or `InteractiveInterpreter` methods. Replace this approach with a secure, restricted method of evaluating expressions if needed. Consider using a sandboxed environment like `RestrictedPython` if you must evaluate dynamic code."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ]
    },
    {
      "id": "python.lang.security.deserialization.avoid-jsonpickle.avoid-jsonpickle",
      "patterns": [
        {
          "pattern": "jsonpickle.decode($PAYLOAD,...)\n"
        },
        {
          "pattern-not": "jsonpickle.decode(\"...\",...)\n"
        }
      ],
      "metadata": {
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "references": [
          "https://github.com/jsonpickle/jsonpickle#jsonpickle",
          "https://www.exploit-db.com/exploits/49585"
        ],
        "category": "security",
        "technology": [
          "jsonpickle"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "jsonpickle can run code during deserialization, unsafe",
        "fix-suggestion": "Avoid using `jsonpickle` for deserialization of untrusted data; choose safer serialization libraries that do not allow arbitrary code execution."
      },
      "message": "This vulnerability happens because jsonpickle can deserialize arbitrary Python objects, potentially executing code during deserialization. Attackers can craft malicious serialized data that executes code when deserialized. This can lead to remote code execution with the privileges of the application.",
      "languages": [
        "python"
      ],
      "severity": "WARNING"
    },
    {
      "id": "python.lang.security.deserialization.avoid-pyyaml-load.avoid-pyyaml-load",
      "metadata": {
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "references": [
          "https://github.com/yaml/pyyaml/wiki/PyYAML-yaml.load(input)-Deprecation",
          "https://nvd.nist.gov/vuln/detail/CVE-2017-18342"
        ],
        "category": "security",
        "technology": [
          "pyyaml"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "yaml.load can execute code, use safe_load",
        "fix-suggestion": "Replace `yaml.load()` with `yaml.safe_load()` to prevent execution of arbitrary code during YAML deserialization."
      },
      "languages": [
        "python"
      ],
      "message": "This vulnerability occurs when yaml.load() or other unsafe YAML parsing functions are used instead of yaml.safe_load(). The unsafe loaders can construct arbitrary Python objects during deserialization, including ones that execute code. This can lead to remote code execution when processing untrusted YAML data.",
      "fix-regex": {
        "regex": "unsafe_load",
        "replacement": "safe_load",
        "count": 1
      },
      "severity": "ERROR",
      "patterns": [
        {
          "pattern-inside": "import yaml\n...\n"
        },
        {
          "pattern-not-inside": "$YAML = ruamel.yaml.YAML(...)\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "yaml.unsafe_load(...)"
            },
            {
              "pattern": "yaml.load(..., Loader=yaml.Loader, ...)"
            },
            {
              "pattern": "yaml.load(..., Loader=yaml.UnsafeLoader, ...)"
            },
            {
              "pattern": "yaml.load(..., Loader=yaml.CLoader, ...)"
            },
            {
              "pattern": "yaml.load_all(..., Loader=yaml.Loader, ...)"
            },
            {
              "pattern": "yaml.load_all(..., Loader=yaml.UnsafeLoader, ...)"
            },
            {
              "pattern": "yaml.load_all(..., Loader=yaml.CLoader, ...)"
            }
          ]
        }
      ]
    },
    {
      "id": "python.lang.security.deserialization.avoid-unsafe-ruamel.avoid-unsafe-ruamel",
      "metadata": {
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "references": [
          "https://yaml.readthedocs.io/en/latest/basicuse.html?highlight=typ"
        ],
        "category": "security",
        "technology": [
          "ruamel.yaml"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "Default ruamel.yaml can create objects unsafely",
        "fix-suggestion": "Configure `ruamel.yaml` with safe loading options or switch to a safer YAML parser to mitigate arbitrary object instantiation."
      },
      "languages": [
        "python"
      ],
      "message": "This vulnerability happens when the default ruamel.yaml.YAML() constructor is used which can create arbitrary Python objects during deserialization. Attackers can craft malicious YAML data that executes code when processed. This can lead to arbitrary code execution with the privileges of the application.",
      "severity": "ERROR",
      "pattern-either": [
        {
          "pattern": "ruamel.yaml.YAML(..., typ='unsafe', ...)"
        },
        {
          "pattern": "ruamel.yaml.YAML(..., typ='base', ...)"
        }
      ]
    },
    {
      "id": "python.lang.security.deserialization.pickle.avoid-cPickle",
      "metadata": {
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "references": [
          "https://docs.python.org/3/library/pickle.html"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "cPickle can run malicious code on load, insecure",
        "fix-suggestion": "Do not use `cPickle` for deserialization of untrusted data; use secure alternatives or validate that data comes from trusted sources."
      },
      "languages": [
        "python"
      ],
      "message": "This vulnerability occurs because cPickle can deserialize arbitrary Python objects, potentially executing code during deserialization. Attackers who can control serialized data can craft malicious pickle payloads that execute code when unpickled. This can lead to remote code execution in the context of the application.",
      "severity": "WARNING",
      "patterns": [
        {
          "pattern": "cPickle.$FUNC(...)"
        },
        {
          "pattern-not": "cPickle.$FUNC(\"...\")"
        }
      ]
    },
    {
      "id": "python.lang.security.deserialization.pickle.avoid-dill",
      "metadata": {
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "references": [
          "https://docs.python.org/3/library/pickle.html"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "dill extends pickle and is also unsafe",
        "fix-suggestion": "Avoid using `dill` to deserialize untrusted data; select safer serialization methods that do not execute arbitrary code."
      },
      "languages": [
        "python"
      ],
      "message": "This vulnerability happens because dill, like pickle, can deserialize arbitrary Python objects and execute code during deserialization. Attackers can craft malicious serialized data that executes arbitrary code when deserialized. This can lead to remote code execution with the privileges of the application.",
      "severity": "WARNING",
      "patterns": [
        {
          "pattern": "dill.$FUNC(...)"
        },
        {
          "pattern-not": "dill.$FUNC(\"...\")"
        }
      ]
    },
    {
      "id": "python.lang.security.deserialization.pickle.avoid-pickle",
      "metadata": {
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "references": [
          "https://docs.python.org/3/library/pickle.html"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "pickle is unsafe, can execute arbitrary code",
        "fix-suggestion": "Refrain from using `pickle` to deserialize data from untrusted sources; opt for secure serialization formats instead."
      },
      "languages": [
        "python"
      ],
      "message": "This vulnerability occurs because pickle can deserialize arbitrary Python objects, potentially executing code during the process. Attackers who can control serialized data can craft malicious pickle payloads that execute arbitrary code when unpickled. This can lead to remote code execution in the context of the application.",
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "pickle.$FUNC(...)"
            },
            {
              "pattern": "_pickle.$FUNC(...)"
            }
          ]
        },
        {
          "pattern-not": "pickle.$FUNC(\"...\")"
        },
        {
          "pattern-not": "_pickle.$FUNC(\"...\")"
        }
      ]
    },
    {
      "id": "python.lang.security.deserialization.pickle.avoid-shelve",
      "metadata": {
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "references": [
          "https://docs.python.org/3/library/pickle.html"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "shelve uses pickle internally, vulnerable to code execution",
        "fix-suggestion": "Do not use `shelve` with untrusted data since it relies on pickle; use alternative storage mechanisms that enforce proper security."
      },
      "languages": [
        "python"
      ],
      "message": "This vulnerability happens because shelve uses pickle internally for serialization and deserialization, which can execute arbitrary code. Attackers who can control the serialized data can craft malicious payloads that execute code when loaded from the shelf. This can lead to remote code execution with the privileges of the application.",
      "severity": "WARNING",
      "pattern": "shelve.$FUNC(...)"
    },
    {
      "id": "python.lang.security.insecure-hash-algorithms.insecure-hash-algorithm-sha1",
      "pattern": "hashlib.sha1(...)",
      "fix-regex": {
        "regex": "sha1",
        "replacement": "sha256"
      },
      "message": "Your code uses the SHA1 hash algorithm which is cryptographically broken. SHA1 is vulnerable to collision attacks, making it unsuitable for security-critical applications. Using this algorithm for sensitive operations can lead to security vulnerabilities.",
      "metadata": {
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59",
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "bandit-code": "B303",
        "asvs": {
          "section": "V6 Stored Cryptography Verification Requirements",
          "control_id": "6.2.2 Insecure Custom Algorithm",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x14-V6-Cryptography.md#v62-algorithms",
          "version": "4"
        },
        "references": [
          "https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html",
          "https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability",
          "http://2012.sharcs.org/slides/stevens.pdf",
          "https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html"
        ],
        "category": "security",
        "technology": [
          "python"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Deprecated SHA1 hash algorithm usage",
        "fix-suggestion": "Replace SHA1 with stronger alternatives like `SHA256`, `SHA3`, or `BLAKE2` for all security-sensitive operations. Update your code to use `hashlib.sha256()` or stronger algorithms instead of `hashlib.sha1()`. For password storage, use specialized password hashing functions like `bcrypt` or `Argon2`."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ]
    },
    {
      "id": "python.pycryptodome.security.insecure-cipher-algorithm-blowfish.insecure-cipher-algorithm-blowfish",
      "message": "Your code uses the Blowfish cipher algorithm which is considered cryptographically insecure. While Blowfish was once strong, it uses a small 64-bit block size that makes it vulnerable to attacks. Modern applications should use more secure cipher algorithms for data protection.",
      "metadata": {
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84",
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "bandit-code": "B304",
        "references": [
          "https://stackoverflow.com/questions/1135186/whats-wrong-with-xor-encryption",
          "https://www.pycryptodome.org/src/cipher/cipher"
        ],
        "category": "security",
        "technology": [
          "pycryptodome"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "functional-categories": [
          "crypto::search::symmetric-algorithm::pycryptodome",
          "crypto::search::symmetric-algorithm::pycryptodomex"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Outdated Blowfish encryption algorithm",
        "fix-suggestion": "Replace Blowfish with modern algorithms like AES with a minimum key size of 128 bits. Use secure modes of operation such as GCM or ChaCha20-Poly1305 that provide both confidentiality and authenticity. For PyCryptodome specifically, use `AES.new()` with appropriate modes instead of `Blowfish.new()`."
      },
      "options": {
        "symbolic_propagation": true
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "pattern-either": [
        {
          "pattern": "Cryptodome.Cipher.Blowfish.new(...)"
        },
        {
          "pattern": "Crypto.Cipher.Blowfish.new(...)"
        }
      ]
    },
    {
      "id": "python.pycryptodome.security.insecure-cipher-algorithm-des.insecure-cipher-algorithm-des",
      "message": "Your code uses the DES or Triple DES algorithm which is cryptographically broken. These algorithms are vulnerable to brute force attacks due to small key sizes and other weaknesses. Using them for sensitive data encryption creates significant security risks.",
      "metadata": {
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84",
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "bandit-code": "B304",
        "references": [
          "https://cwe.mitre.org/data/definitions/326.html",
          "https://www.pycryptodome.org/src/cipher/cipher"
        ],
        "category": "security",
        "technology": [
          "pycryptodome"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "functional-categories": [
          "crypto::search::symmetric-algorithm::pycryptodome",
          "crypto::search::symmetric-algorithm::pycryptodomex"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Deprecated DES/3DES encryption algorithm",
        "fix-suggestion": "Replace DES/3DES with AES using at least 128-bit keys. Use secure modes like GCM that provide authenticity in addition to confidentiality. In PyCryptodome, replace `DES.new()` or `DES3.new()` calls with `AES.new()` or ChaCha20 implementations."
      },
      "options": {
        "symbolic_propagation": true
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "pattern-either": [
        {
          "pattern": "Cryptodome.Cipher.DES.new(...)"
        },
        {
          "pattern": "Crypto.Cipher.DES.new(...)"
        },
        {
          "pattern": "Cryptodome.Cipher.DES3.new(...)"
        },
        {
          "pattern": "Crypto.Cipher.DES3.new(...)"
        }
      ]
    },
    {
      "id": "python.pycryptodome.security.insecure-cipher-algorithm-rc2.insecure-cipher-algorithm-rc2",
      "message": "Your code uses the RC2 cipher algorithm which is cryptographically broken. RC2 has been compromised due to multiple vulnerabilities and is no longer considered secure for protecting sensitive data. Modern applications should use more robust encryption algorithms.",
      "metadata": {
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84",
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "bandit-code": "B304",
        "references": [
          "https://cwe.mitre.org/data/definitions/326.html",
          "https://www.pycryptodome.org/src/cipher/cipher"
        ],
        "category": "security",
        "technology": [
          "pycryptodome"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "functional-categories": [
          "crypto::search::symmetric-algorithm::pycryptodome",
          "crypto::search::symmetric-algorithm::pycryptodomex"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Deprecated RC2 encryption algorithm",
        "fix-suggestion": "Replace RC2 with modern algorithms like AES with appropriate key lengths (minimum 128 bits). Use secure modes of operation that provide both encryption and authentication such as GCM. In PyCryptodome, use `AES.new()` or ChaCha20 instead of `RC2.new()`."
      },
      "options": {
        "symbolic_propagation": true
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "pattern-either": [
        {
          "pattern": "Cryptodome.Cipher.ARC2.new(...)"
        },
        {
          "pattern": "Crypto.Cipher.ARC2.new(...)"
        }
      ]
    },
    {
      "id": "python.pycryptodome.security.insecure-cipher-algorithm-rc4.insecure-cipher-algorithm-rc4",
      "message": "Your code uses the ARC4 (RC4) cipher algorithm which is cryptographically broken. RC4 has multiple critical vulnerabilities that allow attackers to recover the plaintext from ciphertext. Using this algorithm for encrypting sensitive data creates serious security risks.",
      "metadata": {
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84",
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "bandit-code": "B304",
        "references": [
          "https://cwe.mitre.org/data/definitions/326.html",
          "https://www.pycryptodome.org/src/cipher/cipher"
        ],
        "category": "security",
        "technology": [
          "pycryptodome"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "functional-categories": [
          "crypto::search::symmetric-algorithm::pycryptodome",
          "crypto::search::symmetric-algorithm::pycryptodomex"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Broken RC4 stream cipher implementation",
        "fix-suggestion": "Replace RC4/ARC4 with modern stream ciphers like ChaCha20 or block ciphers like AES with secure modes. In PyCryptodome, use `ChaCha20.new()` or `AES.new()` with GCM mode instead of `ARC4.new()`. Implement proper key management with secure random key generation."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "pattern-either": [
        {
          "pattern": "Cryptodome.Cipher.ARC4.new(...)"
        },
        {
          "pattern": "Crypto.Cipher.ARC4.new(...)"
        }
      ]
    },
    {
      "id": "python.pycryptodome.security.insecure-hash-algorithm-md2.insecure-hash-algorithm-md2",
      "message": "Your code uses the MD2 hash algorithm which is cryptographically broken. MD2 is vulnerable to collision attacks and is not collision resistant, making it unsuitable for security applications. Using this algorithm puts your application at risk for various cryptographic attacks.",
      "metadata": {
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59",
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "references": [
          "https://www.pycryptodome.org/src/hash/hash#modern-hash-algorithms",
          "https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html",
          "https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability",
          "http://2012.sharcs.org/slides/stevens.pdf",
          "https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html"
        ],
        "category": "security",
        "technology": [
          "pycryptodome"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "functional-categories": [
          "crypto::search::hash-algorithm::pycryptodome",
          "crypto::search::hash-algorithm::pycryptodomex"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Severely outdated MD2 hash algorithm",
        "fix-suggestion": "Replace MD2 with modern hash algorithms from the SHA-2 or SHA-3 family. In PyCryptodome, use `SHA256.new()`, `SHA3_256.new()`, or `BLAKE2b.new()` instead of `MD2.new()`. For password hashing, use specialized algorithms like Argon2 or bcrypt."
      },
      "options": {
        "symbolic_propagation": true
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "pattern-either": [
        {
          "pattern": "Crypto.Hash.MD2.new(...)"
        },
        {
          "pattern": "Cryptodome.Hash.MD2.new (...)"
        }
      ]
    },
    {
      "id": "python.pycryptodome.security.insecure-hash-algorithm-md4.insecure-hash-algorithm-md4",
      "message": "Your code uses the MD4 hash algorithm which is cryptographically broken. MD4 is vulnerable to collision attacks and has been compromised for decades. Using this algorithm for security-sensitive operations creates significant vulnerabilities in your application.",
      "metadata": {
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59",
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "references": [
          "https://www.pycryptodome.org/src/hash/hash#modern-hash-algorithms",
          "https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html",
          "https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability",
          "http://2012.sharcs.org/slides/stevens.pdf",
          "https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html"
        ],
        "category": "security",
        "technology": [
          "pycryptodome"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "functional-categories": [
          "crypto::search::hash-algorithm::pycryptodome",
          "crypto::search::hash-algorithm::pycryptodomex"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Broken MD4 hash algorithm implementation",
        "fix-suggestion": "Replace MD4 with modern hash algorithms from the SHA-2 or SHA-3 family. In PyCryptodome, use `SHA256.new()`, `SHA3_256.new()`, or `BLAKE2b.new()` instead of `MD4.new()`. For digital signatures, use secure algorithms recommended by current cryptographic standards."
      },
      "options": {
        "symbolic_propagation": true
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "pattern-either": [
        {
          "pattern": "Crypto.Hash.MD4.new(...)"
        },
        {
          "pattern": "Cryptodome.Hash.MD4.new (...)"
        }
      ]
    },
    {
      "id": "python.pycryptodome.security.insecure-hash-algorithm-md5.insecure-hash-algorithm-md5",
      "message": "Your code uses the MD5 hash algorithm which is cryptographically broken. MD5 is vulnerable to collision attacks and is not suitable for security applications like digital signatures or certificate validation. Using MD5 creates serious security vulnerabilities.",
      "metadata": {
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59",
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "references": [
          "https://www.pycryptodome.org/src/hash/hash#modern-hash-algorithms",
          "https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html",
          "https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability",
          "http://2012.sharcs.org/slides/stevens.pdf",
          "https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html"
        ],
        "category": "security",
        "technology": [
          "pycryptodome"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "functional-categories": [
          "crypto::search::hash-algorithm::pycryptodome",
          "crypto::search::hash-algorithm::pycryptodomex"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Compromised MD5 hash algorithm usage",
        "fix-suggestion": "Replace MD5 with modern hash algorithms from the SHA-2 or SHA-3 family. In PyCryptodome, use `SHA256.new()`, `SHA3_256.new()`, or `BLAKE2b.new()` instead of `MD5.new()`. For password storage, implement specialized algorithms like Argon2 or bcrypt."
      },
      "options": {
        "symbolic_propagation": true
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "pattern-either": [
        {
          "pattern": "Crypto.Hash.MD5.new(...)"
        },
        {
          "pattern": "Cryptodome.Hash.MD5.new (...)"
        }
      ]
    },
    {
      "id": "python.pycryptodome.security.insufficient-dsa-key-size.insufficient-dsa-key-size",
      "message": "Your code uses DSA keys smaller than the recommended secure size. NIST recommends a minimum of 2048 bits for DSA keys to protect against modern cryptographic attacks. Using smaller keys reduces security and makes the encrypted data vulnerable to compromise.",
      "metadata": {
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/weak_cryptographic_key.py",
        "references": [
          "https://www.pycryptodome.org/src/public_key/dsa",
          "https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf"
        ],
        "category": "security",
        "technology": [
          "pycryptodome"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "functional-categories": [
          "crypto::search::key-length::pycryptodome",
          "crypto::search::key-length::pycryptodomex"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "DSA keys below recommended security threshold",
        "fix-suggestion": "Increase DSA key size to at least 2048 bits as recommended by NIST standards. When generating keys with PyCryptodome, specify the larger key size with `DSA.generate(2048)` or higher. Consider using more modern algorithms like Ed25519 for digital signatures where appropriate."
      },
      "options": {
        "symbolic_propagation": true
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "Crypto.PublicKey.DSA.generate(..., bits=$SIZE, ...)"
            },
            {
              "pattern": "Crypto.PublicKey.DSA.generate($SIZE, ...)"
            },
            {
              "pattern": "Cryptodome.PublicKey.DSA.generate(..., bits=$SIZE, ...)"
            },
            {
              "pattern": "Cryptodome.PublicKey.DSA.generate($SIZE, ...)"
            }
          ]
        },
        {
          "metavariable-comparison": {
            "metavariable": "$SIZE",
            "comparison": "$SIZE < 2048"
          }
        }
      ]
    },
    {
      "id": "python.pycryptodome.security.insufficient-rsa-key-size.insufficient-rsa-key-size",
      "message": "Your code uses RSA keys smaller than the recommended secure size. NIST recommends a minimum of 3072 bits for RSA keys to resist quantum computing attacks. Smaller keys significantly reduce security and can be compromised through advanced cryptanalysis.",
      "metadata": {
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/b1411bfb43795d3ffd268bef17a839dee954c2b1/bandit/plugins/weak_cryptographic_key.py",
        "references": [
          "https://www.pycryptodome.org/src/public_key/rsa#rsa",
          "https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf"
        ],
        "category": "security",
        "technology": [
          "pycryptodome"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "functional-categories": [
          "crypto::search::key-length::pycryptodome",
          "crypto::search::key-length::pycryptodomex"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "RSA keys below recommended security threshold",
        "fix-suggestion": "Increase RSA key size to at least 3072 bits as recommended by current NIST standards. When generating RSA keys with PyCryptodome, specify the key size with `RSA.generate(3072)` or higher. Consider using elliptic curve cryptography as a more efficient alternative where appropriate."
      },
      "options": {
        "symbolic_propagation": true
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "Crypto.PublicKey.RSA.generate(..., bits=$SIZE, ...)"
            },
            {
              "pattern": "Crypto.PublicKey.RSA.generate($SIZE, ...)"
            },
            {
              "pattern": "Cryptodome.PublicKey.RSA.generate(..., bits=$SIZE, ...)"
            },
            {
              "pattern": "Cryptodome.PublicKey.RSA.generate($SIZE, ...)"
            }
          ]
        },
        {
          "metavariable-comparison": {
            "metavariable": "$SIZE",
            "comparison": "$SIZE < 3072"
          }
        }
      ]
    },
    {
      "id": "python.pycryptodome.security.insecure-cipher-algorithm.insecure-cipher-algorithm-xor",
      "message": "Your code uses simple XOR for encryption which is cryptographically weak. XOR operations without proper key management and additional cryptographic protections are easily broken. This approach provides minimal security and should never be used for protecting sensitive data.",
      "metadata": {
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L84",
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "bandit-code": "B304",
        "references": [
          "https://stackoverflow.com/questions/1135186/whats-wrong-with-xor-encryption"
        ],
        "category": "security",
        "technology": [
          "pycryptodome"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Weak XOR-based encryption implementation",
        "fix-suggestion": "Replace simple XOR encryption with standard cryptographic algorithms like AES. Use PyCryptodome's `AES.new()` with a secure mode like GCM or ChaCha20-Poly1305 instead of XOR operations. Implement proper key management with secure random key generation."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "pattern-either": [
        {
          "pattern": "Cryptodome.Cipher.XOR.new(...)"
        },
        {
          "pattern": "Crypto.Cipher.XOR.new(...)"
        }
      ]
    },
    {
      "id": "python.pycryptodome.security.insecure-hash-algorithm.insecure-hash-algorithm-sha1",
      "message": "Your code uses the SHA1 hash algorithm through PyCryptodome which is cryptographically broken. SHA1 has been compromised through collision attacks, making it unsuitable for security applications. Using this algorithm creates vulnerabilities in your application's security.",
      "metadata": {
        "source-rule-url": "https://github.com/PyCQA/bandit/blob/d5f8fa0d89d7b11442fc6ec80ca42953974354c8/bandit/blacklists/calls.py#L59",
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "references": [
          "https://www.schneier.com/blog/archives/2012/10/when_will_we_se.html",
          "https://www.trendmicro.com/vinfo/us/security/news/vulnerabilities-and-exploits/sha-1-collision-signals-the-end-of-the-algorithm-s-viability",
          "http://2012.sharcs.org/slides/stevens.pdf",
          "https://pycryptodome.readthedocs.io/en/latest/src/hash/sha3_256.html"
        ],
        "category": "security",
        "technology": [
          "pycryptodome"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Broken SHA1 hash via PyCryptodome",
        "fix-suggestion": "Replace SHA1 with stronger algorithms like SHA256, SHA3, or BLAKE2. In PyCryptodome, use `SHA256.new()`, `SHA3_256.new()`, or `BLAKE2b.new()` instead of `SHA1.new()`. For digital signatures, ensure you're using secure algorithms that comply with current standards."
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "pattern-either": [
        {
          "pattern": "Crypto.Hash.SHA.new(...)"
        },
        {
          "pattern": "Cryptodome.Hash.SHA.new (...)"
        }
      ]
    },
    {
      "id": "python.pymongo.security.mongodb.mongo-client-bad-auth",
      "pattern": "pymongo.MongoClient(..., authMechanism='MONGODB-CR')\n",
      "message": "Your MongoDB connection uses the deprecated MONGODB-CR authentication mechanism. This authentication method was deprecated in MongoDB 3.6 and is no longer supported in MongoDB 4.0. Using deprecated authentication methods creates security risks as they often contain known vulnerabilities.",
      "fix-regex": {
        "regex": "MONGODB-CR",
        "replacement": "SCRAM-SHA-256"
      },
      "severity": "WARNING",
      "languages": [
        "python"
      ],
      "metadata": {
        "cwe": [
          "CWE-477: Use of Obsolete Function"
        ],
        "category": "security",
        "technology": [
          "pymongo"
        ],
        "references": [
          "https://cwe.mitre.org/data/definitions/477.html"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Dangerous Method or Function"
        ],
        "short-description": "Deprecated MongoDB authentication mechanism",
        "fix-suggestion": "Update your authentication mechanism to SCRAM-SHA-1 (default) or SCRAM-SHA-256. When creating the `MongoClient`, specify the authentication mechanism with the `authMechanism` parameter in the connection string. Ensure your MongoDB version and driver are also updated to compatible versions."
      }
    },
    {
      "id": "python.pyramid.security.direct-use-of-response.pyramid-direct-use-of-response",
      "message": "This vulnerability occurs when data is directly written to a Response object in Pyramid instead of using the template engine to render HTML. Direct Response usage bypasses the automatic HTML escaping provided by the template system. This can lead to cross-site scripting (XSS) vulnerabilities if user input is included in the response without proper escaping.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "pyramid"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Direct Response usage might skip HTML escaping, risking XSS",
        "fix-suggestion": "Leverage Pyramid's templating system for generating responses to ensure automatic escaping of user input."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-inside": "@pyramid.view.view_config( ... )\ndef $VIEW($REQ):\n  ...\n"
            },
            {
              "pattern": "$REQ.$ANYTHING"
            },
            {
              "pattern-not": "$REQ.dbsession"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "pyramid.request.Response.text($SINK)\n"
                },
                {
                  "pattern": "pyramid.request.Response($SINK)\n"
                },
                {
                  "pattern": "$REQ.response.body = $SINK\n"
                },
                {
                  "pattern": "$REQ.response.text = $SINK\n"
                },
                {
                  "pattern": "$REQ.response.ubody = $SINK\n"
                },
                {
                  "pattern": "$REQ.response.unicode_body = $SINK\n"
                }
              ]
            },
            {
              "pattern": "$SINK"
            }
          ]
        }
      ]
    },
    {
      "id": "python.pyramid.security.sqlalchemy-sql-injection.pyramid-sqlalchemy-sql-injection",
      "message": "This vulnerability happens when user input is directly incorporated into SQL clauses like DISTINCT, HAVING, GROUP BY, ORDER BY, or FILTER in SQLAlchemy without proper parameterization. Attackers can inject SQL syntax into these clauses to modify query logic or extract unauthorized data. This can lead to data theft, unauthorized data modification, or complete database compromise.",
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.sqlalchemy.org/en/14/tutorial/data_select.html#tutorial-selecting-data"
        ],
        "technology": [
          "pyramid"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Raw SQL in SQLAlchemy fosters injection vulnerabilities",
        "fix-suggestion": "Ensure all SQL queries in Pyramid are parameterized or use ORM methods to separate SQL logic from user input."
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-inside": "from pyramid.view import view_config\n...\n@view_config( ... )\ndef $VIEW($REQ):\n  ...\n"
            },
            {
              "pattern": "$REQ.$ANYTHING"
            },
            {
              "pattern-not": "$REQ.dbsession"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-inside": "$QUERY = $REQ.dbsession.query(...)\n...\n"
            },
            {
              "pattern-either": [
                {
                  "pattern": "$QUERY.$SQLFUNC(\"...\".$FORMATFUNC(..., $SINK, ...))\n"
                },
                {
                  "pattern": "$QUERY.join(...).$SQLFUNC(\"...\".$FORMATFUNC(..., $SINK, ...))\n"
                }
              ]
            },
            {
              "pattern": "$SINK"
            },
            {
              "metavariable-regex": {
                "metavariable": "$SQLFUNC",
                "regex": "(group_by|order_by|distinct|having|filter)"
              }
            },
            {
              "metavariable-regex": {
                "metavariable": "$FORMATFUNC",
                "regex": "(?!bindparams)"
              }
            }
          ]
        }
      ],
      "fix-regex": {
        "regex": "format",
        "replacement": "bindparams"
      }
    },
    {
      "id": "python.requests.security.disabled-cert-validation.disabled-cert-validation",
      "message": "Certificate validation has been explicitly disabled in your requests library calls. This makes your HTTPS connections vulnerable to man-in-the-middle attacks as any SSL certificate will be accepted. Without certificate validation, encrypted connections provide a false sense of security.",
      "metadata": {
        "cwe": [
          "CWE-295: Improper Certificate Validation"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A07:2021 - Identification and Authentication Failures"
        ],
        "references": [
          "https://stackoverflow.com/questions/41740361/is-it-safe-to-disable-ssl-certificate-verification-in-pythonss-requests-lib"
        ],
        "category": "security",
        "technology": [
          "requests"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "SSL certificate verification disabled in requests",
        "fix-suggestion": "Remove `verify=False` from all `requests` library calls. Always validate SSL certificates when making HTTPS requests to ensure proper security. If dealing with internal certificates, use the `verify='/path/to/cert.pem'` parameter to specify your CA bundle instead of disabling verification entirely."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "pattern-either": [
        {
          "pattern": "requests.put(..., verify=False, ...)"
        },
        {
          "pattern": "requests.patch(..., verify=False, ...)"
        },
        {
          "pattern": "requests.delete(..., verify=False, ...)"
        },
        {
          "pattern": "requests.head(..., verify=False, ...)"
        },
        {
          "pattern": "requests.options(..., verify=False, ...)"
        },
        {
          "pattern": "requests.request(..., verify=False, ...)"
        },
        {
          "pattern": "requests.get(..., verify=False, ...)"
        },
        {
          "pattern": "requests.post(..., verify=False, ...)"
        }
      ],
      "fix-regex": {
        "regex": "verify(\\s)*=(\\s)*False",
        "replacement": "verify=True"
      }
    },
    {
      "id": "python.requests.security.no-auth-over-http.no-auth-over-http",
      "fix-regex": {
        "regex": "http:\\/\\/",
        "replacement": "https://",
        "count": 1
      },
      "message": "Authentication credentials are being sent over an unencrypted HTTP connection. This exposes usernames, passwords, and tokens to network eavesdropping attacks. Sensitive authentication information should only be transmitted over encrypted connections.",
      "metadata": {
        "cwe": [
          "CWE-523: Unprotected Transport of Credentials"
        ],
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://pypi.org/project/flake8-flask/",
        "references": [
          "https://semgrep.dev/blog/2020/bento-check-no-auth-over-http/",
          "https://bento.dev/checks/requests/no-auth-over-http/"
        ],
        "category": "security",
        "technology": [
          "requests"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Credentials transmitted over insecure HTTP",
        "fix-suggestion": "Always use HTTPS (`https://`) URLs when sending authentication credentials. Replace all HTTP URLs with HTTPS equivalents in authentication calls. Implement certificate validation to ensure the authenticity of the remote server during authentication."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "pattern-either": [
        {
          "pattern": "requests.$W(\"=~/http:\\/\\/.*/\", ..., auth=$X, ...)"
        },
        {
          "pattern": "$URL = \"=~/http:\\/\\/.../\"\n...\nrequests.$W($URL, ..., auth=$X, ...)\n"
        }
      ]
    },
    {
      "id": "python.sh.security.string-concat.string-concat",
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "message": "This vulnerability occurs when shell commands are built by concatenating strings that include unvalidated user input. Attackers can inject shell metacharacters or command separators to execute additional commands beyond what was intended. This can lead to arbitrary command execution on the system with the privileges of the application.",
      "metadata": {
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "sh"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "String-concatenated shell commands can lead to code injection",
        "fix-suggestion": "Avoid constructing shell commands via string concatenation with untrusted input; use safe methods that separate command arguments."
      },
      "pattern-either": [
        {
          "pattern": "sh.$BIN($X + $Y)"
        },
        {
          "pattern": "sh.$BIN($X.format(...))"
        },
        {
          "pattern": "sh.$BIN(f\"...{...}...\")"
        }
      ]
    },
    {
      "id": "python.sqlalchemy.security.sqlalchemy-execute-raw-query.sqlalchemy-execute-raw-query",
      "message": "This vulnerability happens when raw SQL queries in SQLAlchemy include user input through string concatenation rather than using parameterized queries. Attackers can inject SQL syntax that alters the query structure to perform unauthorized database operations. This can lead to data theft, unauthorized data modification, or authentication bypass.",
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.sqlalchemy.org/en/14/core/tutorial.html#using-textual-sql",
          "https://www.tutorialspoint.com/sqlalchemy/sqlalchemy_quick_guide.htm",
          "https://docs.sqlalchemy.org/en/14/core/tutorial.html#using-more-specific-text-with-table-expression-literal-column-and-expression-column"
        ],
        "category": "security",
        "technology": [
          "sqlalchemy"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Unparameterized raw SQL queries in SQLAlchemy are injection-prone",
        "fix-suggestion": "Replace raw SQL execution with parameterized queries using SQLAlchemy\u00e2\u20ac\u2122s safe methods to securely handle user input."
      },
      "severity": "ERROR",
      "languages": [
        "python"
      ],
      "pattern-either": [
        {
          "pattern": "$CONNECTION.execute( $SQL + ..., ... )\n"
        },
        {
          "pattern": "$CONNECTION.execute( $SQL % (...), ...)\n"
        },
        {
          "pattern": "$CONNECTION.execute( $SQL.format(...), ... )\n"
        },
        {
          "pattern": "$CONNECTION.execute(f\"...{...}...\", ...)\n"
        },
        {
          "patterns": [
            {
              "pattern-inside": "$QUERY = $SQL + ...\n...\n"
            },
            {
              "pattern": "$CONNECTION.execute($QUERY, ...)\n"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$QUERY = $SQL % (...)\n...\n"
            },
            {
              "pattern": "$CONNECTION.execute($QUERY, ...)\n"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$QUERY = $SQL.format(...)\n...\n"
            },
            {
              "pattern": "$CONNECTION.execute($QUERY, ...)\n"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "$QUERY = f\"...{...}...\"\n...\n"
            },
            {
              "pattern": "$CONNECTION.execute($QUERY, ...)\n"
            }
          ]
        }
      ]
    },
    {
      "id": "python.sqlalchemy.security.sqlalchemy-sql-injection.sqlalchemy-sql-injection",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "def $FUNC(...,$VAR,...):\n  ...\n  $SESSION.query(...).$SQLFUNC(\"...\".$FORMATFUNC(...,$VAR,...))\n"
            },
            {
              "pattern": "def $FUNC(...,$VAR,...):\n  ...\n  $SESSION.query.join(...).$SQLFUNC(\"...\".$FORMATFUNC(...,$VAR,...))\n"
            },
            {
              "pattern": "def $FUNC(...,$VAR,...):\n  ...\n  $SESSION.query.$SQLFUNC(\"...\".$FORMATFUNC(...,$VAR,...))\n"
            },
            {
              "pattern": "def $FUNC(...,$VAR,...):\n  ...\n  query.$SQLFUNC(\"...\".$FORMATFUNC(...,$VAR,...))\n"
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$SQLFUNC",
            "regex": "(group_by|order_by|distinct|having|filter)"
          }
        },
        {
          "metavariable-regex": {
            "metavariable": "$FORMATFUNC",
            "regex": "(?!bindparams)"
          }
        }
      ],
      "message": "This vulnerability occurs when user input is directly incorporated into SQL clauses in SQLAlchemy without proper parameterization. Attackers can inject specially crafted SQL to modify query behavior or access unauthorized data. This can result in information disclosure, data manipulation, or authentication bypass.",
      "fix-regex": {
        "regex": "format",
        "replacement": "bindparams"
      },
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "category": "security",
        "technology": [
          "sqlalchemy"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Unsanitized SQL expressions in SQLAlchemy can be injected",
        "fix-suggestion": "Utilize SQLAlchemy\u00e2\u20ac\u2122s ORM or parameterized query features to ensure user input is safely bound and cannot alter SQL query structure."
      }
    },
    {
      "id": "python.sqlalchemy.security.audit.avoid-sqlalchemy-text.avoid-sqlalchemy-text",
      "mode": "taint",
      "pattern-sinks": [
        {
          "pattern": "sqlalchemy.text(...)\n"
        }
      ],
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "$X + $Y\n"
            },
            {
              "metavariable-type": {
                "metavariable": "$X",
                "type": "string"
              }
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern": "$X + $Y\n"
            },
            {
              "metavariable-type": {
                "metavariable": "$Y",
                "type": "string"
              }
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern": "f\"...\"\n"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern": "$X.format(...)\n"
            },
            {
              "metavariable-type": {
                "metavariable": "$X",
                "type": "string"
              }
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern": "$X % $Y\n"
            },
            {
              "metavariable-type": {
                "metavariable": "$X",
                "type": "string"
              }
            }
          ]
        }
      ],
      "message": "This vulnerability happens when sqlalchemy.text() is used with user input, bypassing SQLAlchemy's protections against SQL injection. The text() function passes SQL strings mostly unchanged to the database, allowing attackers to inject malicious SQL. This can lead to data theft, unauthorized data modification, or even full database compromise.",
      "metadata": {
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "category": "security",
        "technology": [
          "sqlalchemy"
        ],
        "confidence": "MEDIUM",
        "references": [
          "https://docs.sqlalchemy.org/en/14/core/tutorial.html#using-textual-sql"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "sqlalchemy.text usage bypasses injection protection",
        "fix-suggestion": "Avoid using `sqlalchemy.text()` with user-supplied input entirely. Use SQLAlchemy's ORM query methods instead, and if `text()` must be used, ensure all user inputs are passed as bind parameters (e.g., `text('SELECT * FROM users WHERE id = :user_id').bindparams(user_id=user_input)`)."
      },
      "languages": [
        "python"
      ],
      "severity": "ERROR"
    },
    {
      "id": "python.twilio.security.twiml-injection.twiml-injection",
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "message": "Non-constant user input is being used in TwiML (Twilio Markup Language) commands. This can lead to TwiML injection attacks where attackers inject unexpected TwiML commands that change the behavior of your Twilio service. Such attacks can result in unauthorized calls, messages, or data exposure.",
      "metadata": {
        "cwe": [
          "CWE-91: XML Injection"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "python",
          "twilio",
          "twiml"
        ],
        "confidence": "MEDIUM",
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "subcategory": "vuln",
        "references": [
          "https://codeberg.org/fennix/funjection"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "User input enables TwiML command injection",
        "fix-suggestion": "Validate and sanitize all user inputs before using them in TwiML generation. Use Twilio's helper libraries like `twilio.twiml.VoiceResponse` or `MessagingResponse` which properly escape inputs. Implement strict input validation to ensure only expected values are accepted in TwiML contexts."
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern": "f\"...\"\n"
        },
        {
          "pattern": "\"...\" % ...\n"
        },
        {
          "pattern": "\"...\".format(...)\n"
        },
        {
          "patterns": [
            {
              "pattern": "$ARG"
            },
            {
              "pattern-inside": "def $F(..., $ARG, ...):\n    ...\n"
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "pattern": "xml.sax.saxutils.escape(...)"
        },
        {
          "pattern": "html.escape(...)"
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$CLIENT.calls.create(..., twiml=$SINK, ...)\n"
            },
            {
              "focus-metavariable": "$SINK"
            }
          ]
        }
      ]
    },
    {
      "id": "ruby.aws-lambda.security.activerecord-sqli.activerecord-sqli",
      "languages": [
        "ruby"
      ],
      "message": "This vulnerability occurs when ActiveRecord queries in Ruby AWS Lambda functions include user input without proper parameterization. Attackers can inject SQL syntax that changes the query structure to perform unauthorized database operations. This can lead to data theft, unauthorized data modification, or authentication bypass.",
      "mode": "taint",
      "metadata": {
        "references": [
          "https://guides.rubyonrails.org/active_record_querying.html#finding-by-sql"
        ],
        "category": "security",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "technology": [
          "aws-lambda",
          "active-record"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "ActiveRecord SQL with untrusted event data can be injected",
        "fix-suggestion": "Use `ActiveRecord`'s parameterized query methods like `where` with hash conditions to safely bind user input. Avoid string interpolation or concatenation when building SQL queries. Consider implementing model validations to reject potentially malicious inputs before they reach the database layer."
      },
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$QUERY"
            },
            {
              "pattern-either": [
                {
                  "pattern": "ActiveRecord::Base.connection.execute($QUERY,...)"
                },
                {
                  "pattern": "$MODEL.find_by_sql($QUERY,...)"
                },
                {
                  "pattern": "$MODEL.select_all($QUERY,...)"
                }
              ]
            },
            {
              "pattern-inside": "require 'active_record'\n...\n"
            }
          ]
        }
      ],
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "event"
            },
            {
              "pattern-inside": "def $HANDLER(event, context)\n  ...\nend\n"
            }
          ]
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "ruby.aws-lambda.security.mysql2-sqli.mysql2-sqli",
      "languages": [
        "ruby"
      ],
      "message": "This vulnerability happens when MySQL queries in Ruby AWS Lambda functions are built by concatenating user input rather than using parameterized queries. Attackers can inject SQL syntax that modifies query behavior to access or manipulate unauthorized data. This can result in information disclosure, data manipulation, or complete database compromise.",
      "mode": "taint",
      "metadata": {
        "references": [
          "https://github.com/brianmario/mysql2"
        ],
        "category": "security",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "technology": [
          "aws-lambda",
          "mysql2"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "mysql2 queries with user input risk injection in Lambda",
        "fix-suggestion": "Replace string-concatenated queries with parameterized queries using `mysql2`'s prepared statement functionality (`prepare` and `execute`). Never directly interpolate user input into SQL strings with `#{variable}` or string concatenation. Implement input validation at the application layer to reject suspicious patterns before they reach database operations."
      },
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$QUERY"
            },
            {
              "pattern-either": [
                {
                  "pattern": "$CLIENT.query($QUERY,...)"
                },
                {
                  "pattern": "$CLIENT.prepare($QUERY,...)"
                }
              ]
            },
            {
              "pattern-inside": "require 'mysql2'\n...\n"
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "pattern": "$CLIENT.escape(...)"
        }
      ],
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "event"
            },
            {
              "pattern-inside": "def $HANDLER(event, context)\n  ...\nend\n"
            }
          ]
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "ruby.aws-lambda.security.pg-sqli.pg-sqli",
      "languages": [
        "ruby"
      ],
      "message": "This vulnerability occurs when PostgreSQL queries in Ruby AWS Lambda functions are constructed with user input through string concatenation instead of parameterized queries. Attackers can inject SQL syntax that alters the query's intended behavior to perform unauthorized operations. This can lead to data theft, data manipulation, or authentication bypass.",
      "mode": "taint",
      "metadata": {
        "references": [
          "https://www.rubydoc.info/gems/pg/PG/Connection"
        ],
        "category": "security",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "technology": [
          "aws-lambda",
          "postgres",
          "pg"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "PostgreSQL queries from event data cause injection risk",
        "fix-suggestion": "Use parameterized queries with the `pg` gem's `exec_params` method or `ActiveRecord`'s query interface instead of string interpolation. Replace any instances of string concatenation in SQL with placeholder parameters (`$1`, `$2`). Implement proper input validation before database operations to reject potentially malicious patterns."
      },
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$QUERY"
            },
            {
              "pattern-either": [
                {
                  "pattern": "$CONN.exec($QUERY,...)"
                },
                {
                  "pattern": "$CONN.exec_params($QUERY,...)"
                },
                {
                  "pattern": "$CONN.exec_prepared($QUERY,...)"
                },
                {
                  "pattern": "$CONN.async_exec($QUERY,...)"
                },
                {
                  "pattern": "$CONN.async_exec_params($QUERY,...)"
                },
                {
                  "pattern": "$CONN.async_exec_prepared($QUERY,...)"
                }
              ]
            },
            {
              "pattern-inside": "require 'pg'\n...\n"
            }
          ]
        }
      ],
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "event"
            },
            {
              "pattern-inside": "def $HANDLER(event, context)\n  ...\nend\n"
            }
          ]
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "ruby.aws-lambda.security.sequel-sqli.sequel-sqli",
      "languages": [
        "ruby"
      ],
      "message": "This vulnerability happens when Sequel queries in Ruby AWS Lambda functions include user input through string concatenation rather than parameterization. Attackers can inject SQL syntax that changes the query structure to perform unauthorized database operations. This can result in data theft, unauthorized data modification, or authentication bypass.",
      "mode": "taint",
      "metadata": {
        "references": [
          "https://github.com/jeremyevans/sequel#label-Arbitrary+SQL+queries"
        ],
        "category": "security",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "technology": [
          "aws-lambda",
          "sequel"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Sequel with concatenated user input can lead to injection",
        "fix-suggestion": "Replace string-interpolated queries with `Sequel`'s parameterized methods using placeholders like `?` or named parameters. Avoid using string concatenation (`+`) or interpolation (`#{var}`) when building SQL queries. Consider using `Sequel`'s dataset methods like `where`, `select`, and `join` which automatically handle parameter binding."
      },
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$QUERY"
            },
            {
              "pattern-either": [
                {
                  "pattern": "DB[$QUERY,...]"
                },
                {
                  "pattern": "DB.run($QUERY,...)"
                }
              ]
            },
            {
              "pattern-inside": "require 'sequel'\n...\n"
            }
          ]
        }
      ],
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "event"
            },
            {
              "pattern-inside": "def $HANDLER(event, context)\n  ...\nend\n"
            }
          ]
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "ruby.aws-lambda.security.tainted-deserialization.tainted-deserialization",
      "mode": "taint",
      "languages": [
        "ruby"
      ],
      "message": "This vulnerability occurs when potentially dangerous deserialization methods (like Marshal.load, YAML.load, or CSV.parse) are used on untrusted data in Ruby AWS Lambda functions. These methods can create arbitrary Ruby objects during deserialization, potentially executing code. This can lead to remote code execution with the privileges of the Lambda function.",
      "metadata": {
        "references": [
          "https://ruby-doc.org/core-3.1.2/doc/security_rdoc.html",
          "https://groups.google.com/g/rubyonrails-security/c/61bkgvnSGTQ/m/nehwjA8tQ8EJ",
          "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_deserialize.rb"
        ],
        "category": "security",
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "technology": [
          "ruby",
          "aws-lambda"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "Deserializing untrusted data in Lambda can allow code execution",
        "fix-suggestion": "Replace unsafe deserialization methods like `Marshal.load` or `YAML.load` with safer alternatives such as `YAML.safe_load` or `JSON.parse`. Implement cryptographic signature verification to ensure data hasn't been tampered with before deserialization. Consider using application-specific data structures that validate input during reconstruction rather than generic deserialization."
      },
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$SINK"
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "YAML.load($SINK,...)\n"
                },
                {
                  "pattern-inside": "CSV.load($SINK,...)\n"
                },
                {
                  "pattern-inside": "Marshal.load($SINK,...)\n"
                },
                {
                  "pattern-inside": "Marshal.restore($SINK,...)\n"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "event"
            },
            {
              "pattern-inside": "def $HANDLER(event, context)\n  ...\nend\n"
            }
          ]
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "ruby.aws-lambda.security.tainted-sql-string.tainted-sql-string",
      "languages": [
        "ruby"
      ],
      "severity": "ERROR",
      "message": "This vulnerability happens when SQL queries in Ruby AWS Lambda functions are built by concatenating user input instead of using parameterized queries or ORM methods. Attackers can inject SQL syntax that alters the query structure to perform unauthorized operations. This can lead to data theft, unauthorized data modification, or authentication bypass.",
      "metadata": {
        "references": [
          "https://rorsecurity.info/portfolio/ruby-on-rails-sql-injection-cheat-sheet"
        ],
        "category": "security",
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "technology": [
          "aws-lambda"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Constructing SQL with user data fosters injection vulnerabilities",
        "fix-suggestion": "Replace string-concatenated SQL with parameterized queries using placeholders like `?` or named parameters. Use ORM methods that automatically handle parameter binding, such as `ActiveRecord`'s `where` with hash conditions. Implement input validation before queries to reject suspicious patterns that could indicate SQL injection attempts."
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "event"
            },
            {
              "pattern-inside": "def $HANDLER(event, context)\n  ...\nend\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern": "\"...#{...}...\"\n"
                    },
                    {
                      "pattern-regex": "(?i)(select|delete|insert|create|update|alter|drop)\\b|\\w+\\s*!?[<>=].*"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "Kernel::sprintf(\"$SQLSTR\", ...)"
                        },
                        {
                          "pattern": "\"$SQLSTR\" + $EXPR\n"
                        },
                        {
                          "pattern": "\"$SQLSTR\" % $EXPR\n"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$SQLSTR",
                        "regex": "(?i)(select|delete|insert|create|update|alter|drop)\\b|\\w+\\s*!?[<>=].*"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "pattern-not-inside": "puts(...)\n"
            }
          ]
        }
      ]
    },
    {
      "id": "ruby.jwt.security.audit.jwt-decode-without-verify.ruby-jwt-decode-without-verify",
      "message": "JWT tokens are being decoded without verification in your Ruby application. Without verification, any malicious user can forge a JWT token with arbitrary claims. This bypasses authentication and authorization controls, potentially granting unauthorized access to protected resources.",
      "metadata": {
        "cwe": [
          "CWE-345: Insufficient Verification of Data Authenticity"
        ],
        "owasp": [
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "source-rule-url": "https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/",
        "category": "security",
        "technology": [
          "jwt"
        ],
        "references": [
          "https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "JWT tokens decoded without signature verification",
        "fix-suggestion": "Always include verification when decoding JWT tokens by setting the `verify` parameter to `true` in `JWT.decode()` calls. Add appropriate verification options including `verify_expiration` and `verify_not_before`. Implement proper key management for JWT token verification."
      },
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "require 'jwt'\n...\n"
        },
        {
          "pattern": "JWT.decode($PAYLOAD,$SECRET,false,...)"
        }
      ]
    },
    {
      "id": "ruby.jwt.security.audit.jwt-exposed-data.ruby-jwt-exposed-data",
      "message": "Sensitive data may be exposed in JWT token payloads. JWT tokens are encoded but not encrypted by default, making their contents readable to anyone who obtains the token. Including sensitive information in tokens creates serious security and privacy risks.",
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A04:2021 - Insecure Design"
        ],
        "cwe": [
          "CWE-522: Insufficiently Protected Credentials"
        ],
        "source-rule-url": "https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/",
        "category": "security",
        "technology": [
          "jwt"
        ],
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Sensitive data exposed in JWT payloads",
        "fix-suggestion": "Review all data included in JWT token payloads and remove sensitive information like passwords, PII, or secrets. Only include the minimum necessary claims like user IDs or roles in JWT tokens. For sensitive data that must be included, consider using encrypted JWE tokens instead of standard JWT."
      },
      "languages": [
        "ruby"
      ],
      "patterns": [
        {
          "pattern-inside": "require 'jwt'\n...\n"
        },
        {
          "pattern-inside": "def $FUNC(...,$INPUT,...)\n  ...\nend\n"
        },
        {
          "pattern": "JWT.encode($INPUT,...)\n"
        }
      ]
    },
    {
      "id": "ruby.jwt.security.jwt-exposed-credentials.ruby-jwt-exposed-credentials",
      "languages": [
        "ruby"
      ],
      "metadata": {
        "cwe": [
          "CWE-522: Insufficiently Protected Credentials"
        ],
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A04:2021 - Insecure Design"
        ],
        "source-rule-url": "https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/",
        "references": [
          "https://cwe.mitre.org/data/definitions/522.html"
        ],
        "category": "security",
        "technology": [
          "jwt"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Passwords exposed in JWT token payloads",
        "fix-suggestion": "Never store passwords or other credentials in JWT tokens. Only include non-sensitive identifiers or authorization information in token payloads. Store sensitive authentication data server-side and associate it with the user via secure session management."
      },
      "message": "Passwords are being stored in JWT token payloads. JWT tokens are not encrypted by default and their contents can be easily decoded. Storing passwords in tokens creates a serious security risk even if the tokens are transmitted securely.",
      "patterns": [
        {
          "pattern-inside": "require 'jwt'\n...\n"
        },
        {
          "pattern": "$PAYLOAD = {...,password:...,...}\n...\nJWT.encode($PAYLOAD,...)\n"
        }
      ],
      "severity": "ERROR"
    },
    {
      "id": "ruby.jwt.security.jwt-hardcode.ruby-jwt-hardcoded-secret",
      "message": "JWT secrets or private keys are hardcoded in your application code. Hardcoded secrets in source code are easily compromised through code repositories, backups, or when multiple developers have access. This significantly weakens the security of your JWT implementation.",
      "metadata": {
        "cwe": [
          "CWE-522: Insufficiently Protected Credentials"
        ],
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A04:2021 - Insecure Design"
        ],
        "source-rule-url": "https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/",
        "category": "security",
        "technology": [
          "jwt"
        ],
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Hardcoded JWT secrets in application code",
        "fix-suggestion": "Remove hardcoded JWT secrets and store them in environment variables or a secure vault. Use `ENV['JWT_SECRET']` or a secrets management system to access the JWT secret at runtime. Implement proper key rotation procedures to regularly update JWT secrets."
      },
      "patterns": [
        {
          "pattern-inside": "require 'jwt'\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "JWT.encode($PAYLOAD,\"...\",...)\n"
            },
            {
              "pattern": "JWT.decode($PAYLOAD,\"...\",...)\n"
            },
            {
              "pattern": "JWT.encode($PAYLOAD,nil,...)\n"
            },
            {
              "pattern": "JWT.decode($PAYLOAD,nil,...)\n"
            },
            {
              "pattern": "$SECRET = \"...\"\n...\nJWT.encode($PAYLOAD,$SECRET,...)\n"
            },
            {
              "pattern": "$SECRET = \"...\"\n...\nJWT.decode($PAYLOAD,$SECRET,...)\n"
            }
          ]
        },
        {
          "pattern-not": "JWT.encode($PAYLOAD, nil, ... , jwks: ..., ...)\n"
        },
        {
          "pattern-not": "JWT.decode($PAYLOAD, nil, ..., jwks: ..., ...)\n"
        }
      ],
      "languages": [
        "ruby"
      ],
      "severity": "ERROR"
    },
    {
      "id": "ruby.jwt.security.jwt-none-alg.ruby-jwt-none-alg",
      "message": "Your code uses the 'none' algorithm for JWT tokens. This completely removes signature validation, allowing anyone to forge valid tokens with arbitrary claims. Using the 'none' algorithm effectively bypasses all JWT security mechanisms.",
      "metadata": {
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "source-rule-url": "https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/",
        "category": "security",
        "technology": [
          "jwt"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Insecure 'none' algorithm in JWT tokens",
        "fix-suggestion": "Never use the `none` algorithm for JWT tokens. Always specify a secure algorithm like `HS256` or `RS256` when creating JWT tokens. Implement proper key management and verification for all tokens to ensure cryptographic security."
      },
      "languages": [
        "ruby"
      ],
      "severity": "ERROR",
      "patterns": [
        {
          "pattern-inside": "require 'jwt'\n...\n"
        },
        {
          "pattern": "JWT.encode($PAYLOAD, $SECRET, 'none', ...)\n"
        }
      ]
    },
    {
      "id": "ruby.lang.security.bad-deserialization.bad-deserialization",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern-either": [
            {
              "pattern": "params"
            },
            {
              "pattern": "cookies"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "pattern-either": [
            {
              "pattern": "CSV.load(...)\n"
            },
            {
              "pattern": "Marshal.load(...)\n"
            },
            {
              "pattern": "Marshal.restore(...)\n"
            },
            {
              "pattern": "Oj.object_load(...)\n"
            },
            {
              "pattern": "Oj.load($X)\n"
            }
          ]
        }
      ],
      "message": "This vulnerability occurs when Ruby's load or object_load methods are used to deserialize untrusted data, which can create arbitrary Ruby objects. Attackers can craft malicious serialized data that executes code when deserialized. This can lead to remote code execution with the privileges of the application.",
      "metadata": {
        "references": [
          "https://groups.google.com/g/rubyonrails-security/c/61bkgvnSGTQ/m/nehwjA8tQ8EJ",
          "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_deserialize.rb"
        ],
        "category": "security",
        "cwe": [
          "CWE-502: Deserialization of Untrusted Data"
        ],
        "owasp": [
          "A08:2017 - Insecure Deserialization",
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "technology": [
          "ruby"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "load or object_load on user data can run arbitrary code",
        "fix-suggestion": "Replace `Marshal.load`, `YAML.load`, and `JSON.load` with safer alternatives like `YAML.safe_load` or `JSON.parse`. Add cryptographic verification of serialized data before deserialization using HMAC signatures. Consider using structured data formats with schema validation rather than arbitrary object deserialization."
      },
      "languages": [
        "ruby"
      ],
      "severity": "ERROR"
    },
    {
      "id": "ruby.lang.security.cookie-serialization.cookie-serialization",
      "message": "This vulnerability happens when Marshal is used to serialize and deserialize cookies in Ruby applications. Attackers who can control cookie values can craft malicious serialized data that executes code when deserialized. This can lead to remote code execution in the context of the application.",
      "metadata": {
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "references": [
          "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_cookie_serialization.rb",
          "https://robertheaton.com/2013/07/22/how-to-hack-a-rails-app-using-its-secret-token/"
        ],
        "category": "security",
        "technology": [
          "ruby"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Marshal-based cookie serialization can be maliciously crafted",
        "fix-suggestion": "Replace `Marshal`-based cookie serialization with secure alternatives like JSON serialization by setting `Rails.application.config.action_dispatch.cookies_serializer = :json`. Store only primitive data (strings, integers) in cookies rather than complex objects. Add HMAC signature verification to ensure cookie integrity."
      },
      "languages": [
        "ruby"
      ],
      "severity": "ERROR",
      "pattern-either": [
        {
          "pattern": "Rails.application.config.action_dispatch.cookies_serializer = :marshal\n"
        },
        {
          "pattern": "Rails.application.config.action_dispatch.cookies_serializer = :hybrid\n"
        }
      ]
    },
    {
      "id": "ruby.lang.security.create-with.create-with",
      "patterns": [
        {
          "pattern-not": "$FUNC.create_with($PARAMSB.permit(...))\n"
        },
        {
          "pattern": "$FUNC.create_with($PARAMSA)\n"
        }
      ],
      "message": "Your code uses 'create_with' which bypasses Rails strong parameter protection. This can allow attackers to set arbitrary attributes on models, potentially leading to mass assignment vulnerabilities. When used without proper validation, this method can create serious security risks.",
      "metadata": {
        "cwe": [
          "CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes"
        ],
        "references": [
          "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_create_with.rb",
          "https://groups.google.com/g/rubyonrails-security/c/M4chq5Sb540/m/CC1Fh0Y_NWwJ"
        ],
        "category": "security",
        "technology": [
          "ruby"
        ],
        "owasp": [
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mass Assignment"
        ],
        "short-description": "Mass assignment vulnerability via create_with",
        "fix-suggestion": "Either remove `create_with` calls or explicitly use the `permit` function to specify allowed attributes. Implement proper attribute filtering on all model creation methods. Consider using strong parameters consistently throughout your application to prevent mass assignment vulnerabilities."
      },
      "languages": [
        "ruby"
      ],
      "severity": "ERROR"
    },
    {
      "id": "ruby.lang.security.dangerous-exec.dangerous-exec",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "def $F(...,$ARG,...)\n    ...\nend\n"
            },
            {
              "focus-metavariable": "$ARG"
            }
          ]
        },
        {
          "pattern": "params"
        },
        {
          "pattern": "cookies"
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$EXEC(...)\n"
            },
            {
              "pattern-not": "$EXEC(\"...\",\"...\",\"...\",...)\n"
            },
            {
              "pattern-not": "$EXEC([\"...\",\"...\",\"...\",...],...)\n"
            },
            {
              "pattern-not": "$EXEC({...},\"...\",\"...\",\"...\",...)\n"
            },
            {
              "pattern-not": "$EXEC({...},[\"...\",\"...\",\"...\",...],...)\n"
            },
            {
              "metavariable-regex": {
                "metavariable": "$EXEC",
                "regex": "^(system|exec|spawn|Process.exec|Process.spawn|Open3.capture2|Open3.capture2e|Open3.capture3|Open3.popen2|Open3.popen2e|Open3.popen3|IO.popen|Gem::Util.popen|PTY.spawn)$"
              }
            }
          ]
        }
      ],
      "message": "This vulnerability occurs when user input is passed to exec or similar methods in Ruby without proper validation. Attackers can inject shell metacharacters or command separators to execute arbitrary commands on the system. This can lead to complete system compromise, data theft, or service disruption.",
      "metadata": {
        "source-rule-url": "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_execute.rb",
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "ruby",
          "rails"
        ],
        "references": [
          "https://guides.rubyonrails.org/security.html#command-line-injection"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "exec with untrusted input leads to OS command injection",
        "fix-suggestion": "Never pass unsanitized user input to methods like `exec`, `system`, or backticks. Use allowlists to validate command arguments or parameters before execution. Consider safer alternatives like built-in Ruby APIs that provide the functionality without shell execution."
      },
      "severity": "WARNING",
      "languages": [
        "ruby"
      ]
    },
    {
      "id": "ruby.lang.security.dangerous-open.dangerous-open",
      "patterns": [
        {
          "pattern": "open($CMD,...)\n"
        },
        {
          "pattern-not": "open(\"...\",...)\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$CMD",
            "regex": "|"
          }
        }
      ],
      "message": "This vulnerability happens when Ruby's open method is used with user-controlled input without validation. If the input starts with a pipe character (|), open will execute the rest as a shell command instead of opening a file. This can lead to arbitrary command execution on the server with the application's privileges.",
      "metadata": {
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "ruby"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "open with user input can run commands unexpectedly",
        "fix-suggestion": "Ensure file paths passed to `open()` begin with a safe directory and don't contain `..` or other path traversal patterns. Use `File.open` instead of `Kernel.open` to prevent execution when paths start with pipe characters. Consider implementing a whitelist of allowed file paths or directories to restrict access."
      },
      "severity": "WARNING",
      "languages": [
        "ruby"
      ]
    },
    {
      "id": "ruby.lang.security.dangerous-open3-pipeline.dangerous-open3-pipeline",
      "patterns": [
        {
          "pattern": "Open3.$PIPE(...)\n"
        },
        {
          "pattern-not": "Open3.$PIPE(...,\"...\",...)\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$PIPE",
            "regex": "^(pipeline|pipeline_r|pipeline_rw|pipeline_start|pipeline_w)$"
          }
        }
      ],
      "message": "This vulnerability occurs when Open3.pipeline is used with user-controlled input without validation in Ruby. Attackers can inject shell metacharacters to execute arbitrary commands on the system. This can lead to complete system compromise, data theft, or service disruption.",
      "metadata": {
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "ruby"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "open3 pipeline with user input is injection risk",
        "fix-suggestion": "Avoid using `Open3.pipeline` with user-supplied input in command strings or arguments. Implement strict validation of all command components against an allowlist before execution. Consider safer alternatives that don't involve shell command execution to achieve the same functionality."
      },
      "severity": "WARNING",
      "languages": [
        "ruby"
      ]
    },
    {
      "id": "ruby.lang.security.dangerous-subshell.dangerous-subshell",
      "patterns": [
        {
          "pattern": "`...#{$VAL}...`\n"
        },
        {
          "pattern-not": "`...#{\"...\"}...`\n"
        },
        {
          "pattern-not-inside": "$VAL = \"...\"\n...\n"
        }
      ],
      "message": "This vulnerability happens when backticks or system() are used with user input in Ruby, which executes the input as shell commands. Attackers can inject shell metacharacters to execute additional malicious commands. This can lead to arbitrary command execution on the server with the application's privileges.",
      "metadata": {
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "ruby"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Backticks with untrusted data can cause command injection",
        "fix-suggestion": "Replace backticks, `system()`, and `%x[]` with safer alternatives like `Open3.capture2` with explicit arguments. Never include user input directly in command strings; use an array form with separate arguments instead. Implement strict validation of all command components before execution."
      },
      "severity": "WARNING",
      "languages": [
        "ruby"
      ]
    },
    {
      "id": "ruby.lang.security.dangerous-syscall.dangerous-syscall",
      "pattern": "syscall\n",
      "message": "This vulnerability occurs when Ruby's syscall function is used, which provides direct access to low-level system calls. This function is both unsafe and unportable, potentially allowing attackers to manipulate system resources or bypass security controls. This can lead to system crashes, privilege escalation, or other security issues.",
      "metadata": {
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "ruby"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "syscall usage in Ruby can be unsafe and unportable",
        "fix-suggestion": "Replace low-level `syscall` functions with higher-level Ruby APIs that include built-in safety checks. Never pass unsanitized user input to system calls. Implement strict validation of all inputs against a whitelist of safe values."
      },
      "severity": "WARNING",
      "languages": [
        "ruby"
      ]
    },
    {
      "id": "ruby.lang.security.divide-by-zero.divide-by-zero",
      "message": "Your code contains a potential division by zero that could cause a runtime error. When division by zero occurs, it typically results in an exception that terminates the current operation. This can be exploited for denial of service attacks if the divisor comes from user input.",
      "metadata": {
        "cwe": [
          "CWE-369: Divide By Zero"
        ],
        "references": [
          "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_divide_by_zero.rb"
        ],
        "category": "security",
        "technology": [
          "ruby"
        ],
        "confidence": "MEDIUM",
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Denial-of-Service (DoS)"
        ],
        "short-description": "Potential division by zero exception",
        "fix-suggestion": "Add guards to check for zero values before performing division operations. Use conditional statements like `if divisor != 0` or `divisor.zero?` to handle zero cases gracefully. Consider providing default values or error messages instead of allowing exceptions to occur."
      },
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "$VAR"
            },
            {
              "metavariable-regex": {
                "metavariable": "$VAR",
                "regex": "^\\d*(?!\\.)$"
              }
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-inside": "$NUMER / 0"
            },
            {
              "pattern": "$NUMER"
            }
          ]
        }
      ]
    },
    {
      "id": "ruby.lang.security.file-disclosure.file-disclosure",
      "message": "This vulnerability happens when a Ruby application allows users to access files outside the application's root directory. Attackers can use path traversal techniques to access sensitive files on the server, such as configuration files containing credentials. This can lead to information disclosure, credential theft, or further system compromise.",
      "metadata": {
        "cwe": [
          "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
        ],
        "references": [
          "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_file_disclosure.rb",
          "https://groups.google.com/g/rubyonrails-security/c/23fiuwb1NBA/m/MQVM1-5GkPMJ"
        ],
        "category": "security",
        "technology": [
          "ruby"
        ],
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "short-description": "Serving files from outside root can leak sensitive data",
        "fix-suggestion": "Validate all file paths against a strict allowlist of permitted directories and files. Remove `..` sequences and normalize paths with `File.expand_path` to prevent directory traversal attacks. Consider implementing a file access abstraction layer that restricts operations to specific safe directories."
      },
      "languages": [
        "ruby"
      ],
      "severity": "ERROR",
      "pattern": "config.serve_static_assets = true",
      "fix-regex": {
        "regex": "=(\\s)*true",
        "replacement": "= false"
      }
    },
    {
      "id": "ruby.lang.security.force-ssl-false.force-ssl-false",
      "message": "Your application is configured with HTTPS enforcement disabled. Without HTTPS, sensitive information can be intercepted by attackers through network eavesdropping. This allows attackers to steal credentials, session tokens, and other sensitive data transmitted between your application and users.",
      "metadata": {
        "cwe": [
          "CWE-311: Missing Encryption of Sensitive Data"
        ],
        "references": [
          "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_force_ssl.rb"
        ],
        "category": "security",
        "technology": [
          "ruby"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A04:2021 - Insecure Design"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "HTTPS enforcement disabled in Rails configuration",
        "fix-suggestion": "Set `config.force_ssl = true` in your Rails application configuration to enforce HTTPS for all traffic. This ensures all communication between clients and your server is encrypted, preventing eavesdropping and man-in-the-middle attacks."
      },
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "pattern": "config.force_ssl = false",
      "fix-regex": {
        "regex": "=\\s*false",
        "replacement": "= true"
      }
    },
    {
      "id": "ruby.lang.security.hardcoded-http-auth-in-controller.hardcoded-http-auth-in-controller",
      "patterns": [
        {
          "pattern-inside": "class $CONTROLLER < ApplicationController\n  ...\n  http_basic_authenticate_with ..., :password => \"$SECRET\", ...\nend\n"
        },
        {
          "focus-metavariable": "$SECRET"
        }
      ],
      "message": "This vulnerability occurs when HTTP authentication credentials are hardcoded directly in a Ruby controller. These credentials can be discovered through code repository access, decompilation, or distribution in client-side code. This can lead to unauthorized access to protected resources using the hardcoded credentials.",
      "severity": "WARNING",
      "metadata": {
        "cwe": [
          "CWE-798: Use of Hard-coded Credentials"
        ],
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html"
        ],
        "source-rule-url": "https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/basic_auth/index.markdown",
        "category": "security",
        "technology": [
          "ruby",
          "secrets"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Hard-coded Secrets"
        ],
        "short-description": "Hardcoded HTTP credentials easily compromised in source",
        "fix-suggestion": "Move HTTP authentication credentials from controller code to environment variables using `ENV['USERNAME']` and `ENV['PASSWORD']`. Use a secure credential management system like Rails credentials or a third-party vault service. Implement proper authentication mechanisms rather than relying on HTTP Basic Authentication for sensitive areas."
      },
      "languages": [
        "ruby"
      ]
    },
    {
      "id": "ruby.lang.security.hardcoded-secret-rsa-passphrase.hardcoded-secret-rsa-passphrase",
      "message": "This vulnerability happens when RSA passphrases are hardcoded directly in the source code instead of being stored securely. These secrets can be discovered through code repository access, decompilation, or when distributed in client-side code. This can lead to unauthorized access to encrypted data or signing capabilities.",
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "metadata": {
        "technology": [
          "ruby",
          "secrets"
        ],
        "category": "security",
        "references": [
          "https://cwe.mitre.org/data/definitions/522.html"
        ],
        "cwe": [
          "CWE-798: Use of Hard-coded Credentials"
        ],
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Hard-coded Secrets"
        ],
        "short-description": "RSA passphrase stored in code is insecure",
        "fix-suggestion": "Replace hardcoded RSA passphrases with values loaded from environment variables using `ENV['RSA_PASSPHRASE']`. Use a secure secret management system like Rails credentials or a dedicated vault service. Implement secret rotation policies to regularly update sensitive cryptographic material."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "OpenSSL::PKey::RSA.new(..., '...')"
            },
            {
              "pattern": "OpenSSL::PKey::RSA.new(...).to_pem(..., '...')"
            },
            {
              "pattern": "OpenSSL::PKey::RSA.new(...).export(..., '...')"
            },
            {
              "patterns": [
                {
                  "pattern-inside": "$OPENSSL = OpenSSL::PKey::RSA.new(...)\n...\n"
                },
                {
                  "pattern-either": [
                    {
                      "pattern": "$OPENSSL.export(...,'...')\n"
                    },
                    {
                      "pattern": "$OPENSSL.to_pem(...,'...')\n"
                    }
                  ]
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "patterns": [
                        {
                          "pattern-inside": "$ASSIGN = '...'\n...\n"
                        },
                        {
                          "pattern": "OpenSSL::PKey::RSA.new(..., $ASSIGN)"
                        }
                      ]
                    },
                    {
                      "patterns": [
                        {
                          "pattern-inside": "def $METHOD1(...)\n...\n$ASSIGN = '...'\n...\nend\n...\ndef $METHOD2(...)\n...\nend\n"
                        },
                        {
                          "pattern": "OpenSSL::PKey::RSA.new(..., $ASSIGN)"
                        }
                      ]
                    },
                    {
                      "patterns": [
                        {
                          "pattern-inside": "$ASSIGN = '...'\n...\ndef $METHOD(...)\n  $OPENSSL = OpenSSL::PKey::RSA.new(...)\n...\nend\n...\n"
                        },
                        {
                          "pattern-either": [
                            {
                              "pattern": "$OPENSSL.export(...,$ASSIGN)"
                            },
                            {
                              "pattern": "$OPENSSL.to_pem(...,$ASSIGN)"
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "patterns": [
                        {
                          "pattern-inside": "def $METHOD1(...)\n...\n$OPENSSL = OpenSSL::PKey::RSA.new(...)\n...\n$ASSIGN = '...'\n...\nend\n...\n"
                        },
                        {
                          "pattern-either": [
                            {
                              "pattern": "$OPENSSL.export(...,$ASSIGN)"
                            },
                            {
                              "pattern": "$OPENSSL.to_pem(...,$ASSIGN)"
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "patterns": [
                        {
                          "pattern-inside": "def $METHOD1(...)\n...\n$ASSIGN = '...'\n...\nend\n...\ndef $METHOD2(...)\n...\n$OPENSSL = OpenSSL::PKey::RSA.new(...)\n...\nend\n...\n"
                        },
                        {
                          "pattern-either": [
                            {
                              "pattern": "$OPENSSL.export(...,$ASSIGN)"
                            },
                            {
                              "pattern": "$OPENSSL.to_pem(...,$ASSIGN)"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "ruby.lang.security.insufficient-rsa-key-size.insufficient-rsa-key-size",
      "message": "Your RSA key size is too small according to NIST security standards. Small key sizes are vulnerable to brute force attacks with modern computing power. Keys below 2048 bits are considered too weak for protecting sensitive information.",
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "metadata": {
        "technology": [
          "ruby"
        ],
        "category": "security",
        "references": [
          "https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57Pt3r1.pdf"
        ],
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "RSA key size below NIST recommended length",
        "fix-suggestion": "Increase your RSA key size to at least `2048` bits to meet NIST recommendations. Generate new keys with sufficient length using `OpenSSL::PKey::RSA.new(2048)` or higher values for more security-critical applications."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "OpenSSL::PKey::RSA.generate($SIZE,...)"
            },
            {
              "pattern": "OpenSSL::PKey::RSA.new($SIZE, ...)"
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "patterns": [
                        {
                          "pattern-inside": "$ASSIGN = $SIZE\n...\n"
                        },
                        {
                          "pattern-either": [
                            {
                              "pattern": "OpenSSL::PKey::RSA.new($ASSIGN, ...)"
                            },
                            {
                              "pattern": "OpenSSL::PKey::RSA.generate($ASSIGN, ...)"
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "patterns": [
                        {
                          "pattern-inside": "def $METHOD1(...)\n...\n$ASSIGN = $SIZE\n...\nend\n...\n"
                        },
                        {
                          "pattern-either": [
                            {
                              "pattern": "OpenSSL::PKey::RSA.new($ASSIGN, ...)"
                            },
                            {
                              "pattern": "OpenSSL::PKey::RSA.generate($ASSIGN, ...)"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "metavariable-comparison": {
            "metavariable": "$SIZE",
            "comparison": "$SIZE < 2048"
          }
        }
      ]
    },
    {
      "id": "ruby.lang.security.json-entity-escape.json-entity-escape",
      "pattern-either": [
        {
          "pattern": "ActiveSupport.escape_html_entities_in_json = false\n"
        },
        {
          "pattern": "config.active_support.escape_html_entities_in_json = false\n"
        }
      ],
      "message": "This vulnerability occurs when HTML escaping is disabled for JSON responses in Ruby applications. Without proper escaping, JSON containing user-controlled data can include HTML or JavaScript code. This can lead to cross-site scripting (XSS) vulnerabilities when the JSON is inserted into the DOM on the client side.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "source-rule-url": "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_json_entity_escape.rb",
        "category": "security",
        "technology": [
          "ruby"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Global HTML escaping for JSON is disabled, possible XSS",
        "fix-suggestion": "Use Rails' built-in JSON encoder or the `json` gem instead of custom JSON string building. Ensure HTML entities in JSON responses are properly escaped using `ERB::Util.html_escape` or `CGI.escapeHTML` if the JSON will be rendered in HTML. Set the proper `Content-Type: application/json` header to ensure browsers interpret the response correctly."
      },
      "languages": [
        "ruby"
      ],
      "severity": "WARNING"
    },
    {
      "id": "ruby.lang.security.mass-assignment-protection-disabled.mass-assignment-protection-disabled",
      "pattern": "$MODEL.new(params[...], ..., :without_protection => true, ...)",
      "message": "Mass assignment protection is disabled for your model, allowing attackers to modify sensitive fields not intended for user input. This vulnerability can lead to privilege escalation, data manipulation, or authentication bypasses. Without proper attribute protection, malicious users can overwrite any attribute by simply including it in a request.",
      "metadata": {
        "cwe": [
          "CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes"
        ],
        "owasp": [
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "source-rule-url": "https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/mass_assignment/index.markdown",
        "category": "security",
        "technology": [
          "ruby"
        ],
        "references": [
          "https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mass Assignment"
        ],
        "short-description": "Model allows unrestricted mass assignment of attributes",
        "fix-suggestion": "Remove `:without_protection => true` from your model instantiation and use `attr_accessible` to whitelist only the attributes that should be mass-assignable. Alternatively, enable system-wide protection with `config.active_record.whitelist_attributes = true` in your Rails configuration."
      },
      "severity": "WARNING",
      "languages": [
        "ruby"
      ]
    },
    {
      "id": "ruby.lang.security.md5-used-as-password.md5-used-as-password",
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "message": "MD5 is being used to hash passwords, which is highly insecure and easily cracked. Modern hardware can compute billions of MD5 hashes per second, making brute force attacks practical. Password hashing requires algorithms specifically designed to be computationally expensive and resistant to hardware acceleration.",
      "metadata": {
        "category": "security",
        "technology": [
          "md5"
        ],
        "references": [
          "https://tools.ietf.org/id/draft-lvelvindron-tls-md5-sha1-deprecate-01.html",
          "https://security.stackexchange.com/questions/211/how-to-securely-hash-passwords",
          "https://github.com/returntocorp/semgrep-rules/issues/1609"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-327: Use of a Broken or Risky Cryptographic Algorithm"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Weak MD5 algorithm used for password hashing",
        "fix-suggestion": "Replace MD5 with the `bcrypt` gem, which is designed specifically for password hashing and includes built-in salting. Add `gem 'bcrypt'` to your Gemfile and use `BCrypt::Password.create(password)` to create secure password hashes that automatically include salt and proper work factors."
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern": "Digest::MD5"
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$FUNCTION(...);"
            },
            {
              "metavariable-regex": {
                "metavariable": "$FUNCTION",
                "regex": "(?i)(.*password.*)"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "ruby.lang.security.missing-csrf-protection.missing-csrf-protection",
      "patterns": [
        {
          "pattern": "class $CONTROLLER < ActionController::Base\n  ...\nend\n"
        },
        {
          "pattern-not": "class $CONTROLLER < ActionController::Base\n  ...\n  protect_from_forgery :with => :exception\nend\n"
        },
        {
          "pattern-not": "class $CONTROLLER < ActionController::Base\n  ...\n  protect_from_forgery prepend: true, with: :exception\nend\n"
        }
      ],
      "message": "This vulnerability happens when a Ruby controller doesn't have Cross-Site Request Forgery (CSRF) protection enabled. Without CSRF protection, attackers can trick authenticated users into submitting malicious requests by creating forged forms or links. This can lead to unauthorized actions being performed on behalf of users, such as changing settings, making purchases, or deleting data.",
      "severity": "ERROR",
      "metadata": {
        "cwe": [
          "CWE-352: Cross-Site Request Forgery (CSRF)"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "source-rule-url": "https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/cross-site_request_forgery/index.markdown",
        "category": "security",
        "technology": [
          "ruby"
        ],
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site Request Forgery (CSRF)"
        ],
        "short-description": "Controller lacks CSRF defenses, allowing cross-site requests",
        "fix-suggestion": "Enable CSRF protection by adding `protect_from_forgery with: :exception` to your application controller. Include CSRF tokens in all forms using the `form_with` or `form_for` helpers with the `authenticity_token: true` option. Verify CSRF tokens on all non-GET requests to prevent cross-site request forgery attacks."
      },
      "languages": [
        "ruby"
      ]
    },
    {
      "id": "ruby.lang.security.model-attr-accessible.model-attr-accessible",
      "message": "Sensitive attributes like admin, role, or account_id are permitted for mass assignment in your model. This allows attackers to escalate privileges by modifying these fields through normal form submissions. Never allow security-critical attributes to be mass assigned from user input.",
      "metadata": {
        "cwe": [
          "CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes"
        ],
        "references": [
          "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_model_attr_accessible.rb"
        ],
        "category": "security",
        "technology": [
          "ruby"
        ],
        "owasp": [
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mass Assignment"
        ],
        "short-description": "Security-critical attributes exposed to mass assignment",
        "fix-suggestion": "Remove sensitive attributes (`admin`, `banned`, `role`, `account_id`) from your `attr_accessible` or `params.permit` declarations. Avoid using `params.permit!` which allows all parameters, and instead explicitly whitelist only the attributes that should be updatable by users."
      },
      "languages": [
        "ruby"
      ],
      "severity": "ERROR",
      "pattern-either": [
        {
          "pattern": "....permit(..., :admin, ...)\n"
        },
        {
          "pattern": "....permit(..., :role, ...)\n"
        },
        {
          "pattern": "....permit(..., :banned, ...)\n"
        },
        {
          "pattern": "....permit(..., :account_id, ...)\n"
        },
        {
          "pattern": "attr_accessible ..., :admin, ...\n"
        },
        {
          "pattern": "attr_accessible ..., :role, ...\n"
        },
        {
          "pattern": "attr_accessible ..., :banned, ...\n"
        },
        {
          "pattern": "attr_accessible ..., :account_id, ...\n"
        },
        {
          "pattern": "params.permit!\n"
        }
      ]
    },
    {
      "id": "ruby.lang.security.model-attributes-attr-accessible.model-attributes-attr-accessible",
      "patterns": [
        {
          "pattern-not": "class $CLASS < $TYPE\n...\nattr_accessible :$XXX\n...\nend\n...\n$CLASS.$FUNC(...)\n"
        },
        {
          "pattern": "class $CLASS < $TYPE\n...\nend\n...\n$CLASS.$FUNC(...)\n"
        },
        {
          "metavariable-pattern": {
            "metavariable": "$TYPE",
            "patterns": [
              {
                "pattern-not-regex": "(?i)(Error|Exception)"
              }
            ]
          }
        },
        {
          "focus-metavariable": "$CLASS"
        }
      ],
      "message": "Your model lacks mass assignment protection, allowing users to modify any attribute including sensitive ones. This can result in privilege escalation, data manipulation, or authentication bypasses. Without explicit allowlists, attackers can set any attribute by including it in request parameters.",
      "metadata": {
        "references": [
          "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_model_attributes.rb"
        ],
        "category": "security",
        "owasp": [
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "cwe": [
          "CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes"
        ],
        "technology": [
          "rails"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mass Assignment"
        ],
        "short-description": "Model missing mass assignment protection controls",
        "fix-suggestion": "For newer Rails applications, use strong parameters by implementing methods like `params.require(:model).permit(:attr1, :attr2)` in your controllers. For older Rails versions, add `attr_accessible :attr1, :attr2` to your model to explicitly define which attributes can be mass-assigned."
      },
      "languages": [
        "ruby"
      ],
      "severity": "ERROR"
    },
    {
      "id": "ruby.lang.security.ssl-mode-no-verify.ssl-mode-no-verify",
      "pattern": "OpenSSL::SSL::VERIFY_NONE",
      "message": "SSL certificate verification is disabled in your code, accepting any certificate without validation. This makes your application vulnerable to man-in-the-middle attacks where attackers can intercept and modify traffic. Without certificate verification, an attacker can impersonate legitimate servers and capture sensitive data.",
      "fix-regex": {
        "regex": "VERIFY_NONE",
        "replacement": "VERIFY_PEER"
      },
      "severity": "WARNING",
      "languages": [
        "ruby"
      ],
      "metadata": {
        "cwe": [
          "CWE-295: Improper Certificate Validation"
        ],
        "category": "security",
        "technology": [
          "ruby"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A07:2021 - Identification and Authentication Failures"
        ],
        "references": [
          "https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "SSL certificate verification disabled in connections",
        "fix-suggestion": "Enable proper SSL certificate verification by replacing the current mode with `OpenSSL::SSL::VERIFY_PEER`. Ensure your SSL context or client is configured to validate certificates against trusted certificate authorities and perform hostname verification."
      }
    },
    {
      "id": "ruby.lang.security.weak-hashes-md5.weak-hashes-md5",
      "message": "MD5 is being used for hashing, which is cryptographically broken and vulnerable to collision attacks. Attackers can generate different inputs that produce the same MD5 hash, compromising data integrity validation. MD5 should never be used for security-sensitive applications like digital signatures or integrity verification.",
      "metadata": {
        "cwe": [
          "CWE-328: Use of Weak Hash"
        ],
        "references": [
          "https://www.ibm.com/support/pages/security-bulletin-vulnerability-md5-signature-and-hash-algorithm-affects-sterling-integrator-and-sterling-file-gateway-cve-2015-7575"
        ],
        "category": "security",
        "technology": [
          "ruby"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Hashing Algorithm"
        ],
        "short-description": "Cryptographically broken MD5 hash function used",
        "fix-suggestion": "Replace MD5 with a secure hashing algorithm like `SHA-256` or `SHA-3`. Use `Digest::SHA256.hexdigest(data)` instead of MD5 for general hashing needs, or consider `HMAC` with SHA-256 when authentication is required."
      },
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "Digest::MD5.base64digest $X"
        },
        {
          "pattern": "Digest::MD5.hexdigest $X"
        },
        {
          "pattern": "Digest::MD5.digest $X"
        },
        {
          "pattern": "Digest::MD5.new"
        },
        {
          "pattern": "OpenSSL::Digest::MD5.base64digest $X"
        },
        {
          "pattern": "OpenSSL::Digest::MD5.hexdigest $X"
        },
        {
          "pattern": "OpenSSL::Digest::MD5.digest $X"
        },
        {
          "pattern": "OpenSSL::Digest::MD5.new"
        }
      ]
    },
    {
      "id": "ruby.lang.security.weak-hashes-sha1.weak-hashes-sha1",
      "message": "SHA-1 is being used for hashing, which has been proven vulnerable to collision attacks. Google has demonstrated practical SHA-1 collisions, making it unsuitable for security applications. Using SHA-1 for digital signatures, certificate validation, or content verification poses security risks.",
      "metadata": {
        "cwe": [
          "CWE-328: Use of Weak Hash"
        ],
        "references": [
          "https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html",
          "https://shattered.io/"
        ],
        "category": "security",
        "technology": [
          "ruby"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Hashing Algorithm"
        ],
        "short-description": "Deprecated SHA-1 hash algorithm with known collisions",
        "fix-suggestion": "Replace SHA-1 with a modern, secure hashing algorithm like `SHA-256` or `SHA-3`. Use `Digest::SHA256.hexdigest(data)` instead of SHA-1 for any security-related hashing operations to prevent collision attacks."
      },
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "Digest::SHA1.$FUNC"
        },
        {
          "pattern": "OpenSSL::Digest::SHA1.$FUNC"
        },
        {
          "pattern": "OpenSSL::HMAC.$FUNC(\"sha1\",...)"
        }
      ]
    },
    {
      "id": "ruby.lang.security.audit.sha224-hash.sha224-hash",
      "message": "SHA-224 hash function is being used, which is considered insufficient by many security standards and compliance frameworks. While not broken, SHA-224 has a smaller output size that provides less security margin against future attacks. Some regulatory frameworks explicitly require stronger hash functions.",
      "metadata": {
        "cwe": [
          "CWE-328: Use of Weak Hash"
        ],
        "references": [
          "https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar3.ipd.pdf",
          "https://www.cyber.gov.au/resources-business-and-government/essential-cyber-security/ism/cyber-security-guidelines/guidelines-cryptography"
        ],
        "category": "security",
        "technology": [
          "ruby"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insecure Hashing Algorithm"
        ],
        "short-description": "SHA-224 hash function below recommended strength",
        "fix-suggestion": "Replace SHA-224 with a stronger hash function like `SHA-384` or `SHA-512`. Use `Digest::SHA384.hexdigest(data)` or `Digest::SHA512.hexdigest(data)` instead to ensure both security and compliance with common security policies."
      },
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "Digest::SHA224.$FUNC"
        },
        {
          "pattern": "OpenSSL::Digest::SHA224.$FUNC"
        },
        {
          "pattern": "SHA3::Digest::SHA224(...)"
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "OpenSSL::HMAC.hexdigest(\"$ALGO\", ...)"
                },
                {
                  "pattern": "OpenSSL::HMAC.digest(\"$ALGO\", ...)"
                },
                {
                  "pattern": "OpenSSL::HMAC.new($KEY, \"$ALGO\")"
                },
                {
                  "pattern": "OpenSSL::Digest.digest(\"$ALGO\", ...)"
                },
                {
                  "pattern": "OpenSSL::Digest.new(\"$ALGO\", ...)"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$ALGO",
                "regex": ".*224"
              }
            }
          ]
        }
      ]
    },
    {
      "id": "ruby.lang.security.no-eval.ruby-eval",
      "message": "This vulnerability occurs when Ruby's eval function is used with user-controlled input. Eval executes the provided string as Ruby code, allowing attackers to inject and execute arbitrary code. This can lead to complete application compromise, data theft, or service disruption.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "source-rule-url": "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_evaluation.rb",
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "ruby",
          "rails"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "eval with user data can run arbitrary Ruby code",
        "fix-suggestion": "Remove all uses of `eval`, `instance_eval`, and `class_eval` with user-supplied input. Replace dynamic evaluation with safer alternatives like case statements, polymorphism, or strategy patterns. If dynamic evaluation is absolutely necessary, strictly validate input against an allowlist of permitted expressions."
      },
      "languages": [
        "ruby"
      ],
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern-either": [
            {
              "pattern": "params"
            },
            {
              "pattern": "cookies"
            },
            {
              "patterns": [
                {
                  "pattern": "RubyVM::InstructionSequence.compile(...)\n"
                },
                {
                  "pattern-not": "RubyVM::InstructionSequence.compile(\"...\")\n"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$X.eval"
                },
                {
                  "pattern": "$X.class_eval"
                },
                {
                  "pattern": "$X.instance_eval"
                },
                {
                  "pattern": "$X.module_eval"
                },
                {
                  "pattern": "$X.eval(...)"
                },
                {
                  "pattern": "$X.class_eval(...)"
                },
                {
                  "pattern": "$X.instance_eval(...)"
                },
                {
                  "pattern": "$X.module_eval(...)"
                },
                {
                  "pattern": "eval(...)"
                },
                {
                  "pattern": "class_eval(...)"
                },
                {
                  "pattern": "module_eval(...)"
                },
                {
                  "pattern": "instance_eval(...)"
                }
              ]
            },
            {
              "pattern-not": "$M(\"...\",...)"
            }
          ]
        }
      ]
    },
    {
      "id": "ruby.lang.security.no-send.bad-send",
      "message": "This vulnerability happens when methods like send or __send__ are used with user-controlled input in Ruby. These reflection methods can call any method in the application, allowing attackers to invoke sensitive or dangerous methods. This can lead to information disclosure, security bypass, or even remote code execution.",
      "metadata": {
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "references": [
          "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_send.rb",
          "https://the.igreque.info/posts/2016/01-object-send-considered-harmful-en.html"
        ],
        "category": "security",
        "technology": [
          "ruby"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "send or __send__ with user input can call dangerous methods",
        "fix-suggestion": "Avoid using `send`, `__send__`, or `public_send` with user-controlled method names. If dynamic method dispatch is necessary, validate method names against an explicit allowlist of safe methods. Consider using a case statement or polymorphism instead of dynamic method invocation."
      },
      "languages": [
        "ruby"
      ],
      "severity": "ERROR",
      "pattern-either": [
        {
          "pattern": "$PARAM = params[...]\n...\n$RES = $MOD.send($PARAM.$FUNC)\n"
        },
        {
          "pattern": "$PARAM = params[...]\n...\n$RES = $MOD.try($PARAM.$FUNC)\n"
        },
        {
          "pattern": "$PARAM = params[...]\n...\n$RES = $MOD.__send__($PARAM.$FUNC)\n"
        },
        {
          "pattern": "$PARAM = params[...]\n...\n$RES = $MOD.public_send($PARAM.$FUNC)"
        }
      ]
    },
    {
      "id": "ruby.lang.security.unprotected-mass-assign.mass-assignment-vuln",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$MOD.new(params[$CODE])\n"
            },
            {
              "pattern": "$MOD.new(..., params[$CODE], :without_protection => true, ...)\n"
            }
          ]
        },
        {
          "pattern-not-inside": "attr_accessible $VAR\n...\n$MOD.new(params[$CODE])\n"
        }
      ],
      "message": "Mass assignment protection is being explicitly bypassed with `:without_protection => true`. This dangerous practice allows attackers to set any attribute, including sensitive ones not intended for user modification. Without proper protection, attackers can escalate privileges, manipulate records, or bypass security controls.",
      "metadata": {
        "owasp": [
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "cwe": [
          "CWE-915: Improperly Controlled Modification of Dynamically-Determined Object Attributes"
        ],
        "references": [
          "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_without_protection.rb",
          "https://www.acunetix.com/vulnerabilities/web/rails-mass-assignment/"
        ],
        "category": "security",
        "technology": [
          "ruby"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mass Assignment"
        ],
        "short-description": "Explicit bypass of mass assignment protection",
        "fix-suggestion": "Remove `:without_protection => true` from all model instantiation and update calls. Instead, use strong parameters with `params.require(:model).permit(:attr1, :attr2)` in controllers or `attr_accessible` in models to explicitly whitelist attributes that should be mass-assignable."
      },
      "languages": [
        "ruby"
      ],
      "severity": "WARNING"
    },
    {
      "id": "ruby.rails.security.audit.avoid-session-manipulation.avoid-session-manipulation",
      "metadata": {
        "shortDescription": "Allowing an attacker to manipulate the session may lead to unintended behavior.",
        "tags": [
          "security"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-276: Incorrect Default Permissions"
        ],
        "references": [
          "https://brakemanscanner.org/docs/warning_types/session_manipulation/"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "help": "## Remediation\nSession manipulation can occur when an application allows user-input in session keys. Since sessions are typically considered a source of truth (e.g. to check the logged-in user or to match CSRF tokens), allowing an attacker to manipulate the session may lead to unintended behavior.\n\n## References\n[Session Manipulation](https://brakemanscanner.org/docs/warning_types/session_manipulation/)\n",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "User input altering session data can cause security holes",
        "fix-suggestion": "Don't allow user input to directly determine session keys or values without validation. Use strong parameters with `params.require().permit()` to filter session-related input. Implement server-side validation of all session data to ensure integrity and prevent tampering."
      },
      "message": "This vulnerability occurs when session keys or values are determined by user input in Rails applications. Attackers can manipulate the session data to potentially access other users' sessions or bypass authentication. This can lead to session hijacking, unauthorized access, or privilege escalation.",
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern": "params"
        },
        {
          "pattern": "cookies"
        },
        {
          "pattern": "request.env"
        }
      ],
      "pattern-sinks": [
        {
          "pattern": "session[...]"
        }
      ]
    },
    {
      "id": "ruby.rails.security.audit.avoid-tainted-file-access.avoid-tainted-file-access",
      "metadata": {
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
        ],
        "references": [
          "https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/file_access/index.markdown"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "short-description": "User-supplied paths for file access risk data exposure",
        "fix-suggestion": "Validate all file paths against a whitelist of permitted directories and normalize paths with `File.expand_path`. Remove directory traversal sequences like `../` from user input before using in file operations. Consider implementing a file access abstraction that restricts operations to specific safe directories."
      },
      "message": "This vulnerability happens when file paths in Rails applications are built using user input without proper validation. Attackers can use path traversal techniques (like '../') to access files outside the intended directory. This can lead to unauthorized access to sensitive files, information disclosure, or even code execution if writable paths are accessible.",
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern": "params"
        },
        {
          "pattern": "cookies"
        },
        {
          "pattern": "request.env"
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "Dir.$X(...)"
                },
                {
                  "pattern": "File.$X(...)"
                },
                {
                  "pattern": "IO.$X(...)"
                },
                {
                  "pattern": "Kernel.$X(...)"
                },
                {
                  "pattern": "PStore.$X(...)"
                },
                {
                  "pattern": "Pathname.$X(...)"
                }
              ]
            },
            {
              "metavariable-pattern": {
                "metavariable": "$X",
                "patterns": [
                  {
                    "pattern-either": [
                      {
                        "pattern": "chdir"
                      },
                      {
                        "pattern": "chroot"
                      },
                      {
                        "pattern": "delete"
                      },
                      {
                        "pattern": "entries"
                      },
                      {
                        "pattern": "foreach"
                      },
                      {
                        "pattern": "glob"
                      },
                      {
                        "pattern": "install"
                      },
                      {
                        "pattern": "lchmod"
                      },
                      {
                        "pattern": "lchown"
                      },
                      {
                        "pattern": "link"
                      },
                      {
                        "pattern": "load"
                      },
                      {
                        "pattern": "load_file"
                      },
                      {
                        "pattern": "makedirs"
                      },
                      {
                        "pattern": "move"
                      },
                      {
                        "pattern": "new"
                      },
                      {
                        "pattern": "open"
                      },
                      {
                        "pattern": "read"
                      },
                      {
                        "pattern": "readlines"
                      },
                      {
                        "pattern": "rename"
                      },
                      {
                        "pattern": "rmdir"
                      },
                      {
                        "pattern": "safe_unlink"
                      },
                      {
                        "pattern": "symlink"
                      },
                      {
                        "pattern": "syscopy"
                      },
                      {
                        "pattern": "sysopen"
                      },
                      {
                        "pattern": "truncate"
                      },
                      {
                        "pattern": "unlink"
                      }
                    ]
                  }
                ]
              }
            }
          ]
        }
      ]
    },
    {
      "id": "ruby.rails.security.audit.avoid-tainted-ftp-call.avoid-tainted-ftp-call",
      "metadata": {
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
        ],
        "references": [
          "https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/file_access/index.markdown"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "short-description": "FTP calls with untrusted input can lead to unauthorized actions",
        "fix-suggestion": "Validate FTP server addresses, paths, and credentials against an allowlist of permitted values. Never directly use user input in FTP commands without sanitization and validation. Consider implementing a secure file transfer abstraction that restricts operations to authorized servers and paths."
      },
      "message": "This vulnerability occurs when FTP operations in Rails applications use user input to determine server addresses, filenames, or paths. Attackers can manipulate these inputs to access unauthorized FTP servers or files. This can lead to information disclosure, data theft, or server-side request forgery.",
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern": "params"
        },
        {
          "pattern": "cookies"
        },
        {
          "pattern": "request.env"
        }
      ],
      "pattern-sinks": [
        {
          "pattern-either": [
            {
              "pattern": "Net::FTP.$X(...)"
            },
            {
              "patterns": [
                {
                  "pattern-inside": "$FTP = Net::FTP.$OPEN(...)\n...\n$FTP.$METHOD(...)\n"
                },
                {
                  "pattern": "$FTP.$METHOD(...)"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "ruby.rails.security.audit.avoid-tainted-http-request.avoid-tainted-http-request",
      "metadata": {
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "references": [
          "https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/file_access/index.markdown"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "impact": "MEDIUM",
        "likelihood": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "User input in HTTP request can fetch or manipulate external resources",
        "fix-suggestion": "Validate all user-supplied URLs against an allowlist of permitted domains and schemes before making HTTP requests. Use the `URI` class to parse and validate URL components before constructing requests. Implement network-level controls like egress filtering to prevent SSRF attacks to internal resources."
      },
      "message": "This vulnerability happens when HTTP requests in Rails applications are built using user input to determine URLs, headers, or request parameters. Attackers can manipulate these inputs to make the server connect to unauthorized internal or external resources. This can lead to server-side request forgery (SSRF), information disclosure, or bypassing access controls.",
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern": "params"
        },
        {
          "pattern": "cookies"
        },
        {
          "pattern": "request.env"
        }
      ],
      "pattern-sinks": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern": "Net::HTTP::$METHOD.new(...)"
                },
                {
                  "metavariable-pattern": {
                    "metavariable": "$METHOD",
                    "patterns": [
                      {
                        "pattern-either": [
                          {
                            "pattern": "Copy"
                          },
                          {
                            "pattern": "Delete"
                          },
                          {
                            "pattern": "Get"
                          },
                          {
                            "pattern": "Head"
                          },
                          {
                            "pattern": "Lock"
                          },
                          {
                            "pattern": "Mkcol"
                          },
                          {
                            "pattern": "Move"
                          },
                          {
                            "pattern": "Options"
                          },
                          {
                            "pattern": "Patch"
                          },
                          {
                            "pattern": "Post"
                          },
                          {
                            "pattern": "Propfind"
                          },
                          {
                            "pattern": "Proppatch"
                          },
                          {
                            "pattern": "Put"
                          },
                          {
                            "pattern": "Trace"
                          },
                          {
                            "pattern": "Unlock"
                          }
                        ]
                      }
                    ]
                  }
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern": "Net::HTTP.$X(...)"
                },
                {
                  "metavariable-pattern": {
                    "metavariable": "$X",
                    "patterns": [
                      {
                        "pattern-either": [
                          {
                            "pattern": "get"
                          },
                          {
                            "pattern": "get2"
                          },
                          {
                            "pattern": "head"
                          },
                          {
                            "pattern": "head2"
                          },
                          {
                            "pattern": "options"
                          },
                          {
                            "pattern": "patch"
                          },
                          {
                            "pattern": "post"
                          },
                          {
                            "pattern": "post2"
                          },
                          {
                            "pattern": "post_form"
                          },
                          {
                            "pattern": "put"
                          },
                          {
                            "pattern": "request"
                          },
                          {
                            "pattern": "request_get"
                          },
                          {
                            "pattern": "request_head"
                          },
                          {
                            "pattern": "request_post"
                          },
                          {
                            "pattern": "send_request"
                          },
                          {
                            "pattern": "trace"
                          },
                          {
                            "pattern": "get_print"
                          },
                          {
                            "pattern": "get_response"
                          },
                          {
                            "pattern": "start"
                          }
                        ]
                      }
                    ]
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "ruby.rails.security.audit.avoid-tainted-shell-call.avoid-tainted-shell-call",
      "metadata": {
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "references": [
          "https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/file_access/index.markdown"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Shell commands with user data can be injected",
        "fix-suggestion": "Replace shell commands that include user input with safer Ruby APIs that don't require shell execution. If shell commands are necessary, use the array form of `exec` or `system` and never interpolate user input into command strings. Validate all command arguments against an allowlist of permitted values before execution."
      },
      "message": "This vulnerability occurs when shell commands in Rails applications include user input without proper validation or sanitization. Attackers can inject shell metacharacters to execute additional commands beyond what was intended. This can lead to arbitrary command execution on the server with the application's privileges.",
      "languages": [
        "ruby"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern-either": [
            {
              "pattern": "params[...]"
            },
            {
              "pattern": "cookies"
            },
            {
              "pattern": "request.env"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern": "Kernel.$X(...)"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "Shell.$X(...)"
                        },
                        {
                          "patterns": [
                            {
                              "pattern-inside": "$SHELL = Shell.$ANY(...)\n...\n$SHELL.$X(...)\n"
                            },
                            {
                              "pattern": "$SHELL.$X(...)"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "metavariable-pattern": {
                "metavariable": "$X",
                "patterns": [
                  {
                    "pattern-either": [
                      {
                        "pattern": "cat"
                      },
                      {
                        "pattern": "chdir"
                      },
                      {
                        "pattern": "chroot"
                      },
                      {
                        "pattern": "delete"
                      },
                      {
                        "pattern": "entries"
                      },
                      {
                        "pattern": "exec"
                      },
                      {
                        "pattern": "foreach"
                      },
                      {
                        "pattern": "glob"
                      },
                      {
                        "pattern": "install"
                      },
                      {
                        "pattern": "lchmod"
                      },
                      {
                        "pattern": "lchown"
                      },
                      {
                        "pattern": "link"
                      },
                      {
                        "pattern": "load"
                      },
                      {
                        "pattern": "load_file"
                      },
                      {
                        "pattern": "makedirs"
                      },
                      {
                        "pattern": "move"
                      },
                      {
                        "pattern": "new"
                      },
                      {
                        "pattern": "open"
                      },
                      {
                        "pattern": "read"
                      },
                      {
                        "pattern": "readlines"
                      },
                      {
                        "pattern": "rename"
                      },
                      {
                        "pattern": "rmdir"
                      },
                      {
                        "pattern": "safe_unlink"
                      },
                      {
                        "pattern": "symlink"
                      },
                      {
                        "pattern": "syscopy"
                      },
                      {
                        "pattern": "sysopen"
                      },
                      {
                        "pattern": "system"
                      },
                      {
                        "pattern": "truncate"
                      },
                      {
                        "pattern": "unlink"
                      }
                    ]
                  }
                ]
              }
            }
          ]
        }
      ]
    },
    {
      "id": "ruby.rails.security.audit.detailed-exceptions.detailed-exceptions",
      "metadata": {
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor"
        ],
        "source-rule-url": "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_detailed_exceptions.rb",
        "category": "security",
        "technology": [
          "rails"
        ],
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Production environment leaking detailed error information",
        "fix-suggestion": "Disable detailed error reporting in production by setting `config.consider_all_requests_local = false` in your production environment configuration. Create custom error pages that don't reveal sensitive implementation details but provide appropriate user guidance."
      },
      "message": "Detailed exception reporting is enabled in your production environment. This exposes sensitive information like stack traces, file paths, database queries, and environment details to users. Attackers can use this information to understand your application structure and find potential vulnerabilities to exploit.",
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern": "config.consider_all_requests_local = true\n"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-inside": "class $CONTROLLER < ApplicationController\n  ...\nend\n"
                },
                {
                  "pattern": "def show_detailed_exceptions? (...)\n  ...\nreturn $RETURN\nend\n"
                },
                {
                  "metavariable-pattern": {
                    "metavariable": "$RETURN",
                    "patterns": [
                      {
                        "pattern-not": "false\n"
                      }
                    ]
                  }
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "ruby.rails.security.audit.rails-skip-forgery-protection.rails-skip-forgery-protection",
      "pattern": "skip_forgery_protection",
      "message": "This vulnerability happens when CSRF protection is explicitly disabled in Rails controllers using skip_forgery_protection. Without CSRF protection, attackers can trick authenticated users into submitting malicious requests through forged forms or links. This can lead to unauthorized actions being performed on behalf of the victim, such as changing account settings or transferring funds.",
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "metadata": {
        "cwe": [
          "CWE-352: Cross-Site Request Forgery (CSRF)"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "references": [
          "https://api.rubyonrails.org/classes/ActionController/RequestForgeryProtection/ClassMethods.html#method-i-skip_forgery_protection"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site Request Forgery (CSRF)"
        ],
        "short-description": "Skipping protect_from_forgery makes Rails app vulnerable to CSRF",
        "fix-suggestion": "Remove all `skip_forgery_protection` calls from controllers to ensure CSRF protection is consistently applied. If API endpoints need to bypass CSRF, use token-based authentication or implement specific exceptions in a secure manner. Consider implementing additional security headers like `Content-Security-Policy` to further protect against XSS and CSRF attacks."
      }
    },
    {
      "id": "ruby.rails.security.audit.sqli.ruby-pg-sqli.ruby-pg-sqli",
      "mode": "taint",
      "pattern-propagators": [
        {
          "pattern": "$X << $Y",
          "from": "$Y",
          "to": "$X"
        }
      ],
      "pattern-sources": [
        {
          "pattern-either": [
            {
              "pattern": "params\n"
            },
            {
              "pattern": "cookies\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$CON = PG.connect(...)\n...\n"
                },
                {
                  "pattern-inside": "$CON = PG::Connection.open(...)\n...\n"
                },
                {
                  "pattern-inside": "$CON = PG::Connection.new(...)\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$CON.$METHOD($X,...)\n"
                },
                {
                  "pattern": "$CON.$METHOD $X, ...\n"
                }
              ]
            },
            {
              "focus-metavariable": "$X"
            },
            {
              "metavariable-regex": {
                "metavariable": "$METHOD",
                "regex": "^(exec|exec_params)$"
              }
            }
          ]
        }
      ],
      "languages": [
        "ruby"
      ],
      "message": "This vulnerability occurs when PostgreSQL queries in Rails are built by concatenating user input rather than using parameterized queries. Attackers can inject SQL syntax that alters the query structure to perform unauthorized database operations. This can lead to data theft, unauthorized data modification, or authentication bypass.",
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://www.rubydoc.info/gems/pg/PG/Connection"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "ruby-pg queries with user input can cause injection",
        "fix-suggestion": "Replace string-concatenated SQL queries with parameterized queries using `PG::Connection#exec_params` or ActiveRecord's secure query methods. Never interpolate user input directly into SQL strings with `#{variable}` or string concatenation. Implement input validation to reject potentially malicious patterns before they reach database operations."
      },
      "severity": "WARNING"
    },
    {
      "id": "ruby.rails.security.audit.xss.avoid-content-tag.avoid-content-tag",
      "metadata": {
        "source-rule-url": "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_content_tag.rb",
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "references": [
          "https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/template_injection/index.markdown",
          "https://www.netsparker.com/blog/web-security/preventing-xss-ruby-on-rails-web-applications/"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "content_tag usage with user input may bypass escaping",
        "fix-suggestion": "When using `content_tag`, ensure all user-supplied attributes and content are properly sanitized or validated. Use Rails' built-in sanitization helpers like `sanitize` or `h` before passing user input to `content_tag`. Consider using the `tag` helper with explicit options instead of directly building HTML."
      },
      "message": "This vulnerability happens when the content_tag() helper in Rails is used with user-controlled content without proper escaping. This helper doesn't fully escape all content, allowing attackers to inject HTML or JavaScript code. This can lead to cross-site scripting (XSS) vulnerabilities that allow session hijacking or other client-side attacks.",
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "pattern": "content_tag(...)"
    },
    {
      "id": "ruby.rails.security.audit.xss.avoid-default-routes.avoid-default-routes",
      "metadata": {
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-276: Incorrect Default Permissions"
        ],
        "references": [
          "https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/default_routes/index.markdown"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Default routes expose unintended actions to potential XSS or attacks",
        "fix-suggestion": "Replace legacy wildcard routing (`map.connect ':controller/:action/:id'`) with explicitly defined routes for each controller action. Use the `resources` and `resource` routing helpers to create RESTful routes with proper constraints. Implement authorization checks in controllers to ensure users can only access permitted actions."
      },
      "message": "This vulnerability occurs when Rails applications use default routing (map.connect ':controller/:action/:id') that exposes all controller actions as public endpoints. Attackers can access internal or administrative functions that weren't meant to be publicly accessible. This can lead to information disclosure, unauthorized actions, or authentication bypass.",
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "map.connect \":controller/:action/:id\""
            },
            {
              "pattern": "match ':controller(/:action(/:id(.:format)))'"
            }
          ]
        }
      ],
      "paths": {
        "include": [
          "*routes.rb"
        ]
      }
    },
    {
      "id": "ruby.rails.security.audit.xss.avoid-html-safe.avoid-html-safe",
      "metadata": {
        "source-rule-url": "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_cross_site_scripting.rb",
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "references": [
          "https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/cross_site_scripting/index.markdown",
          "https://www.netsparker.com/blog/web-security/preventing-xss-ruby-on-rails-web-applications/"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "html_safe on untrusted data can lead to XSS",
        "fix-suggestion": "Remove calls to `html_safe` on user-supplied content to allow Rails' automatic HTML escaping to work. If HTML content must be included, use `sanitize` with appropriate options to remove dangerous tags and attributes. Consider using Rails' `content_tag` helpers to build HTML structures safely."
      },
      "message": "This vulnerability happens when html_safe() is used with user-controlled content in Rails applications. This method explicitly marks strings as HTML-safe, bypassing all automatic escaping protections. This can lead to cross-site scripting (XSS) vulnerabilities that allow attackers to execute arbitrary JavaScript in users' browsers.",
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "$STR.html_safe"
        },
        {
          "pattern": "$STR.html_safe.$MORE"
        }
      ]
    },
    {
      "id": "ruby.rails.security.audit.xss.avoid-link-to.avoid-link-to",
      "metadata": {
        "source-rule-url": "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_link_to.rb",
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "references": [
          "https://brakemanscanner.org/docs/warning_types/link_to/",
          "https://brakemanscanner.org/docs/warning_types/link_to_href/"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "link_to with untrusted data might allow javascript: injection",
        "fix-suggestion": "Validate user-provided URLs before passing them to `link_to` using URI/URL parsing libraries to ensure safe schemes. Explicitly specify permitted protocols using the `:allow_protocols` option (e.g., `link_to url, allow_protocols: ['http', 'https']`) and consider implementing a URL allowlist of trusted destinations."
      },
      "message": "This vulnerability occurs when the link_to helper in Rails is used with user-controlled URLs without validation. If attacker-controlled input begins with 'javascript:', it can execute arbitrary JavaScript when the link is clicked. This can lead to cross-site scripting (XSS) attacks that steal cookies, hijack sessions, or perform actions on behalf of victims.",
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern": "params"
        },
        {
          "pattern": "cookies"
        },
        {
          "pattern": "request.env"
        },
        {
          "pattern-either": [
            {
              "pattern": "$MODEL.url(...)"
            },
            {
              "pattern": "$MODEL.uri(...)"
            },
            {
              "pattern": "$MODEL.link(...)"
            },
            {
              "pattern": "$MODEL.page(...)"
            },
            {
              "pattern": "$MODEL.site(...)"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "pattern": "link_to(...)"
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern": "\"...#{...}...\"\n"
            },
            {
              "pattern-not": "\"#{...}...\"\n"
            }
          ]
        }
      ]
    },
    {
      "id": "ruby.rails.security.audit.xss.avoid-raw.avoid-raw",
      "metadata": {
        "source-rule-url": "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_cross_site_scripting.rb",
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "references": [
          "https://api.rubyonrails.org/classes/ActionView/Helpers/OutputSafetyHelper.html#method-i-raw",
          "https://www.netsparker.com/blog/web-security/preventing-xss-ruby-on-rails-web-applications/"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "raw renders HTML without escaping, enabling XSS",
        "fix-suggestion": "Avoid using `raw()` with any user-controlled content. Use Rails' built-in automatic HTML escaping with `<%= content %>` syntax and for displaying HTML content, use `sanitize()` instead of `raw()` to strip potentially malicious tags while preserving safe formatting."
      },
      "message": "This vulnerability happens when the raw() method in Rails is used with user-controlled content. This method outputs content without any HTML escaping, allowing attackers to inject malicious HTML or JavaScript. This can lead to cross-site scripting (XSS) vulnerabilities that allow session hijacking or other client-side attacks.",
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "pattern": "raw(...)"
    },
    {
      "id": "ruby.rails.security.audit.xss.avoid-redirect.avoid-redirect",
      "metadata": {
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')"
        ],
        "references": [
          "https://brakemanscanner.org/docs/warning_types/redirect/"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Open Redirect"
        ],
        "short-description": "Unvalidated user input in redirect target URLs",
        "fix-suggestion": "Always validate redirect URLs against a whitelist of allowed destinations or restrict redirects to relative paths. Use `redirect_to` with known routes rather than user-provided URLs, or implement a URL validation function that rejects external domains not in your approved list."
      },
      "message": "Redirects are being performed based on user-supplied URLs without proper validation. This enables open redirect vulnerabilities where attackers can redirect users to malicious sites that appear to come from your domain. These attacks can facilitate phishing or allow bypassing of access controls to reach restricted parts of your application.",
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern": "params"
        },
        {
          "pattern": "cookies"
        },
        {
          "pattern": "request.env"
        },
        {
          "patterns": [
            {
              "pattern": "$MODEL.$X(...)"
            },
            {
              "pattern-not": "$MODEL.$X(\"...\")"
            },
            {
              "metavariable-pattern": {
                "metavariable": "$X",
                "pattern-either": [
                  {
                    "pattern": "all"
                  },
                  {
                    "pattern": "create"
                  },
                  {
                    "pattern": "create!"
                  },
                  {
                    "pattern": "find"
                  },
                  {
                    "pattern": "find_by_sql"
                  },
                  {
                    "pattern": "first"
                  },
                  {
                    "pattern": "last"
                  },
                  {
                    "pattern": "new"
                  },
                  {
                    "pattern": "from"
                  },
                  {
                    "pattern": "group"
                  },
                  {
                    "pattern": "having"
                  },
                  {
                    "pattern": "joins"
                  },
                  {
                    "pattern": "lock"
                  },
                  {
                    "pattern": "order"
                  },
                  {
                    "pattern": "reorder"
                  },
                  {
                    "pattern": "select"
                  },
                  {
                    "pattern": "where"
                  },
                  {
                    "pattern": "find_by"
                  },
                  {
                    "pattern": "find_by!"
                  },
                  {
                    "pattern": "take"
                  }
                ]
              }
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "pattern": "redirect_to(...)"
        }
      ],
      "pattern-sanitizers": [
        {
          "pattern": "params.merge(:only_path => true)"
        },
        {
          "pattern": "params.merge(:host => ...)"
        }
      ]
    },
    {
      "id": "ruby.rails.security.audit.xss.avoid-render-dynamic-path.avoid-render-dynamic-path",
      "metadata": {
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
        ],
        "references": [
          "https://brakemanscanner.org/docs/warning_types/dynamic_render_paths/"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "short-description": "Dynamic template rendering can expose local file includes",
        "fix-suggestion": "Never allow direct user input to determine template paths in `render` calls. Implement a mapping system where user input selects from predefined keys that map to specific template paths, and use symbolic template references (`render :template_name`) instead of string paths when possible."
      },
      "message": "Allowing user input to determine which template to render creates a path traversal vulnerability that can expose sensitive files or templates. Attackers can manipulate the template path parameter to access unauthorized views or server files. Always validate template paths against a predefined allowlist of acceptable templates to prevent unauthorized access.",
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern": "params"
        },
        {
          "pattern": "cookies"
        },
        {
          "pattern": "request.env"
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-inside": "render($X => $INPUT, ...)"
            },
            {
              "pattern": "$INPUT"
            },
            {
              "metavariable-pattern": {
                "metavariable": "$X",
                "pattern-either": [
                  {
                    "pattern": "action"
                  },
                  {
                    "pattern": "template"
                  },
                  {
                    "pattern": "partial"
                  },
                  {
                    "pattern": "file"
                  }
                ]
              }
            }
          ]
        }
      ]
    },
    {
      "id": "ruby.rails.security.audit.xss.avoid-render-inline.avoid-render-inline",
      "metadata": {
        "source-rule-url": "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_render_inline.rb",
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "references": [
          "https://brakemanpro.com/2017/09/08/cross-site-scripting-in-rails#inline-renders---even-worse-than-xss"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Inline template rendering with user input leads to RCE or XSS",
        "fix-suggestion": "Completely avoid using `render inline` when handling any form of user input. Use predefined view templates stored in the `app/views` directory instead, and for dynamic content, use Rails' `content_for` or `yield` mechanisms within safe templates."
      },
      "message": "Using render inline with user-controlled data allows attackers to inject malicious ERB code that executes on the server. This server-side template injection vulnerability can lead to complete system compromise through arbitrary code execution. Avoid using inline templates with user input and instead use predefined view templates.",
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "pattern": "render inline: ..."
    },
    {
      "id": "ruby.rails.security.audit.xss.avoid-render-text.avoid-render-text",
      "metadata": {
        "source-rule-url": "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_render_inline.rb",
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "references": [
          "https://brakemanpro.com/2017/09/08/cross-site-scripting-in-rails#inline-renders---even-worse-than-xss"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "render text sends raw HTML, risking XSS",
        "fix-suggestion": "Replace all instances of `render text:` with `render plain:` which sets the `Content-Type` header to `text/plain`, preventing browsers from interpreting content as HTML. For HTML responses, use `render html:` with properly escaped content or use regular view templates with automatic escaping."
      },
      "message": "The render text method sets the content-type to text/html which browsers interpret and execute as HTML, including any embedded scripts. When user input is included in the response, attackers can inject malicious JavaScript that executes in users' browsers. Use render plain for plain text responses to ensure proper content-type headers are set.",
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "pattern": "render text: ...",
      "fix-regex": {
        "regex": "text:",
        "replacement": "plain:"
      }
    },
    {
      "id": "ruby.rails.security.audit.xss.manual-template-creation.manual-template-creation",
      "metadata": {
        "source-rule-url": "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_template_injection.rb",
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "references": [
          "https://github.com/presidentbeef/brakeman/blob/main/docs/warning_types/template_injection/index.markdown"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Manually creating ERB templates from user data can cause injection",
        "fix-suggestion": "Never create ERB templates from strings containing user input. Use predefined template files stored in the `app/views` directory and pass data to templates as instance variables rather than embedding user data in the template itself."
      },
      "message": "Creating ERB templates directly from user input enables attackers to inject template code that executes in the server context. This server-side template injection vulnerability can lead to remote code execution with the privileges of the application server. Use predefined template files instead of dynamically creating templates from untrusted input.",
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "pattern": "ERB.new(...)"
    },
    {
      "id": "ruby.rails.security.audit.xss.templates.alias-for-html-safe.alias-for-html-safe",
      "message": "The <%== %> syntax in ERB templates is an alias for html_safe which bypasses all HTML escaping mechanisms. This allows any embedded user input to be rendered directly as HTML/JavaScript, enabling cross-site scripting attacks. Only use this syntax with content you fully control and have sanitized appropriately.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "references": [
          "https://medium.com/sumone-technical-blog/a-pretty-way-to-unescape-html-in-a-ruby-on-rails-application-efc22b850027",
          "https://stackoverflow.com/questions/4251284/raw-vs-html-safe-vs-h-to-unescape-html#:~:text==="
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "<%== usage is same as html_safe, enabling XSS",
        "fix-suggestion": "Replace all instances of `<%== user_input %>` with the standard `<%= user_input %>` syntax, which applies automatic HTML escaping. Never use `<%== %>` or `raw()` with user-controlled data, and if HTML formatting is required, use `sanitize()` instead."
      },
      "languages": [
        "generic"
      ],
      "paths": {
        "include": [
          "*.erb"
        ]
      },
      "severity": "WARNING",
      "patterns": [
        {
          "pattern": "<%== ... %>"
        },
        {
          "pattern-not": "<%== $...A.to_json %>"
        }
      ]
    },
    {
      "id": "ruby.rails.security.audit.xss.templates.avoid-content-tag.avoid-content-tag",
      "message": "The content_tag helper creates HTML elements without fully escaping all parts of its output, particularly attributes. If user input is included in these attributes, attackers can break out of the attribute context and inject malicious scripts. Always sanitize user input before passing it to content_tag, especially for attribute values.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "source-rule-url": "https://brakemanscanner.org/docs/warning_types/content_tag/",
        "references": [
          "https://brakemanscanner.org/docs/warning_types/content_tag/"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "content_tag with unescaped user data leads to XSS",
        "fix-suggestion": "Apply `html_escape()` or `h()` to user-controlled data before passing it to `content_tag` attributes. Use Rails' tag builder methods which automatically escape attribute values, and for URLs in HTML attributes, validate them to ensure only safe protocols like `https://`."
      },
      "languages": [
        "generic"
      ],
      "paths": {
        "include": [
          "*.erb"
        ]
      },
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "<%= ... %>"
        },
        {
          "pattern": "content_tag"
        }
      ]
    },
    {
      "id": "ruby.rails.security.audit.xss.templates.avoid-html-safe.avoid-html-safe",
      "message": "Marking strings as html_safe tells Rails to skip all HTML escaping, allowing any embedded HTML or JavaScript to execute in the browser. If these strings contain user input, attackers can inject malicious scripts that execute in users' browsers. Never use html_safe with user-controlled data or thoroughly sanitize such content first.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "source-rule-url": "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_cross_site_scripting.rb",
        "references": [
          "https://stackoverflow.com/questions/4251284/raw-vs-html-safe-vs-h-to-unescape-html#:~:text===",
          "https://medium.com/sumone-technical-blog/a-pretty-way-to-unescape-html-in-a-ruby-on-rails-application-efc22b850027"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "html_safe usage on user input can cause script injection",
        "fix-suggestion": "Never mark user-controlled strings as `html_safe`. Use the standard `<%= %>` ERB syntax which automatically applies HTML escaping, and if HTML formatting is required, use `sanitize()` with a restrictive tag and attribute allowlist instead of `html_safe`."
      },
      "languages": [
        "generic"
      ],
      "paths": {
        "include": [
          "*.erb"
        ]
      },
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "<%= ... %>"
        },
        {
          "pattern": "$SOMETHING.html_safe"
        }
      ]
    },
    {
      "id": "ruby.rails.security.audit.xss.templates.avoid-raw.avoid-raw",
      "message": "The raw() helper method disables all HTML escaping, rendering content exactly as provided without any sanitization. When user input is included, malicious scripts can be injected and executed in users' browsers. Only use raw() with content you fully control and have verified doesn't contain dangerous content.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "source-rule-url": "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_cross_site_scripting.rb",
        "references": [
          "https://stackoverflow.com/questions/4251284/raw-vs-html-safe-vs-h-to-unescape-html#:~:text===",
          "https://medium.com/sumone-technical-blog/a-pretty-way-to-unescape-html-in-a-ruby-on-rails-application-efc22b850027"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "raw method with user data creates XSS vulnerabilities",
        "fix-suggestion": "Remove uses of the `raw` helper on user-controlled content to enable Rails' automatic HTML escaping. If HTML rendering is necessary, use `sanitize` with appropriate options to remove dangerous elements. Consider using Rails' built-in helpers like `content_tag` for building complex HTML structures safely."
      },
      "languages": [
        "generic"
      ],
      "paths": {
        "include": [
          "*.erb"
        ]
      },
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "<%= ... %>"
        },
        {
          "pattern": "raw"
        }
      ]
    },
    {
      "id": "ruby.rails.security.audit.xss.templates.unquoted-attribute.unquoted-attribute",
      "message": "Unquoted attribute values in HTML allow attribute boundaries to be broken if whitespace or special characters are introduced. Attackers can inject additional attributes or break out of the element entirely to introduce malicious JavaScript. Always quote HTML attribute values when inserting dynamic content to maintain proper context separation.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://brakemanpro.com/2017/09/08/cross-site-scripting-in-rails#unquoted-attributes",
          "https://flask.palletsprojects.com/en/1.1.x/security/#cross-site-scripting-xss"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Unquoted HTML attribute with dynamic input leads to XSS",
        "fix-suggestion": "Always quote HTML attribute values using double quotes and ensure dynamic values are properly escaped. Use Rails helpers like `tag` and `content_tag` which automatically handle attribute escaping. Implement client-side frameworks that properly encode dynamic content (like React) for complex dynamic interfaces."
      },
      "languages": [
        "generic"
      ],
      "paths": {
        "include": [
          "*.erb"
        ]
      },
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "<$TAG ...>"
        },
        {
          "pattern-not-inside": "=\"...\""
        },
        {
          "pattern-not-inside": "=\"<%= ... %>\""
        },
        {
          "pattern-not-inside": "='...'"
        },
        {
          "pattern-not-inside": "='<%= ... %>'"
        },
        {
          "pattern": "<%= ... %>"
        }
      ],
      "fix-regex": {
        "regex": "<%=(.*?)%>",
        "replacement": "\"<%=\\1%>\""
      }
    },
    {
      "id": "ruby.rails.security.audit.xss.templates.var-in-href.var-in-href",
      "message": "Using template variables in href attributes without validation allows attackers to inject javascript: URLs that execute arbitrary code. When a user clicks such a link, the embedded JavaScript executes with full access to the page's content and origin. Validate URLs to ensure they use only safe protocols like http: or https: before placing them in href attributes.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://flask.palletsprojects.com/en/1.1.x/security/#cross-site-scripting-xss#:~:text=javascript:%20URI",
          "https://github.com/pugjs/pug/issues/2952"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Variable in href attribute can allow javascript injection",
        "fix-suggestion": "Validate URLs in `href` attributes using `URI.parse` and ensure they only use safe protocols like `http:` and `https:`. Add a protocol allowlist check that rejects `javascript:` and other dangerous URL schemes. Consider using Rails' `link_to` helper which automatically performs some URL safety checks."
      },
      "languages": [
        "generic"
      ],
      "paths": {
        "include": [
          "*.erb"
        ]
      },
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "<a ... href = \"<%= ... %>\" ... >"
        },
        {
          "pattern": "<a ... href = '<%= ... %>' ... >"
        }
      ]
    },
    {
      "id": "ruby.rails.security.audit.xss.templates.var-in-script-tag.var-in-script-tag",
      "message": "Placing template variables inside script tags allows attackers to escape the JavaScript string context and inject malicious code. The standard HTML escaping that Rails applies is insufficient for JavaScript contexts and doesn't prevent script injection. Use escape_javascript (or j) to properly escape content within script tags or move dynamic data outside scripts using data attributes.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "references": [
          "https://www.netsparker.com/blog/web-security/preventing-xss-ruby-on-rails-web-applications/",
          "https://www.youtube.com/watch?v=yYTkLUEdIyE",
          "https://www.veracode.com/blog/secure-development/nodejs-template-engines-why-default-encoders-are-not-enough"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Variable directly in script tag can produce XSS",
        "fix-suggestion": "Move dynamic data outside of `<script>` tags and use DOM APIs to access it via data attributes or JSON elements. If script embedding is necessary, serialize data with `json_escape(data.to_json)` to properly escape all special characters. Consider using a client-side framework with proper data binding instead of generating JavaScript dynamically."
      },
      "languages": [
        "generic"
      ],
      "paths": {
        "include": [
          "*.erb"
        ]
      },
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-inside": "<script ...> ... </script>"
        },
        {
          "pattern-not": "<%= j ... >"
        },
        {
          "pattern-not": "<%= escape_javascript ... >"
        },
        {
          "pattern": "<%= ... >"
        }
      ]
    },
    {
      "id": "ruby.rails.security.brakeman.check-redirect-to.check-redirect-to",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "cookies"
                },
                {
                  "pattern": "request.env"
                },
                {
                  "pattern": "url_for(params[...],...,:only_path => false,...)"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern": "$F(...)\n"
                    },
                    {
                      "metavariable-pattern": {
                        "metavariable": "$F",
                        "patterns": [
                          {
                            "pattern-not-regex": "(params|url_for|cookies|request.env|permit|redirect_to)"
                          }
                        ]
                      }
                    }
                  ]
                },
                {
                  "pattern": "params.merge! :only_path => true\n...\n"
                },
                {
                  "pattern": "params.slice(...)\n...\n"
                },
                {
                  "pattern": "redirect_to [...]\n"
                },
                {
                  "patterns": [
                    {
                      "pattern": "$MODEL. ... .$M(...)\n...\n"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$MODEL",
                        "regex": "[A-Z]\\w+"
                      }
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$M",
                        "regex": "(all|create|find|find_by|find_by_sql|first|last|new|from|group|having|joins|lock|order|reorder|select|where|take)"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "params.$UNSAFE_HASH.merge(...,:only_path => true,...)\n...\n"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$UNSAFE_HASH",
                        "regex": "to_unsafe_h(ash)?"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "params.permit(...,$X,...)"
                    },
                    {
                      "metavariable-pattern": {
                        "metavariable": "$X",
                        "patterns": [
                          {
                            "pattern-not-regex": "(host|port|(sub)?domain)"
                          }
                        ]
                      }
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$X"
            },
            {
              "pattern-inside": "redirect_to $X, ...\n"
            },
            {
              "pattern-not-regex": "params\\.\\w+(?<!permit)\\(.*?\\)"
            }
          ]
        }
      ],
      "message": "User input is being directly passed to `redirect_to` without proper restrictions. This allows attackers to create open redirect vulnerabilities where users can be sent to malicious websites that appear trustworthy. Without the `:only_path` option, attackers can redirect to any external domain.",
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "metadata": {
        "source-rule-url": "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_redirect.rb",
        "category": "security",
        "cwe": [
          "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')"
        ],
        "technology": [
          "ruby",
          "rails"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Open Redirect"
        ],
        "short-description": "Open redirect vulnerability in redirect_to call",
        "fix-suggestion": "Add the `:only_path => true` option to your `redirect_to` calls when using user-controlled input to restrict redirects to your application's domain. Alternatively, validate user input against a whitelist of allowed destinations before using it in redirects."
      }
    },
    {
      "id": "ruby.rails.security.brakeman.check-regex-dos.check-regex-dos",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "cookies[...]\n"
                },
                {
                  "patterns": [
                    {
                      "pattern": "cookies. ... .$PROPERTY[...]\n"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$PROPERTY",
                        "regex": "(?!signed|encrypted)"
                      }
                    }
                  ]
                },
                {
                  "pattern": "params[...]\n"
                },
                {
                  "pattern": "request.env[...]\n"
                },
                {
                  "patterns": [
                    {
                      "pattern": "$Y"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "$RECORD.read_attribute($Y)\n"
                        },
                        {
                          "pattern-inside": "$RECORD[$Y]\n"
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$RECORD",
                        "regex": "[A-Z][a-z]+"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern": "$Y"
                    },
                    {
                      "pattern-inside": "/...#{...}.../\n"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "$Y"
                    },
                    {
                      "pattern-inside": "Regexp.new(...)\n"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "message": "User input is being incorporated into regular expressions, creating a potential denial-of-service vulnerability. Certain regex patterns can cause catastrophic backtracking, where processing a single request consumes excessive CPU time. Attackers can exploit this to severely degrade application performance with minimal effort.",
      "languages": [
        "ruby"
      ],
      "severity": "ERROR",
      "metadata": {
        "source-rule-url": "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_regex_dos.rb",
        "category": "security",
        "cwe": [
          "CWE-1333: Inefficient Regular Expression Complexity"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "technology": [
          "ruby",
          "rails"
        ],
        "references": [
          "https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Denial-of-Service (DoS)"
        ],
        "short-description": "User-controlled regex causing potential DoS vulnerability",
        "fix-suggestion": "Avoid incorporating user input directly into regular expressions. If user-defined patterns are necessary, implement time limits on regex execution, restrict input length, and use an allowlist of safe patterns or characters that cannot cause catastrophic backtracking."
      }
    },
    {
      "id": "ruby.rails.security.brakeman.check-render-local-file-include.check-render-local-file-include",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern": "params[...]"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "render ..., file: $X\n"
                },
                {
                  "pattern": "render ..., inline: $X\n"
                },
                {
                  "pattern": "render ..., template: $X\n"
                },
                {
                  "pattern": "render ..., action: $X\n"
                },
                {
                  "pattern": "render $X, ...\n"
                }
              ]
            },
            {
              "focus-metavariable": "$X"
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern": "$MAP[...]"
            },
            {
              "metavariable-pattern": {
                "metavariable": "$MAP",
                "patterns": [
                  {
                    "pattern-not-regex": "params"
                  }
                ]
              }
            }
          ]
        },
        {
          "pattern": "File.basename(...)"
        }
      ],
      "message": "Using user input to determine file paths in render calls enables path traversal attacks that can expose sensitive files. Attackers can use sequences like ../ to break out of the intended directory and access configuration files, credentials, or system files. Validate file paths against an allowlist or sanitize paths using methods like File.basename to prevent directory traversal.",
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "metadata": {
        "technology": [
          "ruby",
          "rails"
        ],
        "category": "security",
        "cwe": [
          "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
        ],
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "source-rule-url": "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_render.rb",
        "references": [
          "https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/07-Input_Validation_Testing/11.1-Testing_for_Local_File_Inclusion",
          "https://github.com/presidentbeef/brakeman/blob/f74cb53/test/apps/rails2/app/controllers/home_controller.rb#L48-L60"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "short-description": "render with user input may read arbitrary local files",
        "fix-suggestion": "Validate file paths against a whitelist of permitted templates or use `File.basename` to strip directory components. Replace dynamic `render file:` calls with explicit template rendering using `render template:`. Consider implementing a template registry that maps identifiers to actual templates rather than using file paths directly."
      }
    },
    {
      "id": "ruby.rails.security.brakeman.check-send-file.check-send-file",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern-either": [
            {
              "pattern": "cookies[...]\n"
            },
            {
              "patterns": [
                {
                  "pattern": "cookies. ... .$PROPERTY[...]\n"
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$PROPERTY",
                    "regex": "(?!signed|encrypted)"
                  }
                }
              ]
            },
            {
              "pattern": "params[...]\n"
            },
            {
              "pattern": "request.env[...]\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "send_file ...\n"
            }
          ]
        }
      ],
      "message": "User-controlled input is passed directly to `send_file`, creating a path traversal vulnerability. Attackers can craft inputs containing '../' sequences to access files outside the intended directory, potentially exposing sensitive system files. This could lead to unauthorized access to configuration files, credentials, or other restricted content.",
      "languages": [
        "ruby"
      ],
      "severity": "ERROR",
      "metadata": {
        "source-rule-url": "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_send_file.rb",
        "category": "security",
        "cwe": [
          "CWE-73: External Control of File Name or Path"
        ],
        "owasp": [
          "A04:2021 - Insecure Design"
        ],
        "technology": [
          "ruby",
          "rails"
        ],
        "references": [
          "https://owasp.org/www-community/attacks/Path_Traversal",
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control/"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "short-description": "Path traversal vulnerability in send_file usage",
        "fix-suggestion": "Never pass user input directly to `send_file`. Extract just the filename using `File.basename(user_input)` to prevent directory traversal, and validate that the resulting file is within an authorized directory before serving it."
      }
    },
    {
      "id": "ruby.rails.security.brakeman.check-sql.check-sql",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern-either": [
            {
              "pattern": "cookies[...]\n"
            },
            {
              "patterns": [
                {
                  "pattern": "cookies. ... .$PROPERTY[...]\n"
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$PROPERTY",
                    "regex": "(?!signed|encrypted)"
                  }
                }
              ]
            },
            {
              "pattern": "params[...]\n"
            },
            {
              "pattern": "request.env[...]\n"
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern": "$X"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": ":$KEY => $X\n"
                        },
                        {
                          "pattern-inside": "[\"...\",$X,...]\n"
                        }
                      ]
                    }
                  ]
                },
                {
                  "pattern": "params[...].to_i\n"
                },
                {
                  "pattern": "params[...].to_f\n"
                },
                {
                  "patterns": [
                    {
                      "pattern": "params[...] ? $A : $B\n"
                    },
                    {
                      "metavariable-pattern": {
                        "metavariable": "$A",
                        "patterns": [
                          {
                            "pattern-not": "params[...]\n"
                          }
                        ]
                      }
                    },
                    {
                      "metavariable-pattern": {
                        "metavariable": "$B",
                        "patterns": [
                          {
                            "pattern-not": "params[...]\n"
                          }
                        ]
                      }
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$X"
            },
            {
              "pattern-not-inside": "$P.where(\"...\",...)\n"
            },
            {
              "pattern-not-inside": "$P.where(:$KEY => $VAL,...)\n"
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "$P.$M(...)\n"
                },
                {
                  "pattern-inside": "$P.$M(\"...\",...)\n"
                }
              ]
            },
            {
              "pattern-inside": "class $P < ActiveRecord::Base\n  ...\nend\n"
            },
            {
              "metavariable-regex": {
                "metavariable": "$M",
                "regex": "(where|find|first|last|select|minimum|maximum|calculate|sum|average)"
              }
            }
          ]
        }
      ],
      "message": "Building SQL queries by directly concatenating or interpolating user input allows attackers to modify query logic and structure. These SQL injection vulnerabilities can lead to unauthorized data access, data modification, or even server compromise. Use parameterized queries with placeholders or Active Record methods that automatically sanitize inputs.",
      "languages": [
        "ruby"
      ],
      "severity": "ERROR",
      "metadata": {
        "source-rule-url": "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_sql.rb",
        "category": "security",
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "technology": [
          "ruby",
          "rails"
        ],
        "references": [
          "https://owasp.org/www-community/attacks/SQL_Injection",
          "https://github.com/presidentbeef/brakeman/blob/main/test/apps/rails3.1/app/models/product.rb"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Raw SQL calls in Rails can be injected by user data",
        "fix-suggestion": "Replace string-interpolated SQL with parameterized queries using `?` placeholders or named parameters. Use ActiveRecord query methods like `where(column: value)` instead of raw SQL strings. Implement input validation before database operations to reject potentially malicious patterns."
      }
    },
    {
      "id": "ruby.rails.security.brakeman.check-unsafe-reflection-methods.check-unsafe-reflection-methods",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern-either": [
            {
              "pattern": "cookies[...]\n"
            },
            {
              "patterns": [
                {
                  "pattern": "cookies. ... .$PROPERTY[...]\n"
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$PROPERTY",
                    "regex": "(?!signed|encrypted)"
                  }
                }
              ]
            },
            {
              "pattern": "params[...]\n"
            },
            {
              "pattern": "request.env[...]\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$X"
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "$X. ... .to_proc\n"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$Y.method($Z)\n"
                    },
                    {
                      "focus-metavariable": "$Z"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$Y.tap($Z)\n"
                    },
                    {
                      "focus-metavariable": "$Z"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$Y.tap{ |$ANY| $Z }\n"
                    },
                    {
                      "focus-metavariable": "$Z"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "message": "Using reflection methods (like constantize, send, or eval) with user input allows attackers to execute arbitrary code by specifying unexpected class or method names. This can lead to complete application compromise by running code in the server context. Validate user inputs against an allowlist of permitted values before using them with reflection methods.",
      "languages": [
        "ruby"
      ],
      "severity": "ERROR",
      "metadata": {
        "source-rule-url": "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_unsafe_reflection_methods.rb",
        "category": "security",
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "technology": [
          "ruby",
          "rails"
        ],
        "references": [
          "https://github.com/presidentbeef/brakeman/blob/main/test/apps/rails6/app/controllers/groups_controller.rb"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Reflection methods with untrusted data can call dangerous code",
        "fix-suggestion": "Replace dynamic constant resolution via `constantize` or `const_get` with an explicit mapping of safe values to constants. Avoid using `send` with user-controlled method names; validate against an allowlist of permitted methods. Consider using polymorphism or strategy patterns instead of reflection for dynamic behavior."
      }
    },
    {
      "id": "ruby.rails.security.brakeman.check-unsafe-reflection.check-unsafe-reflection",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern-either": [
            {
              "pattern": "cookies[...]\n"
            },
            {
              "patterns": [
                {
                  "pattern": "cookies. ... .$PROPERTY[...]\n"
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$PROPERTY",
                    "regex": "(?!signed|encrypted)"
                  }
                }
              ]
            },
            {
              "pattern": "params[...]\n"
            },
            {
              "pattern": "request.env[...]\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern": "$X"
            },
            {
              "pattern-either": [
                {
                  "pattern-inside": "$X.constantize\n"
                },
                {
                  "pattern-inside": "$X. ... .safe_constantize\n"
                },
                {
                  "pattern-inside": "const_get(...)\n"
                },
                {
                  "pattern-inside": "qualified_const_get(...)\n"
                }
              ]
            }
          ]
        }
      ],
      "message": "Reflection features in Ruby allow converting strings to code constructs like classes, methods, or symbols based on their names. When user input determines these names, attackers can cause the application to load and execute unintended code. Never use user input directly with reflection features like const_get, constantize, or to_sym unless strictly validated against a limited allowlist.",
      "languages": [
        "ruby"
      ],
      "severity": "ERROR",
      "metadata": {
        "source-rule-url": "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_unsafe_reflection.rb",
        "category": "security",
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "technology": [
          "ruby",
          "rails"
        ],
        "references": [
          "https://github.com/presidentbeef/brakeman/blob/main/test/apps/rails2/app/controllers/application_controller.rb"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "Unsanitized reflection can lead to arbitrary method calls",
        "fix-suggestion": "Replace reflection methods like `constantize`, `const_get`, and `send` that use user input with explicit mappings to permitted values. Implement strict validation against an allowlist of permitted class or method names before using reflection. Consider design patterns like Factory, Strategy, or Command that provide dynamic behavior without unsafe reflection."
      }
    },
    {
      "id": "ruby.rails.security.brakeman.check-unscoped-find.check-unscoped-find",
      "mode": "taint",
      "pattern-sources": [
        {
          "pattern-either": [
            {
              "pattern": "cookies[...]\n"
            },
            {
              "patterns": [
                {
                  "pattern": "cookies. ... .$PROPERTY[...]\n"
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$PROPERTY",
                    "regex": "(?!signed|encrypted)"
                  }
                }
              ]
            },
            {
              "pattern": "params[...]\n"
            },
            {
              "pattern": "request.env[...]\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$MODEL.find(...)"
                },
                {
                  "pattern": "$MODEL.find_by_id(...)"
                },
                {
                  "pattern": "$MODEL.find_by_id!(...)"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$MODEL",
                "regex": "[A-Z]\\S+"
              }
            }
          ]
        }
      ],
      "message": "Unscoped database queries with user-controlled IDs create Insecure Direct Object Reference (IDOR) vulnerabilities. This allows attackers to access records belonging to other users by simply changing ID parameters. Without proper authorization checks, sensitive data can be exposed or manipulated across user boundaries.",
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "metadata": {
        "source-rule-url": "https://github.com/presidentbeef/brakeman/blob/main/lib/brakeman/checks/check_unscoped_find.rb",
        "category": "security",
        "cwe": [
          "CWE-639: Authorization Bypass Through User-Controlled Key"
        ],
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "technology": [
          "ruby",
          "rails"
        ],
        "references": [
          "https://brakemanscanner.org/docs/warning_types/unscoped_find/",
          "https://github.com/presidentbeef/brakeman/blob/main/test/apps/rails3.1/app/controllers/users_controller.rb"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "IDOR vulnerability from unscoped database queries",
        "fix-suggestion": "Scope all database queries to the current user's accessible resources using relationships, like `current_user.accounts.find(params[:id])` instead of `Account.find(params[:id])`. This ensures users can only access their own data even if they manipulate ID parameters."
      }
    },
    {
      "id": "ruby.rails.security.injection.raw-html-format.raw-html-format",
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "message": "Manually constructing HTML by concatenating strings with user input bypasses all of Rails' built-in XSS protections. This allows attackers to inject scripts that execute when users view the generated page. Use Rails' template system with proper escaping or sanitize HTML content before rendering it.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "references": [
          "https://www.netsparker.com/blog/web-security/preventing-xss-ruby-on-rails-web-applications/",
          "https://api.rubyonrails.org/classes/ActionView/Helpers/SanitizeHelper.html"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Manually constructing HTML with user input allows XSS",
        "fix-suggestion": "Replace string concatenation for HTML creation with Rails template rendering or helpers like `content_tag`. Ensure all user-supplied content is automatically escaped by avoiding `html_safe` and `raw`. For complex HTML structures, consider using partial templates or component frameworks with proper escaping."
      },
      "mode": "taint",
      "pattern-sanitizers": [
        {
          "pattern-either": [
            {
              "pattern": "sanitize(...)"
            },
            {
              "pattern": "strip_tags(...)"
            }
          ]
        }
      ],
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "request"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern": "$HTMLSTR\n"
                    },
                    {
                      "pattern-regex": "<\\w+.*"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "Kernel::sprintf(\"$HTMLSTR\", ...)"
                        },
                        {
                          "pattern": "\"$HTMLSTR\" + $EXPR\n"
                        },
                        {
                          "pattern": "\"$HTMLSTR\" % $EXPR\n"
                        }
                      ]
                    },
                    {
                      "metavariable-pattern": {
                        "metavariable": "$HTMLSTR",
                        "language": "generic",
                        "pattern": "<$TAG ..."
                      }
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "ruby.rails.security.injection.tainted-sql-string.tainted-sql-string",
      "languages": [
        "ruby"
      ],
      "severity": "ERROR",
      "message": "Building SQL queries by concatenating strings with user-supplied values lets attackers manipulate the query structure. This SQL injection vulnerability can lead to unauthorized data access, data manipulation, or even server compromise through command execution. Use parameterized queries or Active Record's methods that automatically handle SQL escaping.",
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "references": [
          "https://rorsecurity.info/portfolio/ruby-on-rails-sql-injection-cheat-sheet"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Constructing SQL from user input fosters injection",
        "fix-suggestion": "Replace string concatenation in SQL queries with parameterized queries using `?` placeholders or hash conditions. Use ActiveRecord's query interface methods like `where`, `order`, and `select` which automatically handle parameter binding. Implement input validation to reject suspicious SQL patterns before they reach database operations."
      },
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "request"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "pattern": "$PARAMS.slice(...)\n"
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "patterns": [
                            {
                              "pattern": "$RECORD.where($X,...)\n"
                            }
                          ]
                        },
                        {
                          "pattern": "$RECORD.find(..., :conditions => $X,...)\n"
                        }
                      ]
                    },
                    {
                      "focus-metavariable": "$X"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "\"$SQLVERB#{$EXPR}...\"\n"
                    },
                    {
                      "pattern-not-inside": "$FUNC(\"...\",  \"...#{$EXPR}...\",...)\n"
                    },
                    {
                      "focus-metavariable": "$SQLVERB"
                    },
                    {
                      "pattern-regex": "(?i)(select|delete|insert|create|update|alter|drop)\\b"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "Kernel::sprintf(\"$SQLSTR\", $EXPR)"
                        },
                        {
                          "pattern": "\"$SQLSTR\" + $EXPR\n"
                        },
                        {
                          "pattern": "\"$SQLSTR\" % $EXPR\n"
                        }
                      ]
                    },
                    {
                      "pattern-not-inside": "$FUNC(\"...\",  \"...#{$EXPR}...\",...)\n"
                    },
                    {
                      "focus-metavariable": "$EXPR"
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$SQLSTR",
                        "regex": "(?i)(select|delete|insert|create|update|alter|drop)\\b"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "ruby.rails.security.injection.tainted-url-host.tainted-url-host",
      "languages": [
        "ruby"
      ],
      "severity": "WARNING",
      "message": "Using user input to construct the hostname portion of a URL allows attackers to redirect requests to malicious servers under their control. This Server-Side Request Forgery (SSRF) vulnerability can leak sensitive data, bypass firewalls, or access internal network resources. Validate hostnames against an allowlist or use a library like ssrf_filter to restrict where requests can be sent.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "category": "security",
        "technology": [
          "rails"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html",
          "https://github.com/arkadiyt/ssrf_filter"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Building host from user input in Rails can cause SSRF",
        "fix-suggestion": "Validate all user-supplied hostnames against an explicit allowlist of permitted domains before use in URLs. Use `URI.parse` to extract and validate components of URLs safely. Consider implementing a URL proxy service for dynamic destinations that can perform additional server-side validation."
      },
      "mode": "taint",
      "pattern-sanitizers": [
        {
          "pattern": "SsrfFilter"
        }
      ],
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "params"
                },
                {
                  "pattern": "request"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern": "$URLSTR\n"
                    },
                    {
                      "pattern-regex": "\\w+:\\/\\/#{.*}"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "Kernel::sprintf(\"$URLSTR\", ...)"
                        },
                        {
                          "pattern": "\"$URLSTR\" + $EXPR\n"
                        },
                        {
                          "pattern": "\"$URLSTR\" % $EXPR\n"
                        }
                      ]
                    },
                    {
                      "metavariable-pattern": {
                        "metavariable": "$URLSTR",
                        "language": "generic",
                        "pattern": "$SCHEME:// ..."
                      }
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "rust.lang.security.reqwest-accept-invalid.reqwest-accept-invalid",
      "message": "The application is configured to accept invalid TLS certificates when making HTTP requests. This bypasses critical security verification of the server's identity, enabling man-in-the-middle attacks. Attackers can intercept communications and impersonate legitimate servers without being detected.",
      "pattern-either": [
        {
          "pattern": "reqwest::Client::builder(). ... .danger_accept_invalid_hostnames(true)"
        },
        {
          "pattern": "reqwest::Client::builder(). ... .danger_accept_invalid_certs(true)"
        }
      ],
      "metadata": {
        "references": [
          "https://docs.rs/reqwest/latest/reqwest/struct.ClientBuilder.html#method.danger_accept_invalid_hostnames",
          "https://docs.rs/reqwest/latest/reqwest/struct.ClientBuilder.html#method.danger_accept_invalid_certs"
        ],
        "technology": [
          "reqwest"
        ],
        "category": "security",
        "cwe": "CWE-295: Improper Certificate Validation",
        "confidence": "HIGH",
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "subcategory": "vuln",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "TLS certificate validation disabled in reqwest client",
        "fix-suggestion": "Remove the `danger_accept_invalid_certs(true)` or similar configuration from your reqwest client. Use the default TLS validation behavior that properly verifies certificates against trusted certificate authorities and performs hostname validation."
      },
      "languages": [
        "rust"
      ],
      "severity": "WARNING"
    },
    {
      "id": "rust.lang.security.rustls-dangerous.rustls-dangerous",
      "message": "A dangerous rustls client configuration is being used that disables proper TLS verification. This makes your application vulnerable to man-in-the-middle attacks where malicious actors can intercept and modify communications. Without certificate verification, attackers can impersonate legitimate servers and compromise sensitive data.",
      "pattern-either": [
        {
          "pattern": "rustls::client::DangerousClientConfig"
        },
        {
          "pattern": "$CLIENT.dangerous().set_certificate_verifier(...)"
        },
        {
          "pattern": "let $CLIENT = rustls::client::ClientConfig::dangerous(...);\n...\n$CLIENT.set_certificate_verifier(...);\n"
        }
      ],
      "metadata": {
        "references": [
          "https://docs.rs/rustls/latest/rustls/client/struct.DangerousClientConfig.html",
          "https://docs.rs/rustls/latest/rustls/client/struct.ClientConfig.html#method.dangerous"
        ],
        "technology": [
          "rustls"
        ],
        "category": "security",
        "cwe": "CWE-295: Improper Certificate Validation",
        "confidence": "HIGH",
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "subcategory": "vuln",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Insecure TLS configuration in rustls client",
        "fix-suggestion": "Remove any code that creates custom certificate verifiers that bypass validation, such as `dangerous_config()` or `WebPkiVerifier::new_with_provider(Arc::new(NoCertificateVerification))`. Use the default rustls configuration which properly validates certificates."
      },
      "languages": [
        "rust"
      ],
      "severity": "WARNING"
    },
    {
      "id": "rust.lang.security.ssl-verify-none.ssl-verify-none",
      "message": "SSL certificate verification is explicitly disabled in your code. This critical security feature prevents attackers from intercepting your connections through man-in-the-middle attacks. Without verification, your application will connect to servers presenting invalid or malicious certificates, exposing sensitive data.",
      "pattern": "$BUILDER.set_verify(openssl::ssl::SSL_VERIFY_NONE)",
      "metadata": {
        "references": [
          "https://docs.rs/openssl/latest/openssl/ssl/struct.SslContextBuilder.html#method.set_verify"
        ],
        "technology": [
          "openssl"
        ],
        "category": "security",
        "cwe": "CWE-295: Improper Certificate Validation",
        "confidence": "HIGH",
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "subcategory": "vuln",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "SSL certificate verification explicitly disabled",
        "fix-suggestion": "Remove code that sets `verify_none()`, `dangerous_accept_invalid_certs(true)`, or similar flags that disable SSL verification. Allow the default verification behavior to properly validate server certificates and hostnames against trusted authorities."
      },
      "languages": [
        "rust"
      ],
      "severity": "WARNING"
    },
    {
      "id": "scala.jwt-scala.security.jwt-scala-hardcode.jwt-scala-hardcode",
      "patterns": [
        {
          "pattern-inside": "import pdi.jwt.$DEPS\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "$JWT.encode($X, \"...\", ...)"
            },
            {
              "pattern": "$JWT.decode($X, \"...\", ...)"
            },
            {
              "pattern": "$JWT.decodeRawAll($X, \"...\", ...)"
            },
            {
              "pattern": "$JWT.decodeRaw($X, \"...\", ...)"
            },
            {
              "pattern": "$JWT.decodeAll($X, \"...\", ...)"
            },
            {
              "pattern": "$JWT.validate($X, \"...\", ...)"
            },
            {
              "pattern": "$JWT.isValid($X, \"...\", ...)"
            },
            {
              "pattern": "$JWT.decodeJson($X, \"...\", ...)"
            },
            {
              "pattern": "$JWT.decodeJsonAll($X, \"...\", ...)"
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "$JWT.encode($X, $KEY, ...)"
                    },
                    {
                      "pattern": "$JWT.decode($X, $KEY, ...)"
                    },
                    {
                      "pattern": "$JWT.decodeRawAll($X, $KEY, ...)"
                    },
                    {
                      "pattern": "$JWT.decodeRaw($X, $KEY, ...)"
                    },
                    {
                      "pattern": "$JWT.decodeAll($X, $KEY, ...)"
                    },
                    {
                      "pattern": "$JWT.validate($X, $KEY, ...)"
                    },
                    {
                      "pattern": "$JWT.isValid($X, $KEY, ...)"
                    },
                    {
                      "pattern": "$JWT.decodeJson($X, $KEY, ...)"
                    },
                    {
                      "pattern": "$JWT.decodeJsonAll($X, $KEY, ...)"
                    },
                    {
                      "pattern": "$JWT.encode($X, this.$KEY, ...)"
                    },
                    {
                      "pattern": "$JWT.decode($X, this.$KEY, ...)"
                    },
                    {
                      "pattern": "$JWT.decodeRawAll($X, this.$KEY, ...)"
                    },
                    {
                      "pattern": "$JWT.decodeRaw($X, this.$KEY, ...)"
                    },
                    {
                      "pattern": "$JWT.decodeAll($X, this.$KEY, ...)"
                    },
                    {
                      "pattern": "$JWT.validate($X, this.$KEY, ...)"
                    },
                    {
                      "pattern": "$JWT.isValid($X, this.$KEY, ...)"
                    },
                    {
                      "pattern": "$JWT.decodeJson($X, this.$KEY, ...)"
                    },
                    {
                      "pattern": "$JWT.decodeJsonAll($X, this.$KEY, ...)"
                    }
                  ]
                },
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "class $CL {\n  ...\n  $KEY = \"...\"\n  ...\n}\n"
                    },
                    {
                      "pattern-inside": "object $CL {\n  ...\n  $KEY = \"...\"\n  ...\n}\n"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "metavariable-pattern": {
            "metavariable": "$JWT",
            "patterns": [
              {
                "pattern-either": [
                  {
                    "pattern": "Jwt"
                  },
                  {
                    "pattern": "JwtArgonaut"
                  },
                  {
                    "pattern": "JwtCirce"
                  },
                  {
                    "pattern": "JwtJson4s"
                  },
                  {
                    "pattern": "JwtJson"
                  },
                  {
                    "pattern": "JwtUpickle"
                  }
                ]
              }
            ]
          }
        }
      ],
      "message": "A JWT secret or private key is hardcoded directly in your source code. This exposes sensitive cryptographic material to anyone with access to the codebase, including version control history. If compromised, attackers can forge valid JWTs to impersonate users or bypass authentication entirely.",
      "languages": [
        "scala"
      ],
      "severity": "WARNING",
      "metadata": {
        "references": [
          "https://jwt-scala.github.io/jwt-scala/"
        ],
        "category": "security",
        "cwe": [
          "CWE-522: Insufficiently Protected Credentials"
        ],
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A04:2021 - Insecure Design"
        ],
        "technology": [
          "scala"
        ],
        "confidence": "HIGH",
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Hardcoded JWT secret key in source code",
        "fix-suggestion": "Replace hardcoded JWT secrets with values loaded from environment variables or a secure secrets management system. Use `sys.env.getOrElse(\"JWT_SECRET\", \"\")` to retrieve secrets from environment variables, ensuring they're properly protected in your deployment environment."
      }
    },
    {
      "id": "scala.lang.security.audit.dangerous-seq-run.dangerous-seq-run",
      "patterns": [
        {
          "pattern": "Seq($CMD, ...)"
        },
        {
          "pattern-not": "Seq(\"...\", ...)"
        },
        {
          "pattern-inside": "import sys.process\n...\n"
        },
        {
          "pattern-not-inside": "$CMD = \"...\"\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "Seq(...).!"
            },
            {
              "pattern-inside": "Seq(...).!!"
            },
            {
              "pattern-inside": "Seq(...).lazyLines"
            }
          ]
        }
      ],
      "message": "Using dynamic data to construct command arguments for process execution can allow attackers to inject additional commands. If this input comes from untrusted sources, attackers can execute arbitrary commands with the privileges of the application. Always validate process arguments against a strict allowlist or avoid using user-controlled data entirely in command execution.",
      "languages": [
        "scala"
      ],
      "severity": "ERROR",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "technology": [
          "scala"
        ],
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Sequence-based process run with untrusted data is injection risk",
        "fix-suggestion": "Replace dynamic process creation in `scala.sys.process.Process` with explicit, fixed command arguments. If dynamic arguments are necessary, validate them against a strict allowlist of permitted values. Consider safer alternatives to shell command execution, such as dedicated APIs for the specific functionality needed."
      }
    },
    {
      "id": "scala.lang.security.audit.dangerous-shell-run.dangerous-shell-run",
      "patterns": [
        {
          "pattern": "Seq($SH, \"-c\", $CMD, ...)"
        },
        {
          "pattern-not": "Seq($SH, \"-c\", \"...\", ...)"
        },
        {
          "pattern-inside": "import sys.process\n...\n"
        },
        {
          "pattern-not-inside": "$CMD = \"...\"\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "Seq(...).!"
            },
            {
              "pattern-inside": "Seq(...).!!"
            },
            {
              "pattern-inside": "Seq(...).lazyLines"
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$SH",
            "regex": "\"(sh|bash|ksh|csh|tcsh|zsh)\""
          }
        }
      ],
      "message": "Passing unsanitized user input to shell execution functions can allow attackers to add command separators or modifiers. This command injection vulnerability leads to arbitrary command execution with the same privileges as the application. Avoid running shell commands with user input, or if necessary, strictly validate inputs against a limited allowlist.",
      "languages": [
        "scala"
      ],
      "severity": "ERROR",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "technology": [
          "scala"
        ],
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Shell commands built from user input lead to injection",
        "fix-suggestion": "Replace shell commands containing user input with safe argument passing methods like `Seq(...)`. Always validate and sanitize user input before using it in command execution. Consider using input validation libraries to ensure only intended commands can be executed."
      }
    },
    {
      "id": "scala.lang.security.audit.dispatch-ssrf.dispatch-ssrf",
      "patterns": [
        {
          "pattern": "url($URL)"
        },
        {
          "pattern-inside": "import dispatch._\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "def $FUNC(..., $URL: $T, ...) = $A {\n  ...\n}\n"
            },
            {
              "pattern-inside": "def $FUNC(..., $URL: $T, ...) = {\n  ...\n}\n"
            }
          ]
        }
      ],
      "message": "When user input determines URL destinations in HTTP client requests, attackers can target internal network services normally inaccessible from outside. This Server-Side Request Forgery (SSRF) vulnerability can bypass network security controls and access sensitive internal systems. Implement strict validation of URL hostnames against an allowlist of permitted external domains.",
      "metadata": {
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html",
          "https://dispatchhttp.org/Dispatch.html"
        ],
        "category": "security",
        "technology": [
          "scala",
          "dispatch"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "Dispatch HTTP call with user data can cause SSRF",
        "fix-suggestion": "Implement URL validation by comparing against a predefined `allowlist` before making HTTP client requests. Verify both scheme and hostname components of user-provided URLs. Reject requests to internal networks or unauthorized domains to prevent Server-Side Request Forgery."
      },
      "languages": [
        "scala"
      ],
      "severity": "WARNING"
    },
    {
      "id": "scala.lang.security.audit.documentbuilder-dtd-enabled.documentbuilder-dtd-enabled",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$DF = DocumentBuilderFactory.newInstance(...)\n...\n$DB = $DF.newDocumentBuilder(...)\n"
            },
            {
              "patterns": [
                {
                  "pattern": "$DB = DocumentBuilderFactory.newInstance(...)"
                },
                {
                  "pattern-not-inside": "...\n$X = $DB.newDocumentBuilder(...)\n"
                }
              ]
            },
            {
              "pattern": "$DB = DocumentBuilderFactory.newInstance(...).newDocumentBuilder(...)"
            }
          ]
        },
        {
          "pattern-not-inside": "...\n$DB.setXIncludeAware(true)\n...\n$DB.setNamespaceAware(true)\n...\n$DB.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true)\n...\n$DB.setFeature(\"http://xml.org/sax/features/external-general-entities\", false)\n...\n$DB.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false)\n"
        },
        {
          "pattern-not-inside": "...\n$DB.setXIncludeAware(true)\n...\n$DB.setNamespaceAware(true)\n...\n$DB.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true)\n...\n$DB.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false)\n...\n$DB.setFeature(\"http://xml.org/sax/features/external-general-entities\", false)\n"
        },
        {
          "pattern-not-inside": "...\n$DB.setXIncludeAware(true)\n...\n$DB.setNamespaceAware(true)\n...\n$DB.setFeature(\"http://xml.org/sax/features/external-general-entities\", false)\n...\n$DB.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true)\n...\n$DB.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false)\n"
        },
        {
          "pattern-not-inside": "...\n$DB.setXIncludeAware(true)\n...\n$DB.setNamespaceAware(true)\n...\n$DB.setFeature(\"http://xml.org/sax/features/external-general-entities\", false)\n...\n$DB.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false)\n...\n$DB.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true)\n"
        }
      ],
      "message": "XML parsers with entity processing enabled can be exploited through specially crafted XML documents containing external entity references. These XXE (XML External Entity) attacks can lead to file disclosure, server-side request forgery, or denial of service. Disable DTD processing by setting features like 'http://apache.org/xml/features/disallow-doctype-decl' to true when creating XML parsers.",
      "languages": [
        "scala"
      ],
      "severity": "WARNING",
      "metadata": {
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "source-rule-url": "https://cheatsheetseries.owasp.org//cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html",
        "category": "security",
        "technology": [
          "scala"
        ],
        "confidence": "HIGH",
        "references": [
          "https://owasp.org/Top10/A05_2021-Security_Misconfiguration"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "DTD enabled in DocumentBuilder can cause XXE issues",
        "fix-suggestion": "Set XML parser feature `http://apache.org/xml/features/disallow-doctype-decl` to `true` before processing documents. Disable external entity resolution using `setFeature()` method. Configure the DocumentBuilder to reject DTD processing to prevent XXE attacks."
      }
    },
    {
      "id": "scala.lang.security.audit.insecure-random.insecure-random",
      "metadata": {
        "cwe": [
          "CWE-330: Use of Insufficiently Random Values"
        ],
        "owasp": [
          "A02:2021 - Cryptographic Failures"
        ],
        "category": "security",
        "technology": [
          "scala",
          "cryptography"
        ],
        "resources": [
          "https://find-sec-bugs.github.io/bugs.htm"
        ],
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Weak random number generator in security context",
        "fix-suggestion": "Replace `scala.util.Random` with `java.security.SecureRandom` for all security-related random number generation. Use `val secureRandom = new java.security.SecureRandom()` and its methods to generate unpredictable values for tokens, keys, and other security-sensitive operations."
      },
      "message": "Your code uses `scala.util.Random` which generates predictable sequences unsuitable for security purposes. When used for authentication tokens, session IDs, or cryptographic operations, predictable randomness can be exploited to guess or replay sensitive values. Security-critical applications require cryptographically strong random number generators.",
      "severity": "WARNING",
      "languages": [
        "scala"
      ],
      "patterns": [
        {
          "pattern": "import scala.util.Random\n"
        }
      ]
    },
    {
      "id": "scala.lang.security.audit.io-source-ssrf.io-source-ssrf",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "Source.fromURL($URL,...)"
            },
            {
              "pattern": "Source.fromURI($URL,...)"
            }
          ]
        },
        {
          "pattern-inside": "import scala.io.$SOURCE\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "def $FUNC(..., $URL: $T, ...) = $A {\n  ...\n}\n"
            },
            {
              "pattern-inside": "def $FUNC(..., $URL: $T, ...) = {\n  ...\n}\n"
            }
          ]
        }
      ],
      "message": "Using scala.io.Source.fromURL with user-controlled URLs allows attackers to access internal network resources or local files. This Server-Side Request Forgery vulnerability can expose sensitive data or bypass network security boundaries. Validate URL schemes and hostnames against a strict allowlist before making any network requests.",
      "metadata": {
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html",
          "https://www.scala-lang.org/api/current/scala/io/Source$.html#fromURL(url:java.net.URL)(implicitcodec:scala.io.Codec):scala.io.BufferedSource"
        ],
        "category": "security",
        "technology": [
          "scala"
        ],
        "confidence": "MEDIUM",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "fromURL with untrusted input can lead to SSRF",
        "fix-suggestion": "Validate URL scheme and hostname against a strict `allowlist` before passing to `scala.io.Source.fromURL()`. Implement URL parsing with the `java.net.URL` class to extract components for validation. Restrict allowed protocols to only those required for the application's functionality."
      },
      "languages": [
        "scala"
      ],
      "severity": "WARNING"
    },
    {
      "id": "scala.lang.security.audit.path-traversal-fromfile.path-traversal-fromfile",
      "metadata": {
        "cwe": [
          "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')"
        ],
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "category": "security",
        "technology": [
          "scala"
        ],
        "resources": [
          "https://find-sec-bugs.github.io/bugs.htm"
        ],
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "short-description": "User input in fromFile can read arbitrary files",
        "fix-suggestion": "Normalize file paths using `getCanonicalPath()` and verify they remain within allowed directories. Implement path validation that rejects inputs containing `../` sequences or other directory traversal patterns. Consider using a designated safe directory with fixed filenames for user-accessible files."
      },
      "message": "When user input is used in file paths without proper validation, attackers can use path traversal sequences (like ../) to access files outside the intended directory. This can expose sensitive configuration files, credentials, or system files leading to information disclosure or further system compromise. Validate file paths against an allowlist or use library functions that restrict access to a specific directory.",
      "severity": "WARNING",
      "languages": [
        "scala"
      ],
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "$FILENAME = \"...\" + $VAR\n...\n"
                    },
                    {
                      "pattern-inside": "$FILENAME = $VAR + \"...\"\n...\n"
                    },
                    {
                      "pattern-inside": "$FILENAME = $STR.concat($VAR)\n...\n"
                    },
                    {
                      "pattern-inside": "$FILENAME = \"...\".format(..., $VAR, ...)\n...\n"
                    }
                  ]
                },
                {
                  "pattern": "Source.fromFile($FILENAME, ...)"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "Source.fromFile(\"...\" + $VAR, ...)"
                    },
                    {
                      "pattern": "Source.fromFile($VAR + \"...\", ...)"
                    },
                    {
                      "pattern": "Source.fromFile($STR.concat($VAR), ...)"
                    },
                    {
                      "pattern": "Source.fromFile(\"...\".format(..., $VAR, ...), ...)"
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "pattern-inside": "def $FUNC(..., $VAR: $TYPE, ...) = Action {\n  ...\n}\n"
        }
      ]
    },
    {
      "id": "scala.lang.security.audit.rsa-padding-set.rsa-padding-set",
      "metadata": {
        "cwe": [
          "CWE-780: Use of RSA Algorithm without OAEP"
        ],
        "owasp": [
          "A02:2021 - Cryptographic Failures"
        ],
        "category": "security",
        "technology": [
          "scala",
          "cryptography"
        ],
        "resources": [
          "https://blog.codacy.com/9-scala-security-issues/"
        ],
        "confidence": "HIGH",
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Insecure padding scheme in RSA encryption",
        "fix-suggestion": "Replace the current RSA padding with `OAEPWithSHA256AndMGF1Padding` which provides strong security properties. Update your cipher initialization to specify this padding mode explicitly, for example: `Cipher.getInstance(\"RSA/ECB/OAEPWithSHA256AndMGF1Padding\")`."
      },
      "message": "RSA encryption is being used without secure padding, making it vulnerable to various cryptographic attacks. Proper padding schemes like OAEP are essential for RSA security, as they add randomness and structure to prevent mathematical attacks. Without secure padding, encrypted data may be deciphered by sophisticated attackers.",
      "severity": "WARNING",
      "languages": [
        "scala"
      ],
      "patterns": [
        {
          "pattern": "$VAR = $CIPHER.getInstance($MODE)\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$MODE",
            "regex": ".*RSA/.*/NoPadding.*"
          }
        }
      ]
    },
    {
      "id": "scala.lang.security.audit.sax-dtd-enabled.sax-dtd-enabled",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$SR = new SAXReader(...)"
            },
            {
              "pattern": "$SF = SAXParserFactory.newInstance(...)\n...\n$SR = $SF.newSAXParser(...)\n"
            },
            {
              "patterns": [
                {
                  "pattern": "$SR = SAXParserFactory.newInstance(...)"
                },
                {
                  "pattern-not-inside": "...\n$X = $SR.newSAXParser(...)\n"
                }
              ]
            },
            {
              "pattern": "$SR = SAXParserFactory.newInstance(...).newSAXParser(...)"
            },
            {
              "pattern": "$SR = new SAXBuilder(...)"
            }
          ]
        },
        {
          "pattern-not-inside": "...\n$SR.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true)\n...\n$SR.setFeature(\"http://xml.org/sax/features/external-general-entities\", false)\n...\n$SR.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false)\n"
        },
        {
          "pattern-not-inside": "...\n$SR.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true)\n...\n$SR.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false)\n...\n$SR.setFeature(\"http://xml.org/sax/features/external-general-entities\", false)\n"
        },
        {
          "pattern-not-inside": "...\n$SR.setFeature(\"http://xml.org/sax/features/external-general-entities\", false)\n...\n$SR.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true)\n...\n$SR.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false)\n"
        },
        {
          "pattern-not-inside": "...\n$SR.setFeature(\"http://xml.org/sax/features/external-general-entities\", false)\n...\n$SR.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false)\n...\n$SR.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true)\n"
        }
      ],
      "message": "SAX parsers with DTD processing enabled can be exploited through malicious XML files that reference external entities. These XXE (XML External Entity) attacks can lead to sensitive file disclosure, SSRF, or denial of service through resource exhaustion. Disable DTD processing by setting the appropriate parser features before parsing any XML from untrusted sources.",
      "languages": [
        "scala"
      ],
      "severity": "WARNING",
      "metadata": {
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "source-rule-url": "https://cheatsheetseries.owasp.org//cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html",
        "category": "security",
        "technology": [
          "scala"
        ],
        "confidence": "HIGH",
        "references": [
          "https://owasp.org/Top10/A05_2021-Security_Misconfiguration"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "SAX parser with DTD enabled can be exploited by XXE",
        "fix-suggestion": "Configure SAX parser with `setFeature(\"http://xml.org/sax/features/external-general-entities\", false)` to disable external entities. Set `http://xml.org/sax/features/external-parameter-entities` to `false` to block parameter entities. Use a factory method pattern to ensure all parser instances have proper security settings."
      }
    },
    {
      "id": "scala.lang.security.audit.scala-dangerous-process-run.scala-dangerous-process-run",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$X.!"
            },
            {
              "pattern": "$X.!!"
            },
            {
              "pattern": "$X.lazyLines"
            }
          ]
        },
        {
          "pattern-inside": "import sys.process\n...\n"
        },
        {
          "pattern-not": "\"...\".!\n"
        },
        {
          "pattern-not": "\"...\".!!\n"
        },
        {
          "pattern-not": "\"...\".lazyLines\n"
        },
        {
          "pattern-not": "Seq(...).!\n"
        },
        {
          "pattern-not": "Seq(...).!!\n"
        },
        {
          "pattern-not": "Seq(...).lazyLines\n"
        },
        {
          "pattern-not-inside": "val $X = \"...\"\n...\n"
        },
        {
          "pattern-not-inside": "val $X = Seq(...)\n...\n"
        }
      ],
      "message": "Using string concatenation or interpolation to build command lines for external processes allows attackers to inject additional commands. If the input is user-controlled, this can lead to arbitrary command execution with the application's privileges. Use the safer Seq(...) form for process arguments to ensure proper argument separation and escaping.",
      "languages": [
        "scala"
      ],
      "severity": "ERROR",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "technology": [
          "scala"
        ],
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Running external process from user input fosters injection",
        "fix-suggestion": "Replace string-based process creation with the safer `Seq(...)` approach for command arguments. Implement strict validation rules for any user-supplied command components. Create a whitelist of allowed commands and arguments to prevent execution of unauthorized processes."
      }
    },
    {
      "id": "scala.lang.security.audit.scalac-debug.scalac-debug",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "scalacOptions ... \"-Vdebug\""
            },
            {
              "pattern": "scalacOptions ... \"-Ydebug\""
            }
          ]
        }
      ],
      "message": "Debug mode is enabled in what appears to be a production environment. This can expose sensitive information through error messages, stack traces, and logging that would help attackers understand your application structure. Debug mode also negatively impacts application performance and may introduce reliability issues.",
      "languages": [
        "generic"
      ],
      "severity": "WARNING",
      "paths": {
        "include": [
          "*.sbt*"
        ]
      },
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-489: Active Debug Code"
        ],
        "owasp": "A05:2021 - Security Misconfiguration",
        "technology": [
          "scala",
          "sbt"
        ],
        "references": [
          "https://docs.scala-lang.org/overviews/compiler-options/index.html"
        ],
        "confidence": "MEDIUM",
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Active Debug Code"
        ],
        "short-description": "Debug mode enabled in production environment",
        "fix-suggestion": "Remove `debug = true` from your production configuration files. Create separate development and production configurations, ensuring that debug features are only enabled in development environments and never deployed to production systems."
      }
    },
    {
      "id": "scala.lang.security.audit.scalaj-http-ssrf.scalaj-http-ssrf",
      "patterns": [
        {
          "pattern": "Http($URL)"
        },
        {
          "pattern-inside": "import scalaj.http.$HTTP\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "def $FUNC(..., $URL: $T, ...) = $A {\n  ...\n}\n"
            },
            {
              "pattern-inside": "def $FUNC(..., $URL: $T, ...) = {\n  ...\n}\n"
            }
          ]
        }
      ],
      "message": "When HTTP requests are made to URLs containing user-supplied input, attackers can redirect those requests to internal network services. This Server-Side Request Forgery (SSRF) can bypass network security controls and access sensitive systems or services. Implement strict validation of URL hostnames against an allowlist of permitted external domains.",
      "metadata": {
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html",
          "https://github.com/scalaj/scalaj-http#simplified-http"
        ],
        "category": "security",
        "technology": [
          "scala",
          "scalaj-http"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "scalaj-http calls with unvalidated host can do SSRF",
        "fix-suggestion": "Create an `allowlist` of permitted domains and validate all user-provided URLs against it before making HTTP requests. Parse URLs with `java.net.URL` to extract and verify hostname and scheme components. Consider implementing a URL proxy service that performs additional server-side validation for dynamic destinations."
      },
      "languages": [
        "scala"
      ],
      "severity": "WARNING"
    },
    {
      "id": "scala.lang.security.audit.xmlinputfactory-dtd-enabled.xmlinputfactory-dtd-enabled",
      "patterns": [
        {
          "pattern-not-inside": "...\n$XMLFACTORY.setProperty(\"javax.xml.stream.isSupportingExternalEntities\", false)\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "$XMLFACTORY = XMLInputFactory.newFactory(...)"
            },
            {
              "pattern": "$XMLFACTORY = XMLInputFactory.newInstance(...)"
            },
            {
              "pattern": "$XMLFACTORY = new XMLInputFactory(...)"
            }
          ]
        }
      ],
      "message": "Creating an XMLInputFactory without disabling entity processing allows processing of external entities in XML documents. Attackers can exploit this with malicious XML containing external entity references to exfiltrate sensitive files or cause denial of service. Disable DTD processing by calling setProperty with the appropriate features before using the XMLInputFactory with untrusted input.",
      "languages": [
        "scala"
      ],
      "severity": "WARNING",
      "metadata": {
        "cwe": [
          "CWE-611: Improper Restriction of XML External Entity Reference"
        ],
        "owasp": [
          "A04:2017 - XML External Entities (XXE)",
          "A05:2021 - Security Misconfiguration"
        ],
        "source-rule-url": "https://cheatsheetseries.owasp.org//cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html",
        "category": "security",
        "technology": [
          "scala"
        ],
        "confidence": "HIGH",
        "references": [
          "https://owasp.org/Top10/A05_2021-Security_Misconfiguration"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "XMLInputFactory with entity processing enabled causes XXE risk",
        "fix-suggestion": "Configure XMLInputFactory with `factory.setProperty(XMLInputFactory.SUPPORT_DTD, false)` to disable DTD processing. Set `XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES` to `false` to prevent external entity resolution. Create a factory helper method that applies all security settings consistently across your application."
      }
    },
    {
      "id": "scala.play.security.conf-insecure-cookie-settings.conf-insecure-cookie-settings",
      "patterns": [
        {
          "pattern": "secure = false"
        },
        {
          "pattern-inside": "session = {\n  ...\n}\n"
        }
      ],
      "message": "Session cookies are configured without the 'Secure' flag, allowing them to be transmitted over unencrypted HTTP connections. This exposes session cookies to interception by attackers on the network. Session cookies containing authentication data could be stolen, leading to session hijacking attacks.",
      "languages": [
        "generic"
      ],
      "severity": "WARNING",
      "paths": {
        "include": [
          "*.conf"
        ]
      },
      "metadata": {
        "category": "security",
        "references": [
          "https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#security",
          "https://www.playframework.com/documentation/2.8.x/SettingsSession#Session-Configuration"
        ],
        "technology": [
          "play",
          "scala"
        ],
        "cwe": [
          "CWE-614: Sensitive Cookie in HTTPS Session Without 'Secure' Attribute"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "confidence": "MEDIUM",
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cookie Security"
        ],
        "short-description": "Session cookies missing Secure flag protection",
        "fix-suggestion": "Set `play.http.session.secure = true` in your Play Framework configuration file to enable the Secure flag on session cookies. This ensures cookies are only transmitted over HTTPS connections, protecting them from interception on the network."
      }
    },
    {
      "id": "scala.play.security.tainted-html-response.tainted-html-response",
      "mode": "taint",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "technology": [
          "scala",
          "play"
        ],
        "confidence": "MEDIUM",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Returning user data in an Ok() response without escaping",
        "fix-suggestion": "Use Play Framework's Twirl templates with the `@` syntax for safe HTML rendering instead of raw HTML strings. Replace `Ok(Html(userInput))` with template-based rendering like `Ok(views.html.myTemplate(safeData))`. Implement Content Security Policy headers to provide additional protection against XSS attacks."
      },
      "message": "Directly returning unsanitized user input in Play Framework's Ok() responses bypasses the template engine's automatic HTML escaping. This allows attackers to inject JavaScript that executes when the response is rendered in users' browsers. Use proper template rendering with Twirl which automatically applies context-appropriate escaping to prevent XSS attacks.",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern": "$REQ"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "Action {\n  $REQ: Request[$T] => \n    ...\n}\n"
                        },
                        {
                          "pattern-inside": "Action(...) {\n  $REQ: Request[$T] => \n    ...\n}\n"
                        },
                        {
                          "pattern-inside": "Action.async {\n  $REQ: Request[$T] => \n    ...\n}\n"
                        },
                        {
                          "pattern-inside": "Action.async(...) {\n  $REQ: Request[$T] => \n    ...\n}\n"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "$PARAM"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "def $CTRL(..., $PARAM: $TYPE, ...) = Action {\n  ...\n}\n"
                        },
                        {
                          "pattern-inside": "def $CTRL(..., $PARAM: $TYPE, ...) = Action(...) {\n  ...\n}\n"
                        },
                        {
                          "pattern-inside": "def $CTRL(..., $PARAM: $TYPE, ...) = Action.async {\n  ...\n}\n"
                        },
                        {
                          "pattern-inside": "def $CTRL(..., $PARAM: $TYPE, ...) = Action.async(...) {\n  ...\n}\n"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "pattern-either": [
            {
              "pattern": "org.apache.commons.lang3.StringEscapeUtils.escapeHtml4(...)"
            },
            {
              "pattern": "org.owasp.encoder.Encode.forHtml(...)"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "pattern-either": [
            {
              "pattern": "Html.apply(...)"
            },
            {
              "pattern": "Ok(...).as(HTML)"
            },
            {
              "pattern": "Ok(...).as(ContentTypes.HTML)"
            },
            {
              "patterns": [
                {
                  "pattern": "Ok(...).as($CTYPE)"
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$CTYPE",
                    "regex": "\"[tT][eE][xX][tT]/[hH][tT][mM][lL]\""
                  }
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern": "Ok(...).as($CTYPE)"
                },
                {
                  "pattern-not": "Ok(...).as(\"...\")"
                },
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "def $FUNC(..., $URL: $T, ...) = $A {\n  ...\n}\n"
                    },
                    {
                      "pattern-inside": "def $FUNC(..., $URL: $T, ...) = {\n  ...\n}\n"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "severity": "WARNING",
      "languages": [
        "scala"
      ]
    },
    {
      "id": "scala.play.security.tainted-slick-sqli.tainted-slick-sqli",
      "mode": "taint",
      "metadata": {
        "references": [
          "https://scala-slick.org/doc/3.3.3/sql.html#splicing-literal-values",
          "https://scala-slick.org/doc/3.2.0/sql-to-slick.html#non-optimal-sql-code"
        ],
        "category": "security",
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "technology": [
          "scala",
          "slick",
          "play"
        ],
        "confidence": "HIGH",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Slick SQL injection from user data in Play framework",
        "fix-suggestion": "Replace string interpolation in SQL queries with Slick's parameterized query methods using `bindValue` or `?`. Implement repository patterns that encapsulate all database access through type-safe query builders. Create input validation routines that sanitize user input before it reaches database layer."
      },
      "message": "Building SQL queries with user input through string concatenation or interpolation allows attackers to modify the query structure. This SQL injection vulnerability can lead to unauthorized data access, data manipulation, or even server compromise. Use Slick's parameterized queries to properly separate query structure from the data being queried.",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern": "$REQ"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "Action {\n  $REQ: Request[$T] => \n    ...\n}\n"
                        },
                        {
                          "pattern-inside": "Action(...) {\n  $REQ: Request[$T] => \n    ...\n}\n"
                        },
                        {
                          "pattern-inside": "Action.async {\n  $REQ: Request[$T] => \n    ...\n}\n"
                        },
                        {
                          "pattern-inside": "Action.async(...) {\n  $REQ: Request[$T] => \n    ...\n}\n"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "$PARAM"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "def $CTRL(..., $PARAM: $TYPE, ...) = Action {\n  ...\n}\n"
                        },
                        {
                          "pattern-inside": "def $CTRL(..., $PARAM: $TYPE, ...) = Action(...) {\n  ...\n}\n"
                        },
                        {
                          "pattern-inside": "def $CTRL(..., $PARAM: $TYPE, ...) = Action.async {\n  ...\n}\n"
                        },
                        {
                          "pattern-inside": "def $CTRL(..., $PARAM: $TYPE, ...) = Action.async(...) {\n  ...\n}\n"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$MODEL.overrideSql(...)"
                },
                {
                  "pattern": "sql\"...\""
                }
              ]
            },
            {
              "pattern-inside": "import slick.$DEPS\n...\n"
            }
          ]
        }
      ],
      "severity": "ERROR",
      "languages": [
        "scala"
      ]
    },
    {
      "id": "scala.play.security.tainted-sql-from-http-request.tainted-sql-from-http-request",
      "languages": [
        "scala"
      ],
      "severity": "ERROR",
      "mode": "taint",
      "message": "Constructing SQL queries by directly incorporating HTTP request parameters allows attackers to inject malicious SQL syntax. This SQL injection vulnerability can lead to unauthorized data access, data modification, or even complete database compromise. Use prepared statements or an ORM with proper parameterization to safely incorporate user input in database queries.",
      "metadata": {
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.oracle.com/javase/7/docs/api/java/sql/PreparedStatement.html"
        ],
        "category": "security",
        "technology": [
          "scala",
          "play"
        ],
        "confidence": "HIGH",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Manually constructing SQL with untrusted Play request data",
        "fix-suggestion": "Construct SQL queries from HTTP request data using prepared statements or an ORM with parameterized queries to avoid injection vulnerabilities."
      },
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern": "$REQ"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "Action {\n  $REQ: Request[$T] => \n    ...\n}\n"
                        },
                        {
                          "pattern-inside": "Action(...) {\n  $REQ: Request[$T] => \n    ...\n}\n"
                        },
                        {
                          "pattern-inside": "Action.async {\n  $REQ: Request[$T] => \n    ...\n}\n"
                        },
                        {
                          "pattern-inside": "Action.async(...) {\n  $REQ: Request[$T] => \n    ...\n}\n"
                        }
                      ]
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "$PARAM"
                    },
                    {
                      "pattern-either": [
                        {
                          "pattern-inside": "def $CTRL(..., $PARAM: $TYPE, ...) = Action {\n  ...\n}\n"
                        },
                        {
                          "pattern-inside": "def $CTRL(..., $PARAM: $TYPE, ...) = Action(...) {\n  ...\n}\n"
                        },
                        {
                          "pattern-inside": "def $CTRL(..., $PARAM: $TYPE, ...) = Action.async {\n  ...\n}\n"
                        },
                        {
                          "pattern-inside": "def $CTRL(..., $PARAM: $TYPE, ...) = Action.async(...) {\n  ...\n}\n"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-either": [
                        {
                          "pattern": "\"$SQLSTR\" + ...\n"
                        },
                        {
                          "pattern": "\"$SQLSTR\".format(...)\n"
                        },
                        {
                          "patterns": [
                            {
                              "pattern-inside": "$SB = new StringBuilder(\"$SQLSTR\");\n...\n"
                            },
                            {
                              "pattern": "$SB.append(...)"
                            }
                          ]
                        },
                        {
                          "patterns": [
                            {
                              "pattern-inside": "$VAR = \"$SQLSTR\"\n...\n"
                            },
                            {
                              "pattern": "$VAR += ..."
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "metavariable-regex": {
                        "metavariable": "$SQLSTR",
                        "regex": "(?i)(select|delete|insert|create|update|alter|drop)\\b"
                      }
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern": "s\"...\""
                    },
                    {
                      "pattern-regex": ".*\\b(?i)(select|delete|insert|create|update|alter|drop)\\b.*\n"
                    }
                  ]
                }
              ]
            },
            {
              "pattern-not-inside": "println(...)"
            }
          ]
        }
      ]
    },
    {
      "id": "scala.play.security.webservice-ssrf.webservice-ssrf",
      "patterns": [
        {
          "pattern": "$WS.url($URL)"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "class $CLASS (..., $WS: WSClient, ...) {\n  ...\n}\n"
            },
            {
              "pattern-inside": "def $FUNC(..., $WS: WSClient, ...) = {\n  ...\n}\n"
            },
            {
              "pattern-inside": "$WS = AhcWSClient(...)\n...\n"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "def $FUNC(..., $URL: $T, ...) = $A {\n  ...\n}\n"
            },
            {
              "pattern-inside": "def $FUNC(..., $URL: $T, ...) = {\n  ...\n}\n"
            }
          ]
        }
      ],
      "message": "Using unsanitized user input to specify the URL for WSClient requests allows attackers to target internal network services. This Server-Side Request Forgery (SSRF) vulnerability can bypass network security boundaries to access sensitive internal systems or exfiltrate data. Validate URLs against a strict allowlist of permitted domains before making any WSClient requests with user-controlled input.",
      "metadata": {
        "cwe": [
          "CWE-918: Server-Side Request Forgery (SSRF)"
        ],
        "owasp": [
          "A10:2021 - Server-Side Request Forgery (SSRF)"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html",
          "https://www.playframework.com/documentation/2.8.x/ScalaWS"
        ],
        "category": "security",
        "technology": [
          "scala",
          "play"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "WSClient call with user input can cause SSRF",
        "fix-suggestion": "Validate user-supplied URLs against a strict allowlist before using them in WSClient requests to prevent SSRF and unauthorized internal network access."
      },
      "languages": [
        "scala"
      ],
      "severity": "WARNING"
    },
    {
      "id": "scala.scala-jwt.security.jwt-hardcode.scala-jwt-hardcoded-secret",
      "languages": [
        "scala"
      ],
      "message": "JWT signing keys or secrets are hardcoded directly in the source code. This exposes critical security material to anyone with code access, including in version control history. Compromised JWT signing keys allow attackers to forge authentication tokens and impersonate any user in your system.",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-522: Insufficiently Protected Credentials"
        ],
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A04:2021 - Insecure Design"
        ],
        "source-rule-url": "https://semgrep.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/",
        "technology": [
          "jwt"
        ],
        "confidence": "HIGH",
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "JWT cryptographic keys hardcoded in source code",
        "fix-suggestion": "Remove hardcoded JWT secrets from your code and load them from environment variables or a secure secret management system. Use configuration providers like `ConfigFactory.load()` to retrieve secrets from properly secured external sources rather than embedding them in code."
      },
      "pattern-either": [
        {
          "pattern": "com.auth0.jwt.algorithms.Algorithm.HMAC256(\"...\");\n"
        },
        {
          "pattern": "$SECRET = \"...\";\n...\ncom.auth0.jwt.algorithms.Algorithm.HMAC256($SECRET);\n"
        },
        {
          "pattern": "class $CLASS {\n  ...\n  $DECL $SECRET = \"...\";\n  ...\n  def $FUNC (...): $RETURNTYPE = {\n    ...\n    com.auth0.jwt.algorithms.Algorithm.HMAC256($SECRET);\n    ...\n  }\n  ...\n}\n"
        },
        {
          "pattern": "com.auth0.jwt.algorithms.Algorithm.HMAC384(\"...\");\n"
        },
        {
          "pattern": "$SECRET = \"...\";\n...\ncom.auth0.jwt.algorithms.Algorithm.HMAC384($SECRET);\n"
        },
        {
          "pattern": "class $CLASS {\n  ...\n  $DECL $SECRET = \"...\";\n  ...\n  def $FUNC (...): $RETURNTYPE = {\n    ...\n    com.auth0.jwt.algorithms.Algorithm.HMAC384($SECRET);\n    ...\n  }\n  ...\n}\n"
        },
        {
          "pattern": "com.auth0.jwt.algorithms.Algorithm.HMAC512(\"...\");\n"
        },
        {
          "pattern": "$SECRET = \"...\";\n...\ncom.auth0.jwt.algorithms.Algorithm.HMAC512($SECRET);\n"
        },
        {
          "pattern": "class $CLASS {\n  ...\n  $DECL $SECRET = \"...\";\n  ...\n  def $FUNC (...): $RETURNTYPE = {\n    ...\n    com.auth0.jwt.algorithms.Algorithm.HMAC512($SECRET);\n    ...\n  }\n  ...\n}\n"
        }
      ],
      "severity": "ERROR"
    },
    {
      "id": "scala.slick.security.scala-slick-sql-non-literal.scala-slick-sql-non-literal",
      "patterns": [
        {
          "pattern": "sql\"...\""
        },
        {
          "pattern-regex": "\\#\\$"
        },
        {
          "pattern-inside": "import slick.$DEPS\n...\n"
        }
      ],
      "message": "Building SQL queries using string interpolation or concatenation with user input allows attackers to modify the query structure. This SQL injection vulnerability can lead to unauthorized data access, modification, or deletion. Use Slick's parameterized queries or prepared statements where query structure and parameters are properly separated.",
      "languages": [
        "scala"
      ],
      "severity": "ERROR",
      "metadata": {
        "source-rule-url": "https://find-sec-bugs.github.io/bugs.htm#SCALA_SQL_INJECTION_SLICK",
        "references": [
          "https://scala-slick.org/doc/3.3.3/sql.html#splicing-literal-values"
        ],
        "category": "security",
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "technology": [
          "scala",
          "slick"
        ],
        "confidence": "LOW",
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "Non-literal Slick SQL statements risk injection",
        "fix-suggestion": "Replace string concatenation in queries with Slick's parameterized query methods like `bindValue` or `?`. Use typed parameter binding to separate SQL structure from data input. Implement repository patterns that encapsulate all database access through safe query builders."
      }
    },
    {
      "id": "scala.slick.security.scala-slick-overridesql-literal.scala-slick-overrideSql-literal",
      "patterns": [
        {
          "pattern": "$MODEL.overrideSql($QUERY,...)"
        },
        {
          "pattern-not": "$MODEL.overrideSql(\"...\",...)"
        },
        {
          "pattern-not-inside": "$QUERY = \"...\"\n...\n"
        }
      ],
      "message": "The overrideSql method in Slick bypasses the query builder's safety mechanisms when used with non-literal SQL strings. If these strings contain user input, attackers can inject malicious SQL that modifies query logic or structure. Only use overrideSql with hardcoded literal SQL strings and never with dynamically constructed queries containing user input.",
      "languages": [
        "scala"
      ],
      "severity": "ERROR",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "technology": [
          "scala",
          "slick"
        ],
        "confidence": "LOW",
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "SQL Injection"
        ],
        "short-description": "overrideSql with dynamic input leads to injection",
        "fix-suggestion": "Remove any user input from queries using `overrideSql` and use only hardcoded SQL strings. Replace dynamic queries with parameterized alternatives using Slick's type-safe DSL. Create separate query methods for each variation needed rather than building SQL dynamically."
      }
    },
    {
      "id": "solidity.security.balancer-readonly-reentrancy-getpooltokens.balancer-readonly-reentrancy-getpooltokens",
      "message": "The contract calls `getPoolTokens()` on a Balancer pool without protection against read-only reentrancy attacks. This vulnerability allows malicious contracts to manipulate the executed code flow during token balance readings. An attacker could exploit this to create inconsistent state views leading to financial losses.",
      "metadata": {
        "category": "security",
        "technology": [
          "solidity"
        ],
        "cwe": "CWE-841: Improper Enforcement of Behavioral Workflow",
        "confidence": "HIGH",
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "subcategory": [
          "vuln"
        ],
        "references": [
          "https://quillaudits.medium.com/decoding-sentiment-protocols-1-million-exploit-quillaudits-f36bee77d376",
          "https://hackmd.io/@sentimentxyz/SJCySo1z2"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Unprotected Balancer pool calls enabling reentrancy",
        "fix-suggestion": "Implement a reentrancy guard before calling `getPoolTokens()` or use the Balancer vault directly as a view function. Consider adding checks for return values consistency or implementing a mutex pattern to prevent reentrant calls affecting your contract's state."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "function $F(...) {\n  ...\n  $RETURN = $VAULT.getPoolTokens(...);\n  ...\n}\n"
            }
          ]
        },
        {
          "metavariable-pattern": {
            "metavariable": "$RETURN",
            "pattern-regex": ".*uint256\\[].*"
          }
        },
        {
          "pattern-not-inside": "contract $C {\n  ...\n  function $CHECKFUNC(...) {\n    ...\n    VaultReentrancyLib.ensureNotInVaultContext(...);\n    ...\n  }\n  ...\n  function $F(...) {\n    ...\n    $CHECKFUNC(...);\n    ...\n    $RETURN = $VAULT.getPoolTokens(...);\n    ...\n  }\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "contract $C {\n  ...\n  function $CHECKFUNC(...) {\n    ...\n    VaultReentrancyLib.ensureNotInVaultContext(...);\n    ...\n  }\n  ...\n  function $F(...) {\n    ...\n    $RETURN = $VAULT.getPoolTokens(...);\n    ...\n    $CHECKFUNC(...);\n    ...\n  }\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "contract $C {\n  ...\n  function $CHECKFUNC(...) {\n    ...\n    $VAULT.manageUserBalance(...);\n    ...\n  }\n  ...\n  function $F(...) {\n    ...\n    $RETURN = $VAULT.getPoolTokens(...);\n    ...\n    $CHECKFUNC(...);\n    ...\n  }\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "contract $C {\n  ...\n  function $CHECKFUNC(...) {\n    ...\n    $VAULT.manageUserBalance(...);\n    ...\n  }\n  ...\n  function $F(...) {\n    ...\n    $CHECKFUNC(...);\n    ...\n    $RETURN = $VAULT.getPoolTokens(...);\n    ...\n  }\n  ...\n}\n"
        },
        {
          "pattern-not": "function $F(...) {\n  ...\n  VaultReentrancyLib.ensureNotInVaultContext(...);\n  ...\n}\n"
        },
        {
          "pattern-not": "function $F(...) {\n  ...\n  $VAULT.manageUserBalance(...);\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "contract LinearPool {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "contract ComposableStablePool {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "contract BalancerQueries {\n  ...\n} \n"
        },
        {
          "pattern-not-inside": "contract ManagedPool {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "contract BaseWeightedPool {\n  ...\n} \n"
        },
        {
          "pattern-not-inside": "contract ComposableStablePoolStorage {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "contract RecoveryModeHelper {\n  ...\n}\n"
        },
        {
          "focus-metavariable": [
            "$VAULT"
          ]
        }
      ],
      "languages": [
        "solidity"
      ],
      "severity": "ERROR"
    },
    {
      "id": "solidity.security.balancer-readonly-reentrancy-getrate.balancer-readonly-reentrancy-getrate",
      "message": "The contract calls `getRate()` on a Balancer pool without protection against read-only reentrancy attacks. This vulnerability enables attackers to manipulate exchange rate readings through malicious callbacks. Without proper guards, inconsistent rates can be exploited to execute trades at favorable conditions, resulting in financial losses.",
      "metadata": {
        "category": "security",
        "technology": [
          "solidity"
        ],
        "cwe": "CWE-841: Improper Enforcement of Behavioral Workflow",
        "confidence": "HIGH",
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "subcategory": [
          "vuln"
        ],
        "references": [
          "https://forum.balancer.fi/t/reentrancy-vulnerability-scope-expanded/4345"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Balancer getRate() vulnerable to read-only reentrancy",
        "fix-suggestion": "Implement reentrancy protection before calling `getRate()` using a guard pattern, or cache the rate value before making external calls. Consider using a reentrancy lock or retrieving rates through a more secure interface that prevents callback manipulation."
      },
      "patterns": [
        {
          "pattern": "function $F(...) {\n  ...\n  $VAR.getRate();\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "function $F(...) {\n  ...\n  VaultReentrancyLib.ensureNotInVaultContext(...);\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "function $F(...) {\n  ...\n  $VAULT.manageUserBalance(...);\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "function _updateTokenRateCache(...) {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "contract PoolRecoveryHelper {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "contract ComposableStablePoolRates {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "contract WeightedPoolProtocolFees {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "contract $C {\n  ...\n  function $CHECKFUNC(...) {\n    ...\n    VaultReentrancyLib.ensureNotInVaultContext(...);\n    ...\n  }\n  ...\n  function $F(...) {\n    ...\n    $CHECKFUNC(...);\n    ...\n    $VAR.getRate();\n    ...\n  }\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "contract $C {\n  ...\n  function $CHECKFUNC(...) {\n    ...\n    VaultReentrancyLib.ensureNotInVaultContext(...);\n    ...\n  }\n  ...\n  function $F(...) {\n    ...\n    $VAR.getRate();\n    ...\n    $CHECKFUNC(...);\n    ...\n  }\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "contract $C {\n  ...\n  function $CHECKFUNC(...) {\n    ...\n    $VAULT.manageUserBalance(...);\n    ...\n  }\n  ...\n  function $F(...) {\n    ...\n    $VAR.getRate();\n    ...\n    $CHECKFUNC(...);\n    ...\n  }\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "contract $C {\n  ...\n  function $CHECKFUNC(...) {\n    ...\n    $VAULT.manageUserBalance(...);\n    ...\n  }\n  ...\n  function $F(...) {\n    ...\n    $CHECKFUNC(...);\n    ...\n    $VAR.getRate();\n    ...\n  }\n  ...\n}\n"
        },
        {
          "focus-metavariable": "$VAR"
        }
      ],
      "languages": [
        "solidity"
      ],
      "severity": "ERROR"
    },
    {
      "id": "solidity.security.compound-borrowfresh-reentrancy.compound-borrowfresh-reentrancy",
      "message": "The `borrowFresh()` function updates state after performing an external call via `doTransferOut()`. This creates a classic reentrancy vulnerability where the external call may execute malicious code before state updates occur. An attacker could potentially re-enter the function and borrow multiple times against the same collateral.",
      "metadata": {
        "category": "security",
        "technology": [
          "solidity"
        ],
        "cwe": "CWE-841: Improper Enforcement of Behavioral Workflow",
        "confidence": "HIGH",
        "likelihood": "LOW",
        "impact": "HIGH",
        "subcategory": [
          "vuln"
        ],
        "references": [
          "https://twitter.com/peckshield/status/1509431646818234369",
          "https://twitter.com/blocksecteam/status/1509466576848064512",
          "https://slowmist.medium.com/another-day-another-reentrancy-attack-5cde10bbb2b4",
          "https://explorer.fuse.io/address/0x139Eb08579eec664d461f0B754c1F8B569044611"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Reentrancy vulnerability in Compound borrowing function",
        "fix-suggestion": "Restructure the `borrowFresh()` function to follow the checks-effects-interactions pattern. Update all state variables before making the external `doTransferOut()` call, or implement a reentrancy guard using a mutex pattern to prevent multiple reentrant calls."
      },
      "patterns": [
        {
          "pattern-inside": "function borrowFresh(...) {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "accountBorrows[borrower].interestIndex = borrowIndex;\n...\n"
        },
        {
          "pattern": "doTransferOut(...);"
        }
      ],
      "languages": [
        "solidity"
      ],
      "severity": "WARNING"
    },
    {
      "id": "solidity.security.compound-sweeptoken-not-restricted.compound-sweeptoken-not-restricted",
      "message": "The `sweepToken` function lacks access controls, allowing anyone to call it. This function typically transfers tokens out of the contract to a specified address. Without proper restrictions, attackers can drain any ERC20 tokens accidentally sent to the contract.",
      "metadata": {
        "category": "security",
        "technology": [
          "solidity"
        ],
        "cwe": "CWE-284: Improper Access Control",
        "confidence": "MEDIUM",
        "likelihood": "LOW",
        "impact": "HIGH",
        "subcategory": [
          "vuln"
        ],
        "references": [
          "https://medium.com/chainsecurity/trueusd-compound-vulnerability-bc5b696d29e2",
          "https://chainsecurity.com/security-audit/compound-ctoken/",
          "https://blog.openzeppelin.com/compound-comprehensive-protocol-audit/",
          "https://etherscan.io/address/0xa035b9e130f2b1aedc733eefb1c67ba4c503491f"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Unrestricted token sweeping function without access controls",
        "fix-suggestion": "Add an access control modifier like `onlyAdmin` or `onlyOwner` to the `sweepToken` function to restrict who can call it. Implement a role-based access control system using OpenZeppelin's `AccessControl` library to manage permissions properly."
      },
      "patterns": [
        {
          "pattern-inside": "function sweepToken(...) {\n...\n}\n"
        },
        {
          "pattern-not-inside": "function sweepToken(...) $M {\n...\n}\n"
        },
        {
          "pattern": "token.transfer(...);"
        },
        {
          "pattern-not-inside": "require(msg.sender == admin, \"...\");\n...\n"
        },
        {
          "pattern-not-inside": "require(_msgSender() == admin, \"...\");\n...\n"
        }
      ],
      "languages": [
        "solidity"
      ],
      "severity": "WARNING"
    },
    {
      "id": "solidity.security.curve-readonly-reentrancy.curve-readonly-reentrancy",
      "message": "The contract calls `get_virtual_price()` on a Curve pool without protection against read-only reentrancy attacks. This vulnerability allows attackers to manipulate the virtual price during calculations, leading to incorrect pricing. DeFi protocols relying on these price feeds may execute trades at unfavorable rates, resulting in financial losses.",
      "metadata": {
        "category": "security",
        "technology": [
          "solidity"
        ],
        "cwe": "CWE-841: Improper Enforcement of Behavioral Workflow",
        "confidence": "HIGH",
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "subcategory": [
          "vuln"
        ],
        "references": [
          "https://chainsecurity.com/heartbreaks-curve-lp-oracles/",
          "https://chainsecurity.com/curve-lp-oracle-manipulation-post-mortem/"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Curve pool price oracle vulnerable to reentrancy",
        "fix-suggestion": "Implement a reentrancy guard before calling `get_virtual_price()` or cache the value to prevent multiple reads within the same transaction. Consider using the Chainlink Price Oracle which has built-in protections against these types of attacks."
      },
      "patterns": [
        {
          "pattern": "$POOL.get_virtual_price()\n"
        },
        {
          "pattern-not-inside": "function $F(...) {\n  ...\n  $VAR.withdraw_admin_fees(...);\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "function $F(...) {\n  ...\n  $VAR.withdraw_admin_fees(...);\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "contract $C {\n  ...\n  function $CHECKFUNC(...) {\n    ...\n    $VAR.withdraw_admin_fees(...);\n    ...\n  }\n  ...\n  function $F(...) {\n    ...\n    $CHECKFUNC(...);\n    ...\n    $POOL.get_virtual_price();\n    ...\n  }\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "contract $C {\n  ...\n  function $CHECKFUNC(...) {\n    ...\n    $VAR.withdraw_admin_fees(...);\n    ...\n  }\n  ...\n  function $F(...) {\n    ...\n    $POOL.get_virtual_price();\n    ...\n    $CHECKFUNC(...);\n    ...\n  }\n  ...\n}\n"
        }
      ],
      "languages": [
        "solidity"
      ],
      "severity": "ERROR"
    },
    {
      "id": "solidity.security.encode-packed-collision.encode-packed-collision",
      "message": "The function uses `abi.encodePacked()` with multiple variable-length arguments, creating potential hash collision vulnerabilities. With variable-length inputs, different parameter combinations can produce identical encoded outputs. Attackers could exploit this to forge signatures or manipulate hashed data structures.",
      "metadata": {
        "category": "security",
        "technology": [
          "solidity"
        ],
        "cwe": "CWE-20: Improper Input Validation",
        "confidence": "HIGH",
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "subcategory": [
          "vuln"
        ],
        "references": [
          "https://swcregistry.io/docs/SWC-133"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "Hash collision risk in abi.encodePacked usage",
        "fix-suggestion": "Replace `abi.encodePacked()` with `abi.encode()` which includes type information and prevents collisions. Alternatively, if gas optimization is necessary, separate variable-length arguments with fixed-length arguments or use `abi.encodePacked(arg1, abi.encodePacked(arg2))` to avoid collisions."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "function $F(..., bytes $A, ..., bytes $B, ...) public {\n  ...\n}\n"
            },
            {
              "pattern-inside": "function $F(..., string $A, ..., string $B, ...) public {\n  ...\n}\n"
            },
            {
              "pattern-inside": "function $F(..., bytes $A, ..., string $B, ...) public {\n  ...\n}\n"
            },
            {
              "pattern-inside": "function $F(..., string $A, ..., bytes $B, ...) public {\n  ...\n}\n"
            },
            {
              "pattern-inside": "function $F(..., address[] $A, ..., address[] $B, ...) public {\n  ...\n}\n"
            },
            {
              "pattern-inside": "function $F(..., uint256[] $A, ..., uint256[] $B, ...) public {\n  ...\n}\n"
            },
            {
              "pattern-inside": "function $F(..., bytes $A, ..., bytes $B, ...) external {\n  ...\n}\n"
            },
            {
              "pattern-inside": "function $F(..., string $A, ..., string $B, ...) external {\n  ...\n}\n"
            },
            {
              "pattern-inside": "function $F(..., bytes $A, ..., string $B, ...) external {\n  ...\n}\n"
            },
            {
              "pattern-inside": "function $F(..., string $A, ..., bytes $B, ...) external {\n  ...\n}\n"
            },
            {
              "pattern-inside": "function $F(..., address[] $A, ..., address[] $B, ...) external {\n  ...\n}\n"
            },
            {
              "pattern-inside": "function $F(..., uint256[] $A, ..., uint256[] $B, ...) external {\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern": "keccak256(abi.encodePacked(..., $A, $B, ...))\n"
            },
            {
              "pattern": "$X = abi.encodePacked(..., $A, $B, ...);\n...\nkeccak256($X);\n"
            }
          ]
        }
      ],
      "languages": [
        "solidity"
      ],
      "severity": "ERROR"
    },
    {
      "id": "solidity.security.erc677-reentrancy.erc677-reentrancy",
      "message": "The ERC677 token implementation contains a reentrancy vulnerability in the `callAfterTransfer()` function. This function makes an external call to the recipient before completing all state changes. Malicious recipients can exploit this to re-enter the contract and manipulate token balances or execute unauthorized operations.",
      "metadata": {
        "category": "security",
        "technology": [
          "solidity"
        ],
        "cwe": "CWE-841: Improper Enforcement of Behavioral Workflow",
        "confidence": "HIGH",
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "subcategory": [
          "vuln"
        ],
        "references": [
          "https://twitter.com/peckshield/status/1509431646818234369",
          "https://twitter.com/blocksecteam/status/1509466576848064512",
          "https://explorer.fuse.io/address/0x139Eb08579eec664d461f0B754c1F8B569044611",
          "https://explorer.fuse.io/address/0x5De15b5543c178C111915d6B8ae929Af01a8cC58"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Reentrancy vulnerability in ERC677 token implementation",
        "fix-suggestion": "Restructure the code to follow the checks-effects-interactions pattern by updating all state variables before making external calls in `callAfterTransfer()`. Alternatively, implement a reentrancy guard using a mutex pattern or use OpenZeppelin's `ReentrancyGuard` contract."
      },
      "patterns": [
        {
          "pattern-inside": "function transfer(...) {\n    ...\n}\n"
        },
        {
          "pattern": "callAfterTransfer(...);"
        }
      ],
      "languages": [
        "solidity"
      ],
      "severity": "WARNING"
    },
    {
      "id": "solidity.security.erc721-arbitrary-transferfrom.erc721-arbitrary-transferfrom",
      "message": "Your custom ERC721 implementation is missing proper access control checks in the `_transfer()` function. This allows unauthorized transfers of tokens without ownership validation. Attackers could potentially transfer any NFT to themselves without approval, resulting in theft of digital assets.",
      "metadata": {
        "category": "security",
        "technology": [
          "solidity"
        ],
        "cwe": "CWE-284: Improper Access Control",
        "confidence": "MEDIUM",
        "likelihood": "HIGH",
        "impact": "HIGH",
        "subcategory": [
          "vuln"
        ],
        "references": [
          "https://twitter.com/BlockSecAlert/status/1516289618605654024",
          "https://etherscan.io/address/0xf3821adaceb6500c0a202971aecf840a033f236b"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Missing ownership validation in ERC721 transfers",
        "fix-suggestion": "Add ownership validation in the `_transfer()` function to ensure only the token owner or approved addresses can transfer tokens. Implement checks such as `require(ownerOf(tokenId) == msg.sender || getApproved(tokenId) == msg.sender || isApprovedForAll(ownerOf(tokenId), msg.sender))` before allowing transfers."
      },
      "patterns": [
        {
          "pattern-inside": "function _transfer(...) {\n...\n}\n"
        },
        {
          "pattern-inside": "require(prevOwnership.addr == $FROM, ...);\n...\n"
        },
        {
          "pattern-not-inside": "(<... _msgSender() == $FROM ...>);\n...\n"
        },
        {
          "pattern-not-inside": "(<... _msgSender() == $PREV.$ADDR ...>);\n...\n"
        },
        {
          "pattern-not-inside": "(<... msg.sender == $FROM ...>);\n...\n"
        },
        {
          "pattern-not-inside": "require(_isApprovedOrOwner(...), ...);\n...\n"
        },
        {
          "pattern": "_approve(...);"
        }
      ],
      "languages": [
        "solidity"
      ],
      "severity": "WARNING"
    },
    {
      "id": "solidity.security.erc721-reentrancy.erc721-reentrancy",
      "message": "The contract performs state changes after calling `onERC721Received()` during token transfers, creating a reentrancy vulnerability. This callback function allows recipient contracts to execute arbitrary code during the transfer. Malicious contracts can exploit this to re-enter your contract and manipulate its state before updates are completed.",
      "metadata": {
        "category": "security",
        "technology": [
          "solidity"
        ],
        "cwe": "CWE-841: Improper Enforcement of Behavioral Workflow",
        "confidence": "HIGH",
        "likelihood": "LOW",
        "impact": "HIGH",
        "subcategory": [
          "vuln"
        ],
        "references": [
          "https://blocksecteam.medium.com/when-safemint-becomes-unsafe-lessons-from-the-hypebears-security-incident-2965209bda2a",
          "https://etherscan.io/address/0x14e0a1f310e2b7e321c91f58847e98b8c802f6ef"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Reentrancy vulnerability in ERC721 token transfers",
        "fix-suggestion": "Follow the checks-effects-interactions pattern by updating all state variables before calling `onERC721Received()`. Alternatively, implement a reentrancy guard using the `nonReentrant` modifier from OpenZeppelin's `ReentrancyGuard` contract to prevent multiple reentrant calls."
      },
      "patterns": [
        {
          "pattern": "_checkOnERC721Received(...)"
        }
      ],
      "languages": [
        "solidity"
      ],
      "severity": "WARNING"
    },
    {
      "id": "solidity.security.erc777-reentrancy.erc777-reentrancy",
      "message": "The contract interacts with ERC777 tokens but lacks protection against reentrancy attacks via the `tokensReceived()` hook. This hook allows recipient contracts to execute arbitrary code during token transfers. Without proper guards, malicious contracts can re-enter your functions and exploit intermediate contract states.",
      "metadata": {
        "category": "security",
        "technology": [
          "solidity"
        ],
        "cwe": "CWE-841: Improper Enforcement of Behavioral Workflow",
        "confidence": "HIGH",
        "likelihood": "LOW",
        "impact": "HIGH",
        "subcategory": [
          "vuln"
        ],
        "references": [
          "https://mirror.xyz/baconcoin.eth/LHaPiX38mnx8eJ2RVKNXHttHfweQMKNGmEnX4KUksk0",
          "https://etherscan.io/address/0xf53f00f844b381963a47fde3325011566870b31f"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Reentrancy vulnerability through ERC777 hooks",
        "fix-suggestion": "Implement a reentrancy guard using OpenZeppelin's `ReentrancyGuard` contract and add the `nonReentrant` modifier to functions that interact with ERC777 tokens. Alternatively, follow the checks-effects-interactions pattern by updating all state before interacting with external ERC777 tokens."
      },
      "patterns": [
        {
          "pattern": "$X.tokensReceived(...);"
        }
      ],
      "languages": [
        "solidity"
      ],
      "severity": "WARNING"
    },
    {
      "id": "solidity.security.incorrect-use-of-blockhash.incorrect-use-of-blockhash",
      "message": "The contract attempts to access the hash of the current or future blocks, which always returns zero. Solidity's `blockhash()` function only returns valid hashes for the 256 most recent blocks, excluding the current one. This incorrect usage may lead to unexpected behavior or vulnerabilities in randomness generation.",
      "metadata": {
        "category": "security",
        "technology": [
          "solidity"
        ],
        "cwe": "CWE-341: Predictable from Observable State",
        "confidence": "HIGH",
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "subcategory": [
          "vuln"
        ],
        "references": [
          "https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Invalid block hash access for current or future blocks",
        "fix-suggestion": "Use `blockhash(block.number - 1)` to access the previous block's hash, or implement a more secure randomness source like Chainlink VRF. For historical blocks, ensure you're only accessing the 256 most recent blocks, as `blockhash(block.number - n)` returns zero for n > 256."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "blockhash(block.number)"
            },
            {
              "pattern": "blockhash(block.number + $N)"
            },
            {
              "pattern": "blockhash(block.number * $N)"
            },
            {
              "pattern": "block.blockhash(block.number)"
            },
            {
              "pattern": "block.blockhash(block.number + $N)"
            },
            {
              "pattern": "block.blockhash(block.number * $N)"
            }
          ]
        }
      ],
      "severity": "ERROR",
      "languages": [
        "solidity"
      ]
    },
    {
      "id": "solidity.security.keeper-network-oracle-manipulation.keeper-network-oracle-manipulation",
      "message": "The contract uses `Keep3rV2.current()` for price data, which can be easily manipulated by attackers. Despite providing fresh data, this oracle requires control of only two data points to significantly impact the price feed. Price manipulation can lead to unfair liquidations, incorrect swap rates, or exploitable arbitrage opportunities.",
      "metadata": {
        "category": "security",
        "technology": [
          "solidity"
        ],
        "cwe": "CWE-682: Incorrect Calculation",
        "confidence": "HIGH",
        "likelihood": "LOW",
        "impact": "HIGH",
        "subcategory": [
          "vuln"
        ],
        "references": [
          "https://twitter.com/peckshield/status/1510232640338608131",
          "https://twitter.com/FrankResearcher/status/1510239094777032713",
          "https://twitter.com/larry0x/status/1510263618180464644",
          "https://andrecronje.medium.com/keep3r-network-on-chain-oracle-price-feeds-3c67ed002a9",
          "https://etherscan.io/address/0x210ac53b27f16e20a9aa7d16260f84693390258f"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Easily manipulated price oracle with low security",
        "fix-suggestion": "Replace `Keep3rV2.current()` with a more secure price oracle like Chainlink, which has multiple independent validators and stronger manipulation resistance. Consider implementing a Time-Weighted Average Price (TWAP) mechanism or using multiple oracle sources with median selection to increase manipulation resistance."
      },
      "patterns": [
        {
          "pattern": "$KEEPER.current($TOKENIN, $AMOUNTIN, $TOKENOUT);"
        }
      ],
      "languages": [
        "solidity"
      ],
      "severity": "WARNING"
    },
    {
      "id": "solidity.security.missing-self-transfer-check-ercx.missing-self-transfer-check-ercx",
      "languages": [
        "solidity"
      ],
      "message": "The token contract doesn't check if the sender and recipient are the same address in transfer functions. Without this validation, self-transfers may incorrectly manipulate token balances due to rounding errors or fee calculations. This could lead to unintended token creation or destruction, compromising the token's supply integrity.",
      "severity": "ERROR",
      "metadata": {
        "category": "security",
        "technology": [
          "blockchain",
          "solidity"
        ],
        "cwe": "CWE-682: Incorrect Calculation",
        "subcategory": [
          "vuln"
        ],
        "confidence": "HIGH",
        "likelihood": "HIGH",
        "impact": "HIGH",
        "owasp": [
          "A7:2021 Identification and Authentication Failures"
        ],
        "references": [
          "https://blog.verichains.io/p/miner-project-attacked-by-vulnerabilities",
          "https://x.com/shoucccc/status/1757777764646859121"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "Missing validation for self-transfers in token contract",
        "fix-suggestion": "Add a condition to check if `from` and `to` addresses are identical before processing transfers. Implement `if (from == to) return true;` or a similar early-return pattern at the beginning of your transfer functions to handle self-transfers appropriately without unnecessary state changes."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "_balances[$FROM] = $FROM_BALANCE - value;\n"
            },
            {
              "pattern": "_balances[$TO] = $TO_BALANCE + value;\n"
            }
          ]
        },
        {
          "pattern-not-inside": "if ($FROM != $TO) {\n  ...\n  _balances[$FROM] = $FROM_BALANCE - value;\n  ...\n  _balances[$TO] = $TO_BALANCE + value;\n  ...\n}\n"
        },
        {
          "pattern-inside": "function _update(address $FROM, address $TO, uint256 value, bool mint) internal virtual {\n  ...\n}\n"
        }
      ]
    },
    {
      "id": "solidity.security.no-bidi-characters.no-bidi-characters",
      "message": "Unicode bidirectional control characters were detected in your code. These characters can be used to manipulate text display order without changing the underlying characters. Attackers could use them to disguise malicious code, making harmful functions appear legitimate to code reviewers.",
      "metadata": {
        "category": "security",
        "technology": [
          "solidity"
        ],
        "cwe": "CWE-837: Improper Enforcement of a Single, Unique Action",
        "confidence": "HIGH",
        "likelihood": "LOW",
        "impact": "LOW",
        "subcategory": [
          "audit"
        ],
        "references": [
          "https://entethalliance.org/specs/ethtrust-sl/v1/#req-1-unicode-bdo"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Bidirectional Unicode characters in source code",
        "fix-suggestion": "Remove all Unicode bidirectional control characters from your source code including RLO, LRO, RLE, LRE, and others. Use a specialized tool or editor that can identify and highlight these invisible control characters, then replace them with standard ASCII characters."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-regex": "\u202a"
            },
            {
              "pattern-regex": "\u202b"
            },
            {
              "pattern-regex": "\u202d"
            },
            {
              "pattern-regex": "\u202e"
            },
            {
              "pattern-regex": "\u2066"
            },
            {
              "pattern-regex": "\u2067"
            },
            {
              "pattern-regex": "\u2068"
            },
            {
              "pattern-regex": "\u202c"
            },
            {
              "pattern-regex": "\u2069"
            }
          ]
        }
      ],
      "languages": [
        "solidity"
      ],
      "severity": "WARNING"
    },
    {
      "id": "solidity.security.no-slippage-check.no-slippage-check",
      "message": "The contract performs Uniswap trades without slippage protection. Without minimum output checks, trades are vulnerable to front-running and sandwich attacks. Malicious actors can manipulate the price just before your transaction executes, causing you to receive significantly fewer tokens than expected.",
      "metadata": {
        "category": "security",
        "technology": [
          "solidity"
        ],
        "cwe": "CWE-682: Incorrect Calculation",
        "confidence": "MEDIUM",
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "subcategory": [
          "vuln"
        ],
        "references": [
          "https://uniswapv3book.com/docs/milestone_3/slippage-protection/"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Missing slippage protection in Uniswap trades",
        "fix-suggestion": "Add a minimum output amount parameter to your swap function and pass it to Uniswap as `amountOutMin`. Implement a check like to ensure the trade meets minimum expectations,or use Uniswap's built-in slippage protection parameters."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$X.swapExactTokensForTokens($A, $LIMIT, $B, $C, $D)"
            },
            {
              "pattern": "$X.swapExactTokensForTokensSupportingFeeOnTransferTokens($A, $LIMIT, $B, $C, $D)"
            },
            {
              "pattern": "$X.swapExactTokensForETH($A, $LIMIT, $B, $C, $D)"
            },
            {
              "pattern": "$X.swapExactTokensForETHSupportingFeeOnTransferTokens($A, $LIMIT, $B, $C, $D)"
            },
            {
              "pattern": "$X.swapExactETHForTokens{$VALUE:...}($LIMIT, $A, $B, $C)"
            },
            {
              "pattern": "$X.swapExactETHForTokensSupportingFeeOnTransferTokens{$VALUE:...}($LIMIT, $A, $B, $C)"
            },
            {
              "pattern": "$X.swapTokensForExactTokens($A, $LIMIT, $B, $C, $D)"
            },
            {
              "pattern": "$X.swapTokensForExactETH($A, $LIMIT, $B, $C, $D)"
            },
            {
              "pattern": "function $FUNC(...) {\n  ...\n  $Y = $SWAPROUTER.ExactInputSingleParams({\n    tokenIn: $A, \n    tokenOut: $B, \n    fee: $C, \n    recipient: $D, \n    deadline: $E, \n    amountIn: $F, \n    amountOutMinimum: $LIMIT, \n    sqrtPriceLimitX96: 0\n  });\n  ...\n  $X.exactInputSingle($Y);\n  ...\n}\n"
            },
            {
              "pattern": "$X.exactInputSingle($SWAPROUTER.ExactInputSingleParams({\n  tokenIn: $A,\n  tokenOut: $B,\n  fee: $C,\n  recipient: $D,\n  deadline: $E,\n  amountIn: $F,\n  amountOutMinimum: $LIMIT,\n  sqrtPriceLimitX96: 0\n}));\n"
            },
            {
              "pattern": "function $FUNC(...) {\n  ...\n  $Y = $SWAPROUTER.ExactOutputSingleParams({\n    tokenIn: $A,\n    tokenOut: $B,\n    fee: $C,\n    recipient: $D,\n    deadline: $E,\n    amountOut: $F,\n    amountInMaximum: $LIMIT,\n    sqrtPriceLimitX96: 0\n  });\n  ...\n  $X.exactOutputSingle($Y);\n  ...\n}\n"
            },
            {
              "pattern": "$X.exactOutputSingle($SWAPROUTER.ExactOutputSingleParams({\n  tokenIn: $A,\n  tokenOut: $B,\n  fee: $C,\n  recipient: $D,\n  deadline: $E,\n  amountOut: $F,\n  amountInMaximum: $LIMIT,\n  sqrtPriceLimitX96: 0\n}));\n"
            },
            {
              "pattern": "$X.swap($RECIPIENT, $ZEROFORONE, $AMOUNTIN, $LIMIT, $DATA)"
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$LIMIT",
            "regex": "^(0)|(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)|(type\\(uint(256)?\\)\\.max)|(uint(256)?\\(-1)|(115792089237316195423570985008687907853269984665640564039457584007913129639935)|(2\\s?\\*\\*\\s?256\\s?-\\s?1)$"
          }
        }
      ],
      "languages": [
        "solidity"
      ],
      "severity": "ERROR"
    },
    {
      "id": "solidity.security.proxy-storage-collision.proxy-storage-collision",
      "message": "The proxy contract declares state variables that could collide with the implementation contract's storage layout. Storage collisions in proxy patterns can corrupt data or cause unexpected behavior when the implementation accesses its variables. This can lead to critical vulnerabilities including loss of funds or contract lockouts.",
      "metadata": {
        "category": "security",
        "technology": [
          "solidity"
        ],
        "cwe": "CWE-787: Out-of-bounds Write",
        "confidence": "HIGH",
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "subcategory": [
          "vuln"
        ],
        "references": [
          "https://blog.audius.co/article/audius-governance-takeover-post-mortem-7-23-22"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Storage collision risk in proxy contract pattern",
        "fix-suggestion": "Move state variables from the proxy contract to a separate storage contract, or use OpenZeppelin's `ERC1967Proxy` pattern with specific storage slots. Implement the Unstructured Storage pattern where the proxy uses specific storage slots (like `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`) instead of standard state variables."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "contract $CONTRACT is ..., $PROXY, ... {\n    ...\n    $TYPE $VAR;\n    ...\n    constructor(...) {\n        ...\n    }\n    ...\n}\n"
            },
            {
              "pattern": "contract $CONTRACT is ..., $PROXY, ... {\n    ...\n    $TYPE $VAR = ...;\n    ...\n    constructor(...) {\n        ...\n    }\n    ...\n}\n"
            }
          ]
        },
        {
          "pattern-not": "contract $CONTRACT is ..., $PROXY, ... {\n    $TYPE immutable $VAR;\n    ...\n    constructor(...) {\n        ...\n    }\n    ...\n}\n"
        },
        {
          "pattern-not": "contract $CONTRACT is ..., $PROXY, ... {\n    $TYPE immutable $VAR = ...;\n    ...\n    constructor(...) {\n        ...\n    }\n    ...\n}\n"
        },
        {
          "pattern-not": "contract $CONTRACT is ..., $PROXY, ... {\n    $TYPE constant $VAR = ...;\n    ...\n    constructor(...) {\n        ...\n    }\n    ...\n}\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$CONTRACT",
            "regex": "^(?!AdminUpgradeabilityProxy|OwnedUpgrade*abilityProxy).*$"
          }
        },
        {
          "metavariable-regex": {
            "metavariable": "$PROXY",
            "regex": "(UpgradeabilityProxy|AdminUpgradeabilityProxy|OwnedUpgrade*abilityProxy|TransparentUpgradeableProxy|ERC1967Proxy)"
          }
        },
        {
          "focus-metavariable": "$PROXY"
        }
      ],
      "languages": [
        "solidity"
      ],
      "severity": "WARNING"
    },
    {
      "id": "solidity.security.redacted-cartel-custom-approval-bug.redacted-cartel-custom-approval-bug",
      "message": "The `transferFrom()` implementation contains a vulnerability similar to the Redacted Cartel bug. This flaw allows attackers to steal token allowances belonging to other accounts. By manipulating function parameters, attackers can spend tokens they shouldn't have access to, potentially draining approved tokens from many accounts.",
      "metadata": {
        "category": "security",
        "technology": [
          "solidity"
        ],
        "cwe": "CWE-688: Function Call With Incorrect Variable or Reference as Argument",
        "confidence": "HIGH",
        "likelihood": "HIGH",
        "impact": "HIGH",
        "subcategory": [
          "vuln"
        ],
        "references": [
          "https://medium.com/immunefi/redacted-cartel-custom-approval-logic-bugfix-review-9b2d039ca2c5",
          "https://etherscan.io/address/0x186E55C0BebD2f69348d94C4A27556d93C5Bd36C"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Authorization bypass in transferFrom() stealing allowances",
        "fix-suggestion": "Fix the `transferFrom()` function by properly validating that `msg.sender` has sufficient allowance from the `from` address. Ensure you're using the correct variables in your allowance check: `require(_allowances[from][msg.sender] >= amount, \"ERC20: insufficient allowance\")` to prevent unauthorized transfers."
      },
      "patterns": [
        {
          "pattern-inside": "function transferFrom(...) {\n...\n}\n"
        },
        {
          "pattern": "_approve(..., allowance(sender, recipient).sub(amount, ...), ...);"
        }
      ],
      "languages": [
        "solidity"
      ],
      "severity": "ERROR"
    },
    {
      "id": "solidity.security.rigoblock-missing-access-control.rigoblock-missing-access-control",
      "message": "The `setMultipleAllowances()` function lacks appropriate access controls. This critical function can modify multiple token allowances but can be called by anyone. Without access restrictions, attackers can authorize themselves or others to spend tokens from the contract, potentially leading to theft of all tokens.",
      "metadata": {
        "category": "security",
        "technology": [
          "solidity"
        ],
        "cwe": "CWE-284: Improper Access Control",
        "confidence": "HIGH",
        "likelihood": "HIGH",
        "impact": "HIGH",
        "subcategory": [
          "vuln"
        ],
        "references": [
          "https://twitter.com/danielvf/status/1494317265835147272",
          "https://etherscan.io/address/0x876b9ebd725d1fa0b879fcee12560a6453b51dc8",
          "https://play.secdim.com/game/dapp/challenge/rigoownsol"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Missing access control on token allowance function",
        "fix-suggestion": "Add the `onlyOwner` modifier to the `setMultipleAllowances()` function to restrict its usage to authorized accounts only. If you need more granular control, implement a role-based access control system using OpenZeppelin's `AccessControl` library with a specific role for allowance management."
      },
      "patterns": [
        {
          "pattern": "function setMultipleAllowances(...) {...}"
        },
        {
          "pattern-not": "function setMultipleAllowances(...) onlyOwner {...}"
        }
      ],
      "languages": [
        "solidity"
      ],
      "severity": "ERROR"
    },
    {
      "id": "solidity.security.sense-missing-oracle-access-control.sense-missing-oracle-access-control",
      "message": "The oracle update function lacks access control restrictions. This allows anyone to update critical price or data feeds that your contract relies on for financial decisions. Malicious actors can manipulate oracle data to trigger unfavorable trades, incorrect liquidations, or other exploitative actions.",
      "metadata": {
        "category": "security",
        "technology": [
          "solidity"
        ],
        "cwe": "CWE-284: Improper Access Control",
        "confidence": "MEDIUM",
        "likelihood": "HIGH",
        "impact": "HIGH",
        "subcategory": [
          "vuln"
        ],
        "author": "https://twitter.com/ArbazKiraak",
        "references": [
          "https://medium.com/immunefi/sense-finance-access-control-issue-bugfix-review-32e0c806b1a0"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Unrestricted oracle updates without access controls",
        "fix-suggestion": "Implement access control on the oracle update function using modifiers like `onlyOwner` or a more granular role-based system. Consider using Chainlink's oracle network which has built-in security controls, or implement a multi-oracle system requiring consensus before accepting data updates."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "function $F(...,$D $REQUEST,...) external {\n    ...\n}\n"
            },
            {
              "pattern-inside": "function $F(...,$D $REQUEST,...) public {\n    ...\n}\n"
            }
          ]
        },
        {
          "pattern-not-inside": "function $F(...,$D $REQUEST,...) external onlyVault(...) {\n    ...\n}\n"
        },
        {
          "patterns": [
            {
              "pattern": "_updateOracle($LASTBLOCK,...,...)"
            },
            {
              "pattern-not-inside": "...\nif (msg.sender == $BALANCER) { ... }\n...\n"
            },
            {
              "pattern-not-inside": "...\nrequire(msg.sender == address($BALANCER),...);\n...\n"
            },
            {
              "pattern-not-inside": "...\nif (_msgSender() == $BALANCER) { ... }\n...\n"
            },
            {
              "pattern-not-inside": "...\nrequire(_msgSender() == address($BALANCER),...);\n...\n"
            }
          ]
        }
      ],
      "languages": [
        "solidity"
      ],
      "severity": "ERROR"
    },
    {
      "id": "solidity.security.superfluid-ctx-injection.superfluid-ctx-injection",
      "message": "The contract is vulnerable to context injection attacks when interacting with Superfluid protocol. By crafting specific calldata, attackers can manipulate the context parameter to impersonate other accounts. This can lead to unauthorized actions being performed with elevated privileges, potentially resulting in theft of funds or manipulation of contract state.",
      "metadata": {
        "category": "security",
        "technology": [
          "solidity"
        ],
        "cwe": "CWE-20: Improper Input Validation",
        "confidence": "HIGH",
        "likelihood": "HIGH",
        "impact": "HIGH",
        "subcategory": [
          "vuln"
        ],
        "references": [
          "https://rekt.news/superfluid-rekt/",
          "https://medium.com/superfluid-blog/08-02-22-exploit-post-mortem-15ff9c97cdd",
          "https://polygonscan.com/address/0x07711bb6dfbc99a1df1f2d7f57545a67519941e7"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "Context injection vulnerability in Superfluid integration",
        "fix-suggestion": "Validate all incoming context parameters before using them in Superfluid operations. Implement proper sanitization by using Superfluid's `_validateCtx` function, or follow the recommended pattern of handling context data as demonstrated in Superfluid's official examples and documentation."
      },
      "patterns": [
        {
          "pattern": "$T.decodeCtx(ctx);"
        },
        {
          "pattern-not-inside": "require($T.isCtxValid(...), \"...\");\n...\n"
        }
      ],
      "languages": [
        "solidity"
      ],
      "severity": "ERROR"
    },
    {
      "id": "solidity.security.tecra-coin-burnfrom-bug.tecra-coin-burnfrom-bug",
      "message": "The `burnFrom` function contains an allowance validation bug similar to the TecraCoim vulnerability. The `_allowances` mapping parameters are in the wrong order, causing the contract to check the wrong allowance. This allows attackers to burn tokens from any account that has approved the contract for any amount.",
      "metadata": {
        "category": "security",
        "technology": [
          "solidity"
        ],
        "cwe": "CWE-688: Function Call With Incorrect Variable or Reference as Argument",
        "confidence": "MEDIUM",
        "likelihood": "HIGH",
        "impact": "HIGH",
        "subcategory": [
          "vuln"
        ],
        "references": [
          "https://twitter.com/Mauricio_0218/status/1490082073096462340",
          "https://etherscan.io/address/0xe38b72d6595fd3885d1d2f770aa23e94757f91a1"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Parameter order swapped in allowance check",
        "fix-suggestion": "Fix the parameter order in the `_allowances` mapping access to ensure the correct allowance is being checked. Change `_allowances[msg.sender][from]` to `_allowances[from][msg.sender]` to properly verify that the caller is authorized to burn tokens on behalf of the specified address."
      },
      "patterns": [
        {
          "pattern-inside": "function $BURN(..., address $FROM, ...) {\n    ...\n    _burn($FROM, ...);\n    ...\n}\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "require(_allowances[$S][$FROM] >= $X, ...)"
            },
            {
              "pattern": "require(allowance($S, $FROM) >= $X, ...)"
            }
          ]
        }
      ],
      "languages": [
        "solidity"
      ],
      "severity": "ERROR"
    },
    {
      "id": "swift.lang.storage.sensitive-storage-userdefaults.swift-user-defaults",
      "message": "Sensitive information is being stored in UserDefaults, which provides no encryption or security protection. UserDefaults data is stored in plaintext and can be easily extracted from device backups or by malicious applications. This storage method is inappropriate for credentials, tokens, personal data, or any confidential information.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "category": "security",
        "cwe": [
          "CWE-311: Missing Encryption of Sensitive Data"
        ],
        "masvs": [
          "MASVS-STORAGE-1: The app securely stores sensitive data"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A04:2021 - Insecure Design"
        ],
        "references": [
          "https://developer.apple.com/library/archive/documentation/Security/Conceptual/SecureCodingGuide/Articles/ValidatingInput.html",
          "https://mas.owasp.org/MASVS/controls/MASVS-STORAGE-1/"
        ],
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "ios",
          "macos"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Sensitive data insecurely stored in UserDefaults",
        "fix-suggestion": "Replace UserDefaults with the iOS Keychain for storing sensitive information. Use `KeychainSwift` or Apple's `Security` framework to securely store and retrieve sensitive data with proper encryption. For example: `KeychainSwift().set(sensitiveValue, forKey: \"sensitiveKey\")`."
      },
      "languages": [
        "swift"
      ],
      "options": {
        "symbolic_propagation": true
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "UserDefaults.standard.set(\"$VALUE\", forKey: \"$KEY\")\n"
                    },
                    {
                      "pattern": "UserDefaults.standard.set(\"$VALUE\", forKey: $KEY)\n"
                    },
                    {
                      "pattern": "UserDefaults.standard.set($VALUE, forKey: \"$KEY\")\n"
                    },
                    {
                      "pattern": "UserDefaults.standard.set($VALUE, forKey: $KEY)\n"
                    }
                  ]
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$VALUE",
                    "regex": "(?i).*(passcode|password|pass_word|passphrase|pass_code|pass_word|pass_phrase)$"
                  }
                },
                {
                  "focus-metavariable": "$VALUE"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "UserDefaults.standard.set(\"$VALUE\", forKey: \"$KEY\")\n"
                    },
                    {
                      "pattern": "UserDefaults.standard.set(\"$VALUE\", forKey: $KEY)\n"
                    },
                    {
                      "pattern": "UserDefaults.standard.set($VALUE, forKey: \"$KEY\")\n"
                    },
                    {
                      "pattern": "UserDefaults.standard.set($VALUE, forKey: $KEY)\n"
                    }
                  ]
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$KEY",
                    "regex": "(?i).*(passcode|password|pass_word|passphrase|pass_code|pass_word|pass_phrase)$"
                  }
                },
                {
                  "focus-metavariable": "$KEY"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "UserDefaults.standard.set(\"$VALUE\", forKey: \"$KEY\")\n"
                    },
                    {
                      "pattern": "UserDefaults.standard.set(\"$VALUE\", forKey: $KEY)\n"
                    },
                    {
                      "pattern": "UserDefaults.standard.set($VALUE, forKey: \"$KEY\")\n"
                    },
                    {
                      "pattern": "UserDefaults.standard.set($VALUE, forKey: $KEY)\n"
                    }
                  ]
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$VALUE",
                    "regex": "(?i).*(api_key|apikey)$"
                  }
                },
                {
                  "focus-metavariable": "$VALUE"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "UserDefaults.standard.set(\"$VALUE\", forKey: \"$KEY\")\n"
                    },
                    {
                      "pattern": "UserDefaults.standard.set(\"$VALUE\", forKey: $KEY)\n"
                    },
                    {
                      "pattern": "UserDefaults.standard.set($VALUE, forKey: \"$KEY\")\n"
                    },
                    {
                      "pattern": "UserDefaults.standard.set($VALUE, forKey: $KEY)\n"
                    }
                  ]
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$KEY",
                    "regex": "(?i).*(api_key|apikey)$"
                  }
                },
                {
                  "focus-metavariable": "$KEY"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "UserDefaults.standard.set(\"$VALUE\", forKey: \"$KEY\")\n"
                    },
                    {
                      "pattern": "UserDefaults.standard.set(\"$VALUE\", forKey: $KEY)\n"
                    },
                    {
                      "pattern": "UserDefaults.standard.set($VALUE, forKey: \"$KEY\")\n"
                    },
                    {
                      "pattern": "UserDefaults.standard.set($VALUE, forKey: $KEY)\n"
                    }
                  ]
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$VALUE",
                    "regex": "(?i).*(secretkey|secret_key|secrettoken|secret_token|clientsecret|client_secret)$"
                  }
                },
                {
                  "focus-metavariable": "$VALUE"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "UserDefaults.standard.set(\"$VALUE\", forKey: \"$KEY\")\n"
                    },
                    {
                      "pattern": "UserDefaults.standard.set(\"$VALUE\", forKey: $KEY)\n"
                    },
                    {
                      "pattern": "UserDefaults.standard.set($VALUE, forKey: \"$KEY\")\n"
                    },
                    {
                      "pattern": "UserDefaults.standard.set($VALUE, forKey: $KEY)\n"
                    }
                  ]
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$KEY",
                    "regex": "(?i).*(secretkey|secret_key|secrettoken|secret_token|clientsecret|client_secret)$"
                  }
                },
                {
                  "focus-metavariable": "$KEY"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "UserDefaults.standard.set(\"$VALUE\", forKey: \"$KEY\")\n"
                    },
                    {
                      "pattern": "UserDefaults.standard.set(\"$VALUE\", forKey: $KEY)\n"
                    },
                    {
                      "pattern": "UserDefaults.standard.set($VALUE, forKey: \"$KEY\")\n"
                    },
                    {
                      "pattern": "UserDefaults.standard.set($VALUE, forKey: $KEY)\n"
                    }
                  ]
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$VALUE",
                    "regex": "(?i).*(cryptkey|cryptokey|crypto_key|cryptionkey|symmetrickey|privatekey|symmetric_key|private_key)$"
                  }
                },
                {
                  "focus-metavariable": "$VALUE"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern": "UserDefaults.standard.set(\"$VALUE\", forKey: \"$KEY\")\n"
                    },
                    {
                      "pattern": "UserDefaults.standard.set(\"$VALUE\", forKey: $KEY)\n"
                    },
                    {
                      "pattern": "UserDefaults.standard.set($VALUE, forKey: \"$KEY\")\n"
                    },
                    {
                      "pattern": "UserDefaults.standard.set($VALUE, forKey: $KEY)\n"
                    }
                  ]
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$KEY",
                    "regex": "(?i).*(cryptkey|cryptokey|crypto_key|cryptionkey|symmetrickey|privatekey|symmetric_key|private_key)$"
                  }
                },
                {
                  "focus-metavariable": "$KEY"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "swift.webview.webview-js-window.swift-webview-config-allows-js-open-windows",
      "message": "Your WKWebView is configured to allow JavaScript to open new windows automatically without user interaction. This creates potential security risks including phishing, pop-up spam, and potential exploitation of browser vulnerabilities. Unnecessary JavaScript capabilities increase the attack surface of your application.",
      "severity": "WARNING",
      "metadata": {
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "HIGH",
        "category": "security",
        "cwe": [
          "CWE-272: Least Privilege Violation"
        ],
        "masvs": [
          "MASVS-PLATFORM-2: The app uses WebViews securely"
        ],
        "references": [
          "https://mas.owasp.org/MASVS/controls/MASVS-PLATFORM-2/",
          "https://developer.apple.com/documentation/webkit/wkpreferences/1536573-javascriptcanopenwindowsautomati"
        ],
        "subcategory": [
          "audit"
        ],
        "technology": [
          "ios",
          "macos"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "WebView allowing automatic window opening via JavaScript",
        "fix-suggestion": "Disable automatic window opening by setting `WKPreferences().javaScriptCanOpenWindowsAutomatically = false` in your WebView configuration. If this functionality is absolutely necessary, implement additional security controls such as URL allowlisting and Content-Security-Policy headers to mitigate potential abuse."
      },
      "languages": [
        "swift"
      ],
      "patterns": [
        {
          "pattern": "$P = WKPreferences()\n...\n"
        },
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-inside": "$P.JavaScriptCanOpenWindowsAutomatically  = $FALSE\n...\n$P.JavaScriptCanOpenWindowsAutomatically  = $TRUE\n"
                },
                {
                  "pattern-not-inside": "...\n$P.JavaScriptCanOpenWindowsAutomatically  = $TRUE\n...\n$P.JavaScriptCanOpenWindowsAutomatically = $FALSE\n"
                },
                {
                  "pattern": "$P.JavaScriptCanOpenWindowsAutomatically  = true\n"
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$TRUE",
                    "regex": "^(true)$"
                  }
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$TRUE",
                    "regex": "(.*(?!true))"
                  }
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern": "$P.JavaScriptCanOpenWindowsAutomatically  = true\n"
                },
                {
                  "pattern-not-inside": "...\n$P.JavaScriptCanOpenWindowsAutomatically  = ...\n...\n$P.JavaScriptCanOpenWindowsAutomatically  = ...\n"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "terraform.aws.security.aws-athena-workgroup-unencrypted.aws-athena-workgroup-unencrypted",
      "patterns": [
        {
          "pattern": "resource \"aws_athena_workgroup\" $ANYTHING {\n  ...\n  configuration {\n    ...\n    result_configuration {\n      ...\n    }\n    ...\n  }\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_athena_workgroup\" $ANYTHING {\n  ...\n  configuration {\n    ...\n    result_configuration {\n      ...\n      encryption_configuration {\n        ...\n      }\n      ...\n    }\n    ...\n  }\n  ...\n}\n"
        }
      ],
      "message": "Your AWS Athena workgroup isn't configured with encryption, leaving query results and stored data unprotected. Without encryption, sensitive data processed by Athena could be exposed if storage is compromised. Query results often contain valuable business intelligence or personal information that should be protected at rest.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A04:2021 - Insecure Design"
        ],
        "cwe": [
          "CWE-311: Missing Encryption of Sensitive Data"
        ],
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "AWS Athena workgroup missing encryption configuration",
        "fix-suggestion": "Enable encryption for your Athena workgroup by adding the `encryption_configuration` block to your Terraform resource. Use `aws_kms_key` resource to create a custom key or reference an existing key with `encrypt_configuration { encryption_option = \"SSE_KMS\" kms_key_arn = aws_kms_key.athena_key.arn }`."
      }
    },
    {
      "id": "terraform.aws.security.aws-backup-vault-unencrypted.aws-backup-vault-unencrypted",
      "patterns": [
        {
          "pattern-not-inside": "resource \"aws_backup_vault\" $BACKUP {\n  ...\n  kms_key_arn = ...\n  ...\n}\n"
        },
        {
          "pattern": "resource \"aws_backup_vault\" $BACKUP {...}"
        }
      ],
      "message": "The AWS Backup vault lacks encryption configuration, exposing your backup data to potential unauthorized access. Encryption at rest is essential for protecting sensitive backup information from data breaches. Implement AWS KMS encryption to secure your backup vault data according to security best practices.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "cwe": [
          "CWE-320: CWE CATEGORY: Key Management Errors"
        ],
        "technology": [
          "aws",
          "terraform"
        ],
        "category": "security",
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "AWS Backup vault missing encryption protection",
        "fix-suggestion": "Enable encryption for your AWS Backup vault by adding the `kms_key_arn` attribute to your `aws_backup_vault` resource. Either create a new KMS key using `aws_kms_key` or reference an existing key's ARN to enable strong encryption for your backup data."
      }
    },
    {
      "id": "terraform.aws.security.aws-cloudtrail-encrypted-with-cmk.aws-cloudtrail-encrypted-with-cmk",
      "patterns": [
        {
          "pattern": "resource \"aws_cloudtrail\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_cloudtrail\" $ANYTHING {\n  ...\n  kms_key_id = ...\n  ...\n}\n"
        }
      ],
      "message": "Your CloudTrail logs are not encrypted with a Customer Managed Key (CMK). Using CMKs provides enhanced control over encryption, including key rotation and access management. Encrypting CloudTrail logs with CMKs helps secure audit trails containing sensitive operational data.",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "cwe": [
          "CWE-320: CWE CATEGORY: Key Management Errors"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "CloudTrail logs not encrypted with customer key",
        "fix-suggestion": "Configure CloudTrail to use a Customer Managed Key by adding `kms_key_id` to your `aws_cloudtrail` resource. Create a dedicated `aws_kms_key` resource for CloudTrail encryption to maintain control over key rotation schedules and access permissions."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.aws.security.aws-cloudwatch-log-group-no-retention.aws-cloudwatch-log-group-no-retention",
      "patterns": [
        {
          "pattern": "resource \"aws_cloudwatch_log_group\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_cloudwatch_log_group\" $ANYTHING {\n  ...\n  retention_in_days = ...\n  ...\n}\n"
        }
      ],
      "message": "Your AWS CloudWatch Log Group doesn't have a retention period configured. Without a defined retention policy, logs are stored indefinitely, which can increase storage costs and compliance risks. Setting an appropriate retention period helps manage resources efficiently while maintaining necessary audit trails.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "cwe": [
          "CWE-320: CWE CATEGORY: Key Management Errors"
        ],
        "technology": [
          "aws",
          "terraform"
        ],
        "category": "security",
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "CloudWatch Log Group missing retention policy",
        "fix-suggestion": "Set a retention period by adding the `retention_in_days` attribute to your `aws_cloudwatch_log_group` resource. Choose an appropriate retention value (such as `30`, `60`, or `90`) based on your compliance requirements and operational needs."
      }
    },
    {
      "id": "terraform.aws.security.aws-cloudwatch-log-group-unencrypted.aws-cloudwatch-log-group-unencrypted",
      "patterns": [
        {
          "pattern": "resource \"aws_cloudwatch_log_group\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_cloudwatch_log_group\" $ANYTHING {\n  ...\n  kms_key_id = ...\n  ...\n}\n"
        }
      ],
      "message": "Your CloudWatch Log Group is using default AWS-managed encryption rather than a customer-managed key. Using your own KMS key provides greater control over encryption policies and key rotation. Customer-managed encryption helps meet compliance requirements for sensitive log data.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-732: Incorrect Permission Assignment for Critical Resource"
        ],
        "technology": [
          "aws",
          "terraform"
        ],
        "category": "security",
        "references": [
          "https://cwe.mitre.org/data/definitions/732.html"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "CloudWatch logs missing customer-managed encryption",
        "fix-suggestion": "Add the `kms_key_id` attribute to your `aws_cloudwatch_log_group` resource. Create a new KMS key using `aws_kms_key` or reference an existing key's ARN to enable customer-managed encryption for your log data."
      }
    },
    {
      "id": "terraform.aws.security.aws-codebuild-project-artifacts-unencrypted.aws-codebuild-project-artifacts-unencrypted",
      "patterns": [
        {
          "pattern": "resource \"aws_codebuild_project\" $ANYTHING {\n  ...\n  artifacts {\n    ...\n    encryption_disabled = true\n    ...\n  }\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_codebuild_project\" $ANYTHING {\n  ...\n  artifacts {\n    type = \"NO_ARTIFACTS\"\n    encryption_disabled = true\n  }\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_codebuild_project\" $ANYTHING {\n  ...\n  artifacts {\n    type = \"NO_ARTIFACTS\"\n  }\n  ...\n}\n"
        }
      ],
      "message": "CodeBuild project artifacts are not encrypted with a customer-managed key. Unencrypted artifacts could expose sensitive build outputs to unauthorized access. Implementing KMS encryption protects build artifacts containing proprietary code or configurations.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "cwe": [
          "CWE-320: CWE CATEGORY: Key Management Errors"
        ],
        "technology": [
          "aws",
          "terraform"
        ],
        "category": "security",
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "CodeBuild artifacts lack encryption protection",
        "fix-suggestion": "Enable artifact encryption by configuring the `encryption_key` attribute in the `artifacts` block of your `aws_codebuild_project` resource. Use an `aws_kms_key` resource to create a dedicated key or reference an existing key's ARN for encryption."
      }
    },
    {
      "id": "terraform.aws.security.aws-codebuild-project-unencrypted.aws-codebuild-project-unencrypted",
      "patterns": [
        {
          "pattern": "resource \"aws_codebuild_project\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_codebuild_project\" $ANYTHING {\n  ...\n  encryption_key = ...\n  ...\n}\n"
        }
      ],
      "message": "Your CodeBuild project is not using encryption for its build environment. Unencrypted build environments may expose sensitive data like credentials or proprietary code. Implementing KMS encryption adds security to your CI/CD pipeline and protects build-time secrets.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "cwe": [
          "CWE-320: CWE CATEGORY: Key Management Errors"
        ],
        "technology": [
          "aws",
          "terraform"
        ],
        "category": "security",
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "CodeBuild project missing encryption settings",
        "fix-suggestion": "Add encryption to your CodeBuild project by setting the `encryption_key` attribute in your `aws_codebuild_project` resource. Create a dedicated KMS key with `aws_kms_key` or use an existing key's ARN to secure your build environment and artifacts."
      }
    },
    {
      "id": "terraform.aws.security.aws-config-aggregator-not-all-regions.aws-config-aggregator-not-all-regions",
      "pattern-either": [
        {
          "pattern": "resource \"aws_config_configuration_aggregator\" $ANYTHING {\n  ...\n  account_aggregation_source {\n    ...\n    regions = ...\n    ...\n  }\n  ...\n}\n"
        },
        {
          "pattern": "resource \"aws_config_configuration_aggregator\" $ANYTHING {\n  ...\n  organization_aggregation_source {\n    ...\n    regions = ...\n    ...\n  }\n  ...\n}\n"
        }
      ],
      "message": "Your AWS Config aggregator isn't configured to monitor all regions. This creates blind spots in your configuration monitoring where resources in unmarked regions remain unaudited. Complete visibility across all regions is crucial for maintaining a comprehensive security posture.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A09:2021 - Security Logging and Monitoring Failures"
        ],
        "cwe": [
          "CWE-778: Insufficient Logging"
        ],
        "references": [
          "https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insufficient Logging"
        ],
        "short-description": "Config aggregator missing multi-region coverage",
        "fix-suggestion": "Enable multi-region monitoring by setting `all_regions = true` in the `account_aggregation_source` block of your `aws_config_aggregator` resource. This ensures complete visibility of configuration changes across your entire AWS environment, including regions you may not actively use."
      }
    },
    {
      "id": "terraform.aws.security.aws-db-instance-no-logging.aws-db-instance-no-logging",
      "patterns": [
        {
          "pattern": "resource \"aws_db_instance\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_db_instance\" $ANYTHING {\n  ...\n  enabled_cloudwatch_logs_exports = [$SOMETHING, ...]\n  ...\n}\n"
        }
      ],
      "message": "Database logging is disabled on your RDS instance. Without logging, you can't track database activities, investigate security incidents, or monitor performance issues. Enabling logging is essential for database auditing and troubleshooting.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A04:2021 - Insecure Design"
        ],
        "cwe": [
          "CWE-311: Missing Encryption of Sensitive Data"
        ],
        "technology": [
          "aws",
          "terraform"
        ],
        "category": "security",
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "LOW",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "RDS database instance missing activity logging",
        "fix-suggestion": "Enable database logging by adding appropriate logging parameters to your `aws_db_instance` resource. For MySQL, add `enabled_cloudwatch_logs_exports = [\"audit\", \"error\", \"general\", \"slowquery\"]`, for PostgreSQL use `enabled_cloudwatch_logs_exports = [\"postgresql\", \"upgrade\"]` to capture critical database events."
      }
    },
    {
      "id": "terraform.aws.security.aws-docdb-encrypted-with-cmk.aws-docdb-encrypted-with-cmk",
      "patterns": [
        {
          "pattern": "resource \"aws_docdb_cluster\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_docdb_cluster\" $ANYTHING {\n  ...\n  kms_key_id = ...\n  ...\n}\n"
        }
      ],
      "message": "Your DocumentDB cluster is not using a Customer Managed Key (CMK) for encryption. Using CMKs provides enhanced control over encryption policies and key rotation schedules. Customer-managed encryption helps meet compliance requirements for data security.",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "cwe": [
          "CWE-320: CWE CATEGORY: Key Management Errors"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "DocumentDB missing customer-managed encryption key",
        "fix-suggestion": "Configure DocumentDB to use a Customer Managed Key by adding `kms_key_id` to your `aws_docdb_cluster` resource. Create a dedicated KMS key with `aws_kms_key` or reference an existing key's ARN to enable stronger encryption controls for your database."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.aws.security.aws-documentdb-auditing-disabled.aws-documentdb-auditing-disabled",
      "patterns": [
        {
          "pattern": "resource \"aws_docdb_cluster\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_docdb_cluster\" $ANYTHING {\n  ...\n  enabled_cloudwatch_logs_exports = [..., \"audit\", ...]\n  ...\n}\n"
        }
      ],
      "message": "Auditing is disabled on your DocumentDB cluster. Without audit logging, you can't track database access patterns, detect unauthorized activities, or fulfill compliance requirements. Enabling auditing provides essential visibility into who is accessing your database and what actions they're performing.",
      "languages": [
        "hcl"
      ],
      "severity": "INFO",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A09:2021 - Security Logging and Monitoring Failures"
        ],
        "cwe": [
          "CWE-778: Insufficient Logging"
        ],
        "references": [
          "https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/docdb_cluster#enabled_cloudwatch_logs_exports",
          "https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insufficient Logging"
        ],
        "short-description": "DocumentDB missing audit logging configuration",
        "fix-suggestion": "Enable audit logging by adding `enabled_cloudwatch_logs_exports = [\"audit\"]` to your `aws_docdb_cluster` resource. Configure a CloudWatch log group to receive these logs and set appropriate retention periods to maintain your audit trail."
      }
    },
    {
      "id": "terraform.aws.security.aws-dynamodb-table-unencrypted.aws-dynamodb-table-unencrypted",
      "patterns": [
        {
          "pattern": "resource \"aws_dynamodb_table\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_dynamodb_table\" $ANYTHING {\n  ...\n  server_side_encryption {\n    enabled = true\n    kms_key_arn = ...\n  }\n  ...\n}\n"
        }
      ],
      "message": "Your DynamoDB table is using AWS-managed encryption instead of a customer-managed key. Using your own KMS key provides greater control over encryption policies and key rotation. Customer-managed encryption helps meet compliance requirements for sensitive data.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "technology": [
          "aws",
          "terraform"
        ],
        "category": "security",
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "DynamoDB table using default encryption",
        "fix-suggestion": "Enable customer-managed encryption by adding a `server_side_encryption` block with `kms_key_arn` to your `aws_dynamodb_table` resource. Create a new KMS key or reference an existing one to implement stronger encryption controls for your data."
      }
    },
    {
      "id": "terraform.aws.security.aws-ebs-snapshot-encrypted-with-cmk.aws-ebs-snapshot-encrypted-with-cmk",
      "patterns": [
        {
          "pattern": "resource \"aws_ebs_snapshot_copy\" $ANYTHING {\n  ...\n  encrypted = true\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_ebs_snapshot_copy\" $ANYTHING {\n  ...\n  encrypted = true\n  kms_key_id = ...\n  ...\n}\n"
        }
      ],
      "message": "Your EBS snapshot is not encrypted with a Customer Managed Key (CMK). Using CMKs provides enhanced control over encryption, including key rotation and access management. Customer-managed encryption helps protect sensitive data in your volume snapshots.",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "cwe": [
          "CWE-320: CWE CATEGORY: Key Management Errors"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "EBS snapshot lacks customer-managed encryption",
        "fix-suggestion": "Enable CMK encryption for EBS snapshots by adding the `kms_key_id` attribute to your `aws_ebs_snapshot` resource. Create a dedicated KMS key with `aws_kms_key` or reference an existing key's ARN to implement stronger encryption for your snapshots."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.aws.security.aws-ebs-unencrypted.aws-ebs-unencrypted",
      "patterns": [
        {
          "pattern": "resource \"aws_ebs_encryption_by_default\" $ANYTHING {\n  ...\n  enabled = false\n  ...\n}\n"
        }
      ],
      "message": "Your EBS volume is not encrypted, leaving sensitive data vulnerable to unauthorized access. Encryption protects data at rest by ensuring it cannot be read without the appropriate key. Enabling encryption is a fundamental security control for protecting stored information.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "cwe": [
          "CWE-320: CWE CATEGORY: Key Management Errors"
        ],
        "technology": [
          "aws",
          "terraform"
        ],
        "category": "security",
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "EBS volume missing encryption protection",
        "fix-suggestion": "Enable EBS encryption by adding `encrypted = true` to your `aws_ebs_volume` resource. For additional control, also specify a `kms_key_id` to use a specific KMS key instead of the default AWS-managed key."
      }
    },
    {
      "id": "terraform.aws.security.aws-ebs-volume-encrypted-with-cmk.aws-ebs-volume-encrypted-with-cmk",
      "patterns": [
        {
          "pattern": "resource \"aws_ebs_volume\" $ANYTHING {\n  ...\n  encrypted = true\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_ebs_volume\" $ANYTHING {\n  ...\n  encrypted = true\n  kms_key_id = ...\n  ...\n}\n"
        }
      ],
      "message": "Your EBS volume is not encrypted with a Customer Managed Key (CMK). Using CMKs provides enhanced control over encryption policies and key rotation schedules. Customer-managed encryption helps meet compliance requirements for securing stored data.",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "cwe": [
          "CWE-320: CWE CATEGORY: Key Management Errors"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "EBS volume missing customer-managed encryption",
        "fix-suggestion": "Enable CMK encryption by setting `encrypted = true` and adding the `kms_key_id` attribute to your `aws_ebs_volume` resource. Create a dedicated KMS key or reference an existing one to implement stronger encryption controls for your storage volumes."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.aws.security.aws-ebs-volume-unencrypted.aws-ebs-volume-unencrypted",
      "patterns": [
        {
          "pattern": "resource \"aws_ebs_volume\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not": "resource \"aws_ebs_volume\" $ANYTHING {\n  ...\n  encrypted = true\n  ...\n}\n"
        }
      ],
      "message": "Your EBS volume is not encrypted, potentially exposing sensitive data to unauthorized access. Unencrypted volumes leave data vulnerable during compromise of physical media or unauthorized snapshots. Enabling encryption protects data at rest and is a crucial security control.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A04:2021 - Insecure Design"
        ],
        "cwe": [
          "CWE-311: Missing Encryption of Sensitive Data"
        ],
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design",
          "https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/ebs_volume#encrypted",
          "https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Unencrypted EBS volume exposes data",
        "fix-suggestion": "Enable encryption by adding `encrypted = true` to your `aws_ebs_volume` resource. For better security, also specify a `kms_key_id` to use a customer-managed key instead of the default AWS-managed encryption key."
      }
    },
    {
      "id": "terraform.aws.security.aws-ec2-has-public-ip.aws-ec2-has-public-ip",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "resource \"aws_instance\" $ANYTHING {\n  ...\n  associate_public_ip_address = true\n  ...\n}\n"
            },
            {
              "pattern": "resource \"aws_launch_template\" $ANYTHING {\n  ...\n  network_interfaces {\n    ...\n    associate_public_ip_address = true\n    ...\n  }\n  ...\n}\n"
            }
          ]
        }
      ],
      "message": "Your EC2 instance is configured with a public IP address, making it directly accessible from the internet. Public-facing instances create an expanded attack surface for potential unauthorized access. Use private IPs with controlled access paths to reduce exposure to internet-based threats.",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-284: Improper Access Control"
        ],
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "EC2 instance exposed with public IP",
        "fix-suggestion": "Remove public internet exposure by setting `associate_public_ip_address = false` in your `aws_instance` resource. Use a bastion host, VPN, or AWS Systems Manager Session Manager for secure administrative access to instances in private subnets."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.aws.security.aws-ec2-launch-template-metadata-service-v1-enabled.aws-ec2-launch-template-metadata-service-v1-enabled",
      "patterns": [
        {
          "pattern": "resource \"aws_launch_template\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_launch_template\" $ANYTHING {\n  ...\n  metadata_options {\n    ...\n    http_endpoint = \"disabled\"\n    ...\n  }\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_launch_template\" $ANYTHING {\n  ...\n  metadata_options {\n    ...\n    http_tokens = \"required\"\n    ...\n  }\n  ...\n}\n"
        }
      ],
      "message": "Your EC2 launch template enables IMDSv1, which lacks the security improvements of IMDSv2. IMDSv1 is vulnerable to SSRF attacks that can steal instance credentials. IMDSv2 adds session authentication tokens that significantly improve instance metadata security.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "cwe": [
          "CWE-1390: Weak Authentication"
        ],
        "references": [
          "https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/",
          "https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/launch_configuration#metadata_options",
          "https://aws.amazon.com/blogs/security/defense-in-depth-open-firewalls-reverse-proxies-ssrf-vulnerabilities-ec2-instance-metadata-service"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "EC2 template using insecure metadata service",
        "fix-suggestion": "Enforce IMDSv2 by adding `metadata_options { http_tokens = \"required\" }` to your `aws_launch_template` resource. This disables IMDSv1 and requires the more secure token-based requests for accessing instance metadata."
      }
    },
    {
      "id": "terraform.aws.security.aws-ecr-mutable-image-tags.aws-ecr-mutable-image-tags",
      "patterns": [
        {
          "pattern": "resource \"aws_ecr_repository\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_ecr_repository\" $ANYTHING {\n  ...\n  image_tag_mutability = \"IMMUTABLE\"\n  ...\n}\n"
        }
      ],
      "message": "Your ECR repository allows image tags to be overwritten. Mutable tags create security risks as attackers could replace legitimate images with compromised versions. Immutable tags ensure that container images cannot be tampered with once pushed to the repository.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A08:2021 - Software and Data Integrity Failures"
        ],
        "cwe": [
          "CWE-345: Insufficient Verification of Data Authenticity"
        ],
        "references": [
          "https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/ecr_repository#image_tag_mutability",
          "https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "ECR repo allows overwriting image tags",
        "fix-suggestion": "Prevent tag mutation by setting `image_tag_mutability = \"IMMUTABLE\"` in your `aws_ecr_repository` resource. This ensures tags cannot be overwritten once pushed, preventing potential image substitution attacks in your container pipeline."
      }
    },
    {
      "id": "terraform.aws.security.aws-ecr-repository-wildcard-principal.aws-ecr-repository-wildcard-principal",
      "patterns": [
        {
          "pattern-inside": "resource \"aws_ecr_repository_policy\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern": "policy = \"$JSONPOLICY\""
                },
                {
                  "metavariable-pattern": {
                    "metavariable": "$JSONPOLICY",
                    "language": "json",
                    "patterns": [
                      {
                        "pattern-not-inside": "{..., \"Effect\": \"Deny\", ...}\n"
                      },
                      {
                        "pattern-either": [
                          {
                            "pattern": "{..., \"Principal\": \"*\", ...}\n"
                          },
                          {
                            "pattern": "{..., \"Principal\": [..., \"*\", ...], ...}\n"
                          },
                          {
                            "pattern": "{..., \"Principal\": { \"AWS\": \"*\" }, ...}\n"
                          },
                          {
                            "pattern": "{..., \"Principal\": { \"AWS\": [..., \"*\", ...] }, ...}\n"
                          }
                        ]
                      }
                    ]
                  }
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-inside": "policy = jsonencode(...)"
                },
                {
                  "pattern-not-inside": "{..., Effect = \"Deny\", ...}\n"
                },
                {
                  "pattern-either": [
                    {
                      "pattern": "{..., Principal = \"*\", ...}\n"
                    },
                    {
                      "pattern": "{..., Principal = [..., \"*\", ...], ...}\n"
                    },
                    {
                      "pattern": "{..., Principal = { AWS = \"*\" }, ...}\n"
                    },
                    {
                      "pattern": "{..., Principal = { AWS = [..., \"*\", ...] }, ...}\n"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "message": "Your ECR repository policy uses a wildcard principal, granting overly broad access. This allows any entity, potentially including anonymous users, to perform actions on your container images. Specific principal restrictions help prevent unauthorized access to sensitive container images.",
      "metadata": {
        "category": "security",
        "technology": [
          "aws",
          "terraform"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "cwe": [
          "CWE-732: Incorrect Permission Assignment for Critical Resource"
        ],
        "references": [
          "https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/ecr_repository_policy",
          "https://docs.aws.amazon.com/lambda/latest/operatorguide/wildcard-permissions-iam.html",
          "https://docs.aws.amazon.com/prescriptive-guidance/latest/patterns/monitor-amazon-ecr-repositories-for-wildcard-permissions-using-aws-cloudformation-and-aws-config.html",
          "https://cwe.mitre.org/data/definitions/732.html"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "ECR repo policy grants excessive access",
        "fix-suggestion": "Replace wildcard principals (`\"*\"` or `\"AWS\":\"*\"`) in your `aws_ecr_repository_policy` with specific ARNs of users or roles. Implement the principle of least privilege by limiting both the principals who can access the repository and the actions they can perform."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.aws.security.aws-efs-filesystem-encrypted-with-cmk.aws-efs-filesystem-encrypted-with-cmk",
      "patterns": [
        {
          "pattern": "resource \"aws_efs_file_system\" $ANYTHING {\n  ...\n  encrypted  = true\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_efs_file_system\" $ANYTHING {\n  ...\n  encrypted  = true\n  kms_key_id = ...\n  ...\n}\n"
        }
      ],
      "message": "Your EFS filesystem is not encrypted with a Customer Managed Key (CMK). Using CMKs provides enhanced control over encryption policies and key rotation schedules. Customer-managed encryption helps meet compliance requirements for securing file system data.",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "cwe": [
          "CWE-320: CWE CATEGORY: Key Management Errors"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "EFS filesystem lacks customer-managed encryption",
        "fix-suggestion": "Enable CMK encryption by adding the `kms_key_id` attribute to your `aws_efs_file_system` resource. Create a dedicated KMS key with `aws_kms_key` or reference an existing key's ARN to implement stronger encryption controls for your filesystem."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.aws.security.aws-elasticsearch-insecure-tls-version.aws-elasticsearch-insecure-tls-version",
      "pattern": "resource \"aws_elasticsearch_domain\" $ANYTHING {\n  ...\n  domain_endpoint_options {\n    ...\n    enforce_https = true\n    tls_security_policy = \"Policy-Min-TLS-1-0-2019-07\"\n    ...\n  }\n  ...\n}\n",
      "message": "Your Elasticsearch domain is configured with an insecure TLS policy. Older TLS versions contain known vulnerabilities that attackers can exploit to compromise encrypted communications. Requiring TLS 1.2 or later ensures modern encryption protections for data in transit.",
      "languages": [
        "terraform"
      ],
      "severity": "WARNING",
      "metadata": {
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "category": "security",
        "technology": [
          "aws",
          "terraform"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Elasticsearch using outdated TLS version",
        "fix-suggestion": "Set `domain_endpoint_options { tls_security_policy = \"Policy-Min-TLS-1-2-2019-07\" }` in your `aws_elasticsearch_domain` resource. This enforces the use of TLS 1.2 or higher, preventing connections with insecure older protocol versions."
      }
    },
    {
      "id": "terraform.aws.security.aws-elb-access-logs-not-enabled.aws-elb-access-logs-not-enabled",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "resource \"aws_lb\" $ANYTHING {\n  ...\n}\n"
            },
            {
              "pattern": "resource \"aws_alb\" $ANYTHING {\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern-not-inside": "resource $ANYLB $ANYTHING {\n  ...\n  access_logs {\n    ...\n    enabled = true\n    ...\n  }\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource $ANYLB $ANYTHING {\n  ...\n  subnet_mapping {\n    ...\n  }\n  ...\n} \n"
        }
      ],
      "message": "Your Elastic Load Balancer doesn't have access logging enabled. Without logging, you can't analyze traffic patterns, investigate security incidents, or monitor for suspicious activities. Access logs provide crucial visibility into who is accessing your applications and potential attack vectors.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "technology": [
          "aws",
          "terraform"
        ],
        "category": "security",
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "ELB missing access logging configuration",
        "fix-suggestion": "Enable access logging by adding an `access_logs` block to your load balancer resource with `enabled = true`. Specify a dedicated S3 bucket with `bucket` and appropriate `bucket_prefix` to store logs securely with defined retention policies."
      }
    },
    {
      "id": "terraform.aws.security.aws-emr-encrypted-with-cmk.aws-emr-encrypted-with-cmk",
      "patterns": [
        {
          "pattern-inside": "resource \"aws_emr_security_configuration\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern": "configuration = \"$STATEMENT\""
        },
        {
          "metavariable-pattern": {
            "metavariable": "$STATEMENT",
            "language": "json",
            "patterns": [
              {
                "pattern-not-inside": "\"AwsKmsKey\": ...\n"
              }
            ]
          }
        }
      ],
      "message": "Your EMR cluster is not encrypted with a Customer Managed Key (CMK). Using CMKs provides enhanced control over encryption policies and key rotation schedules. Customer-managed encryption helps protect sensitive data processed in your EMR cluster.",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "cwe": [
          "CWE-320: CWE CATEGORY: Key Management Errors"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "EMR cluster lacking customer-managed encryption",
        "fix-suggestion": "Enable CMK encryption by adding `security_configuration` to your `aws_emr_cluster` resource that references a configuration with KMS encryption. Create the security configuration with `aws_emr_security_configuration` that specifies your KMS key ARN for both at-rest and in-transit encryption."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.aws.security.aws-fsx-lustre-filesystem-encrypted-with-cmk.aws-fsx-lustre-filesystem-encrypted-with-cmk",
      "patterns": [
        {
          "pattern": "resource \"aws_fsx_lustre_file_system\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_fsx_lustre_file_system\" $ANYTHING {\n  ...\n  kms_key_id = ...\n  ...\n}\n"
        }
      ],
      "message": "Your FSx Lustre filesystem is not encrypted with a Customer Managed Key (CMK). Using CMKs provides enhanced control over encryption policies and key rotation schedules. Customer-managed encryption helps meet compliance requirements for high-performance file system data.",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A04:2021 - Insecure Design"
        ],
        "cwe": [
          "CWE-311: Missing Encryption of Sensitive Data"
        ],
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "FSx Lustre filesystem missing CMK encryption",
        "fix-suggestion": "Enable CMK encryption by adding the `kms_key_id` attribute to your `aws_fsx_lustre_file_system` resource. Create a dedicated KMS key with `aws_kms_key` or reference an existing key's ARN to implement stronger encryption controls for your filesystem."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.aws.security.aws-fsx-ontapfs-encrypted-with-cmk.aws-fsx-ontapfs-encrypted-with-cmk",
      "patterns": [
        {
          "pattern": "resource \"aws_fsx_ontap_file_system\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_fsx_ontap_file_system\" $ANYTHING {\n  ...\n  kms_key_id = ...\n  ...\n}\n"
        }
      ],
      "message": "Your FSx ONTAP filesystem is not encrypted with a Customer Managed Key (CMK). Using CMKs provides enhanced control over encryption policies and key rotation schedules. Customer-managed encryption helps meet compliance requirements for securing enterprise file system data.",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "cwe": [
          "CWE-320: CWE CATEGORY: Key Management Errors"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "FSx ONTAP filesystem missing CMK encryption",
        "fix-suggestion": "Enable CMK encryption by adding the `kms_key_id` attribute to your `aws_fsx_ontap_file_system` resource. Create a dedicated KMS key with `aws_kms_key` or reference an existing key's ARN to implement stronger encryption controls for your file system."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.aws.security.aws-fsx-windows-encrypted-with-cmk.aws-fsx-windows-encrypted-with-cmk",
      "patterns": [
        {
          "pattern": "resource \"aws_fsx_windows_file_system\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_fsx_windows_file_system\" $ANYTHING {\n  ...\n  kms_key_id = ...\n  ...\n}\n"
        }
      ],
      "message": "Your FSx Windows filesystem is not encrypted with a Customer Managed Key (CMK). Using CMKs provides enhanced control over encryption policies and key rotation schedules. Customer-managed encryption helps meet compliance requirements for securing Windows file server data.",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "cwe": [
          "CWE-320: CWE CATEGORY: Key Management Errors"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "FSx Windows filesystem missing CMK encryption",
        "fix-suggestion": "Enable CMK encryption by adding the `kms_key_id` attribute to your `aws_fsx_windows_file_system` resource. Create a dedicated KMS key with `aws_kms_key` or reference an existing key's ARN to implement stronger encryption controls for your file system."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.aws.security.aws-glacier-vault-any-principal.aws-glacier-vault-any-principal",
      "patterns": [
        {
          "pattern-inside": "resource \"aws_glacier_vault\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern": "access_policy = \"$STATEMENT\""
        },
        {
          "metavariable-pattern": {
            "metavariable": "$STATEMENT",
            "language": "json",
            "patterns": [
              {
                "pattern-inside": "{..., \"Effect\": \"Allow\", ...}\n"
              },
              {
                "pattern-either": [
                  {
                    "pattern": "\"Principal\": \"*\"\n"
                  },
                  {
                    "pattern": "\"Principal\": {..., \"AWS\": \"*\", ...}\n"
                  },
                  {
                    "pattern-inside": "\"Principal\": {..., \"AWS\": ..., ...}\n"
                  },
                  {
                    "pattern-regex": "(^\\\"arn:aws:iam::\\*:(.*)\\\"$)\n"
                  }
                ]
              }
            ]
          }
        }
      ],
      "message": "Your Glacier Vault access policy contains a wildcard principal, granting overly broad access. This allows any entity within your AWS account to access or modify archived data. Specific principal restrictions help prevent unauthorized access to sensitive cold storage data.",
      "metadata": {
        "category": "security",
        "technology": [
          "aws"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "cwe": [
          "CWE-732: Incorrect Permission Assignment for Critical Resource"
        ],
        "references": [
          "https://cwe.mitre.org/data/definitions/732.html"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Glacier Vault policy grants excessive access",
        "fix-suggestion": "Replace wildcard principals (`\"*\"` or `\"AWS\":\"*\"`) in your `aws_glacier_vault_access_policy` with specific ARNs of authorized users or roles. Define a more restrictive policy that limits access based on the principle of least privilege to protect your archived data."
      },
      "languages": [
        "hcl"
      ],
      "severity": "ERROR"
    },
    {
      "id": "terraform.aws.security.aws-iam-admin-policy-ssoadmin.aws-iam-admin-policy-ssoadmin",
      "patterns": [
        {
          "pattern-inside": "resource \"aws_ssoadmin_permission_set_inline_policy\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern": "inline_policy = \"$STATEMENT\""
        },
        {
          "metavariable-pattern": {
            "metavariable": "$STATEMENT",
            "language": "json",
            "patterns": [
              {
                "pattern-not-inside": "{..., \"Effect\": \"Deny\", ...}\n"
              },
              {
                "pattern-either": [
                  {
                    "pattern": "{..., \"Action\": [..., \"*\", ...], \"Resource\": [..., \"*\", ...], ...}\n"
                  },
                  {
                    "pattern": "{..., \"Action\": \"*\", \"Resource\": \"*\", ...}\n"
                  },
                  {
                    "pattern": "{..., \"Action\": \"*\", \"Resource\": [...], ...}\n"
                  },
                  {
                    "pattern": "{..., \"Action\": [...], \"Resource\": \"*\", ...}\n"
                  }
                ]
              }
            ]
          }
        }
      ],
      "message": "Your IAM policy grants administrative permissions to SSO users or roles. Administrative access should be limited to only those who absolutely require it for their job functions. Excessive administrative privileges increase the risk and potential impact of credential compromise.",
      "metadata": {
        "category": "security",
        "technology": [
          "aws"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "cwe": [
          "CWE-732: Incorrect Permission Assignment for Critical Resource"
        ],
        "references": [
          "https://cwe.mitre.org/data/definitions/732.html"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Excessive admin permissions in SSO policy",
        "fix-suggestion": "Replace broad administrative permissions with more granular, task-specific permissions in your IAM policy. Follow the principle of least privilege by explicitly listing only the actions and resources required for the role instead of using wildcards like `\"Action\": \"*\"` or `\"Resource\": \"*\"`."
      },
      "languages": [
        "hcl"
      ],
      "severity": "ERROR"
    },
    {
      "id": "terraform.aws.security.aws-iam-admin-policy.aws-iam-admin-policy",
      "patterns": [
        {
          "pattern-inside": "resource \"aws_iam_policy\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern": "policy = \"$STATEMENT\""
        },
        {
          "metavariable-pattern": {
            "metavariable": "$STATEMENT",
            "language": "json",
            "patterns": [
              {
                "pattern-not-inside": "{..., \"Effect\": \"Deny\", ...}\n"
              },
              {
                "pattern-either": [
                  {
                    "pattern": "{..., \"Action\": [..., \"*\", ...], \"Resource\": [..., \"*\", ...], ...}\n"
                  },
                  {
                    "pattern": "{..., \"Action\": \"*\", \"Resource\": \"*\", ...}\n"
                  },
                  {
                    "pattern": "{..., \"Action\": \"*\", \"Resource\": [...], ...}\n"
                  },
                  {
                    "pattern": "{..., \"Action\": [...], \"Resource\": \"*\", ...}\n"
                  }
                ]
              }
            ]
          }
        }
      ],
      "message": "Your IAM policy grants broad administrative permissions. Administrative access should be limited to only those who absolutely require it for their job functions. Excessive administrative privileges increase the risk and potential impact of credential compromise.",
      "metadata": {
        "category": "security",
        "technology": [
          "aws",
          "terraform"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "cwe": [
          "CWE-732: Incorrect Permission Assignment for Critical Resource"
        ],
        "references": [
          "https://cwe.mitre.org/data/definitions/732.html"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "IAM policy grants excessive admin privileges",
        "fix-suggestion": "Replace broad administrative permissions with more granular, task-specific permissions in your IAM policy. Follow the principle of least privilege by explicitly listing only the actions and resources required for the role instead of using wildcards like `\"Action\": \"*\"` or `\"Resource\": \"*\"`."
      },
      "languages": [
        "hcl"
      ],
      "severity": "ERROR"
    },
    {
      "id": "terraform.aws.security.aws-imagebuilder-component-encrypted-with-cmk.aws-imagebuilder-component-encrypted-with-cmk",
      "patterns": [
        {
          "pattern": "resource \"aws_imagebuilder_component\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_imagebuilder_component\" $ANYTHING {\n  ...\n  kms_key_id = ...\n  ...\n}\n"
        }
      ],
      "message": "Your ImageBuilder component is not encrypted with a Customer Managed Key (CMK). Using CMKs provides enhanced control over encryption policies and key rotation schedules. Customer-managed encryption helps protect sensitive configurations in your image-building pipeline.",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "cwe": [
          "CWE-320: CWE CATEGORY: Key Management Errors"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "ImageBuilder component lacks CMK encryption",
        "fix-suggestion": "Enable CMK encryption by adding the `kms_key_id` attribute to your `aws_imagebuilder_component` resource. Create a dedicated KMS key with `aws_kms_key` or reference an existing key's ARN to implement stronger encryption controls for your image components."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.aws.security.aws-insecure-redshift-ssl-configuration.aws-insecure-redshift-ssl-configuration",
      "patterns": [
        {
          "pattern": "resource \"aws_redshift_parameter_group\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_redshift_parameter_group\" $ANYTHING {\n  ...\n  parameter {\n    name  = \"require_ssl\"\n    value = \"true\"\n  }\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_redshift_parameter_group\" $ANYTHING {\n  ...\n  parameter {\n    name  = \"require_ssl\"\n    value = true\n  }\n  ...\n}\n"
        }
      ],
      "message": "Your Redshift cluster doesn't require SSL/TLS connections. Without enforced SSL, data transmitted between clients and your database could be intercepted by attackers. Requiring encrypted connections prevents eavesdropping and tampering of data in transit.",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Redshift not enforcing encrypted connections",
        "fix-suggestion": "Enable SSL requirement by adding `require_ssl = true` to your `aws_redshift_cluster` resource. This forces all connections to the cluster to use SSL/TLS encryption, protecting data in transit between clients and your database."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.aws.security.aws-kinesis-stream-encrypted-with-cmk.aws-kinesis-stream-encrypted-with-cmk",
      "patterns": [
        {
          "pattern": "resource \"aws_kinesis_stream\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_kinesis_stream\" $ANYTHING {\n  ...\n  kms_key_id = ...\n  ...\n}\n"
        }
      ],
      "message": "Your Kinesis stream is not encrypted with a Customer Managed Key (CMK). Using CMKs provides enhanced control over encryption policies and key rotation schedules. Customer-managed encryption helps meet compliance requirements for streaming data protection.",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "cwe": [
          "CWE-320: CWE CATEGORY: Key Management Errors"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Kinesis stream missing customer-managed encryption",
        "fix-suggestion": "Enable CMK encryption by adding a `kms_key_id` attribute to your `aws_kinesis_stream` resource. Create a dedicated KMS key with `aws_kms_key` or reference an existing key's ARN to implement stronger encryption controls for your streaming data."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.aws.security.aws-kinesis-stream-unencrypted.aws-kinesis-stream-unencrypted",
      "patterns": [
        {
          "pattern": "resource \"aws_kinesis_stream\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not": "resource \"aws_kinesis_stream\" $ANYTHING {\n  ...\n  encryption_type = \"KMS\"\n  ...\n}\n"
        }
      ],
      "message": "Your Kinesis stream is not encrypting data at rest. Unencrypted streams leave your streaming data vulnerable to unauthorized access if storage is compromised. Enabling encryption helps protect sensitive information flowing through your stream processing pipeline.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A04:2021 - Insecure Design"
        ],
        "cwe": [
          "CWE-311: Missing Encryption of Sensitive Data"
        ],
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design",
          "https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/kinesis_stream#encryption_type",
          "https://docs.aws.amazon.com/streams/latest/dev/server-side-encryption.html"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "rule-origin-note": "published from /src/aws-kinesis-stream-unencrypted.yml in None",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Kinesis stream data not encrypted",
        "fix-suggestion": "Enable encryption by adding `encryption_type = \"KMS\"` to your `aws_kinesis_stream` resource. For better security, also specify a `kms_key_id` to use a customer-managed key instead of the default AWS-managed encryption key."
      }
    },
    {
      "id": "terraform.aws.security.aws-kinesis-video-stream-encrypted-with-cmk.aws-kinesis-video-stream-encrypted-with-cmk",
      "patterns": [
        {
          "pattern": "resource \"aws_kinesis_video_stream\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_kinesis_video_stream\" $ANYTHING {\n  ...\n  kms_key_id = ...\n  ...\n}\n"
        }
      ],
      "message": "Your Kinesis Video stream is not encrypted with a Customer Managed Key (CMK). Using CMKs provides enhanced control over encryption policies and key rotation schedules. Customer-managed encryption helps meet compliance requirements for video streaming data protection.",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "cwe": [
          "CWE-320: CWE CATEGORY: Key Management Errors"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Kinesis Video stream missing CMK encryption",
        "fix-suggestion": "Enable CMK encryption by adding the `kms_key_id` attribute to your `aws_kinesis_video_stream` resource. Create a dedicated KMS key with `aws_kms_key` or reference an existing key's ARN to implement stronger encryption controls for your video streaming data."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.aws.security.aws-kms-key-wildcard-principal.aws-kms-key-wildcard-principal",
      "patterns": [
        {
          "pattern-inside": "resource \"aws_kms_key\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern": "policy = \"$STATEMENT\""
        },
        {
          "metavariable-pattern": {
            "metavariable": "$STATEMENT",
            "language": "json",
            "patterns": [
              {
                "pattern-not-inside": "{..., \"Effect\": \"Deny\", ...}\n"
              },
              {
                "pattern-either": [
                  {
                    "pattern": "{..., \"Principal\": \"*\", \"Action\": \"kms:*\", \"Resource\": \"*\", ...}\n"
                  },
                  {
                    "pattern": "{..., \"Principal\": [..., \"*\", ...], \"Action\": \"kms:*\", \"Resource\": \"*\", ...}\n"
                  },
                  {
                    "pattern": "{..., \"Principal\": { \"AWS\": \"*\" }, \"Action\": \"kms:*\", \"Resource\": \"*\", ...}\n"
                  },
                  {
                    "pattern": "{..., \"Principal\": { \"AWS\": [..., \"*\", ...] }, \"Action\": \"kms:*\", \"Resource\": \"*\", ...}\n"
                  }
                ]
              }
            ]
          }
        }
      ],
      "message": "Your KMS key policy contains a wildcard principal, granting overly broad access to the key. This allows any entity, potentially including unauthorized users, to use the key for cryptographic operations. Specific principal restrictions are crucial for protecting sensitive encryption keys.",
      "metadata": {
        "category": "security",
        "technology": [
          "aws",
          "terraform"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "cwe": [
          "CWE-732: Incorrect Permission Assignment for Critical Resource"
        ],
        "references": [
          "https://cwe.mitre.org/data/definitions/732.html"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "KMS key policy grants excessive access",
        "fix-suggestion": "Replace wildcard principals (`\"*\"` or `\"AWS\":\"*\"`) in your KMS key policy with specific ARNs of authorized users or roles. Define a more restrictive policy that carefully limits both who can access the key and what actions they can perform with it."
      },
      "languages": [
        "hcl"
      ],
      "severity": "ERROR"
    },
    {
      "id": "terraform.aws.security.aws-kms-no-rotation.aws-kms-no-rotation",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "resource \"aws_kms_key\" $ANYTHING {\n  ...\n  enable_key_rotation = false\n  ...\n}\n"
            },
            {
              "pattern": "resource \"aws_kms_key\" $ANYTHING {\n  ...\n  customer_master_key_spec = \"SYMMETRIC_DEFAULT\"\n  enable_key_rotation = false\n  ...\n}\n"
            },
            {
              "pattern": "resource \"aws_kms_key\" $ANYTHING {\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern-not-inside": "resource \"aws_kms_key\" $ANYTHING {\n  ...\n  enable_key_rotation = true\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_kms_key\" $ANYTHING {\n  ...\n  customer_master_key_spec = \"RSA_2096\"\n  ...\n}\n"
        }
      ],
      "message": "Your KMS key is not configured for automatic rotation. Regular key rotation is a security best practice that limits the amount of data encrypted under a single key version. Enabling automatic rotation helps mitigate the risk of compromised encryption keys.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "technology": [
          "aws",
          "terraform"
        ],
        "category": "security",
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "KMS key missing automatic rotation",
        "fix-suggestion": "Enable key rotation by adding `enable_key_rotation = true` to your `aws_kms_key` resource. This configures automatic yearly rotation of the key material while maintaining access to data encrypted with previous versions of the key."
      }
    },
    {
      "id": "terraform.aws.security.aws-lambda-environment-credentials.aws-lambda-environment-credentials",
      "patterns": [
        {
          "pattern-inside": "resource \"$ANYTING\" $ANYTHING {\n  ...\n  environment {\n    variables = {\n      ...\n    }\n  }\n  ...\n}\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "AWS_ACCESS_KEY_ID = \"$Y\"\n"
            },
            {
              "pattern-regex": "(?<![A-Z0-9])[A-Z0-9]{20}(?![A-Z0-9])\n"
            },
            {
              "pattern-inside": "AWS_SECRET_ACCESS_KEY = \"$Y\"\n"
            },
            {
              "pattern-regex": "(?<![A-Za-z0-9/+=])[A-Za-z0-9/+=]{40}(?![A-Za-z0-9/+=])\n"
            }
          ]
        },
        {
          "focus-metavariable": "$Y"
        }
      ],
      "message": "Hardcoded credentials detected in your Lambda function environment variables. Storing credentials in source code creates significant security risks if the code is compromised, leaked, or shared. Use secure credential management services instead of embedding sensitive values in your configuration.",
      "metadata": {
        "category": "security",
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "technology": [
          "aws",
          "terraform",
          "secrets"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Lambda function exposes hardcoded credentials",
        "fix-suggestion": "Remove hardcoded credentials from Lambda environment variables and use AWS Secrets Manager or Parameter Store instead. Access secrets at runtime using `aws_secretsmanager_secret_version` or reference parameters with the AWS SDK's `getParameter` function from your Lambda code."
      },
      "languages": [
        "hcl"
      ],
      "severity": "ERROR"
    },
    {
      "id": "terraform.aws.security.aws-lambda-environment-unencrypted.aws-lambda-environment-unencrypted",
      "patterns": [
        {
          "pattern-inside": "resource \"aws_lambda_function\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern": "environment { ... }\n"
                },
                {
                  "pattern-not-inside": "resource $A $B {\n  ...\n  kms_key_arn = ...\n  ...\n}\n"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern": "kms_key_arn = ...\n"
                },
                {
                  "pattern-not-inside": "resource $A $B {\n  ...\n  environment { ... }\n  ...\n}\n"
                }
              ]
            },
            {
              "pattern": "kms_key_arn = \"\""
            }
          ]
        }
      ],
      "message": "Your Lambda function environment variables are encrypted with AWS-managed keys rather than a customer-managed key. Using your own KMS key provides greater control over encryption policies and key rotation. Customer-managed encryption helps secure sensitive configuration values in your functions.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "cwe": [
          "CWE-320: CWE CATEGORY: Key Management Errors"
        ],
        "technology": [
          "aws",
          "terraform"
        ],
        "category": "security",
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Lambda variables using default encryption",
        "fix-suggestion": "Enable customer-managed encryption by adding `kms_key_arn` to your `aws_lambda_function` resource. Create a dedicated KMS key with `aws_kms_key` or reference an existing key's ARN to implement stronger encryption for your Lambda environment variables."
      }
    },
    {
      "id": "terraform.aws.security.aws-lambda-permission-unrestricted-source-arn.aws-lambda-permission-unrestricted-source-arn",
      "patterns": [
        {
          "pattern": "resource \"aws_lambda_permission\" $ANYTHING {\n  ...\n  principal = \"$PRINCIPAL\"\n  ...\n}\n"
        },
        {
          "pattern-not": "resource \"aws_lambda_permission\" $ANYTHING {\n  ...\n  source_arn = ...\n  ...\n}\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$PRINCIPAL",
            "regex": ".*[.]amazonaws[.]com$"
          }
        }
      ],
      "message": "Your Lambda function permission grants access to AWS services without specifying a source ARN restriction. Without source ARN constraints, any resource in other AWS accounts could potentially invoke your function. Restricting the source ARN prevents unauthorized invocation of your Lambda function.",
      "languages": [
        "hcl"
      ],
      "severity": "ERROR",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "cwe": [
          "CWE-732: Incorrect Permission Assignment for Critical Resource"
        ],
        "references": [
          "https://cwe.mitre.org/data/definitions/732.html",
          "https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/lambda_permission",
          "https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-permission.html"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Lambda permission missing source restriction",
        "fix-suggestion": "Add a `source_arn` attribute to your `aws_lambda_permission` resource that specifies the exact ARN of the service resource authorized to invoke your function. This restricts invocation to only the intended resource, such as a specific S3 bucket, API Gateway, or SNS topic."
      }
    },
    {
      "id": "terraform.aws.security.aws-lambda-x-ray-tracing-not-active.aws-lambda-x-ray-tracing-not-active",
      "patterns": [
        {
          "pattern": "resource \"aws_lambda_function\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not": "resource \"aws_lambda_function\" $ANYTHING {\n  ...\n  tracing_config {\n    ...\n    mode = \"Active\"\n    ...\n  }\n  ...\n}\n"
        }
      ],
      "message": "Your Lambda function doesn't have X-Ray tracing enabled. Without tracing, it's difficult to debug performance issues, identify bottlenecks, or trace request flows through your serverless applications. X-Ray provides valuable insights into function execution and dependencies.",
      "languages": [
        "hcl"
      ],
      "severity": "INFO",
      "metadata": {
        "category": "security",
        "technology": [
          "aws",
          "terraform"
        ],
        "owasp": [
          "A09:2021 Security Logging and Monitoring Failures"
        ],
        "cwe": [
          "CWE-778: Insufficient Logging"
        ],
        "references": [
          "https://cwe.mitre.org/data/definitions/778.html",
          "https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/lambda_function#mode",
          "https://docs.aws.amazon.com/lambda/latest/dg/services-xray.html"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insufficient Logging"
        ],
        "short-description": "Lambda function missing X-Ray tracing",
        "fix-suggestion": "Enable X-Ray tracing by adding `tracing_config { mode = \"Active\" }` to your `aws_lambda_function` resource. Also ensure your function's execution role has the `AWSXRayDaemonWriteAccess` policy attached to allow writing trace data to X-Ray."
      }
    },
    {
      "id": "terraform.aws.security.aws-provider-static-credentials.aws-provider-static-credentials",
      "patterns": [
        {
          "pattern-inside": "provider \"aws\" {\n...\n    secret_key = \"$SECRET\"\n}\n"
        },
        {
          "focus-metavariable": "$SECRET"
        }
      ],
      "message": "Embedding access credentials directly in Terraform code makes them visible to anyone with access to the repository or deployment artifacts. These exposed credentials can be stolen and used to gain unauthorized access to cloud resources. Store credentials securely using environment variables, AWS vault, or other secure credential management systems.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "technology": [
          "secrets",
          "aws",
          "terraform"
        ],
        "category": "security",
        "cwe": [
          "CWE-798: Use of Hard-coded Credentials"
        ],
        "references": [
          "https://cheatsheetseries.owasp.org/cheatsheets/Secrets_Management_Cheat_Sheet.html"
        ],
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Hard-coded Secrets"
        ],
        "short-description": "Static AWS credentials in Terraform config are exposed",
        "fix-suggestion": "Remove hardcoded `access_key` and `secret_key` from Terraform AWS provider configurations. Use environment variables like `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY` or instance profiles instead. Consider implementing a secure secrets management system like HashiCorp Vault for credential handling."
      }
    },
    {
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "provisioner \"remote-exec\" {\n    ...\n}\n"
            },
            {
              "pattern": "provisioner \"local-exec\" {\n    ...\n}\n"
            }
          ]
        },
        {
          "pattern-inside": "resource \"aws_instance\" \"...\" {\n    ...\n}\n"
        }
      ],
      "id": "terraform.aws.security.aws-provisioner-exec.aws-provisioner-exec",
      "message": "Terraform provisioners execute arbitrary shell commands that cannot be mapped or predicted during planning. This creates security risks and reduced auditability for your infrastructure operations. Consider alternative approaches that integrate with Terraform's declarative model for better security and predictability.",
      "languages": [
        "terraform"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "owasp": [
          "A03:2021 - Injection",
          "A01:2017 - Injection"
        ],
        "cwe": [
          "CWE-77: Improper Neutralization of Special Elements used in a Command ('Command Injection')",
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "subcategory": [
          "audit"
        ],
        "confidence": "HIGH",
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "technology": [
          "terraform"
        ],
        "references": [
          "https://developer.hashicorp.com/terraform/language/resources/provisioners/remote-exec",
          "https://developer.hashicorp.com/terraform/language/resources/provisioners/local-exec"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection",
          "Configuration"
        ],
        "short-description": "Provisioners execute unpredictable shell commands",
        "fix-suggestion": "Avoid using `provisioners` in Terraform configurations whenever possible. Use native Terraform resources and data sources instead of shell commands. If necessary, implement required functionality through dedicated modules with controlled behavior."
      }
    },
    {
      "id": "terraform.aws.security.aws-rds-backup-no-retention.aws-rds-backup-no-retention",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "resource \"aws_rds_cluster\" $ANYTHING {\n  ...\n  backup_retention_period = 0\n  ...\n}\n"
            },
            {
              "pattern": "resource \"aws_db_instance\" $ANYTHING {\n  ...\n  backup_retention_period = 0\n  ...\n}\n"
            }
          ]
        }
      ],
      "message": "Your AWS RDS database instance does not have a backup retention period configured. Without proper backup retention, you risk losing critical data in case of failures or security incidents. Setting a proper backup retention period ensures your data can be recovered when needed.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "cwe": [
          "CWE-320: CWE CATEGORY: Key Management Errors"
        ],
        "technology": [
          "aws",
          "terraform"
        ],
        "category": "security",
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Missing RDS backup retention period configuration",
        "fix-suggestion": "Add the `backup_retention_period` parameter to your RDS instance configuration with an appropriate value (at least 7 days recommended). Ensure this retention period aligns with your organization's data retention policies and compliance requirements."
      }
    },
    {
      "id": "terraform.aws.security.aws-redshift-cluster-encrypted-with-cmk.aws-redshift-cluster-encrypted-with-cmk",
      "patterns": [
        {
          "pattern": "resource \"aws_redshift_cluster\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_redshift_cluster\" $ANYTHING {\n  ...\n  kms_key_id = ...\n  ...\n}\n"
        }
      ],
      "message": "Your AWS Redshift cluster should be encrypted using AWS KMS Customer Managed Keys (CMKs) rather than default AWS-managed keys. CMKs provide greater control over access policies, key rotation schedules, and audit capabilities. This additional control is essential for sensitive data workloads requiring strict security controls.",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-284: Improper Access Control"
        ],
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Redshift cluster lacks customer-managed encryption keys",
        "fix-suggestion": "Configure your Redshift cluster with a Customer Managed Key (CMK) by setting the `kms_key_id` parameter to your KMS key ARN. Create a CMK using `aws_kms_key` resource and implement proper key rotation policies to maintain encryption security over time."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.aws.security.aws-s3-bucket-object-encrypted-with-cmk.aws-s3-bucket-object-encrypted-with-cmk",
      "patterns": [
        {
          "pattern": "resource \"aws_s3_bucket_object\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_s3_bucket_object\" $ANYTHING {\n  ...\n  kms_key_id = ...\n  ...\n}\n"
        }
      ],
      "message": "Your S3 bucket objects should be encrypted with AWS KMS Customer Managed Keys (CMKs) instead of default AWS-managed keys. CMKs provide enhanced control over access policies, key rotation, and auditing capabilities. This configuration is critical for sensitive data requiring regulatory compliance or enhanced security controls.",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "cwe": [
          "CWE-320: CWE CATEGORY: Key Management Errors"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "S3 objects lack customer-managed encryption keys",
        "fix-suggestion": "Add `kms_key_id` to your S3 bucket's server-side encryption configuration, referencing a KMS CMK created with `aws_kms_key`. Configure appropriate key policies and implement automated key rotation to maintain strong encryption security for your S3 objects."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.aws.security.aws-s3-object-copy-encrypted-with-cmk.aws-s3-object-copy-encrypted-with-cmk",
      "patterns": [
        {
          "pattern": "resource \"aws_s3_object_copy\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_s3_object_copy\" $ANYTHING {\n  ...\n  kms_key_id = ...\n  ...\n}\n"
        }
      ],
      "message": "Your S3 object copies should be encrypted with AWS KMS Customer Managed Keys (CMKs) rather than AWS-managed keys. Using CMKs provides greater control over key access, rotation policies, and audit capabilities. This enhanced control is essential for maintaining security compliance when copying sensitive data between S3 buckets.",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "cwe": [
          "CWE-320: CWE CATEGORY: Key Management Errors"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "S3 object copies lack customer-managed encryption",
        "fix-suggestion": "When using `aws_s3_object_copy`, specify the `kms_key_id` parameter with a reference to your Customer Managed Key. Create the CMK using `aws_kms_key` resource and ensure proper key policies are attached to maintain access control over encrypted objects."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.aws.security.aws-sagemaker-domain-encrypted-with-cmk.aws-sagemaker-domain-encrypted-with-cmk",
      "patterns": [
        {
          "pattern": "resource \"aws_sagemaker_domain\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_sagemaker_domain\" $ANYTHING {\n  ...\n  kms_key_id = ...\n  ...\n}\n"
        }
      ],
      "message": "Your AWS SageMaker domain should be encrypted with Customer Managed Keys (CMKs) rather than default AWS-managed keys. CMKs provide enhanced control over access policies, key rotation schedules, and audit capabilities. This is especially important for SageMaker domains containing proprietary models or sensitive training data.",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "cwe": [
          "CWE-320: CWE CATEGORY: Key Management Errors"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "SageMaker domain lacks customer-managed encryption",
        "fix-suggestion": "Configure your SageMaker domain with encryption by setting the `kms_key_id` parameter to reference your Customer Managed Key. Create a KMS key using `aws_kms_key` resource and implement appropriate IAM policies to control who can use the key for encryption and decryption operations."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.aws.security.aws-secretsmanager-secret-unencrypted.aws-secretsmanager-secret-unencrypted",
      "patterns": [
        {
          "pattern": "resource \"aws_secretsmanager_secret\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_secretsmanager_secret\" $ANYTHING {\n  ...\n  kms_key_id = ...\n  ...\n}\n"
        }
      ],
      "message": "Your AWS Secrets Manager secrets are using default AWS-managed encryption keys rather than Customer Managed Keys (CMKs). While the default encryption provides basic protection, CMKs offer greater control over key access, rotation policies, and audit capabilities. This enhanced control is crucial for secrets requiring strict security compliance.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "technology": [
          "aws",
          "terraform"
        ],
        "category": "security",
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Secrets Manager lacks customer-managed encryption keys",
        "fix-suggestion": "Add the `kms_key_id` parameter to your Secrets Manager configuration, referencing a Customer Managed Key. Create a KMS key using `aws_kms_key` resource with appropriate key policies to control who can use the key for encrypting and accessing secrets."
      }
    },
    {
      "id": "terraform.aws.security.aws-sqs-queue-policy-wildcard-principal.aws-sqs-queue-policy-wildcard-principal",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "resource \"aws_sqs_queue_policy\" $ANYTHING {\n  ...\n}\n"
            },
            {
              "pattern-inside": "resource \"aws_sqs_queue\" $ANYTHING {\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern": "policy = \"$JSONPOLICY\""
                },
                {
                  "metavariable-pattern": {
                    "metavariable": "$JSONPOLICY",
                    "language": "json",
                    "patterns": [
                      {
                        "pattern-not-inside": "{..., \"Effect\": \"Deny\", ...}\n"
                      },
                      {
                        "pattern-either": [
                          {
                            "pattern": "{..., \"Principal\": \"*\", ...}\n"
                          },
                          {
                            "pattern": "{..., \"Principal\": [..., \"*\", ...], ...}\n"
                          },
                          {
                            "pattern": "{..., \"Principal\": { \"AWS\": \"*\" }, ...}\n"
                          },
                          {
                            "pattern": "{..., \"Principal\": { \"AWS\": [..., \"*\", ...] }, ...}\n"
                          }
                        ]
                      }
                    ]
                  }
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-inside": "policy = jsonencode(...)"
                },
                {
                  "pattern-not-inside": "{..., Effect = \"Deny\", ...}\n"
                },
                {
                  "pattern-either": [
                    {
                      "pattern": "{..., Principal = \"*\", ...}\n"
                    },
                    {
                      "pattern": "{..., Principal = [..., \"*\", ...], ...}\n"
                    },
                    {
                      "pattern": "{..., Principal = { AWS = \"*\" }, ...}\n"
                    },
                    {
                      "pattern": "{..., Principal = { AWS = [..., \"*\", ...] }, ...}\n"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ],
      "message": "Your SQS queue policy contains a wildcard principal, granting access to all users including anonymous ones. This overly permissive access model violates the principle of least privilege and could allow unauthorized message processing or sensitive data leakage. Always specify explicit principals with the minimum required permissions in your queue policies.",
      "metadata": {
        "category": "security",
        "technology": [
          "aws",
          "terraform"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "cwe": [
          "CWE-732: Incorrect Permission Assignment for Critical Resource"
        ],
        "references": [
          "https://cwe.mitre.org/data/definitions/732.html",
          "https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/sqs_queue",
          "https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/sqs_queue_policy",
          "https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-security-best-practices.html"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "rule-origin-note": "published from /src/aws-sqs-queue-policy-wildcard-principal.yml in None",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "SQS queue policy uses dangerous wildcard principal",
        "fix-suggestion": "Replace the wildcard (`*`) in your SQS queue policy's `Principal` field with specific AWS account IDs or IAM ARNs. Limit the `Action` elements to only those operations necessary for the application's functionality, following the principle of least privilege to reduce your security exposure."
      },
      "languages": [
        "hcl"
      ],
      "severity": "ERROR"
    },
    {
      "id": "terraform.aws.security.aws-ssm-document-logging-issues.aws-ssm-document-logging-issues",
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-not-inside": "resource \"aws_ssm_document\" $ANYTHING {\n  ...\n  document_format = \"YAML\"\n  ...\n}\n"
                },
                {
                  "pattern": "content = \"$STATEMENT\""
                },
                {
                  "metavariable-pattern": {
                    "metavariable": "$STATEMENT",
                    "language": "json",
                    "patterns": [
                      {
                        "pattern-either": [
                          {
                            "pattern": "\"s3EncryptionEnabled\": false"
                          },
                          {
                            "pattern": "\"cloudWatchEncryptionEnabled\": false"
                          },
                          {
                            "pattern": "{..., \"cloudWatchLogGroupName\": \"\", ..., \"s3BucketName\": \"\", ...}"
                          }
                        ]
                      }
                    ]
                  }
                }
              ]
            }
          ]
        }
      ],
      "message": "Your AWS Systems Manager (SSM) documents have logging that is either disabled or unencrypted. Without proper encrypted logging, you lose visibility into document execution and can't effectively audit sensitive automation activities. Encrypted logs are essential for maintaining proper security controls and compliance with regulatory requirements.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "technology": [
          "aws",
          "terraform"
        ],
        "category": "security",
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "SSM documents missing encrypted logging",
        "fix-suggestion": "Enable SSM document logging and configure encryption using a KMS Customer Managed Key (CMK) by adding the `kms_key_id` parameter to your SSM document configuration. Create a dedicated `aws_kms_key` resource with appropriate key policies to protect your SSM operational logs from unauthorized access."
      }
    },
    {
      "id": "terraform.aws.security.aws-subnet-has-public-ip-address.aws-subnet-has-public-ip-address",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "resource \"aws_subnet\" $ANYTHING {\n  ...\n  map_public_ip_on_launch = true\n  ...\n}\n"
            },
            {
              "pattern": "resource \"aws_default_subnet\" $ANYTHING {\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern-not": "resource \"aws_default_subnet\" $ANYTHING {\n  ...\n  map_public_ip_on_launch = false\n  ...\n}\n"
        }
      ],
      "message": "Your AWS subnet is configured to automatically assign public IP addresses to resources launched within it. This configuration unnecessarily exposes internal resources to the internet, creating potential attack vectors for malicious actors. Follow the principle of least exposure by only assigning public IPs to resources that specifically require internet access.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-284: Improper Access Control"
        ],
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control/",
          "https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/subnet#map_public_ip_on_launch",
          "https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-instance-addressing.html#concepts-public-addresses"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Subnet auto-assigns public IPs to instances",
        "fix-suggestion": "Set `map_public_ip_on_launch = false` in your subnet configuration to prevent automatic public IP assignment. For resources that genuinely need internet access, use a load balancer or NAT gateway as a controlled gateway instead of directly exposing instances with public IPs."
      }
    },
    {
      "id": "terraform.aws.security.aws-timestream-database-encrypted-with-cmk.aws-timestream-database-encrypted-with-cmk",
      "patterns": [
        {
          "pattern": "resource \"aws_timestreamwrite_database\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_timestreamwrite_database\" $ANYTHING {\n  ...\n  kms_key_id = ...\n  ...\n}\n"
        }
      ],
      "message": "Your AWS Timestream database should be encrypted with a Customer Managed Key (CMK) rather than the default AWS-managed keys. CMKs provide enhanced control over key access, rotation policies, and audit capabilities. This additional control is important for time-series data that may contain sensitive operational metrics or customer information.",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "cwe": [
          "CWE-320: CWE CATEGORY: Key Management Errors"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Timestream database lacks customer-managed encryption",
        "fix-suggestion": "Configure your Timestream database with encryption by adding the `kms_key_id` parameter referencing your Customer Managed Key. Create a KMS CMK using the `aws_kms_key` resource and implement appropriate IAM policies to control who can use the key for encryption and decryption operations."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.aws.security.aws-transfer-server-is-public.aws-transfer-server-is-public",
      "patterns": [
        {
          "pattern": "resource \"aws_transfer_server\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_transfer_server\" $ANYTHING {\n  ...\n  endpoint_type = \"VPC\"\n  ...\n}\n"
        }
      ],
      "message": "Your AWS Transfer Server is configured with a public endpoint type, making it accessible from the internet. This exposes your file transfer service to potential unauthorized access and attacks from malicious actors worldwide. Restrict access by using a VPC endpoint that limits connectivity to your internal network resources.",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-284: Improper Access Control"
        ],
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Transfer Server exposed with public endpoint",
        "fix-suggestion": "Set `endpoint_type = \"VPC\"` in your AWS Transfer Server configuration to restrict access to your VPC network only. Configure appropriate security groups and VPC endpoints to control which internal resources can communicate with the transfer service without exposing it to the public internet."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.aws.security.aws-workspaces-root-volume-unencrypted.aws-workspaces-root-volume-unencrypted",
      "patterns": [
        {
          "pattern": "resource \"aws_workspaces_workspace\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_workspaces_workspace\" $ANYTHING {\n  ...\n  root_volume_encryption_enabled = true\n  ...\n}\n"
        }
      ],
      "message": "Your AWS WorkSpaces root volumes are not encrypted, potentially exposing sensitive operating system and application data. Without encryption, data could be vulnerable if the underlying storage is compromised or during hardware decommissioning. Configuring KMS encryption for WorkSpaces root volumes is essential for maintaining data confidentiality.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "technology": [
          "aws",
          "terraform"
        ],
        "category": "security",
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "WorkSpaces root volumes lack encryption",
        "fix-suggestion": "Add the `root_volume_encryption_enabled = true` and `root_volume_kms_key_id` parameters to your WorkSpace configuration. Create a dedicated KMS key using `aws_kms_key` resource with appropriate permissions to ensure your WorkSpaces root volumes are properly encrypted for data protection."
      }
    },
    {
      "id": "terraform.aws.security.aws-workspaces-user-volume-unencrypted.aws-workspaces-user-volume-unencrypted",
      "patterns": [
        {
          "pattern": "resource \"aws_workspaces_workspace\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_workspaces_workspace\" $ANYTHING {\n  ...\n  user_volume_encryption_enabled = true\n  ...\n}\n"
        }
      ],
      "message": "Your AWS WorkSpaces user volumes are not encrypted, leaving user data vulnerable to unauthorized access. Unencrypted user volumes could expose confidential documents, application data, and personal information if the underlying storage is compromised. Implementing KMS encryption for user volumes is critical for protecting sensitive user data.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "cwe": [
          "CWE-320: CWE CATEGORY: Key Management Errors"
        ],
        "technology": [
          "aws",
          "terraform"
        ],
        "category": "security",
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "WorkSpaces user volumes lack encryption",
        "fix-suggestion": "Enable user volume encryption by setting `user_volume_encryption_enabled = true` and specifying a KMS key with `user_volume_kms_key_id` in your WorkSpace configuration. Create a dedicated KMS key using `aws_kms_key` resource with appropriate key policies to protect user data from unauthorized access."
      }
    },
    {
      "id": "terraform.aws.security.insecure-load-balancer-tls-version.insecure-load-balancer-tls-version",
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern": "ssl_policy = $ANYTHING"
                },
                {
                  "pattern-not-regex": "ELBSecurityPolicy-TLS13-1-[23]-[0-9-]+"
                },
                {
                  "pattern-not-regex": "ELBSecurityPolicy-FS-1-2-[(Res)0-9-]+"
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern": "protocol = \"HTTP\""
                },
                {
                  "pattern-not-inside": "resource $ANYTHING $NAME {\n  ...\n  default_action {\n    ...\n    redirect {\n      ...\n      protocol = \"HTTPS\"\n      ...\n    }\n    ...\n  }\n  ...\n}\n"
                }
              ]
            }
          ]
        },
        {
          "pattern-inside": "resource $RESOURCE $X {\n  ...\n}\n"
        },
        {
          "metavariable-pattern": {
            "metavariable": "$RESOURCE",
            "patterns": [
              {
                "pattern-either": [
                  {
                    "pattern": "\"aws_lb_listener\"\n"
                  },
                  {
                    "pattern": "\"aws_alb_listener\"\n"
                  }
                ]
              }
            ]
          }
        }
      ],
      "message": "Your AWS load balancer is configured with an outdated and insecure TLS version. TLS versions older than 1.2 contain known vulnerabilities that attackers can exploit to intercept or modify sensitive data in transit. Using modern TLS protocols is essential to maintain a secure connection between clients and your applications.",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "references": [
          "https://www.ietf.org/rfc/rfc5246.txt"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Load balancer uses deprecated insecure TLS version",
        "fix-suggestion": "Update your load balancer configuration by setting `ssl_policy = \"ELBSecurityPolicy-TLS13-1-2-2021-06\"` to enforce modern TLS protocols. For HTTP listeners, add a default action to redirect traffic to HTTPS to ensure all communications are encrypted with secure protocols."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.aws.security.missing-athena-workgroup-encryption.missing-athena-workgroup-encryption",
      "patterns": [
        {
          "pattern": "resource \"aws_athena_workgroup\" $ANYTHING {...}"
        },
        {
          "pattern-not-inside": "resource \"aws_athena_workgroup\" $ANYTHING {\n  ...\n  encryption_configuration {...}\n  ...\n}\n"
        }
      ],
      "message": "Your AWS Athena workgroup is not configured with encryption for query results. Unencrypted query results could expose sensitive data extracted from your data sources to unauthorized users. Configuring encryption ensures that all query results are protected at rest, maintaining confidentiality for your analytics data.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "metadata": {
        "technology": [
          "aws",
          "terraform"
        ],
        "category": "security",
        "owasp": [
          "A03:2017 - Sensitive Data Exposure"
        ],
        "cwe": [
          "CWE-320: CWE CATEGORY: Key Management Errors"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Athena workgroup lacks query result encryption",
        "fix-suggestion": "Add encryption to your Athena workgroup by configuring `result_configuration { encryption_configuration { encryption_option = \"SSE_KMS\" kms_key_arn = aws_kms_key.example.arn }}` in your resource block. Create a KMS key using `aws_kms_key` resource with appropriate permissions to protect your query results."
      }
    },
    {
      "id": "terraform.aws.security.unrestricted-github-oidc-policy.unrestricted-github-oidc-policy",
      "metadata": {
        "category": "security",
        "subcategory": [
          "audit"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A05:2017 - Sensitive Data Exposure",
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-284: Improper Access Control"
        ],
        "references": [
          "https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services#configuring-the-role-and-trust-policy",
          "https://dagrz.com/writing/aws-security/hacking-github-aws-oidc/"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "GitHub OIDC policy lacks repository restrictions",
        "fix-suggestion": "Add a `condition` block to your IAM role's trust policy that specifies exactly which GitHub repositories can assume the role, using `StringEquals` or `StringLike` with the `token.actions.githubusercontent.com:sub` claim. Limit access to only specific repositories with a pattern like `repo:your-org/your-repo:*` to prevent unauthorized access."
      },
      "message": "Your GitHub OIDC policy lacks proper repository restrictions, allowing any GitHub workflow to assume your AWS role. This configuration creates a significant security risk as malicious actors could create workflows to access your AWS resources. Always restrict OIDC trust policies to specific repositories where your trusted workflows exist.",
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "match": {
        "where": [
          {
            "metavariable": "$IDENTIFIER",
            "regex": ".*oidc-provider/token\\.actions\\.githubusercontent\\.com"
          }
        ],
        "all": [
          {
            "inside": "data \"aws_iam_policy_document\" $POLICY {\n  ...\n}\n"
          },
          "statement {\n  ...\n  principals {\n    ...\n    type = \"Federated\"\n    identifiers = [..., $IDENTIFIER, ...]\n  }\n}\n",
          {
            "not": "statement {\n  ...\n  condition {\n    ...\n    variable = \"token.actions.githubusercontent.com:sub\"\n  }\n}\n"
          }
        ]
      }
    },
    {
      "id": "terraform.aws.security.wildcard-assume-role.wildcard-assume-role",
      "patterns": [
        {
          "pattern-inside": "resource \"aws_iam_role\" $NAME {\n  ...\n}\n"
        },
        {
          "pattern": "assume_role_policy = \"$STATEMENT\""
        },
        {
          "metavariable-pattern": {
            "metavariable": "$STATEMENT",
            "language": "json",
            "patterns": [
              {
                "pattern-inside": "{..., \"Effect\": \"Allow\", ..., \"Action\": \"sts:AssumeRole\", ...}\n"
              },
              {
                "pattern": "\"Principal\": {..., \"AWS\": \"*\", ...}\n"
              }
            ]
          }
        }
      ],
      "message": "Your IAM role trust policy contains a wildcard principal for AssumeRole actions, allowing any entity in your AWS account to assume this role. This overly permissive configuration violates the principle of least privilege and creates potential privilege escalation paths. Restrict role assumption to only specific identities that require this access.",
      "metadata": {
        "cwe": [
          "CWE-250: Execution with Unnecessary Privileges"
        ],
        "category": "security",
        "technology": [
          "aws"
        ],
        "references": [
          "https://rhinosecuritylabs.com/aws/assume-worst-aws-assume-role-enumeration/"
        ],
        "owasp": [
          "A06:2017 - Security Misconfiguration",
          "A05:2021 - Security Misconfiguration"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "IAM role allows wildcard principal assumption",
        "fix-suggestion": "Replace the wildcard principal in your role's trust policy with specific IAM ARNs like `arn:aws:iam::<account_id>:role/<specific-role>` or `arn:aws:iam::<account_id>:user/<specific-user>`. Add conditions to further restrict when the role can be assumed, such as requiring MFA authentication or limiting by source IP address."
      },
      "languages": [
        "hcl"
      ],
      "severity": "ERROR"
    },
    {
      "id": "terraform.aws.security.aws-cloudfront-insecure-tls.aws-insecure-cloudfront-distribution-tls-version",
      "patterns": [
        {
          "pattern": "resource \"aws_cloudfront_distribution\" $ANYTHING {\n  ...\n  viewer_certificate {\n    ...\n  }\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_cloudfront_distribution\" $ANYTHING {\n  ...\n  viewer_certificate {\n    ...\n    minimum_protocol_version = \"TLSv1.2_2018\"\n    ...\n  }\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_cloudfront_distribution\" $ANYTHING {\n  ...\n  viewer_certificate {\n    ...\n    minimum_protocol_version = \"TLSv1.2_2019\"\n    ...\n  }\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_cloudfront_distribution\" $ANYTHING {\n  ...\n  viewer_certificate {\n    ...\n    minimum_protocol_version = \"TLSv1.2_2021\"\n    ...\n  }\n  ...\n}\n"
        }
      ],
      "message": "Your CloudFront distribution is configured with an outdated and vulnerable TLS protocol version. TLS versions older than 1.2 contain known cryptographic weaknesses that attackers can exploit to compromise encrypted connections. Upgrading to modern TLS protocols is essential for protecting the data transmitted between your users and your distribution.",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "CloudFront uses deprecated insecure TLS version",
        "fix-suggestion": "Update your CloudFront distribution's `minimum_protocol_version` to at least `\"TLSv1.2_2021\"` in your viewer certificate configuration. This ensures your distribution uses only secure TLS protocols and cipher suites that provide strong encryption and protection against known attacks."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.aws.security.aws-elasticsearch-nodetonode-encryption.aws-elasticsearch-nodetonode-encryption-not-enabled",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "resource \"aws_elasticsearch_domain\" $ANYTHING {\n  ...\n  node_to_node_encryption {\n    ...\n    enabled = false\n    ...\n  }\n  ...\n}\n"
            },
            {
              "pattern": "resource \"aws_elasticsearch_domain\" $ANYTHING {\n  ...\n  cluster_config {\n    ...\n    instance_count = $COUNT\n    ...\n  }\n}\n"
            }
          ]
        },
        {
          "pattern-not-inside": "resource \"aws_elasticsearch_domain\" $ANYTHING {\n  ...\n  cluster_config {\n    ...\n    instance_count = $COUNT\n    ...\n  }\n  node_to_node_encryption {\n    ...\n    enabled = true\n    ...\n  }\n}\n"
        },
        {
          "metavariable-comparison": {
            "metavariable": "$COUNT",
            "comparison": "$COUNT > 1"
          }
        }
      ],
      "message": "Your Elasticsearch domain does not have node-to-node encryption enabled. Without this encryption, data transmitted between nodes within your cluster is vulnerable to interception by attackers with network access. Enabling node-to-node encryption ensures that all intra-cluster communication is protected, maintaining data confidentiality throughout your Elasticsearch environment.",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "references": [
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Elasticsearch missing node-to-node encryption",
        "fix-suggestion": "Enable node-to-node encryption in your Elasticsearch domain by setting `node_to_node_encryption { enabled = true }` in your domain configuration. This ensures that all communication between nodes in your Elasticsearch cluster is encrypted, preventing unauthorized access to data in transit between nodes."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.aws.security.aws-fsx-lustre-files-ystem.aws-fsx-lustre-filesystem-encrypted-with-cmk",
      "patterns": [
        {
          "pattern": "resource \"aws_fsx_lustre_file_system\" $ANYTHING {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_fsx_lustre_file_system\" $ANYTHING {\n  ...\n  kms_key_id = ...\n  ...\n}\n"
        },
        {
          "pattern-regex": "(^aws_kms_key\\.(.*))"
        }
      ],
      "message": "Your FSx Lustre file system should be encrypted with a Customer Managed Key (CMK) rather than default AWS-managed keys. CMKs provide enhanced control over key access policies, rotation schedules, and audit capabilities. This additional control is important for file systems that may contain sensitive data requiring strong security controls.",
      "metadata": {
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor"
        ],
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "FSx Lustre lacks customer-managed encryption keys",
        "fix-suggestion": "Configure your FSx Lustre file system with encryption by setting the `kms_key_id` parameter to your KMS key ARN. Create a CMK using `aws_kms_key` resource and implement proper key rotation policies to maintain strong encryption security for your file system data."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.azure.security.appservice.appservice-account-identity-registered.appservice-account-identity-registered",
      "message": "Azure App Services without a registered identity must use hardcoded credentials for accessing other Azure resources, risking credential exposure. When an identity is registered, the App Service can use Azure's managed identity system for secure, automatic authentication. Configure the identity block in your Terraform Azure App Service resource to enable secure authentication without credential management.",
      "patterns": [
        {
          "pattern": "resource"
        },
        {
          "pattern-not-inside": "resource \"azurerm_app_service\" \"...\" {\n...\n  identity {\n    type = \"...\"\n    identity_ids = \"...\"\n  }\n...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"azurerm_app_service\" \"...\" {\n...\n  identity {\n    type = \"SystemAssigned\"\n  }\n...\n}\n"
        },
        {
          "pattern-inside": "resource \"azurerm_app_service\" \"...\" {\n...\n}\n"
        }
      ],
      "metadata": {
        "category": "security",
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A07:2021 - Identification and Authentication Failures"
        ],
        "cwe": [
          "CWE-287: Improper Authentication"
        ],
        "technology": [
          "terraform",
          "azure"
        ],
        "references": [
          "https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/app_service#identity"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Azure App Service missing managed identity for secure access",
        "fix-suggestion": "Configure the `identity` block with `type = \"SystemAssigned\"` in your App Service resource definition. Remove hardcoded service principal credentials from your configuration. Use managed identities to automatically handle authentication between your App Service and other Azure resources."
      },
      "languages": [
        "hcl"
      ],
      "severity": "INFO"
    },
    {
      "id": "terraform.azure.security.appservice.appservice-authentication-enabled.appservice-authentication-enabled",
      "message": "An Azure App Service without authentication configured allows anonymous access to all endpoints without user verification. This lack of authentication can lead to unauthorized data access, API abuse, or application compromise. Enable the auth_settings block in your App Service configuration to enforce proper user authentication before accessing sensitive functionality.",
      "patterns": [
        {
          "pattern": "resource"
        },
        {
          "pattern-not-inside": "resource \"azurerm_app_service\" \"...\" {\n...\n  auth_settings {\n    ...\n    enabled = true\n    ...\n  }\n...\n}\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "resource \"azurerm_app_service\" \"...\" {\n...\n}\n"
            },
            {
              "pattern-inside": "resource \"azurerm_app_service\" \"...\" {\n...\n  auth_settings {\n    ...\n    enabled = false\n    ...\n  }\n...\n}\n"
            }
          ]
        }
      ],
      "metadata": {
        "cwe": [
          "CWE-287: Improper Authentication"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "azure"
        ],
        "references": [
          "https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/app_service#auth_settings"
        ],
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A07:2021 - Identification and Authentication Failures"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Azure App Service authentication not enabled",
        "fix-suggestion": "Enable the `auth_settings` block in your Azure App Service configuration with `enabled = true`. Configure appropriate identity providers using the `active_directory` or other provider blocks. Set `unauthenticated_client_action` to restrict access to authenticated users only."
      },
      "languages": [
        "hcl"
      ],
      "severity": "ERROR"
    },
    {
      "id": "terraform.azure.security.appservice.appservice-enable-http2.appservice-enable-http2",
      "message": "Your Azure App Service is not configured to use HTTP/2, missing out on important security improvements and performance benefits. HTTP/2 provides better encryption capabilities, header compression, and multiplexing features that enhance security and efficiency. Enabling HTTP/2 is a simple configuration change that improves your application's security posture.",
      "patterns": [
        {
          "pattern": "resource"
        },
        {
          "pattern-not-inside": "resource \"azurerm_app_service\" \"...\" {\n...\n  site_config {\n    ...\n    http2_enabled = true\n    ...\n  }\n...\n}\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "resource \"azurerm_app_service\" \"...\" {\n...\n}\n"
            },
            {
              "pattern-inside": "resource \"azurerm_app_service\" \"...\" {\n...\n  site_config {\n    ...\n    http2_enabled = false\n    ...\n  }\n...\n}\n"
            }
          ]
        }
      ],
      "metadata": {
        "cwe": [
          "CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "azure"
        ],
        "references": [
          "https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/app_service#http2_enabled"
        ],
        "owasp": [
          "A04:2021 - Insecure Design"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "App Service missing HTTP/2 protocol support",
        "fix-suggestion": "Enable HTTP/2 protocol support in your Azure App Service by adding `http2_enabled = true` to your App Service resource block. This configuration enhances both performance and security by leveraging the improved features of the newer HTTP protocol version."
      },
      "languages": [
        "hcl"
      ],
      "severity": "INFO"
    },
    {
      "id": "terraform.azure.security.appservice.appservice-enable-https-only.appservice-enable-https-only",
      "message": "Your Azure App Service allows insecure HTTP connections, potentially exposing sensitive data in transit. Unencrypted HTTP traffic can be intercepted, revealing user credentials, session tokens, and other confidential information. Enforcing HTTPS-only connections ensures all communication with your application is encrypted and protected from eavesdropping.",
      "patterns": [
        {
          "pattern": "resource"
        },
        {
          "pattern-not-inside": "resource \"azurerm_app_service\" \"...\" {\n...\n  https_only = true\n...\n}\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "resource \"azurerm_app_service\" \"...\" {\n...\n}\n"
            },
            {
              "pattern-inside": "resource \"azurerm_app_service\" \"...\" {\n...\n  https_only = false\n...\n}\n"
            }
          ]
        }
      ],
      "metadata": {
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "azure"
        ],
        "references": [
          "https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/app_service#https_only",
          "https://docs.microsoft.com/en-us/azure/app-service/configure-ssl-bindings#enforce-https"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "App Service allows insecure HTTP connections",
        "fix-suggestion": "Force all traffic to use HTTPS by setting `https_only = true` in your Azure App Service configuration. This prevents clients from connecting over insecure HTTP connections and automatically redirects any HTTP requests to HTTPS, ensuring all data in transit is encrypted."
      },
      "languages": [
        "hcl"
      ],
      "severity": "ERROR"
    },
    {
      "id": "terraform.azure.security.appservice.appservice-require-client-cert.appservice-require-client-cert",
      "message": "Your Azure App Service is not configured to require client certificates for authentication. Without client certificate validation, your app might be vulnerable to unauthorized access as it relies solely on standard authentication methods. Client certificates provide an additional layer of security by ensuring only authorized clients with valid certificates can connect.",
      "patterns": [
        {
          "pattern": "resource"
        },
        {
          "pattern-not-inside": "resource \"azurerm_app_service\" \"...\" {\n...\n  client_cert_enabled = true\n...\n}\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "resource \"azurerm_app_service\" \"...\" {\n...\n}\n"
            },
            {
              "pattern-inside": "resource \"azurerm_app_service\" \"...\" {\n...\n  client_cert_enabled = false\n...\n}\n"
            }
          ]
        }
      ],
      "metadata": {
        "cwe": [
          "CWE-295: Improper Certificate Validation"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "azure"
        ],
        "references": [
          "https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/app_service#client_cert_enabled"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A07:2021 - Identification and Authentication Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "App Service missing client certificate validation",
        "fix-suggestion": "Enable client certificate validation by adding `client_cert_enabled = true` to your App Service resource configuration. Configure the appropriate client certificate mode using `client_cert_mode` to either request or require certificates from connecting clients for enhanced authentication security."
      },
      "languages": [
        "hcl"
      ],
      "severity": "INFO"
    },
    {
      "id": "terraform.azure.security.appservice.appservice-use-secure-tls-policy.appservice-use-secure-tls-policy",
      "message": "Your Azure App Service is configured with outdated TLS protocol versions that contain known security vulnerabilities. Older TLS versions (1.0 and 1.1) have cryptographic weaknesses that can be exploited by attackers to compromise encrypted communications. Enforcing modern TLS standards is essential for maintaining secure connections to your application.",
      "patterns": [
        {
          "pattern": "min_tls_version = $ANYTHING"
        },
        {
          "pattern-inside": "resource \"azurerm_app_service\" \"$NAME\" {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "min_tls_version = \"1.2\""
        }
      ],
      "metadata": {
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "azure"
        ],
        "references": [
          "https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/app_service#min_tls_version"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "App Service uses deprecated insecure TLS version",
        "fix-suggestion": "Set `site_config { min_tls_version = \"1.2\" }` in your App Service configuration to enforce the use of TLS 1.2 or higher. This ensures your app uses secure encryption protocols for all HTTPS connections, protecting sensitive data in transit."
      },
      "languages": [
        "hcl"
      ],
      "severity": "ERROR"
    },
    {
      "id": "terraform.azure.security.functionapp.functionapp-authentication-enabled.functionapp-authentication-enabled",
      "message": "Azure Function Apps without authentication enabled allow anonymous invocation of all functions, potentially exposing sensitive operations. Unauthenticated functions can be abused for data theft, unauthorized actions, or as entry points for further attacks. Configure the auth_settings block in your Function App to ensure proper authentication before allowing function execution.",
      "patterns": [
        {
          "pattern": "resource"
        },
        {
          "pattern-not-inside": "resource \"azurerm_function_app\" \"...\" {\n...\n  auth_settings {\n    ...\n    enabled = true\n    ...\n  }\n...\n}\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "resource \"azurerm_function_app\" \"...\" {\n...\n}\n"
            },
            {
              "pattern-inside": "resource \"azurerm_function_app\" \"...\" {\n...\n  auth_settings {\n    ...\n    enabled = false\n    ...\n  }\n...\n}\n"
            }
          ]
        }
      ],
      "metadata": {
        "cwe": [
          "CWE-287: Improper Authentication"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "azure"
        ],
        "references": [
          "https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/function_app#enabled"
        ],
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A07:2021 - Identification and Authentication Failures"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Azure Function App authentication is not configured",
        "fix-suggestion": "Add an `auth_settings` block to your Azure Function App resource with `enabled = true`. Configure authentication providers appropriate for your application requirements. Set proper `unauthenticated_client_action` to prevent anonymous access to sensitive functions."
      },
      "languages": [
        "hcl"
      ],
      "severity": "INFO"
    },
    {
      "id": "terraform.azure.security.functionapp.functionapp-enable-http2.functionapp-enable-http2",
      "message": "Your Azure Function App is not configured to use HTTP/2, missing out on important security improvements and performance benefits. HTTP/2 provides enhanced encryption, header compression, and multiplexing features that improve security and efficiency. Enabling HTTP/2 is a simple configuration change that improves your function's security posture.",
      "patterns": [
        {
          "pattern": "resource"
        },
        {
          "pattern-not-inside": "resource \"azurerm_function_app\" \"...\" {\n...\n  site_config {\n    ...\n    http2_enabled = true\n    ...\n  }\n...\n}\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "resource \"azurerm_function_app\" \"...\" {\n...\n}\n"
            },
            {
              "pattern-inside": "resource \"azurerm_function_app\" \"...\" {\n...\n  site_config {\n    ...\n    http2_enabled = false\n    ...\n  }\n...\n}\n"
            }
          ]
        }
      ],
      "metadata": {
        "cwe": [
          "CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request/Response Smuggling')"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "azure"
        ],
        "references": [
          "https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/function_app#http2_enabled"
        ],
        "owasp": [
          "A04:2021 - Insecure Design"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "Function App missing HTTP/2 protocol support",
        "fix-suggestion": "Enable HTTP/2 protocol support by adding `http2_enabled = true` to your Azure Function App resource block. This configuration enhances both performance and security by leveraging the improved features of the newer HTTP protocol version."
      },
      "languages": [
        "hcl"
      ],
      "severity": "INFO"
    },
    {
      "id": "terraform.azure.security.keyvault.keyvault-content-type-for-secret.keyvault-content-type-for-secret",
      "message": "Your Azure Key Vault secrets are missing content type metadata. Without proper content type identification, secrets may be misinterpreted or incorrectly processed when retrieved by applications. Setting appropriate content types improves secret management, enhances audit capabilities, and helps prevent misuse of sensitive credentials.",
      "patterns": [
        {
          "pattern": "resource"
        },
        {
          "pattern-not-inside": "resource \"azurerm_key_vault_secret\" \"...\" {\n...\ncontent_type = \"...\"\n...\n}\n"
        },
        {
          "pattern-inside": "resource \"azurerm_key_vault_secret\" \"...\" {\n...\n}\n"
        }
      ],
      "metadata": {
        "category": "correctness",
        "technology": [
          "terraform",
          "azure"
        ],
        "vulnerability_class": [
          "Configuration"
        ],
        "references": [
          "https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/key_vault_secret#content_type",
          "https://docs.microsoft.com/en-us/azure/key-vault/secrets/about-secrets"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "short-description": "Key Vault secrets missing content type metadata",
        "fix-suggestion": "Add the `content_type` attribute to all your Key Vault secret resources with descriptive values like `\"password\"`, `\"connection-string\"`, or `\"certificate\"`. This metadata helps applications correctly process the secrets and improves audit capabilities for tracking what types of secrets are stored."
      },
      "languages": [
        "hcl"
      ],
      "severity": "INFO"
    },
    {
      "id": "terraform.azure.security.keyvault.keyvault-ensure-key-expires.keyvault-ensure-key-expires",
      "message": "Your Azure Key Vault keys do not have expiration dates configured. Without expiration dates, cryptographic keys may remain active indefinitely, increasing the risk of compromise over time. Setting appropriate expiration dates ensures regular key rotation, which is a critical security practice and often required for compliance with security standards.",
      "patterns": [
        {
          "pattern": "resource"
        },
        {
          "pattern-not-inside": "resource \"azurerm_key_vault_key\" \"...\" {\n...\nexpiration_date = \"...\"\n...\n}\n"
        },
        {
          "pattern-inside": "resource \"azurerm_key_vault_key\" \"...\" {\n...\n}\n"
        }
      ],
      "metadata": {
        "cwe": [
          "CWE-262: Not Using Password Aging"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "azure"
        ],
        "references": [
          "https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/key_vault_key#expiration_date",
          "https://docs.microsoft.com/en-us/powershell/module/az.keyvault/update-azkeyvaultkey?view=azps-5.8.0#example-1--modify-a-key-to-enable-it--and-set-the-expiration-date-and-tags"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Key Vault keys lack expiration dates",
        "fix-suggestion": "Add the `expiration_date` attribute to all your Key Vault key resources with an appropriate timeframe based on your security policies. Implement an automated process to create new keys and update applications before existing keys expire to ensure continuous operation."
      },
      "languages": [
        "hcl"
      ],
      "severity": "INFO"
    },
    {
      "id": "terraform.azure.security.keyvault.keyvault-ensure-secret-expires.keyvault-ensure-secret-expires",
      "message": "Your Azure Key Vault secrets do not have expiration dates configured. Without expiration dates, credentials and other sensitive information may remain active long after they should be retired. Setting appropriate expiration dates enforces regular secret rotation, reducing the risk window if secrets are exposed.",
      "patterns": [
        {
          "pattern": "resource"
        },
        {
          "pattern-not-inside": "resource \"azurerm_key_vault_secret\" \"...\" {\n...\nexpiration_date = \"...\"\n...\n}\n"
        },
        {
          "pattern-inside": "resource \"azurerm_key_vault_secret\" \"...\" {\n...\n}\n"
        }
      ],
      "metadata": {
        "cwe": [
          "CWE-262: Not Using Password Aging"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "azure"
        ],
        "references": [
          "https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/key_vault_secret#expiration_date",
          "https://docs.microsoft.com/en-us/azure/key-vault/secrets/about-secrets"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Key Vault secrets lack expiration dates",
        "fix-suggestion": "Add the `expiration_date` attribute to all your Key Vault secret resources with an appropriate timeframe based on your security policies. Implement a process to create new secrets and update applications before the existing secrets expire to maintain system functionality."
      },
      "languages": [
        "hcl"
      ],
      "severity": "INFO"
    },
    {
      "id": "terraform.azure.security.keyvault.keyvault-purge-enabled.keyvault-purge-enabled",
      "message": "Your Azure Key Vault is not configured with purge protection. Without purge protection, permanently deleted secrets, keys, and certificates cannot be recovered, creating a risk of irreversible data loss during security incidents. Enabling purge protection provides a recovery period for accidentally or maliciously deleted vault objects.",
      "patterns": [
        {
          "pattern": "resource"
        },
        {
          "pattern-not-inside": "resource \"azurerm_key_vault\" \"...\" {\n...\n purge_protection_enabled = true\n...\n}\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "resource \"azurerm_key_vault\" \"...\" {\n...\n}\n"
            },
            {
              "pattern-inside": "resource \"azurerm_key_vault\" \"...\" {\n...\n  purge_protection_enabled = false\n...\n}\n"
            }
          ]
        }
      ],
      "metadata": {
        "cwe": [
          "CWE-693: Protection Mechanism Failure"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "azure"
        ],
        "references": [
          "https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/key_vault#purge_protection_enabled",
          "https://docs.microsoft.com/en-us/azure/key-vault/general/soft-delete-overview#purge-protection"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Key Vault missing purge protection safeguards",
        "fix-suggestion": "Enable purge protection for your Key Vault by setting `purge_protection_enabled = true` in your Key Vault resource configuration. This prevents permanent deletion of secrets, keys, and certificates during the retention period, allowing recovery of accidentally or maliciously deleted items."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.azure.security.keyvault.keyvault-specify-network-acl.keyvault-specify-network-acl",
      "message": "Your Azure Key Vault is missing specific network access control rules. Without properly configured network ACLs, your key vault might be accessible from unauthorized networks, increasing exposure to attacks. Implementing network access restrictions ensures your vault is only accessible from trusted networks and services.",
      "patterns": [
        {
          "pattern": "resource"
        },
        {
          "pattern-not-inside": "resource \"azurerm_key_vault\" \"...\" {\n...\nnetwork_acls {\n    ...\n    default_action = \"Deny\"\n    ...\n}\n...\n}\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "resource \"azurerm_key_vault\" \"...\" {\n...\n}\n"
            },
            {
              "pattern-inside": "resource \"azurerm_key_vault\" \"...\" {\n...\nnetwork_acls {\n    ...\n    default_action = \"Allow\"\n    ...\n}\n...\n}\n"
            }
          ]
        }
      ],
      "metadata": {
        "cwe": [
          "CWE-284: Improper Access Control"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "azure"
        ],
        "references": [
          "https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/key_vault#network_acls",
          "https://docs.microsoft.com/en-us/azure/key-vault/general/network-security"
        ],
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Key Vault lacks network access restrictions",
        "fix-suggestion": "Configure network access rules by adding a `network_acls` block to your Key Vault with `default_action = \"Deny\"` and specific `ip_rules` or `virtual_network_subnet_ids` for authorized access. Set `bypass = \"AzureServices\"` if Azure services need to access the vault while maintaining network restrictions for all other traffic."
      },
      "languages": [
        "hcl"
      ],
      "severity": "ERROR"
    },
    {
      "id": "terraform.azure.security.storage.storage-allow-microsoft-service-bypass.storage-allow-microsoft-service-bypass",
      "message": "Your Azure Storage account is not configured to allow trusted Microsoft services to bypass network rules. This can prevent essential Azure services from properly interacting with your storage, potentially breaking functionality like backup, monitoring, or metrics collection. Enabling Microsoft service bypass maintains security while ensuring compatibility with Azure services.",
      "patterns": [
        {
          "pattern-not-inside": "resource \"azurerm_storage_account\" \"...\" {\n...\n  network_rules {\n    ...\n    bypass = [\"...\", \"AzureServices\"]\n    ...\n  }\n...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"azurerm_storage_account_network_rules\" \"...\" {\n...\n  bypass = [\"...\", \"AzureServices\"]\n...\n}\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "resource \"azurerm_storage_account_network_rules\" \"...\" {\n...\nbypass = [$ANYTHING]\n...\n}\n"
            },
            {
              "pattern-inside": "resource \"azurerm_storage_account\" \"...\" {\n...\n  network_rules {\n    ...\n    bypass = [$ANYTHING]\n    ...\n  }\n...\n}\n"
            }
          ]
        }
      ],
      "metadata": {
        "cwe": [
          "CWE-284: Improper Access Control"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "azure"
        ],
        "references": [
          "https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/storage_account#bypass",
          "https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/storage_account_network_rules#bypass",
          "https://docs.microsoft.com/en-us/azure/storage/common/storage-network-security#trusted-microsoft-services"
        ],
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Storage prevents trusted Microsoft services access",
        "fix-suggestion": "Add the `bypass = [\"AzureServices\"]` parameter to your storage account's `network_rules` block to allow trusted Microsoft services to access your storage while maintaining network restrictions for other traffic. This maintains your security posture while ensuring essential Azure services can operate correctly."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.azure.security.storage.storage-default-action-deny.storage-default-action-deny",
      "message": "Your Azure Storage account is not configured to deny access by default for network rules. This open network configuration potentially allows unauthorized access from any network. Implementing a default deny policy with specific allowances follows the security principle of least privilege for your storage data.",
      "patterns": [
        {
          "pattern": "resource"
        },
        {
          "pattern-not-inside": "resource \"azurerm_storage_account_network_rules\" \"...\" {\n...\n  default_action = \"Deny\"\n...\n}\n"
        },
        {
          "pattern-inside": "resource \"azurerm_storage_account_network_rules\" \"...\" {\n...\n  default_action = \"Allow\"\n...\n}\n"
        }
      ],
      "metadata": {
        "cwe": [
          "CWE-16: CWE CATEGORY: Configuration"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "azure"
        ],
        "references": [
          "https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/storage_account_network_rules#default_action",
          "https://docs.microsoft.com/en-us/azure/firewall/rule-processing"
        ],
        "owasp": [
          "A06:2017 - Security Misconfiguration",
          "A05:2021 - Security Misconfiguration"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Storage allows access from all networks",
        "fix-suggestion": "Configure your storage account's network rules with `default_action = \"Deny\"` and then explicitly add allowed networks through `ip_rules` or `virtual_network_subnet_ids`. This ensures your storage is only accessible from specifically authorized networks while blocking all other access attempts."
      },
      "languages": [
        "hcl"
      ],
      "severity": "ERROR"
    },
    {
      "id": "terraform.azure.security.storage.storage-enforce-https.storage-enforce-https",
      "message": "Your Azure Storage account allows insecure HTTP traffic rather than enforcing HTTPS. Unencrypted HTTP connections expose data in transit to potential interception and modification by attackers. Enforcing HTTPS ensures all data transferred between clients and your storage account is encrypted and protected.",
      "patterns": [
        {
          "pattern-not-inside": "resource \"azurerm_storage_account\" \"...\" {\n...\n  enable_https_traffic_only = true\n...\n}\n"
        },
        {
          "pattern-inside": "resource \"azurerm_storage_account\" \"...\" {\n...\n  enable_https_traffic_only = false\n...\n}\n"
        }
      ],
      "metadata": {
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "azure"
        ],
        "references": [
          "https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/storage_account#enable_https_traffic_only",
          "https://docs.microsoft.com/en-us/azure/storage/common/storage-require-secure-transfer"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Storage allows insecure HTTP connections",
        "fix-suggestion": "Force all traffic to use HTTPS by setting `enable_https_traffic_only = true` in your storage account configuration. This prevents clients from connecting over insecure HTTP protocols and ensures all data in transit to and from your storage account is encrypted."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.azure.security.storage.storage-queue-services-logging.storage-queue-services-logging",
      "message": "Your Azure Storage Queue service does not have logging enabled. Without proper logging, you lose visibility into access patterns, potential security incidents, and operational issues affecting your queue storage. Enabling comprehensive logging is essential for security monitoring, troubleshooting, and compliance requirements.",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "resource \"azurerm_storage_account\" \"...\" {\n  ...\n      queue_properties  {\n        ...\n      }\n  ...\n}\n"
            },
            {
              "pattern-inside": "resource \"azurerm_storage_account\" \"...\" {\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern-not-inside": "resource \"azurerm_storage_account\" \"...\" {\n  ...\n        queue_properties  {\n          ...\n          logging {\n            ...\n          }\n          ...\n        }\n  ...\n}\n"
        }
      ],
      "metadata": {
        "cwe": [
          "CWE-778: Insufficient Logging"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "azure"
        ],
        "references": [
          "https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/storage_account#logging",
          "https://docs.microsoft.com/en-us/azure/storage/common/storage-analytics-logging?tabs=dotnet"
        ],
        "owasp": [
          "A10:2017 - Insufficient Logging & Monitoring",
          "A09:2021 - Security Logging and Monitoring Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insufficient Logging"
        ],
        "short-description": "Storage Queue missing operational logging",
        "fix-suggestion": "Enable logging for your Storage Queue service by configuring the `queue_properties` block with appropriate `logging` settings including retention policy and log types. Set all log types (`delete`, `read`, and `write`) to `true` to capture comprehensive operational data for security monitoring and troubleshooting."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.azure.security.storage.storage-use-secure-tls-policy.storage-use-secure-tls-policy",
      "message": "Your Azure Storage account is not enforcing the use of modern TLS protocol versions. Older TLS versions (1.0 and 1.1) contain known security vulnerabilities that could be exploited by attackers. Requiring a minimum of TLS 1.2 ensures strong encryption for data in transit to and from your storage account.",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "resource \"azurerm_storage_account\" \"...\" {\n  ...\n  min_tls_version = \"$ANYTHING\"\n  ...\n}\n"
            },
            {
              "pattern-inside": "resource \"azurerm_storage_account\" \"...\" {\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern-not-inside": "resource \"azurerm_storage_account\" \"...\" {\n  ...\n  min_tls_version = \"TLS1_2\"\n  ...\n}\n"
        }
      ],
      "metadata": {
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "azure"
        ],
        "references": [
          "https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs/resources/storage_account#min_tls_version",
          "https://docs.microsoft.com/en-us/azure/storage/common/transport-layer-security-configure-minimum-version"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Storage allows deprecated insecure TLS versions",
        "fix-suggestion": "Set `min_tls_version = \"TLS1_2\"` in your Azure Storage account configuration to enforce the use of TLS 1.2 or higher. This ensures connections to your storage account use modern, secure encryption protocols that protect against known vulnerabilities in older TLS versions."
      },
      "languages": [
        "hcl"
      ],
      "severity": "ERROR"
    },
    {
      "id": "terraform.gcp.security.gcp-sql-database-ssl-insecure-value-postgres-mysql.gcp-sql-database-ssl-insecure-value-postgres-mysql",
      "patterns": [
        {
          "pattern-inside": "resource \"google_sql_database_instance\" \"...\" {\n    ...\n    database_version = \"$DB\"\n    ...\n}\n"
        },
        {
          "pattern-inside": "resource \"google_sql_database_instance\" \"...\" {\n    ...\n    ip_configuration {\n        ...\n        ssl_mode = $VALUE\n        ...\n    }\n    ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"google_sql_database_instance\" \"...\" {\n    ...\n    ip_configuration {\n        ...\n        ssl_mode = \"TRUSTED_CLIENT_CERTIFICATE_REQUIRED\"\n        ...\n    }\n    ...\n}\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$DB",
            "regex": ".*(MYSQL|POSTGRES).*"
          }
        },
        {
          "focus-metavariable": "$VALUE"
        }
      ],
      "fix": "\"TRUSTED_CLIENT_CERTIFICATE_REQUIRED\"\n",
      "message": "Your GCP Cloud SQL PostgreSQL or MySQL instance does not require SSL for incoming connections. Unencrypted database connections can expose sensitive data in transit to interception by attackers. Enforcing SSL connections ensures all data transmitted between clients and your database is encrypted and protected from eavesdropping.",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "gcp"
        ],
        "references": [
          "https://cloud.google.com/sql/docs/postgres/admin-api/rest/v1/instances#ipconfiguration",
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Cloud SQL allows unencrypted connections",
        "fix-suggestion": "Enforce SSL encryption for your PostgreSQL or MySQL Cloud SQL instance by setting `ssl_mode = \"TRUSTED_CLIENT_CERTIFICATE_REQUIRED\"` in your database configuration. This ensures all clients connecting to your database must use valid certificates and encrypted connections for data security."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.gcp.security.gcp-sql-database-ssl-insecure-value-sqlserver.gcp-sql-database-ssl-insecure-value-sqlserver",
      "patterns": [
        {
          "pattern-inside": "resource \"google_sql_database_instance\" \"...\" {\n    ...\n    database_version = \"$DB\"\n    ...\n}\n"
        },
        {
          "pattern-inside": "resource \"google_sql_database_instance\" \"...\" {\n    ...\n    ip_configuration {\n        ...\n        ssl_mode = $VALUE\n        ...\n    }\n    ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"google_sql_database_instance\" \"...\" {\n    ...\n    ip_configuration {\n        ...\n        ssl_mode = \"ENCRYPTED_ONLY\"\n        ...\n    }\n    ...\n}\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$DB",
            "regex": ".*(SQLSERVER).*"
          }
        },
        {
          "focus-metavariable": "$VALUE"
        }
      ],
      "fix": "\"ENCRYPTED_ONLY\"\n",
      "message": "Your GCP Cloud SQL SQL Server instance does not require SSL for incoming connections. Unencrypted database traffic puts sensitive data at risk of interception during transmission. Enforcing SSL encryption ensures data confidentiality between clients and your SQL Server database, protecting against network-based attacks.",
      "metadata": {
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-326: Inadequate Encryption Strength"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "gcp"
        ],
        "references": [
          "https://cloud.google.com/sql/docs/postgres/admin-api/rest/v1/instances#ipconfiguration",
          "https://owasp.org/Top10/A02_2021-Cryptographic_Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "SQL Server allows unencrypted connections",
        "fix-suggestion": "Enforce SSL encryption for your SQL Server Cloud SQL instance by setting `ssl_mode = \"ENCRYPTED_ONLY\"` in your database configuration. This is the most secure option supported for SQL Server instances and ensures all client connections to your database are encrypted."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.lang.security.ecr-image-scan-on-push.ecr-image-scan-on-push",
      "patterns": [
        {
          "pattern": "resource"
        },
        {
          "pattern-not-inside": "resource \"aws_ecr_repository\" \"...\" {\n  ...\n  image_scanning_configuration {\n    ...\n    scan_on_push=true\n    ...\n  }\n  ...\n}\n"
        },
        {
          "pattern-inside": "resource \"aws_ecr_repository\" \"...\" {\n  ...\n}\n"
        }
      ],
      "languages": [
        "hcl"
      ],
      "message": "Your Amazon ECR repository is not configured to automatically scan container images for vulnerabilities when they are pushed. Without automated scanning, vulnerable images could be deployed to your environment before security issues are identified. Enabling scan-on-push helps detect security vulnerabilities early in your deployment pipeline.",
      "severity": "WARNING",
      "metadata": {
        "cwe": [
          "CWE-1104: Use of Unmaintained Third Party Components"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A06:2021 - Vulnerable and Outdated Components"
        ],
        "references": [
          "https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "ECR repository missing automatic vulnerability scanning",
        "fix-suggestion": "Enable automatic vulnerability scanning by adding `image_scanning_configuration { scan_on_push = true }` to your ECR repository resource. This ensures all images are automatically scanned for security vulnerabilities immediately when pushed to the repository, helping you identify and address issues before deployment."
      }
    },
    {
      "id": "terraform.lang.security.eks-insufficient-control-plane-logging.eks-insufficient-control-plane-logging",
      "patterns": [
        {
          "pattern": "name = ...\n"
        },
        {
          "pattern-inside": "resource \"aws_eks_cluster\" \"...\" {\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_eks_cluster\" \"...\" {\n  ...\n  enabled_cluster_log_types = [..., \"api\", ..., \"audit\", ...]\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_eks_cluster\" \"...\" {\n  ...\n  enabled_cluster_log_types = [..., \"audit\", ..., \"api\", ...]\n  ...\n}\n"
        }
      ],
      "languages": [
        "hcl"
      ],
      "message": "Your Amazon EKS cluster has insufficient control plane logging enabled. Without comprehensive logging, you lack visibility into cluster operations, security events, and potential attacks against your Kubernetes API server. Enabling appropriate logging is essential for security monitoring, incident response, and compliance requirements.",
      "severity": "WARNING",
      "metadata": {
        "references": [
          "https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/eks_cluster#enabling-control-plane-logging",
          "https://docs.aws.amazon.com/eks/latest/userguide/control-plane-logs.html"
        ],
        "category": "security",
        "cwe": [
          "CWE-778: Insufficient Logging"
        ],
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A10:2017 - Insufficient Logging & Monitoring",
          "A09:2021 - Security Logging and Monitoring Failures"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Insufficient Logging"
        ],
        "short-description": "EKS cluster missing critical control plane logs",
        "fix-suggestion": "Enable control plane logging by adding `enabled_cluster_log_types = [\"api\", \"audit\", \"authenticator\"]` to your EKS cluster configuration. At minimum, include the API server logs and audit logs to capture security-relevant events, authentication decisions, and authorization attempts that are critical for monitoring cluster security."
      }
    },
    {
      "id": "terraform.lang.security.eks-public-endpoint-enabled.eks-public-endpoint-enabled",
      "patterns": [
        {
          "pattern": "resource\n"
        },
        {
          "pattern-inside": "resource \"aws_eks_cluster\" \"...\" {...}\n"
        },
        {
          "pattern-not-inside": "resource \"aws_eks_cluster\" \"...\"{\n  ...\n  vpc_config{\n    ...\n    endpoint_public_access = false\n    ...\n  }\n  ...\n}\n"
        }
      ],
      "languages": [
        "hcl"
      ],
      "message": "The EKS cluster has public endpoint access enabled, allowing connections from the internet. This exposes your Kubernetes API server to potential attacks and increases the attack surface. Implement proper network controls to restrict access to your cluster and consider using private endpoints instead.",
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor"
        ],
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "EKS cluster with exposed public endpoint",
        "fix-suggestion": "Disable public endpoint access by setting `endpoint_public_access = false` in your EKS cluster's `vpc_config` block. If public access is required, restrict it with `public_access_cidrs` to limit incoming IP ranges. Consider using a bastion host or AWS Systems Manager for secure cluster management."
      }
    },
    {
      "id": "terraform.lang.security.elastic-search-encryption-at-rest.elastic-search-encryption-at-rest",
      "patterns": [
        {
          "pattern": "resource\n"
        },
        {
          "pattern-not-inside": "resource \"aws_elasticsearch_domain\" \"...\"{\n  ...\n  encrypt_at_rest{\n    ...\n    enabled = true\n    ...\n  }\n  ...\n}\n"
        },
        {
          "pattern-inside": "resource \"aws_elasticsearch_domain\" \"...\" {...}\n"
        }
      ],
      "languages": [
        "hcl"
      ],
      "message": "Your Elasticsearch domain does not have encryption at rest enabled, leaving sensitive data vulnerable if storage media is compromised. Encryption at rest is a critical security measure for protecting data in storage. Without it, unauthorized parties could potentially access sensitive information by obtaining physical access to storage devices.",
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-311: Missing Encryption of Sensitive Data"
        ],
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A04:2021 - Insecure Design"
        ],
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Elasticsearch domain without encryption at rest",
        "fix-suggestion": "Enable encryption at rest by adding `encrypt_at_rest { enabled = true }` to your Elasticsearch domain resource. For better security, specify your own KMS key using the `kms_key_id` parameter. This ensures that your data remains protected even if the storage media is physically accessed."
      }
    },
    {
      "id": "terraform.lang.security.rds-insecure-password-storage-in-source-code.rds-insecure-password-storage-in-source-code",
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern": "password = \"...\""
            },
            {
              "pattern-inside": "resource \"aws_db_instance\" \"...\" {\n  ...\n}\n"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern": "master_password = \"...\""
            },
            {
              "pattern-inside": "resource \"aws_rds_cluster\" \"...\" {\n  ...\n}\n"
            }
          ]
        }
      ],
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "message": "RDS instance or cluster credentials are hardcoded in the source code, creating a security risk if code is exposed. Credentials in code can be leaked through version control, logs, or other means. This practice violates security best practices and can lead to unauthorized database access.",
      "metadata": {
        "references": [
          "https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/db_instance#master_password",
          "https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/rds_cluster#master_password",
          "https://registry.terraform.io/providers/hashicorp/random/latest/docs/resources/password"
        ],
        "cwe": [
          "CWE-522: Insufficiently Protected Credentials"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "aws",
          "secrets"
        ],
        "owasp": [
          "A02:2017 - Broken Authentication",
          "A04:2021 - Insecure Design"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "RDS credentials hardcoded in source code",
        "fix-suggestion": "Remove hardcoded credentials and pass them at runtime through environment variables or AWS Secrets Manager. Use the `random_password` resource to generate secure passwords, with `special = true` and appropriate length. Store the generated credentials securely using `aws_secretsmanager_secret` to manage database access properly."
      }
    },
    {
      "id": "terraform.lang.security.rds-public-access.rds-public-access",
      "patterns": [
        {
          "pattern": "publicly_accessible = true"
        },
        {
          "pattern-inside": "resource \"aws_db_instance\" \"...\" {\n  ...\n}\n"
        }
      ],
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "message": "Your RDS instance is configured to be publicly accessible from the internet. This exposes your database to potential brute force attacks and unauthorized access attempts. Database servers should generally not be directly exposed to the public internet.",
      "metadata": {
        "references": [
          "https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/db_instance#publicly_accessible",
          "https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_VPC.WorkingWithRDSInstanceinaVPC.html#USER_VPC.Hiding"
        ],
        "cwe": [
          "CWE-284: Improper Access Control"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "RDS instance accessible from internet",
        "fix-suggestion": "Set `publicly_accessible = false` in your RDS instance configuration to make it private. Place your database in private subnets with proper network ACLs. Use bastion hosts, VPN, or AWS Direct Connect for legitimate access to your database resources."
      }
    },
    {
      "id": "terraform.lang.security.s3-public-read-bucket.s3-public-read-bucket",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "acl = \"public-read\""
            },
            {
              "pattern": "acl = \"authenticated-read\""
            }
          ]
        },
        {
          "pattern-not-inside": "resource \"aws_s3_bucket\" \"...\" {\n  ...\n  website { ... }\n  ...\n}\n"
        }
      ],
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "message": "S3 bucket allows public read access, which exposes all bucket contents to anyone on the internet. This configuration can lead to data leaks and privacy violations. Unless your bucket is specifically meant to serve public content, this is likely a security misconfiguration.",
      "metadata": {
        "cwe": [
          "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor"
        ],
        "references": [
          "https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket#acl",
          "https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "S3 bucket allows public read access",
        "fix-suggestion": "Remove public read access by setting `acl = \"private\"` on your S3 bucket resource. Implement proper bucket policies that restrict access to authorized principals only. Use presigned URLs or CloudFront distributions with OAI for controlled public access to content when needed."
      }
    },
    {
      "id": "terraform.lang.security.s3-public-rw-bucket.s3-public-rw-bucket",
      "pattern": "acl = \"public-read-write\"",
      "languages": [
        "hcl"
      ],
      "severity": "ERROR",
      "message": "S3 bucket has public read and write access enabled, allowing anyone to view, add, modify, or delete objects. This extremely dangerous configuration can lead to data breaches, malicious content uploads, and resource abuse. Public write access should never be allowed except in rare, controlled circumstances.",
      "metadata": {
        "references": [
          "https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket#acl",
          "https://docs.aws.amazon.com/AmazonS3/latest/dev/acl-overview.html#canned-acl"
        ],
        "cwe": [
          "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "S3 bucket with public read-write access",
        "fix-suggestion": "Immediately remove public access by setting `acl = \"private\"` and applying `block_public_acls = true` and `block_public_policy = true` in an `aws_s3_bucket_public_access_block` resource. Implement proper IAM policies to grant specific permissions to authorized users only. Audit your bucket for unauthorized objects that may have been added."
      }
    },
    {
      "id": "terraform.lang.security.s3-unencrypted-bucket.s3-unencrypted-bucket",
      "patterns": [
        {
          "pattern": "a"
        },
        {
          "pattern": "b"
        }
      ],
      "languages": [
        "hcl"
      ],
      "severity": "INFO",
      "message": "This rule has been deprecated since AWS now encrypts all S3 buckets by default with no way to disable it. Server-side encryption protects data at rest and AWS handles the encryption process transparently. See the AWS S3 documentation for more details on encryption options.",
      "metadata": {
        "references": [
          "https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket#server_side_encryption_configuration",
          "https://docs.aws.amazon.com/AmazonS3/latest/userguide/bucket-encryption.html"
        ],
        "cwe": [
          "CWE-311: Missing Encryption of Sensitive Data"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A04:2021 - Insecure Design"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "deprecated": true,
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "Deprecated rule for S3 bucket encryption",
        "fix-suggestion": "No action needed as AWS now enforces encryption by default. If you need specific encryption settings, use `aws_s3_bucket_server_side_encryption_configuration` with `rule { apply_server_side_encryption_by_default { sse_algorithm = \"AES256\" } }` or specify a KMS key. Refer to the Terraform documentation for more advanced encryption configurations."
      }
    },
    {
      "id": "terraform.lang.security.iam.no-iam-admin-privileges.no-iam-admin-privileges",
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern-inside": "resource $TYPE \"...\" {\n  ...\n  policy = jsonencode({\n    ...\n    Statement = [\n      ...\n    ]\n    ...\n  })\n  ...\n}\n"
            },
            {
              "pattern-not-inside": "resource $TYPE \"...\" {\n  ...\n  policy = jsonencode({\n    ...\n    Statement = [\n      ...,\n      {... Effect = \"Deny\" ...},\n      ...\n    ]\n    ...\n  })\n  ...\n}\n"
            },
            {
              "patterns": [
                {
                  "pattern": "{..., Action = \"*\", ...}\n"
                },
                {
                  "pattern": "{..., Resource = \"*\", ...}\n"
                }
              ]
            },
            {
              "metavariable-pattern": {
                "metavariable": "$TYPE",
                "pattern-either": [
                  {
                    "pattern": "\"aws_iam_role_policy\"\n"
                  },
                  {
                    "pattern": "\"aws_iam_policy\"\n"
                  },
                  {
                    "pattern": "\"aws_iam_user_policy\"\n"
                  },
                  {
                    "pattern": "\"aws_iam_group_policy\"\n"
                  }
                ]
              }
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "data aws_iam_policy_document \"...\" {\n  ...\n  statement {\n    ...\n  }\n  ...\n}\n"
            },
            {
              "pattern-not-inside": "data aws_iam_policy_document \"...\" {\n  ...\n  statement {\n    ...\n    effect = \"Deny\"\n    ...\n  }\n  ...\n}\n"
            },
            {
              "patterns": [
                {
                  "pattern": "{..., resources = [\"*\"], ...}\n"
                },
                {
                  "pattern": "{..., actions = [\"*\"], ...}\n"
                }
              ]
            }
          ]
        }
      ],
      "message": "IAM policies with full \"*-*\" admin privileges violate the principle of least privilege, giving excessive access to all AWS resources. This configuration allows users to perform any action on any resource, creating a significant security risk. If compromised, these credentials could give an attacker complete control over your AWS account.",
      "metadata": {
        "references": [
          "https://github.com/bridgecrewio/checkov/blob/master/checkov/terraform/checks/data/aws/AdminPolicyDocument.py"
        ],
        "category": "security",
        "cwe": [
          "CWE-269: Improper Privilege Management"
        ],
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A04:2021 - Insecure Design"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "IAM policy with excessive admin privileges",
        "fix-suggestion": "Replace wildcard permissions with specific actions and resources that users actually need. Use `Action` and `Resource` constraints in your IAM policy to limit scope. Implement multiple policies with specialized permissions following the principle of least privilege to minimize potential damage from compromised credentials."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.lang.security.iam.no-iam-creds-exposure.no-iam-creds-exposure",
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-inside": "resource $TYPE \"...\" {\n  ...\n  policy = jsonencode({\n    ...\n    Statement = [\n      ...\n    ]\n    ...\n  })\n  ...\n}\n"
                },
                {
                  "pattern-not-inside": "resource $TYPE \"...\" {\n  ...\n  policy = jsonencode({\n    ...\n    Statement = [\n      ...,\n      {... Effect = \"Deny\" ...},\n      ...\n    ]\n    ...\n  })\n  ...\n}\n"
                },
                {
                  "pattern": "Action = $ACTION\n"
                },
                {
                  "metavariable-pattern": {
                    "metavariable": "$TYPE",
                    "pattern-either": [
                      {
                        "pattern": "\"aws_iam_role_policy\"\n"
                      },
                      {
                        "pattern": "\"aws_iam_policy\"\n"
                      },
                      {
                        "pattern": "\"aws_iam_user_policy\"\n"
                      },
                      {
                        "pattern": "\"aws_iam_group_policy\"\n"
                      }
                    ]
                  }
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-inside": "data aws_iam_policy_document \"...\" {\n  ...\n  statement {\n    ...\n  }\n  ...\n}\n"
                },
                {
                  "pattern-not-inside": "data aws_iam_policy_document \"...\" {\n  ...\n  statement {\n    ...\n    effect = \"Deny\"\n    ...\n  }\n  ...\n}\n"
                },
                {
                  "pattern": "actions = [..., $ACTION, ...]\n"
                }
              ]
            }
          ]
        },
        {
          "metavariable-pattern": {
            "metavariable": "$ACTION",
            "pattern-either": [
              {
                "pattern": "\"chime:CreateApiKey\"\n"
              },
              {
                "pattern": "\"codepipeline:PollForJobs\"\n"
              },
              {
                "pattern": "\"cognito-identity:GetOpenIdToken\"\n"
              },
              {
                "pattern": "\"cognito-identity:GetOpenIdTokenForDeveloperEdentity\"\n"
              },
              {
                "pattern": "\"cognito-identity:GetCredentialsForIdentity\"\n"
              },
              {
                "pattern": "\"connect:GetFederationToken\"\n"
              },
              {
                "pattern": "\"connect:GetFederationTokens\"\n"
              },
              {
                "pattern": "\"ec2:GetPasswordData\"\n"
              },
              {
                "pattern": "\"ecr:GetAuthorizationToken\"\n"
              },
              {
                "pattern": "\"gamelift:RequestUploadCredentials\"\n"
              },
              {
                "pattern": "\"iam:CreateAccessKey\"\n"
              },
              {
                "pattern": "\"iam:CreateLoginProfile\"\n"
              },
              {
                "pattern": "\"iam:CreateServiceSpecificCredential\"\n"
              },
              {
                "pattern": "\"iam:ResetServiceSpecificCredential\"\n"
              },
              {
                "pattern": "\"iam:UpdateAccessKey\"\n"
              },
              {
                "pattern": "\"lightsail:GetInstanceAccessDetails\"\n"
              },
              {
                "pattern": "\"lightsail:GetRelationalDatabaseMasterUserPassword\"\n"
              },
              {
                "pattern": "\"rds-db:Connect\"\n"
              },
              {
                "pattern": "\"redshift:GetClusterCredentials\"\n"
              },
              {
                "pattern": "\"sso:GetRoleCredentials\"\n"
              },
              {
                "pattern": "\"mediapackage:RotateChannelCredentials\"\n"
              },
              {
                "pattern": "\"mediapackage:RotateIngestEndpointCredentials\"\n"
              },
              {
                "pattern": "\"sts:AssumeRole\"\n"
              },
              {
                "pattern": "\"sts:AssumeRoleWithSaml\"\n"
              },
              {
                "pattern": "\"sts:AssumeRoleWithWebIdentity\"\n"
              },
              {
                "pattern": "\"sts:GetFederationToken\"\n"
              },
              {
                "pattern": "\"sts:GetSessionToken\"\n"
              },
              {
                "pattern": "\"ec2:*\"\n"
              },
              {
                "pattern": "\"codepipeline:*\"\n"
              },
              {
                "pattern": "\"rds-db:*\"\n"
              },
              {
                "pattern": "\"connect:*\"\n"
              },
              {
                "pattern": "\"iam:*\"\n"
              },
              {
                "pattern": "\"ecr:*\"\n"
              },
              {
                "pattern": "\"sts:*\"\n"
              },
              {
                "pattern": "\"chime:*\"\n"
              },
              {
                "pattern": "\"mediapackage:*\"\n"
              },
              {
                "pattern": "\"redshift:*\"\n"
              },
              {
                "pattern": "\"gamelift:*\"\n"
              },
              {
                "pattern": "\"cognito-identity:*\"\n"
              },
              {
                "pattern": "\"lightsail:*\"\n"
              },
              {
                "pattern": "\"sso:*\"\n"
              }
            ]
          }
        }
      ],
      "message": "IAM policies that allow credential exposure actions return sensitive information in API responses. These actions can lead to accidental or intentional leakage of credentials, tokens, or keys. Allowing these operations dramatically increases the risk of credential theft and unauthorized account access.",
      "metadata": {
        "references": [
          "https://cloudsplaining.readthedocs.io/en/latest/glossary/credentials-exposure/",
          "https://github.com/bridgecrewio/checkov/blob/ca830e14745c2c8e1b941985f305abe985d7f1f9/checkov/terraform/checks/data/aws/IAMCredentialsExposure.py"
        ],
        "category": "security",
        "cwe": [
          "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor"
        ],
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "IAM policy allows credential exposure actions",
        "fix-suggestion": "Remove actions that return credentials in API responses from your IAM policies. Replace with more secure alternatives that don't expose sensitive data. Implement credential management through AWS Secrets Manager or Parameter Store instead of generating and exposing credentials through IAM actions."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.lang.security.iam.no-iam-data-exfiltration.no-iam-data-exfiltration",
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-inside": "resource $TYPE \"...\" {\n  ...\n  policy = jsonencode({\n    ...\n    Statement = [\n      ...,\n      {... Resource = \"*\" ...},\n      ...\n    ]\n    ...\n  })\n  ...\n}\n"
                },
                {
                  "pattern-not-inside": "resource $TYPE \"...\" {\n  ...\n  policy = jsonencode({\n    ...\n    Statement = [\n      ...,\n      {... Effect = \"Deny\" ...},\n      ...\n    ]\n    ...\n  })\n  ...\n}\n"
                },
                {
                  "pattern": "Action = $ACTION\n"
                },
                {
                  "metavariable-pattern": {
                    "metavariable": "$TYPE",
                    "pattern-either": [
                      {
                        "pattern": "\"aws_iam_role_policy\"\n"
                      },
                      {
                        "pattern": "\"aws_iam_policy\"\n"
                      },
                      {
                        "pattern": "\"aws_iam_user_policy\"\n"
                      },
                      {
                        "pattern": "\"aws_iam_group_policy\"\n"
                      }
                    ]
                  }
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-inside": "data aws_iam_policy_document \"...\" {\n  ...\n  statement {\n    ...\n    resources = [\"*\"]\n    ...\n  }\n  ...\n}\n"
                },
                {
                  "pattern-not-inside": "data aws_iam_policy_document \"...\" {\n  ...\n  statement {\n    ...\n    effect = \"Deny\"\n    ...\n  }\n  ...\n}\n"
                },
                {
                  "pattern": "actions = [..., $ACTION, ...]\n"
                }
              ]
            }
          ]
        },
        {
          "metavariable-pattern": {
            "metavariable": "$ACTION",
            "pattern-either": [
              {
                "pattern": "\"s3:GetObject\"\n"
              },
              {
                "pattern": "\"ssm:GetParameter*\"\n"
              },
              {
                "pattern": "\"secretsmanager:GetSecretValue\"\n"
              },
              {
                "pattern": "\"rds:CopyDBSnapshot\"\n"
              },
              {
                "pattern": "\"rds:CreateDBSnapshot\"\n"
              },
              {
                "pattern": "\"ssm:*\"\n"
              },
              {
                "pattern": "\"s3:*\"\n"
              },
              {
                "pattern": "\"rds:*\"\n"
              },
              {
                "pattern": "\"rn: secretsmanager:*\"\n"
              }
            ]
          }
        }
      ],
      "message": "IAM policies allow data exfiltration actions without resource constraints, enabling users to read sensitive data they don't need. Unrestricted read access to data stores creates risks of unauthorized data extraction and theft. These broad permissions violate the principle of least privilege.",
      "metadata": {
        "references": [
          "https://github.com/bridgecrewio/checkov/blob/ca830e14745c2c8e1b941985f305abe985d7f1f9/checkov/terraform/checks/data/aws/IAMDataExfiltration.py",
          "https://cloudsplaining.readthedocs.io/en/latest/glossary/data-exfiltration/"
        ],
        "category": "security",
        "cwe": [
          "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor"
        ],
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "IAM policy enables unrestricted data exfiltration",
        "fix-suggestion": "Restrict data access permissions by specifying explicit `Resource` ARNs in your IAM policies instead of using wildcards. Limit actions to only what's necessary, removing broad read permissions. Implement resource-based policies with conditions that further restrict how and when data can be accessed."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.lang.security.iam.no-iam-priv-esc-funcs.no-iam-priv-esc-funcs",
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-inside": "resource $TYPE \"...\" {\n  ...\n  policy = jsonencode({\n    ...\n    Statement = [\n      ...\n    ]\n    ...\n  })\n  ...\n}\n"
                },
                {
                  "pattern-not-inside": "resource $TYPE \"...\" {\n  ...\n  policy = jsonencode({\n    ...\n    Statement = [\n      ...,\n      {... Effect = \"Deny\" ...},\n      ...\n    ]\n    ...\n  })\n  ...\n}\n"
                },
                {
                  "pattern": "Action = $ACTION"
                },
                {
                  "metavariable-pattern": {
                    "metavariable": "$TYPE",
                    "pattern-either": [
                      {
                        "pattern": "\"aws_iam_role_policy\"\n"
                      },
                      {
                        "pattern": "\"aws_iam_policy\"\n"
                      },
                      {
                        "pattern": "\"aws_iam_user_policy\"\n"
                      },
                      {
                        "pattern": "\"aws_iam_group_policy\"\n"
                      }
                    ]
                  }
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-inside": "data aws_iam_policy_document \"...\" {\n  ...\n  statement {\n    ...\n  }\n  ...\n}\n"
                },
                {
                  "pattern-not-inside": "data aws_iam_policy_document \"...\" {\n  ...\n  statement {\n    ...\n    effect = \"Deny\"\n    ...\n  }\n  ...\n}\n"
                },
                {
                  "pattern": "actions = [..., $ACTION, ...]\n"
                }
              ]
            }
          ]
        },
        {
          "metavariable-pattern": {
            "metavariable": "$ACTION",
            "pattern-either": [
              {
                "pattern": "\"iam:AddUserToGroup\"\n"
              },
              {
                "pattern": "\"iam:CreatePolicyVersion\"\n"
              },
              {
                "pattern": "\"iam:SetDefaultPolicyVersion\"\n"
              },
              {
                "pattern": "\"iam:AttachUserPolicy\"\n"
              },
              {
                "pattern": "\"iam:AttachGroupPolicy\"\n"
              },
              {
                "pattern": "\"iam:AttachRolePolicy\"\n"
              },
              {
                "pattern": "\"iam:PutUserPolicy\"\n"
              },
              {
                "pattern": "\"iam:PutGroupPolicy\"\n"
              },
              {
                "pattern": "\"iam:PutRolePolicy\"\n"
              },
              {
                "pattern": "\"glue:UpdateDevEndpoint\"\n"
              },
              {
                "pattern": "\"iam:*\"\n"
              },
              {
                "pattern": "\"glue:*\"\n"
              }
            ]
          }
        }
      ],
      "message": "IAM policies include actions that can result in privilege escalation, allowing users to gain additional permissions. These actions enable users to create or modify access policies, potentially granting themselves administrator access. If exploited, an attacker could gain complete control over your AWS environment.",
      "metadata": {
        "references": [
          "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/",
          "https://cloudsplaining.readthedocs.io/en/latest/glossary/privilege-escalation/"
        ],
        "category": "security",
        "cwe": [
          "CWE-250: Execution with Unnecessary Privileges"
        ],
        "technology": [
          "terraform",
          "aws"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "IAM policy contains privilege escalation actions",
        "fix-suggestion": "Remove privilege escalation actions like `iam:PutUserPolicy` and `iam:AttachRolePolicy` from your IAM policies. Implement strict permission boundaries to prevent privilege escalation. Consider using AWS Organizations service control policies (SCPs) to enforce guardrails across your organization."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.lang.security.iam.no-iam-priv-esc-other-users.no-iam-priv-esc-other-users",
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-inside": "resource $TYPE \"...\" {\n  ...\n  policy = jsonencode({\n    ...\n    Statement = [\n      ...,\n      {... Resource = $RESOURCE ...},\n      ...\n    ]\n    ...\n  })\n  ...\n}\n"
                },
                {
                  "pattern-not-inside": "resource $TYPE \"...\" {\n  ...\n  policy = jsonencode({\n    ...\n    Statement = [\n      ...,\n      {... Effect = \"Deny\" ...},\n      ...\n    ]\n    ...\n  })\n  ...\n}\n"
                },
                {
                  "pattern": "Action = $ACTION\n"
                },
                {
                  "metavariable-pattern": {
                    "metavariable": "$TYPE",
                    "pattern-either": [
                      {
                        "pattern": "\"aws_iam_role_policy\"\n"
                      },
                      {
                        "pattern": "\"aws_iam_policy\"\n"
                      },
                      {
                        "pattern": "\"aws_iam_user_policy\"\n"
                      },
                      {
                        "pattern": "\"aws_iam_group_policy\"\n"
                      }
                    ]
                  }
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-inside": "data aws_iam_policy_document \"...\" {\n  ...\n  statement {\n    ...\n    resources = $RESOURCE\n    ...\n  }\n  ...\n}\n"
                },
                {
                  "pattern-not-inside": "data aws_iam_policy_document \"...\" {\n  ...\n  statement {\n    ...\n    effect = \"Deny\"\n    ...\n  }\n  ...\n}\n"
                },
                {
                  "pattern": "actions = [..., $ACTION, ...]\n"
                }
              ]
            }
          ]
        },
        {
          "metavariable-pattern": {
            "metavariable": "$RESOURCE",
            "pattern-either": [
              {
                "pattern-regex": ".*\\*.*"
              }
            ]
          }
        },
        {
          "metavariable-pattern": {
            "metavariable": "$ACTION",
            "pattern-either": [
              {
                "pattern": "\"iam:CreateAccessKey\"\n"
              },
              {
                "pattern": "\"iam:CreateLoginProfile\"\n"
              },
              {
                "pattern": "\"iam:UpdateLoginProfile\"\n"
              },
              {
                "pattern": "\"iam:*\"\n"
              }
            ]
          }
        }
      ],
      "message": "IAM policies allow actions on other users that can lead to privilege escalation. These permissions enable modifying permissions for other identities, potentially granting administrator access. Unrestricted user management permissions create significant security risks if compromised.",
      "metadata": {
        "references": [
          "https://cloudsplaining.readthedocs.io/en/latest/glossary/privilege-escalation/",
          "https://github.com/bridgecrewio/checkov/blob/ca830e14745c2c8e1b941985f305abe985d7f1f9/checkov/terraform/checks/data/aws/IAMPrivilegeEscalation.py"
        ],
        "category": "security",
        "cwe": [
          "CWE-269: Improper Privilege Management"
        ],
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A04:2021 - Insecure Design"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "IAM policy enables cross-user privilege escalation",
        "fix-suggestion": "Restrict actions on other users by specifying exact user ARNs in the `Resource` element of your IAM policies. Remove dangerous permissions like `iam:UpdateAssumeRolePolicy` unless absolutely necessary. Create separate admin-only roles with strict controls for user management operations."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.lang.security.iam.no-iam-priv-esc-roles.no-iam-priv-esc-roles",
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-inside": "resource $TYPE \"...\" {\n  ...\n  policy = jsonencode({\n    ...\n    Statement = [\n      ...\n    ]\n    ...\n  })\n  ...\n}\n"
                },
                {
                  "pattern-not-inside": "resource $TYPE \"...\" {\n  ...\n  policy = jsonencode({\n    ...\n    Statement = [\n      ...,\n      {... Effect = \"Deny\" ...},\n      ...\n    ]\n    ...\n  })\n  ...\n}\n"
                },
                {
                  "pattern": "Action = $ACTION\n"
                },
                {
                  "metavariable-pattern": {
                    "metavariable": "$TYPE",
                    "pattern-either": [
                      {
                        "pattern": "\"aws_iam_role_policy\"\n"
                      },
                      {
                        "pattern": "\"aws_iam_policy\"\n"
                      },
                      {
                        "pattern": "\"aws_iam_user_policy\"\n"
                      },
                      {
                        "pattern": "\"aws_iam_group_policy\"\n"
                      }
                    ]
                  }
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-inside": "data aws_iam_policy_document \"...\" {\n  ...\n  statement {\n    ...\n  }\n  ...\n}\n"
                },
                {
                  "pattern-not-inside": "data aws_iam_policy_document \"...\" {\n  ...\n  statement {\n    ...\n    effect = \"Deny\"\n    ...\n  }\n  ...\n}\n"
                },
                {
                  "pattern": "actions = $ACTION\n"
                }
              ]
            }
          ]
        },
        {
          "metavariable-pattern": {
            "metavariable": "$ACTION",
            "pattern-either": [
              {
                "patterns": [
                  {
                    "pattern": "[..., \"sts:AssumeRole\", ...]\n"
                  },
                  {
                    "pattern": "[..., \"iam:UpdateAssumeRolePolicy\", ...]\n"
                  }
                ]
              },
              {
                "patterns": [
                  {
                    "pattern": "[..., \"iam:PassRole\", ...]\n"
                  },
                  {
                    "pattern": "[..., \"lambda:CreateFunction\", ...]\n"
                  },
                  {
                    "pattern": "[..., \"lambda:InvokeFunction\", ...]\n"
                  }
                ]
              },
              {
                "patterns": [
                  {
                    "pattern": "[..., \"iam:PassRole\", ...]\n"
                  },
                  {
                    "pattern": "[..., \"lambda:CreateFunction\", ...]\n"
                  },
                  {
                    "pattern": "[..., \"lambda:CreateEventSourceMapping\", ...]\n"
                  }
                ]
              },
              {
                "pattern": "\"lambda:UpdateFunctionCode\"\n"
              },
              {
                "patterns": [
                  {
                    "pattern": "[..., \"iam:PassRole\", ...]\n"
                  },
                  {
                    "pattern": "[..., \"glue:CreateDevEndpoint\", ...]\n"
                  }
                ]
              },
              {
                "patterns": [
                  {
                    "pattern": "[..., \"iam:PassRole\", ...]\n"
                  },
                  {
                    "pattern": "[..., \"cloudformation:CreateStack\", ...]\n"
                  }
                ]
              },
              {
                "patterns": [
                  {
                    "pattern": "[..., \"iam:PassRole\", ...]\n"
                  },
                  {
                    "pattern": "[..., \"datapipeline:CreatePipeline\", ...]\n"
                  },
                  {
                    "pattern": "[..., \"datapipeline:PutPipelineDefinition\", ...]\n"
                  }
                ]
              }
            ]
          }
        }
      ],
      "message": "IAM policies allow iam:PassRole along with other privileged actions that together enable privilege escalation. The combination of these permissions allows users to create resources that can assume higher privileges. This creates attack paths that could lead to full account compromise.",
      "metadata": {
        "references": [
          "https://cloudsplaining.readthedocs.io/en/latest/glossary/privilege-escalation/",
          "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
        ],
        "category": "security",
        "cwe": [
          "CWE-269: Improper Privilege Management"
        ],
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A04:2021 - Insecure Design"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "IAM policy enables role-based privilege escalation",
        "fix-suggestion": "Avoid granting both `iam:PassRole` and resource creation actions in the same policy. Restrict `iam:PassRole` permissions to specific roles using the `Resource` element. Implement conditions that limit where roles can be passed to prevent privilege escalation paths."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.lang.security.iam.no-iam-resource-exposure.no-iam-resource-exposure",
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-inside": "resource $TYPE \"...\" {\n  ...\n  policy = jsonencode({\n    ...\n    Statement = [\n      ...\n    ]\n    ...\n  })\n  ...\n}\n"
                },
                {
                  "pattern-not-inside": "resource $TYPE \"...\" {\n  ...\n  policy = jsonencode({\n    ...\n    Statement = [\n      ...,\n      {... Effect = \"Deny\" ...},\n      ...\n    ]\n    ...\n  })\n  ...\n}\n"
                },
                {
                  "pattern": "Action = $ACTION\n"
                },
                {
                  "metavariable-pattern": {
                    "metavariable": "$TYPE",
                    "pattern-either": [
                      {
                        "pattern": "\"aws_iam_role_policy\"\n"
                      },
                      {
                        "pattern": "\"aws_iam_policy\"\n"
                      },
                      {
                        "pattern": "\"aws_iam_user_policy\"\n"
                      },
                      {
                        "pattern": "\"aws_iam_group_policy\"\n"
                      }
                    ]
                  }
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-inside": "data aws_iam_policy_document \"...\" {\n  ...\n  statement {\n    ...\n  }\n  ...\n}\n"
                },
                {
                  "pattern-not-inside": "data aws_iam_policy_document \"...\" {\n  ...\n  statement {\n    ...\n    effect = \"Deny\"\n    ...\n  }\n  ...\n}\n"
                },
                {
                  "pattern": "actions = [..., $ACTION, ...]\n"
                }
              ]
            }
          ]
        },
        {
          "metavariable-pattern": {
            "metavariable": "$ACTION",
            "pattern-either": [
              {
                "pattern": "\"acm-pca:CreatePermission\"\n"
              },
              {
                "pattern": "\"acm-pca:DeletePermission\"\n"
              },
              {
                "pattern": "\"acm-pca:DeletePolicy\"\n"
              },
              {
                "pattern": "\"acm-pca:PutPolicy\"\n"
              },
              {
                "pattern": "\"apigateway:UpdateRestApiPolicy\"\n"
              },
              {
                "pattern": "\"backup:DeleteBackupVaultAccessPolicy\"\n"
              },
              {
                "pattern": "\"backup:PutBackupVaultAccessPolicy\"\n"
              },
              {
                "pattern": "\"chime:DeleteVoiceConnectorTerminationCredentials\"\n"
              },
              {
                "pattern": "\"chime:PutVoiceConnectorTerminationCredentials\"\n"
              },
              {
                "pattern": "\"cloudformation:SetStackPolicy\"\n"
              },
              {
                "pattern": "\"cloudsearch:UpdateServiceAccessPolicies\"\n"
              },
              {
                "pattern": "\"codeartifact:DeleteDomainPermissionsPolicy\"\n"
              },
              {
                "pattern": "\"codeartifact:DeleteRepositoryPermissionsPolicy\"\n"
              },
              {
                "pattern": "\"codebuild:DeleteResourcePolicy\"\n"
              },
              {
                "pattern": "\"codebuild:DeleteSourceCredentials\"\n"
              },
              {
                "pattern": "\"codebuild:ImportSourceCredentials\"\n"
              },
              {
                "pattern": "\"codebuild:PutResourcePolicy\"\n"
              },
              {
                "pattern": "\"codeguru-profiler:PutPermission\"\n"
              },
              {
                "pattern": "\"codeguru-profiler:RemovePermission\"\n"
              },
              {
                "pattern": "\"codestar:AssociateTeamMember\"\n"
              },
              {
                "pattern": "\"codestar:CreateProject\"\n"
              },
              {
                "pattern": "\"codestar:DeleteProject\"\n"
              },
              {
                "pattern": "\"codestar:DisassociateTeamMember\"\n"
              },
              {
                "pattern": "\"codestar:UpdateTeamMember\"\n"
              },
              {
                "pattern": "\"cognito-identity:CreateIdentityPool\"\n"
              },
              {
                "pattern": "\"cognito-identity:DeleteIdentities\"\n"
              },
              {
                "pattern": "\"cognito-identity:DeleteIdentityPool\"\n"
              },
              {
                "pattern": "\"cognito-identity:GetId\"\n"
              },
              {
                "pattern": "\"cognito-identity:MergeDeveloperIdentities\"\n"
              },
              {
                "pattern": "\"cognito-identity:SetIdentityPoolRoles\"\n"
              },
              {
                "pattern": "\"cognito-identity:UnlinkDeveloperIdentity\"\n"
              },
              {
                "pattern": "\"cognito-identity:UnlinkIdentity\"\n"
              },
              {
                "pattern": "\"cognito-identity:UpdateIdentityPool\"\n"
              },
              {
                "pattern": "\"deeplens:AssociateServiceRoleToAccount\"\n"
              },
              {
                "pattern": "\"ds:CreateConditionalForwarder\"\n"
              },
              {
                "pattern": "\"ds:CreateDirectory\"\n"
              },
              {
                "pattern": "\"ds:CreateMicrosoftAD\"\n"
              },
              {
                "pattern": "\"ds:CreateTrust\"\n"
              },
              {
                "pattern": "\"ds:ShareDirectory\"\n"
              },
              {
                "pattern": "\"ec2:CreateNetworkInterfacePermission\"\n"
              },
              {
                "pattern": "\"ec2:DeleteNetworkInterfacePermission\"\n"
              },
              {
                "pattern": "\"ec2:ModifySnapshotAttribute\"\n"
              },
              {
                "pattern": "\"ec2:ModifyVpcEndpointServicePermissions\"\n"
              },
              {
                "pattern": "\"ec2:ResetSnapshotAttribute\"\n"
              },
              {
                "pattern": "\"ecr:DeleteRepositoryPolicy\"\n"
              },
              {
                "pattern": "\"ecr:SetRepositoryPolicy\"\n"
              },
              {
                "pattern": "\"elasticfilesystem:DeleteFileSystemPolicy\"\n"
              },
              {
                "pattern": "\"elasticfilesystem:PutFileSystemPolicy\"\n"
              },
              {
                "pattern": "\"elasticmapreduce:PutBlockPublicAccessConfiguration\"\n"
              },
              {
                "pattern": "\"es:CreateElasticsearchDomain\"\n"
              },
              {
                "pattern": "\"es:UpdateElasticsearchDomainConfig\"\n"
              },
              {
                "pattern": "\"glacier:AbortVaultLock\"\n"
              },
              {
                "pattern": "\"glacier:CompleteVaultLock\"\n"
              },
              {
                "pattern": "\"glacier:DeleteVaultAccessPolicy\"\n"
              },
              {
                "pattern": "\"glacier:InitiateVaultLock\"\n"
              },
              {
                "pattern": "\"glacier:SetDataRetrievalPolicy\"\n"
              },
              {
                "pattern": "\"glacier:SetVaultAccessPolicy\"\n"
              },
              {
                "pattern": "\"glue:DeleteResourcePolicy\"\n"
              },
              {
                "pattern": "\"glue:PutResourcePolicy\"\n"
              },
              {
                "pattern": "\"greengrass:AssociateServiceRoleToAccount\"\n"
              },
              {
                "pattern": "\"health:DisableHealthServiceAccessForOrganization\"\n"
              },
              {
                "pattern": "\"health:EnableHealthServiceAccessForOrganization\"\n"
              },
              {
                "pattern": "\"iam:AddClientIDToOpenIDConnectProvider\"\n"
              },
              {
                "pattern": "\"iam:AddRoleToInstanceProfile\"\n"
              },
              {
                "pattern": "\"iam:AddUserToGroup\"\n"
              },
              {
                "pattern": "\"iam:AttachGroupPolicy\"\n"
              },
              {
                "pattern": "\"iam:AttachRolePolicy\"\n"
              },
              {
                "pattern": "\"iam:AttachUserPolicy\"\n"
              },
              {
                "pattern": "\"iam:ChangePassword\"\n"
              },
              {
                "pattern": "\"iam:CreateAccessKey\"\n"
              },
              {
                "pattern": "\"iam:CreateAccountAlias\"\n"
              },
              {
                "pattern": "\"iam:CreateGroup\"\n"
              },
              {
                "pattern": "\"iam:CreateInstanceProfile\"\n"
              },
              {
                "pattern": "\"iam:CreateLoginProfile\"\n"
              },
              {
                "pattern": "\"iam:CreateOpenIDConnectProvider\"\n"
              },
              {
                "pattern": "\"iam:CreatePolicy\"\n"
              },
              {
                "pattern": "\"iam:CreatePolicyVersion\"\n"
              },
              {
                "pattern": "\"iam:CreateRole\"\n"
              },
              {
                "pattern": "\"iam:CreateSAMLProvider\"\n"
              },
              {
                "pattern": "\"iam:CreateServiceLinkedRole\"\n"
              },
              {
                "pattern": "\"iam:CreateServiceSpecificCredential\"\n"
              },
              {
                "pattern": "\"iam:CreateUser\"\n"
              },
              {
                "pattern": "\"iam:CreateVirtualMFADevice\"\n"
              },
              {
                "pattern": "\"iam:DeactivateMFADevice\"\n"
              },
              {
                "pattern": "\"iam:DeleteAccessKey\"\n"
              },
              {
                "pattern": "\"iam:DeleteAccountAlias\"\n"
              },
              {
                "pattern": "\"iam:DeleteAccountPasswordPolicy\"\n"
              },
              {
                "pattern": "\"iam:DeleteGroup\"\n"
              },
              {
                "pattern": "\"iam:DeleteGroupPolicy\"\n"
              },
              {
                "pattern": "\"iam:DeleteInstanceProfile\"\n"
              },
              {
                "pattern": "\"iam:DeleteLoginProfile\"\n"
              },
              {
                "pattern": "\"iam:DeleteOpenIDConnectProvider\"\n"
              },
              {
                "pattern": "\"iam:DeletePolicy\"\n"
              },
              {
                "pattern": "\"iam:DeletePolicyVersion\"\n"
              },
              {
                "pattern": "\"iam:DeleteRole\"\n"
              },
              {
                "pattern": "\"iam:DeleteRolePermissionsBoundary\"\n"
              },
              {
                "pattern": "\"iam:DeleteRolePolicy\"\n"
              },
              {
                "pattern": "\"iam:DeleteSAMLProvider\"\n"
              },
              {
                "pattern": "\"iam:DeleteSSHPublicKey\"\n"
              },
              {
                "pattern": "\"iam:DeleteServerCertificate\"\n"
              },
              {
                "pattern": "\"iam:DeleteServiceLinkedRole\"\n"
              },
              {
                "pattern": "\"iam:DeleteServiceSpecificCredential\"\n"
              },
              {
                "pattern": "\"iam:DeleteSigningCertificate\"\n"
              },
              {
                "pattern": "\"iam:DeleteUser\"\n"
              },
              {
                "pattern": "\"iam:DeleteUserPermissionsBoundary\"\n"
              },
              {
                "pattern": "\"iam:DeleteUserPolicy\"\n"
              },
              {
                "pattern": "\"iam:DeleteVirtualMFADevice\"\n"
              },
              {
                "pattern": "\"iam:DetachGroupPolicy\"\n"
              },
              {
                "pattern": "\"iam:DetachRolePolicy\"\n"
              },
              {
                "pattern": "\"iam:DetachUserPolicy\"\n"
              },
              {
                "pattern": "\"iam:EnableMFADevice\"\n"
              },
              {
                "pattern": "\"iam:PassRole\"\n"
              },
              {
                "pattern": "\"iam:PutGroupPolicy\"\n"
              },
              {
                "pattern": "\"iam:PutRolePermissionsBoundary\"\n"
              },
              {
                "pattern": "\"iam:PutRolePolicy\"\n"
              },
              {
                "pattern": "\"iam:PutUserPermissionsBoundary\"\n"
              },
              {
                "pattern": "\"iam:PutUserPolicy\"\n"
              },
              {
                "pattern": "\"iam:RemoveClientIDFromOpenIDConnectProvider\"\n"
              },
              {
                "pattern": "\"iam:RemoveRoleFromInstanceProfile\"\n"
              },
              {
                "pattern": "\"iam:RemoveUserFromGroup\"\n"
              },
              {
                "pattern": "\"iam:ResetServiceSpecificCredential\"\n"
              },
              {
                "pattern": "\"iam:ResyncMFADevice\"\n"
              },
              {
                "pattern": "\"iam:SetDefaultPolicyVersion\"\n"
              },
              {
                "pattern": "\"iam:SetSecurityTokenServicePreferences\"\n"
              },
              {
                "pattern": "\"iam:UpdateAccessKey\"\n"
              },
              {
                "pattern": "\"iam:UpdateAccountPasswordPolicy\"\n"
              },
              {
                "pattern": "\"iam:UpdateAssumeRolePolicy\"\n"
              },
              {
                "pattern": "\"iam:UpdateGroup\"\n"
              },
              {
                "pattern": "\"iam:UpdateLoginProfile\"\n"
              },
              {
                "pattern": "\"iam:UpdateOpenIDConnectProviderThumbprint\"\n"
              },
              {
                "pattern": "\"iam:UpdateRole\"\n"
              },
              {
                "pattern": "\"iam:UpdateRoleDescription\"\n"
              },
              {
                "pattern": "\"iam:UpdateSAMLProvider\"\n"
              },
              {
                "pattern": "\"iam:UpdateSSHPublicKey\"\n"
              },
              {
                "pattern": "\"iam:UpdateServerCertificate\"\n"
              },
              {
                "pattern": "\"iam:UpdateServiceSpecificCredential\"\n"
              },
              {
                "pattern": "\"iam:UpdateSigningCertificate\"\n"
              },
              {
                "pattern": "\"iam:UpdateUser\"\n"
              },
              {
                "pattern": "\"iam:UploadSSHPublicKey\"\n"
              },
              {
                "pattern": "\"iam:UploadServerCertificate\"\n"
              },
              {
                "pattern": "\"iam:UploadSigningCertificate\"\n"
              },
              {
                "pattern": "\"imagebuilder:PutComponentPolicy\"\n"
              },
              {
                "pattern": "\"imagebuilder:PutImagePolicy\"\n"
              },
              {
                "pattern": "\"imagebuilder:PutImageRecipePolicy\"\n"
              },
              {
                "pattern": "\"iot:AttachPolicy\"\n"
              },
              {
                "pattern": "\"iot:AttachPrincipalPolicy\"\n"
              },
              {
                "pattern": "\"iot:DetachPolicy\"\n"
              },
              {
                "pattern": "\"iot:DetachPrincipalPolicy\"\n"
              },
              {
                "pattern": "\"iot:SetDefaultAuthorizer\"\n"
              },
              {
                "pattern": "\"iot:SetDefaultPolicyVersion\"\n"
              },
              {
                "pattern": "\"iotsitewise:CreateAccessPolicy\"\n"
              },
              {
                "pattern": "\"iotsitewise:DeleteAccessPolicy\"\n"
              },
              {
                "pattern": "\"iotsitewise:UpdateAccessPolicy\"\n"
              },
              {
                "pattern": "\"kms:CreateGrant\"\n"
              },
              {
                "pattern": "\"kms:PutKeyPolicy\"\n"
              },
              {
                "pattern": "\"kms:RetireGrant\"\n"
              },
              {
                "pattern": "\"kms:RevokeGrant\"\n"
              },
              {
                "pattern": "\"lakeformation:BatchGrantPermissions\"\n"
              },
              {
                "pattern": "\"lakeformation:BatchRevokePermissions\"\n"
              },
              {
                "pattern": "\"lakeformation:GrantPermissions\"\n"
              },
              {
                "pattern": "\"lakeformation:PutDataLakeSettings\"\n"
              },
              {
                "pattern": "\"lakeformation:RevokePermissions\"\n"
              },
              {
                "pattern": "\"lambda:AddLayerVersionPermission\"\n"
              },
              {
                "pattern": "\"lambda:AddPermission\"\n"
              },
              {
                "pattern": "\"lambda:DisableReplication\"\n"
              },
              {
                "pattern": "\"lambda:EnableReplication\"\n"
              },
              {
                "pattern": "\"lambda:RemoveLayerVersionPermission\"\n"
              },
              {
                "pattern": "\"lambda:RemovePermission\"\n"
              },
              {
                "pattern": "\"license-manager:UpdateServiceSettings\"\n"
              },
              {
                "pattern": "\"lightsail:GetRelationalDatabaseMasterUserPassword\"\n"
              },
              {
                "pattern": "\"logs:DeleteResourcePolicy\"\n"
              },
              {
                "pattern": "\"logs:PutResourcePolicy\"\n"
              },
              {
                "pattern": "\"mediapackage:RotateIngestEndpointCredentials\"\n"
              },
              {
                "pattern": "\"mediastore:DeleteContainerPolicy\"\n"
              },
              {
                "pattern": "\"mediastore:PutContainerPolicy\"\n"
              },
              {
                "pattern": "\"opsworks:SetPermission\"\n"
              },
              {
                "pattern": "\"opsworks:UpdateUserProfile\"\n"
              },
              {
                "pattern": "\"quicksight:CreateAdmin\"\n"
              },
              {
                "pattern": "\"quicksight:CreateGroup\"\n"
              },
              {
                "pattern": "\"quicksight:CreateGroupMembership\"\n"
              },
              {
                "pattern": "\"quicksight:CreateIAMPolicyAssignment\"\n"
              },
              {
                "pattern": "\"quicksight:CreateUser\"\n"
              },
              {
                "pattern": "\"quicksight:DeleteGroup\"\n"
              },
              {
                "pattern": "\"quicksight:DeleteGroupMembership\"\n"
              },
              {
                "pattern": "\"quicksight:DeleteIAMPolicyAssignment\"\n"
              },
              {
                "pattern": "\"quicksight:DeleteUser\"\n"
              },
              {
                "pattern": "\"quicksight:DeleteUserByPrincipalId\"\n"
              },
              {
                "pattern": "\"quicksight:RegisterUser\"\n"
              },
              {
                "pattern": "\"quicksight:UpdateDashboardPermissions\"\n"
              },
              {
                "pattern": "\"quicksight:UpdateGroup\"\n"
              },
              {
                "pattern": "\"quicksight:UpdateIAMPolicyAssignment\"\n"
              },
              {
                "pattern": "\"quicksight:UpdateTemplatePermissions\"\n"
              },
              {
                "pattern": "\"quicksight:UpdateUser\"\n"
              },
              {
                "pattern": "\"ram:AcceptResourceShareInvitation\"\n"
              },
              {
                "pattern": "\"ram:AssociateResourceShare\"\n"
              },
              {
                "pattern": "\"ram:CreateResourceShare\"\n"
              },
              {
                "pattern": "\"ram:DeleteResourceShare\"\n"
              },
              {
                "pattern": "\"ram:DisassociateResourceShare\"\n"
              },
              {
                "pattern": "\"ram:EnableSharingWithAwsOrganization\"\n"
              },
              {
                "pattern": "\"ram:RejectResourceShareInvitation\"\n"
              },
              {
                "pattern": "\"ram:UpdateResourceShare\"\n"
              },
              {
                "pattern": "\"rds:AuthorizeDBSecurityGroupIngress\"\n"
              },
              {
                "pattern": "\"rds-db:connect\"\n"
              },
              {
                "pattern": "\"redshift:AuthorizeSnapshotAccess\"\n"
              },
              {
                "pattern": "\"redshift:CreateClusterUser\"\n"
              },
              {
                "pattern": "\"redshift:CreateSnapshotCopyGrant\"\n"
              },
              {
                "pattern": "\"redshift:JoinGroup\"\n"
              },
              {
                "pattern": "\"redshift:ModifyClusterIamRoles\"\n"
              },
              {
                "pattern": "\"redshift:RevokeSnapshotAccess\"\n"
              },
              {
                "pattern": "\"route53resolver:PutResolverRulePolicy\"\n"
              },
              {
                "pattern": "\"s3:BypassGovernanceRetention\"\n"
              },
              {
                "pattern": "\"s3:DeleteAccessPointPolicy\"\n"
              },
              {
                "pattern": "\"s3:DeleteBucketPolicy\"\n"
              },
              {
                "pattern": "\"s3:ObjectOwnerOverrideToBucketOwner\"\n"
              },
              {
                "pattern": "\"s3:PutAccessPointPolicy\"\n"
              },
              {
                "pattern": "\"s3:PutAccountPublicAccessBlock\"\n"
              },
              {
                "pattern": "\"s3:PutBucketAcl\"\n"
              },
              {
                "pattern": "\"s3:PutBucketPolicy\"\n"
              },
              {
                "pattern": "\"s3:PutBucketPublicAccessBlock\"\n"
              },
              {
                "pattern": "\"s3:PutObjectAcl\"\n"
              },
              {
                "pattern": "\"s3:PutObjectVersionAcl\"\n"
              },
              {
                "pattern": "\"secretsmanager:DeleteResourcePolicy\"\n"
              },
              {
                "pattern": "\"secretsmanager:PutResourcePolicy\"\n"
              },
              {
                "pattern": "\"secretsmanager:ValidateResourcePolicy\"\n"
              },
              {
                "pattern": "\"servicecatalog:CreatePortfolioShare\"\n"
              },
              {
                "pattern": "\"servicecatalog:DeletePortfolioShare\"\n"
              },
              {
                "pattern": "\"sns:AddPermission\"\n"
              },
              {
                "pattern": "\"sns:CreateTopic\"\n"
              },
              {
                "pattern": "\"sns:RemovePermission\"\n"
              },
              {
                "pattern": "\"sns:SetTopicAttributes\"\n"
              },
              {
                "pattern": "\"sqs:AddPermission\"\n"
              },
              {
                "pattern": "\"sqs:CreateQueue\"\n"
              },
              {
                "pattern": "\"sqs:RemovePermission\"\n"
              },
              {
                "pattern": "\"sqs:SetQueueAttributes\"\n"
              },
              {
                "pattern": "\"ssm:ModifyDocumentPermission\"\n"
              },
              {
                "pattern": "\"sso:AssociateDirectory\"\n"
              },
              {
                "pattern": "\"sso:AssociateProfile\"\n"
              },
              {
                "pattern": "\"sso:CreateApplicationInstance\"\n"
              },
              {
                "pattern": "\"sso:CreateApplicationInstanceCertificate\"\n"
              },
              {
                "pattern": "\"sso:CreatePermissionSet\"\n"
              },
              {
                "pattern": "\"sso:CreateProfile\"\n"
              },
              {
                "pattern": "\"sso:CreateTrust\"\n"
              },
              {
                "pattern": "\"sso:DeleteApplicationInstance\"\n"
              },
              {
                "pattern": "\"sso:DeleteApplicationInstanceCertificate\"\n"
              },
              {
                "pattern": "\"sso:DeletePermissionSet\"\n"
              },
              {
                "pattern": "\"sso:DeletePermissionsPolicy\"\n"
              },
              {
                "pattern": "\"sso:DeleteProfile\"\n"
              },
              {
                "pattern": "\"sso:DisassociateDirectory\"\n"
              },
              {
                "pattern": "\"sso:DisassociateProfile\"\n"
              },
              {
                "pattern": "\"sso:ImportApplicationInstanceServiceProviderMetadata\"\n"
              },
              {
                "pattern": "\"sso:PutPermissionsPolicy\"\n"
              },
              {
                "pattern": "\"sso:StartSSO\"\n"
              },
              {
                "pattern": "\"sso:UpdateApplicationInstanceActiveCertificate\"\n"
              },
              {
                "pattern": "\"sso:UpdateApplicationInstanceDisplayData\"\n"
              },
              {
                "pattern": "\"sso:UpdateApplicationInstanceResponseConfiguration\"\n"
              },
              {
                "pattern": "\"sso:UpdateApplicationInstanceResponseSchemaConfiguration\"\n"
              },
              {
                "pattern": "\"sso:UpdateApplicationInstanceSecurityConfiguration\"\n"
              },
              {
                "pattern": "\"sso:UpdateApplicationInstanceServiceProviderConfiguration\"\n"
              },
              {
                "pattern": "\"sso:UpdateApplicationInstanceStatus\"\n"
              },
              {
                "pattern": "\"sso:UpdateDirectoryAssociation\"\n"
              },
              {
                "pattern": "\"sso:UpdatePermissionSet\"\n"
              },
              {
                "pattern": "\"sso:UpdateProfile\"\n"
              },
              {
                "pattern": "\"sso:UpdateSSOConfiguration\"\n"
              },
              {
                "pattern": "\"sso:UpdateTrust\"\n"
              },
              {
                "pattern": "\"sso-directory:AddMemberToGroup\"\n"
              },
              {
                "pattern": "\"sso-directory:CreateAlias\"\n"
              },
              {
                "pattern": "\"sso-directory:CreateGroup\"\n"
              },
              {
                "pattern": "\"sso-directory:CreateUser\"\n"
              },
              {
                "pattern": "\"sso-directory:DeleteGroup\"\n"
              },
              {
                "pattern": "\"sso-directory:DeleteUser\"\n"
              },
              {
                "pattern": "\"sso-directory:DisableUser\"\n"
              },
              {
                "pattern": "\"sso-directory:EnableUser\"\n"
              },
              {
                "pattern": "\"sso-directory:RemoveMemberFromGroup\"\n"
              },
              {
                "pattern": "\"sso-directory:UpdateGroup\"\n"
              },
              {
                "pattern": "\"sso-directory:UpdatePassword\"\n"
              },
              {
                "pattern": "\"sso-directory:UpdateUser\"\n"
              },
              {
                "pattern": "\"sso-directory:VerifyEmail\"\n"
              },
              {
                "pattern": "\"storagegateway:DeleteChapCredentials\"\n"
              },
              {
                "pattern": "\"storagegateway:SetLocalConsolePassword\"\n"
              },
              {
                "pattern": "\"storagegateway:SetSMBGuestPassword\"\n"
              },
              {
                "pattern": "\"storagegateway:UpdateChapCredentials\"\n"
              },
              {
                "pattern": "\"waf:DeletePermissionPolicy\"\n"
              },
              {
                "pattern": "\"waf:PutPermissionPolicy\"\n"
              },
              {
                "pattern": "\"waf-regional:DeletePermissionPolicy\"\n"
              },
              {
                "pattern": "\"waf-regional:PutPermissionPolicy\"\n"
              },
              {
                "pattern": "\"wafv2:CreateWebACL\"\n"
              },
              {
                "pattern": "\"wafv2:DeletePermissionPolicy\"\n"
              },
              {
                "pattern": "\"wafv2:DeleteWebACL\"\n"
              },
              {
                "pattern": "\"wafv2:PutPermissionPolicy\"\n"
              },
              {
                "pattern": "\"wafv2:UpdateWebACL\"\n"
              },
              {
                "pattern": "\"worklink:UpdateDevicePolicyConfiguration\"\n"
              },
              {
                "pattern": "\"workmail:ResetPassword\"\n"
              },
              {
                "pattern": "\"workmail:ResetUserPassword\"\n"
              },
              {
                "pattern": "\"xray:PutEncryptionConfig\"\n"
              },
              {
                "pattern": "\"worklink:*\"\n"
              },
              {
                "pattern": "\"route53resolver:*\"\n"
              },
              {
                "pattern": "\"es:*\"\n"
              },
              {
                "pattern": "\"greengrass:*\"\n"
              },
              {
                "pattern": "\"redshift:*\"\n"
              },
              {
                "pattern": "\"license-manager:*\"\n"
              },
              {
                "pattern": "\"rds:*\"\n"
              },
              {
                "pattern": "\"lambda:*\"\n"
              },
              {
                "pattern": "\"elasticfilesystem:*\"\n"
              },
              {
                "pattern": "\"logs:*\"\n"
              },
              {
                "pattern": "\"sso:*\"\n"
              },
              {
                "pattern": "\"waf:*\"\n"
              },
              {
                "pattern": "\"mediastore:*\"\n"
              },
              {
                "pattern": "\"acm-pca:*\"\n"
              },
              {
                "pattern": "\"sso-directory:*\"\n"
              },
              {
                "pattern": "\"imagebuilder:*\"\n"
              },
              {
                "pattern": "\"sqs:*\"\n"
              },
              {
                "pattern": "\"codeguru-profiler:*\"\n"
              },
              {
                "pattern": "\"wafv2:*\"\n"
              },
              {
                "pattern": "\"cloudformation:*\"\n"
              },
              {
                "pattern": "\"xray:*\"\n"
              },
              {
                "pattern": "\"codeartifact:*\"\n"
              },
              {
                "pattern": "\"iotsitewise:*\"\n"
              },
              {
                "pattern": "\"workmail:*\"\n"
              },
              {
                "pattern": "\"glue:*\"\n"
              },
              {
                "pattern": "\"deeplens:*\"\n"
              },
              {
                "pattern": "\"chime:*\"\n"
              },
              {
                "pattern": "\"mediapackage:*\"\n"
              },
              {
                "pattern": "\"opsworks:*\"\n"
              },
              {
                "pattern": "\"ds:*\"\n"
              },
              {
                "pattern": "\"ram:*\"\n"
              },
              {
                "pattern": "\"iam:*\"\n"
              },
              {
                "pattern": "\"waf-regional:*\"\n"
              },
              {
                "pattern": "\"glacier:*\"\n"
              },
              {
                "pattern": "\"cloudsearch:*\"\n"
              },
              {
                "pattern": "\"lakeformation:*\"\n"
              },
              {
                "pattern": "\"elasticmapreduce:*\"\n"
              },
              {
                "pattern": "\"quicksight:*\"\n"
              },
              {
                "pattern": "\"sns:*\"\n"
              },
              {
                "pattern": "\"ec2:*\"\n"
              },
              {
                "pattern": "\"health:*\"\n"
              },
              {
                "pattern": "\"lightsail:*\"\n"
              },
              {
                "pattern": "\"codestar:*\"\n"
              },
              {
                "pattern": "\"kms:*\"\n"
              },
              {
                "pattern": "\"codebuild:*\"\n"
              },
              {
                "pattern": "\"s3:*\"\n"
              },
              {
                "pattern": "\"cognito-identity:*\"\n"
              },
              {
                "pattern": "\"apigateway:*\"\n"
              },
              {
                "pattern": "\"rds-db:*\"\n"
              },
              {
                "pattern": "\"iot:*\"\n"
              },
              {
                "pattern": "\"backup:*\"\n"
              },
              {
                "pattern": "\"secretsmanager:*\"\n"
              },
              {
                "pattern": "\"servicecatalog:*\"\n"
              },
              {
                "pattern": "\"ssm:*\"\n"
              },
              {
                "pattern": "\"storagegateway:*\"\n"
              },
              {
                "pattern": "\"ecr:*\"\n"
              }
            ]
          }
        }
      ],
      "message": "IAM policies allow actions that can expose AWS resources to the public internet. These permissions enable changing resource policies to grant public access to sensitive services and data. If exploited, attackers could make private resources accessible to everyone, leading to data breaches.",
      "metadata": {
        "references": [
          "https://cloudsplaining.readthedocs.io/en/latest/glossary/resource-exposure/",
          "https://github.com/bridgecrewio/checkov/blob/ca830e14745c2c8e1b941985f305abe985d7f1f9/checkov/terraform/checks/data/aws/IAMPermissionsManagement.py"
        ],
        "category": "security",
        "cwe": [
          "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor"
        ],
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "IAM policy allows public resource exposure",
        "fix-suggestion": "Remove resource policy modification actions like `s3:PutBucketPolicy` and `ecr:SetRepositoryPolicy` from general IAM policies. If these permissions are necessary, add conditions to prevent exposure using `aws:PrincipalOrgID` or similar constraints. Create dedicated, tightly controlled roles for managing resource policies."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.lang.security.iam.no-iam-star-actions.no-iam-star-actions",
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-inside": "resource $TYPE \"...\" {\n  ...\n  policy = jsonencode({\n    ...\n    Statement = [\n      ...\n    ]\n    ...\n  })\n  ...\n}\n"
                },
                {
                  "pattern-not-inside": "resource $TYPE \"...\" {\n  ...\n  policy = jsonencode({\n    ...\n    Statement = [\n      ...,\n      {... Effect = \"Deny\" ...},\n      ...\n    ]\n    ...\n  })\n  ...\n}\n"
                },
                {
                  "pattern-either": [
                    {
                      "pattern": "Action = \"*\""
                    },
                    {
                      "pattern": "Action = [\"*\"]"
                    }
                  ]
                },
                {
                  "metavariable-pattern": {
                    "metavariable": "$TYPE",
                    "pattern-either": [
                      {
                        "pattern": "\"aws_iam_role_policy\"\n"
                      },
                      {
                        "pattern": "\"aws_iam_policy\"\n"
                      },
                      {
                        "pattern": "\"aws_iam_user_policy\"\n"
                      },
                      {
                        "pattern": "\"aws_iam_group_policy\"\n"
                      }
                    ]
                  }
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-inside": "data aws_iam_policy_document \"...\" {\n  ...\n  statement {\n    ...\n  }\n  ...\n}\n"
                },
                {
                  "pattern-not-inside": "data aws_iam_policy_document \"...\" {\n  ...\n  statement {\n    ...\n    effect = \"Deny\"\n    ...\n  }\n  ...\n}\n"
                },
                {
                  "pattern": "actions = [\"*\"]\n"
                }
              ]
            }
          ]
        }
      ],
      "message": "IAM policies using \"*\" for actions grant excessive permissions, violating the principle of least privilege. Wildcard actions allow all operations on the specified resources, even as new actions are added by AWS. This creates unnecessarily broad access and increases security risk.",
      "metadata": {
        "references": [
          "https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/iam_policy",
          "https://github.com/bridgecrewio/checkov/blob/ca830e14745c2c8e1b941985f305abe985d7f1f9/checkov/terraform/checks/data/aws/StarActionPolicyDocument.py"
        ],
        "category": "security",
        "cwe": [
          "CWE-269: Improper Privilege Management"
        ],
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A04:2021 - Insecure Design"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "IAM policy uses wildcard for all actions",
        "fix-suggestion": "Replace `\"Action\": \"*\"` with a list of specific actions required for the user's job function. Review AWS access advisor to determine which permissions are actually being used. Create separate policies for different responsibilities rather than using overly permissive wildcards."
      },
      "languages": [
        "hcl"
      ],
      "severity": "WARNING"
    },
    {
      "id": "terraform.lang.security.s3-cors-all-origins.all-origins-allowed",
      "patterns": [
        {
          "pattern-inside": "cors_rule { ... }"
        },
        {
          "pattern": "allowed_origins = [\"*\"]"
        }
      ],
      "languages": [
        "hcl"
      ],
      "severity": "WARNING",
      "message": "S3 bucket CORS configuration allows requests from any origin using the wildcard \"*\". This permits any website to make cross-origin requests to your bucket, potentially exposing sensitive data. Unless your bucket serves truly public content, this configuration creates unnecessary security risks.",
      "metadata": {
        "references": [
          "https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/s3_bucket#using-cors"
        ],
        "cwe": [
          "CWE-942: Permissive Cross-domain Policy with Untrusted Domains"
        ],
        "category": "security",
        "technology": [
          "terraform",
          "aws"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "S3 CORS allows requests from any origin",
        "fix-suggestion": "Replace the wildcard `\"*\"` in the `allowed_origins` field with a specific list of trusted domains. Use `aws_s3_bucket_cors_configuration` to apply more restrictive CORS rules. Only allow the HTTP methods and headers that your application actually needs to function properly."
      }
    },
    {
      "id": "trailofbits.go.invalid-usage-of-modified-variable.invalid-usage-of-modified-variable",
      "message": "A variable is likely modified and later used after an error check, which could lead to nil dereference panics. This common Go programming mistake happens when modifying a variable before checking if an operation was successful. The error handling logic doesn't account for the changed variable state.",
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "cwe": "CWE-665: Improper Initialization",
        "subcategory": [
          "audit"
        ],
        "confidence": "HIGH",
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "technology": [
          "--no-technology--"
        ],
        "description": "Possible unintentional assignment when an error occurs",
        "references": [
          "https://blog.trailofbits.com/2019/11/07/attacking-go-vr-ttps/"
        ],
        "license": "AGPL-3.0 license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Go variable used after modification causes panic",
        "fix-suggestion": "Rearrange your code to check errors before modifying variables that depend on successful operations. Store operation results in separate variables before error checking. Consider using the common Go pattern `if err := operation(); err != nil { return err }` to handle errors immediately after operations."
      },
      "patterns": [
        {
          "pattern": "..., $X, ..., $ERR = ...\nif $ERR != nil {\n  ...\n  <... $X.$Y ...>\n}\n"
        },
        {
          "pattern-not": "..., $X, ..., $ERR = ...\nif $ERR != nil {\n  ...\n  $X, ... = ...\n  ...\n  <... $X.$Y ...>\n}\n"
        },
        {
          "pattern-not": "..., $X, ..., $ERR = ...\nif $ERR != nil {\n  ...\n  $X = ...\n  ...\n  <... $X.$Y ...>\n}\n"
        },
        {
          "pattern-not": "..., $X, ..., $ERR = ...\nif $ERR != nil {\n  ...\n  if $X != nil {\n    <... $X.$Y ...>\n  }\n  ...\n}\n"
        },
        {
          "pattern-not": "..., $X, ..., $ERR := ...\nif $ERR != nil {\n  ...\n  if  $X != nil && <... $X.$Y ...> {\n    ...\n  }\n  ...\n}\n"
        }
      ]
    },
    {
      "id": "trailofbits.go.iterate-over-empty-map.iterate-over-empty-map",
      "message": "Code attempts to iterate over a map that might be empty or nil. While this won't cause a panic in Go, it's likely a logical bug as the loop body will never execute. This pattern often indicates a missing initialization or a misunderstood data flow.",
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "cwe": "CWE-665: Improper Initialization",
        "subcategory": [
          "audit"
        ],
        "confidence": "MEDIUM",
        "likelihood": "LOW",
        "impact": "LOW",
        "technology": [
          "--no-technology--"
        ],
        "description": "Probably redundant iteration over an empty map",
        "references": [
          "https://blog.trailofbits.com/2019/11/07/attacking-go-vr-ttps/"
        ],
        "license": "AGPL-3.0 license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Iteration over potentially empty Go map",
        "fix-suggestion": "Add a nil or empty check before iterating over the map: `if myMap == nil || len(myMap) == 0 { /* handle empty case */ }`. Initialize maps with `make(map[KeyType]ValueType)` before use. Consider whether the empty map case is expected and handle it appropriately in your business logic."
      },
      "patterns": [
        {
          "pattern": "$C = make(map[$T1] $T2, ...)\n...\nfor $K := range $C { ... }\n"
        },
        {
          "pattern-not": "$C = make(map[$T1] $T2, ...)\n...\n$C[$X] = $V\n...\nfor $K := range $C { ... }\n"
        },
        {
          "pattern-not": "$C = make(map[$T1] $T2, ...)\n...\n$C[$X]++\n...\nfor $K := range $C { ... }\n"
        },
        {
          "pattern-not": "$C = make(map[$T1] $T2, ...)\n...\n$C[$X]--\n...\nfor $K := range $C { ... }\n"
        },
        {
          "pattern-not": "$C = make(map[$T1] $T2, ...)\n...\n$CODEC.Unmarshal($BYTES, &$C)\n...\nfor $K := range $C { ... }\n"
        }
      ]
    },
    {
      "id": "trailofbits.go.missing-runlock-on-rwmutex.missing-runlock-on-rwmutex",
      "message": "RWMutex read lock is acquired but not released before returning from a function. This lock leak can lead to deadlocks when other goroutines try to acquire a write lock. All locks must be properly released in all code paths, including error conditions.",
      "languages": [
        "go"
      ],
      "severity": "ERROR",
      "metadata": {
        "category": "security",
        "cwe": "CWE-667: Improper Locking",
        "subcategory": [
          "vuln"
        ],
        "confidence": "MEDIUM",
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "technology": [
          "--no-technology--"
        ],
        "description": "Missing `RUnlock` on an `RWMutex` lock before returning from a function",
        "references": [
          "https://pkg.go.dev/sync#RWMutex",
          "https://blog.trailofbits.com/2020/06/09/how-to-check-if-a-mutex-is-locked-in-go/"
        ],
        "license": "AGPL-3.0 license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Go RWMutex read lock not released",
        "fix-suggestion": "Always pair `RLock()` with `RUnlock()` calls using `defer mu.RUnlock()` immediately after acquiring the lock. Use `defer` to ensure locks are released even when functions return early due to errors. Consider restructuring functions to have a single return point after locks are released."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "panic(...)"
            },
            {
              "pattern": "return ..."
            }
          ]
        },
        {
          "metavariable-pattern": {
            "metavariable": "$T",
            "patterns": [
              {
                "pattern": "($T : sync.RWMutex)\n"
              }
            ]
          }
        },
        {
          "pattern-inside": "$T.RLock()\n...\n"
        },
        {
          "pattern-not-inside": "$T.RUnlock()\n...\n"
        },
        {
          "pattern-not-inside": "defer $T.RUnlock()\n...\n"
        },
        {
          "pattern-not-inside": "defer func(...) {\n  ...\n  $T.RUnlock()\n  ...\n}(...)\n...\n"
        },
        {
          "pattern-not-inside": "$FOO(..., ..., func(...) { \n    ... \n})\n"
        },
        {
          "pattern-not-inside": "return func(...) {\n    ...\n    $T.RUnlock()\n    ...\n}\n"
        }
      ]
    },
    {
      "id": "trailofbits.go.missing-unlock-before-return.missing-unlock-before-return",
      "message": "Mutex is locked but not unlocked before returning from a function. This lock leak will cause deadlocks when other goroutines try to acquire the same mutex. Lock leaks are a common source of subtle concurrency bugs that can be difficult to debug.",
      "languages": [
        "go"
      ],
      "severity": "ERROR",
      "metadata": {
        "category": "security",
        "cwe": "CWE-667: Improper Locking",
        "subcategory": [
          "vuln"
        ],
        "confidence": "MEDIUM",
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "technology": [
          "--no-technology--"
        ],
        "description": "Missing `mutex` unlock before returning from a function",
        "references": [
          "https://pkg.go.dev/sync#Mutex",
          "https://blog.trailofbits.com/2020/06/09/how-to-check-if-a-mutex-is-locked-in-go/"
        ],
        "license": "AGPL-3.0 license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Go mutex not unlocked before function return",
        "fix-suggestion": "Always use `defer mu.Unlock()` immediately after acquiring a lock with `mu.Lock()`. This ensures the mutex is released even if the function returns early or panics. Review all code paths to ensure proper lock management and consider using helper functions for complex locking patterns."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "panic(...)"
            },
            {
              "pattern": "return ..."
            }
          ]
        },
        {
          "metavariable-pattern": {
            "metavariable": "$T",
            "patterns": [
              {
                "pattern": "($T : sync.Mutex)\n"
              }
            ]
          }
        },
        {
          "pattern-inside": "$T.Lock()\n...\n"
        },
        {
          "pattern-not-inside": "$T.Unlock()\n...\n"
        },
        {
          "pattern-not-inside": "defer $T.Unlock()\n...\n"
        },
        {
          "pattern-not-inside": "defer func(...) {\n  ...\n  $T.Unlock()\n  ...\n}(...)\n...\n"
        },
        {
          "pattern-not-inside": "$FOO(..., ..., func(...) { \n    ... \n})\n"
        },
        {
          "pattern-not-inside": "return func(...) {\n    ...\n    $T.Unlock()\n    ...\n}\n"
        }
      ]
    },
    {
      "id": "trailofbits.go.racy-append-to-slice.racy-append-to-slice",
      "message": "Multiple goroutines append to the same slice without synchronization, creating a race condition. Concurrent appends to a slice can cause data corruption, lost updates, and unpredictable behavior. Go slices are not thread-safe data structures and require explicit synchronization for concurrent access.",
      "languages": [
        "go"
      ],
      "severity": "ERROR",
      "metadata": {
        "category": "security",
        "cwe": "CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
        "subcategory": [
          "vuln"
        ],
        "confidence": "MEDIUM",
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "technology": [
          "--no-technology--"
        ],
        "description": "Concurrent calls to `append` from multiple goroutines",
        "references": [
          "https://go.dev/blog/maps#concurrency"
        ],
        "license": "AGPL-3.0 license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Concurrent append to slice without synchronization",
        "fix-suggestion": "Protect slice operations with a mutex: `mu.Lock(); slice = append(slice, item); mu.Unlock()`. Consider using channels instead of shared slices for communication between goroutines. For high-performance scenarios, explore sync.Pool or specialized concurrent data structures from the sync package."
      },
      "patterns": [
        {
          "pattern": "$SLICE = append($SLICE, $ITEM)\n"
        },
        {
          "pattern-either": [
            {
              "pattern-inside": "var $SLICE []$TYPE\n...\nfor ... {\n  ...\n  go func(...) {\n    ...\n    $SLICE = append($SLICE, ...)\n    ...\n  }(...)\n  ...\n}\n"
            },
            {
              "pattern-inside": "$SLICE := make([]$TYPE, ...)\n...\nfor ... {\n  ...\n  go func(...) {\n    ...\n    $SLICE = append($SLICE, ...)\n    ...\n  }(...)\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern-not-inside": "$MUTEX.Lock()\n...\n$MUTEX.Unlock()\n"
        },
        {
          "pattern-not-inside": "$MUTEX.Lock()\n...\ndefer $MUTEX.Unlock()\n...\n"
        }
      ]
    },
    {
      "id": "trailofbits.go.racy-write-to-map.racy-write-to-map",
      "message": "Multiple goroutines write to the same map without synchronization, creating a race condition. Concurrent map writes in Go can cause panics with the message \"concurrent map writes\". Maps are not thread-safe in Go and require explicit synchronization for concurrent modifications.",
      "languages": [
        "go"
      ],
      "severity": "ERROR",
      "metadata": {
        "category": "security",
        "cwe": "CWE-362: Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
        "subcategory": [
          "vuln"
        ],
        "confidence": "MEDIUM",
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "technology": [
          "--no-technology--"
        ],
        "description": "Concurrent writes to the same map in multiple goroutines",
        "references": [
          "https://go.dev/blog/maps#concurrency"
        ],
        "license": "AGPL-3.0 license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Concurrent writes to map without synchronization",
        "fix-suggestion": "Protect map operations with a mutex: `mu.Lock(); myMap[key] = value; mu.Unlock()`. Consider using `sync.Map` for simple concurrent map access patterns. For read-heavy workloads, explore sharded maps or concurrent map implementations from third-party libraries."
      },
      "patterns": [
        {
          "pattern": "$MAP[$KEY] = $VALUE\n"
        },
        {
          "pattern-inside": "$MAP = make(map[$KTYPE]$VTYPE)\n...\nfor ... {\n  ...\n  go func(...) {\n    ...\n    $MAP[$KEY] = $VALUE\n    ...\n  }(...)\n  ...\n}\n"
        },
        {
          "pattern-not-inside": "$MUTEX.Lock()\n...\n$MUTEX.Unlock()\n"
        },
        {
          "pattern-not-inside": "$MUTEX.Lock()\n...\ndefer $MUTEX.Unlock()\n...\n"
        }
      ]
    },
    {
      "id": "trailofbits.go.servercodec-readrequestbody-unhandled-nil.servercodec-readrequestbody-unhandled-nil",
      "message": "The ReadRequestBody function in a ServerCodec implementation doesn't correctly handle nil arguments. According to the ServerCodec interface, ReadRequestBody must be able to handle nil arguments, but this implementation fails to do so. This can lead to nil pointer dereferences and potential denial-of-service.",
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "cwe": "CWE-476: NULL Pointer Dereference",
        "subcategory": [
          "vuln"
        ],
        "confidence": "HIGH",
        "likelihood": "MEDIUM",
        "impact": "LOW",
        "technology": [
          "--no-technology--"
        ],
        "description": "Possible incorrect `ServerCodec` interface implementation",
        "references": [
          "https://github.com/golang/go/blob/go1.15.2/src/net/rpc/server.go#L643-L658"
        ],
        "license": "AGPL-3.0 license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "ServerCodec doesn't handle nil in ReadRequestBody",
        "fix-suggestion": "Add nil checks at the beginning of your `ReadRequestBody` method: `if arg == nil { return nil }`. Ensure your implementation follows the ServerCodec interface contract precisely. Test your code with nil arguments explicitly to verify correct behavior and prevent potential panic conditions."
      },
      "patterns": [
        {
          "pattern": "func ($O *$CODEC) ReadRequestBody($ARG $TYPE) error {\n  ...\n}\n"
        },
        {
          "pattern-not": "func ($O *$CODEC) ReadRequestBody($ARG $TYPE) error {\n  ...\n  if $ARG == nil { ... }\n  ...\n}\n"
        },
        {
          "pattern-not": "func ($O *$CODEC) ReadRequestBody($ARG $TYPE) error {\n  ...\n  if $ARG != nil { ... }\n  ...\n}\n"
        }
      ]
    },
    {
      "id": "trailofbits.go.string-to-int-signedness-cast.string-to-int-signedness-cast",
      "message": "String to integer conversion is performed with a casting method that may change signedness, potentially leading to unexpected behavior. Downcasting or changing the sign of integers can cause overflow, underflow, or truncation issues. These errors are particularly problematic in security-sensitive contexts.",
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "cwe": "CWE-681: Incorrect Conversion between Numeric Types",
        "subcategory": [
          "audit"
        ],
        "confidence": "HIGH",
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "technology": [
          "--no-technology--"
        ],
        "description": "Integer underflows",
        "references": [
          "https://github.com/golang/go/issues/30209"
        ],
        "license": "AGPL-3.0 license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Unsafe string to integer signedness conversion",
        "fix-suggestion": "Use appropriate type conversion functions like `strconv.ParseInt()` or `strconv.Atoi()` with proper error handling. Check bounds before converting between integer types with different sizes or signedness. Consider using the `math` package to check for potential overflow conditions when performing conversions."
      },
      "pattern-either": [
        {
          "patterns": [
            {
              "metavariable-pattern": {
                "metavariable": "$CAST_METHOD",
                "pattern-either": [
                  {
                    "pattern": "uint8"
                  },
                  {
                    "pattern": "uint16"
                  },
                  {
                    "pattern": "uint32"
                  },
                  {
                    "pattern": "int8"
                  },
                  {
                    "pattern": "int16"
                  },
                  {
                    "pattern": "int32"
                  }
                ]
              }
            },
            {
              "pattern-either": [
                {
                  "pattern": "$X, ... = strconv.Atoi(...)\n...\n$CAST_METHOD($X)\n"
                },
                {
                  "pattern": "$X, ... = strconv.ParseInt(..., ..., 64)\n...\n$CAST_METHOD($X)\n"
                },
                {
                  "pattern": "$X, ... = strconv.ParseUint(..., ..., 64)\n...\n$CAST_METHOD($X)\n"
                }
              ]
            }
          ]
        },
        {
          "pattern": "$X, ... = strconv.Atoi(...)\n...\nuint64($X)\n"
        },
        {
          "pattern": "$X, ... = strconv.ParseInt(..., ..., 64)\n...\nuint64($X)\n"
        },
        {
          "pattern": "$X, ... = strconv.ParseUint(..., ..., 64)\n...\nint64($X)\n"
        },
        {
          "patterns": [
            {
              "metavariable-pattern": {
                "metavariable": "$CAST_METHOD",
                "pattern-either": [
                  {
                    "pattern": "uint8"
                  },
                  {
                    "pattern": "uint16"
                  },
                  {
                    "pattern": "int8"
                  },
                  {
                    "pattern": "int16"
                  }
                ]
              }
            },
            {
              "pattern-either": [
                {
                  "pattern": "$X, ... = strconv.ParseInt(..., ..., 32)\n...\n$CAST_METHOD($X)\n"
                },
                {
                  "pattern": "$X, ... = strconv.ParseUint(..., ..., 32)\n...\n$CAST_METHOD($X)\n"
                }
              ]
            }
          ]
        },
        {
          "pattern": "$X, ... = strconv.ParseInt(..., ..., 32)\n...\nuint32($X)\n"
        },
        {
          "pattern": "$X, ... = strconv.ParseUint(..., ..., 32)\n...\nint32($X)\n"
        },
        {
          "patterns": [
            {
              "metavariable-pattern": {
                "metavariable": "$CAST_METHOD",
                "pattern-either": [
                  {
                    "pattern": "uint8"
                  },
                  {
                    "pattern": "int8"
                  }
                ]
              }
            },
            {
              "pattern-either": [
                {
                  "pattern": "$X, ... = strconv.ParseInt(..., ..., 16)\n...\n$CAST_METHOD($X)\n"
                },
                {
                  "pattern": "$X, ... = strconv.ParseUint(..., ..., 16)\n...\n$CAST_METHOD($X)\n"
                }
              ]
            }
          ]
        },
        {
          "pattern": "$X, ... = strconv.ParseInt(..., ..., 16)\n...\nuint16($X)\n"
        },
        {
          "pattern": "$X, ... = strconv.ParseUint(..., ..., 16)\n...\nint16($X)\n"
        },
        {
          "pattern": "$X, ... = strconv.ParseInt(..., ..., 8)\n...\nuint8($X)\n"
        },
        {
          "pattern": "$X, ... = strconv.ParseUint(..., ..., 8)\n...\nint8($X)\n"
        }
      ]
    },
    {
      "id": "trailofbits.go.sync-mutex-value-copied.sync-mutex-value-copied",
      "message": "A sync.Mutex is being copied by value, which can lead to synchronization failures. Mutexes contain unexported fields that must maintain their memory address to function correctly. When a mutex is copied, the copy is separate from the original and won't provide the expected locking behavior.",
      "languages": [
        "go"
      ],
      "severity": "ERROR",
      "metadata": {
        "category": "security",
        "cwe": "CWE-688: Function Call With Incorrect Variable or Reference as Argument",
        "subcategory": [
          "vuln"
        ],
        "confidence": "HIGH",
        "likelihood": "HIGH",
        "impact": "LOW",
        "technology": [
          "--no-technology--"
        ],
        "description": "Copying of `sync.Mutex` via value receivers",
        "references": [
          "https://go101.org/article/concurrent-common-mistakes.html"
        ],
        "license": "AGPL-3.0 license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Go mutex copied instead of referenced",
        "fix-suggestion": "Use pointer receivers (`func (m *MyStruct)`) instead of value receivers (`func (m MyStruct)`) for methods on structs containing mutexes. Pass mutex-containing structs by pointer rather than by value. Consider using the `go vet` tool which can detect this issue with the `-copylocks` flag."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "func ($T $TYPE) $FUNC(...){\n  ...\n  $T.Lock()\n  ...\n}\n"
            },
            {
              "pattern": "func ($T $TYPE) $FUNC(...){\n  ...\n  $T.RLock()\n  ...\n}\n"
            }
          ]
        },
        {
          "pattern-not": "func ($T2 *$TYPE2) $FUNC(...){\n  ...\n}\n"
        }
      ]
    },
    {
      "id": "trailofbits.go.waitgroup-add-called-inside-goroutine.waitgroup-add-called-inside-goroutine",
      "message": "WaitGroup.Add is called inside a goroutine, creating a race condition with WaitGroup.Wait. This may cause the Wait call to complete before the Add call executes, leading to unpredictable behavior or panics. WaitGroup counters must be incremented before goroutines are started.",
      "languages": [
        "go"
      ],
      "severity": "ERROR",
      "metadata": {
        "category": "security",
        "cwe": "CWE-667: Improper Locking",
        "subcategory": [
          "vuln"
        ],
        "confidence": "MEDIUM",
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "technology": [
          "--no-technology--"
        ],
        "description": "Calls to `sync.WaitGroup.Add` inside of anonymous goroutines",
        "references": [
          "https://go101.org/article/concurrent-common-mistakes.html"
        ],
        "license": "AGPL-3.0 license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "WaitGroup.Add called inside goroutine",
        "fix-suggestion": "Move the `wg.Add(1)` call before the `go` statement that launches the goroutine. Keep the `wg.Done()` call inside the goroutine to properly decrement the counter when finished. Follow the pattern: `wg.Add(1); go func() { defer wg.Done(); /* work here */ }()`."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$WG := &sync.WaitGroup{}\n...\ngo func(...) {\n  ...\n  $WG.Add(...)\n  ...\n}(...)\n...\n$WG.Wait()\n"
            },
            {
              "pattern": "var $WG sync.WaitGroup\n...\ngo func(...) {\n  ...\n  $WG.Add(...)\n  ...\n}(...)\n...\n$WG.Wait()\n"
            }
          ]
        },
        {
          "pattern-not-inside": "for ... {\n  ...\n  $WG.Add(...)\n  ...\n}\n"
        }
      ]
    },
    {
      "id": "trailofbits.go.waitgroup-wait-inside-loop.waitgroup-wait-inside-loop",
      "message": "WaitGroup.Wait is called inside a loop which also launches goroutines, creating a deadlock. The Wait call blocks until all goroutines complete, but subsequent loop iterations add more work that will never be reached. This creates an unresolvable wait condition.",
      "languages": [
        "go"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "cwe": "CWE-667: Improper Locking",
        "subcategory": [
          "vuln"
        ],
        "confidence": "MEDIUM",
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "technology": [
          "--no-technology--"
        ],
        "description": "Calls to `sync.WaitGroup.Wait` inside a loop",
        "references": [
          "https://go101.org/article/concurrent-common-mistakes.html"
        ],
        "license": "AGPL-3.0 license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "WaitGroup.Wait causes deadlock inside loop",
        "fix-suggestion": "Move the `wg.Wait()` call outside the loop, after all goroutines have been launched. Add all goroutines to the WaitGroup before waiting. Ensure each goroutine calls `wg.Done()` exactly once, typically using `defer wg.Done()` at the start of the goroutine function."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "var $WG sync.WaitGroup\n...\nfor ... {\n  ...\n  go func(...){\n    ...\n    defer $WG.Done()\n    ...\n  }()\n  ...\n  $WG.Wait()\n  ...\n}\n"
            },
            {
              "pattern": "$WG := &sync.WaitGroup{}\n...\nfor ... {\n  ...\n  go func(...){\n    ...\n    defer $WG.Done()\n    ...\n  }()\n  ...\n  $WG.Wait()\n  ...\n}\n"
            },
            {
              "pattern": "var $WG sync.WaitGroup\n...\nfor ... {\n  ...\n  go func(...){\n    ...\n    $WG.Done()\n    ...\n  }()\n  ...\n  $WG.Wait()\n  ...\n}\n"
            },
            {
              "pattern": "$WG := &sync.WaitGroup{}\n...\nfor ... {\n  ...\n  go func(...){\n    ...\n    $WG.Done()\n    ...\n  }()\n  ...\n  $WG.Wait()\n  ...\n}\n"
            }
          ]
        }
      ]
    },
    {
      "id": "trailofbits.python.automatic-memory-pinning.automatic-memory-pinning",
      "message": "Manual memory pinning is used instead of relying on PyTorch's automatic pinning mechanism. Manual pinning can lead to undefined behavior and reduced efficiency if not implemented correctly. PyTorch has built-in memory management that handles tensor location optimally in most cases.",
      "languages": [
        "python"
      ],
      "severity": "WARNING",
      "metadata": {
        "category": "security",
        "cwe": "CWE-676: Use of Potentially Dangerous Function",
        "subcategory": [
          "audit"
        ],
        "confidence": "HIGH",
        "likelihood": "LOW",
        "impact": "LOW",
        "technology": [
          "pytorch"
        ],
        "description": "`PyTorch` memory not automatically pinned",
        "references": [
          "https://pytorch.org/docs/stable/data.html#memory-pinning"
        ],
        "license": "AGPL-3.0 license",
        "vulnerability_class": [
          "Dangerous Method or Function"
        ],
        "short-description": "Unnecessary manual memory pinning in PyTorch",
        "fix-suggestion": "Remove manual calls to `.pin_memory()` and rely on PyTorch's automatic memory management. Use `DataLoader` with `pin_memory=True` to let PyTorch handle pinning automatically. If custom pinning is absolutely necessary, ensure you thoroughly understand the CUDA memory model and PyTorch's implementation details."
      },
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern": "torch.utils.data.DataLoader(...)"
            },
            {
              "pattern-not": "torch.utils.data.DataLoader(..., pin_memory=$VALUE, ...)"
            }
          ]
        },
        {
          "pattern": "torch.utils.data.DataLoader(..., pin_memory=False, ...)"
        }
      ]
    },
    {
      "id": "trailofbits.python.lxml-in-pandas.lxml-in-pandas",
      "message": "The lxml library is being used, which is vulnerable to XML external entity (XXE) attacks. XXE attacks can lead to server-side request forgery, port scanning, sensitive file disclosure, or denial of service. When processing untrusted XML data, using vulnerable parsers like lxml creates significant security risks.",
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "metadata": {
        "category": "security",
        "cwe": "CWE-611: Improper Restriction of XML External Entity Reference",
        "subcategory": [
          "vuln"
        ],
        "confidence": "HIGH",
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "technology": [
          "pandas"
        ],
        "description": "Potential XXE attacks from loading `lxml` in pandas",
        "references": [
          "https://lxml.de/FAQ.html"
        ],
        "license": "AGPL-3.0 license",
        "vulnerability_class": [
          "XML Injection"
        ],
        "short-description": "Vulnerable XML parser prone to XXE attacks",
        "fix-suggestion": "Replace `lxml` with `defusedxml` which is designed to prevent XML vulnerabilities. When using pandas, set `parser='etree'` or specify secure parser options. Always disable DTD processing with `resolve_entities=False` if you must use lxml directly."
      },
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern": "pandas.read_html($IO)"
            },
            {
              "pattern-not": "pandas.read_html(**$KWARGS)"
            }
          ]
        },
        {
          "patterns": [
            {
              "metavariable-pattern": {
                "metavariable": "$FLAVOR",
                "patterns": [
                  {
                    "pattern": "..."
                  },
                  {
                    "pattern-not": "\"bs4\"\n"
                  },
                  {
                    "pattern-not": "\"html5lib\"\n"
                  }
                ]
              }
            },
            {
              "pattern-either": [
                {
                  "pattern": "pandas.read_html(..., flavor=$FLAVOR, ...)"
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$KWARGS = {..., \"flavor\": $FLAVOR, ...}\n...\n"
                    },
                    {
                      "pattern": "pandas.read_html(**$KWARGS)\n"
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "trailofbits.python.pickles-in-numpy.pickles-in-numpy",
      "message": "Python's pickle module is being used with NumPy, which can lead to arbitrary code execution when deserializing untrusted data. Pickle is inherently insecure as it allows the deserialized data to execute code. Any pickled data from untrusted sources poses a serious security risk.",
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "metadata": {
        "category": "security",
        "cwe": "CWE-502: Deserialization of Untrusted Data",
        "subcategory": [
          "vuln"
        ],
        "confidence": "MEDIUM",
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "technology": [
          "numpy"
        ],
        "description": "Potential arbitrary code execution from `NumPy` functions reliant on pickling",
        "references": [
          "https://blog.trailofbits.com/2021/03/15/never-a-dill-moment-exploiting-machine-learning-pickle-files/"
        ],
        "license": "AGPL-3.0 license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "Insecure Python pickle usage in NumPy",
        "fix-suggestion": "Use secure alternatives like `numpy.save()` and `numpy.load()` without allowing pickle. Consider `fickling` for safer pickle handling or use JSON with `numpy.tolist()` for interoperability. If you must use pickle, verify the source of pickled data and never unpickle data from untrusted sources."
      },
      "patterns": [
        {
          "pattern": "numpy.load(..., allow_pickle=$VALUE, ...)"
        },
        {
          "pattern-not": "numpy.load(\"...\", ...)"
        },
        {
          "pattern-not": "numpy.load(..., file=\"...\", ...)"
        },
        {
          "metavariable-pattern": {
            "metavariable": "$VALUE",
            "patterns": [
              {
                "pattern-not": "False\n"
              },
              {
                "pattern-not": "[]\n"
              },
              {
                "pattern-not": "None\n"
              },
              {
                "pattern-not": "\"\"\n"
              }
            ]
          }
        }
      ]
    },
    {
      "id": "trailofbits.python.pickles-in-pandas.pickles-in-pandas",
      "message": "Python's pickle module is being used with Pandas, which can lead to arbitrary code execution when deserializing untrusted data. Pickle does not validate input and can execute malicious code during deserialization. This is particularly dangerous when loading data from external or user-provided sources.",
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "metadata": {
        "category": "security",
        "cwe": "CWE-502: Deserialization of Untrusted Data",
        "subcategory": [
          "vuln"
        ],
        "confidence": "MEDIUM",
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "technology": [
          "pandas"
        ],
        "description": "Potential arbitrary code execution from `Pandas` functions reliant on pickling",
        "references": [
          "https://blog.trailofbits.com/2021/03/15/never-a-dill-moment-exploiting-machine-learning-pickle-files/"
        ],
        "license": "AGPL-3.0 license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "Insecure Python pickle usage in Pandas",
        "fix-suggestion": "Use safer serialization methods like CSV, JSON, or HDF5 with Pandas' built-in functions like `to_csv()` and `read_csv()`. Set `pickle=False` when using HDF5 format. If you must use pickle, consider the `fickling` library to help mitigate risks, but never unpickle data from untrusted sources."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "pandas.read_pickle(...)"
            },
            {
              "pattern": "pandas.to_pickle(...)"
            },
            {
              "patterns": [
                {
                  "pattern-inside": "import pandas\n...\n"
                },
                {
                  "pattern": "$SMTH.to_pickle(...)"
                }
              ]
            }
          ]
        },
        {
          "pattern-not": "pandas.read_pickle(\"...\")"
        },
        {
          "pattern-not": "pandas.to_pickle(..., \"...\")"
        },
        {
          "pattern-not": "$SMTH.to_pickle(\"...\")"
        }
      ]
    },
    {
      "id": "trailofbits.python.pickles-in-pytorch.pickles-in-pytorch",
      "message": "Python's pickle module is being used with PyTorch, which can lead to arbitrary code execution when loading untrusted models. PyTorch's default serialization relies on pickle, making model loading potentially dangerous. Attackers can craft malicious model files that execute code when loaded.",
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "metadata": {
        "category": "security",
        "cwe": "CWE-502: Deserialization of Untrusted Data",
        "subcategory": [
          "vuln"
        ],
        "confidence": "MEDIUM",
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "technology": [
          "pytorch"
        ],
        "description": "Potential arbitrary code execution from `PyTorch` functions reliant on pickling",
        "references": [
          "https://blog.trailofbits.com/2021/03/15/never-a-dill-moment-exploiting-machine-learning-pickle-files/"
        ],
        "license": "AGPL-3.0 license",
        "vulnerability_class": [
          "Insecure Deserialization "
        ],
        "short-description": "Insecure Python pickle usage in PyTorch",
        "fix-suggestion": "Use `state_dict()` and `load_state_dict()` instead of directly saving/loading models with `torch.save()` and `torch.load()`. Consider exporting models to ONNX format for safer interoperability. If you must load pickled models, use the `fickling` library to help mitigate risks and only load models from trusted sources."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "torch.save(...)"
            },
            {
              "pattern": "torch.load(...)"
            }
          ]
        },
        {
          "pattern-not": "torch.load(\"...\")"
        },
        {
          "pattern-not": "torch.save(..., \"...\")"
        },
        {
          "pattern-not": "torch.save($M.state_dict(), ...)"
        },
        {
          "pattern-not-inside": "$M.load_state_dict(...)"
        },
        {
          "pattern-not": {
            "patterns": [
              {
                "pattern": "torch.save($STATE_DICT, ...)"
              },
              {
                "pattern-inside": "$STATE_DICT = $M.state_dict()\n...\n"
              }
            ]
          }
        }
      ]
    },
    {
      "id": "trailofbits.python.tarfile-extractall-traversal.tarfile-extractall-traversal",
      "message": "The tarfile.extractall() method is used without path validation, creating a path traversal vulnerability. Malicious tar files can contain entries with paths like '../../../etc/passwd' that write files outside the intended directory. This can lead to arbitrary file overwrites if untrusted tar archives are processed.",
      "languages": [
        "python"
      ],
      "severity": "ERROR",
      "metadata": {
        "category": "security",
        "cwe": "CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
        "subcategory": [
          "vuln"
        ],
        "confidence": "MEDIUM",
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "technology": [
          "--no-technology--"
        ],
        "description": "Potential path traversal in call to `extractall` for a `tarfile`",
        "references": [
          "https://docs.python.org/3/library/tarfile.html#tarfile.TarFile.extractall"
        ],
        "license": "AGPL-3.0 license",
        "vulnerability_class": [
          "Path Traversal"
        ],
        "short-description": "Tarfile extraction path traversal vulnerability",
        "fix-suggestion": "Validate and sanitize file paths before extraction, rejecting or sanitizing files with suspicious path patterns like `../`. Use `tarfile.extract()` to extract specific members after validation rather than `extractall()`. Consider safer libraries like `patoolib` or explicitly check each file path with `os.path.normpath()` and ensure it doesn't escape the target directory."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "with tarfile.open(...) as $TAR:\n    ...\n    $TAR.extractall(...)\n"
            },
            {
              "pattern": "tarfile.open(...).extractall(...)\n"
            },
            {
              "pattern": "$TAR = tarfile.open(...)\n...\n$TAR.extractall(...)\n"
            }
          ]
        },
        {
          "pattern-not": "with tarfile.open(...) as $TAR:\n    ...\n    $TAR.extractall(..., members=$MEMBERS, ...)\n"
        },
        {
          "pattern-not": "tarfile.open(...).extractall(..., members=$MEMBERS, ...)\n"
        },
        {
          "pattern-not": "$TAR = tarfile.open(...)\n...\n$TAR.extractall(..., members=$MEMBERS, ...)\n"
        }
      ]
    },
    {
      "id": "typescript.angular.security.audit.angular-domsanitizer.angular-bypasssecuritytrust",
      "message": "Angular's bypassSecurityTrust methods (like trustAsHtml, trustAsUrl) bypass the framework's built-in sanitization mechanisms. When used with user-controlled input, attackers can inject malicious scripts that execute in users' browsers. Only use these methods with trusted content that you fully control or after applying proper sanitization.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "references": [
          "https://angular.io/api/platform-browser/DomSanitizer",
          "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "confidence": "MEDIUM",
        "category": "security",
        "technology": [
          "angular",
          "browser"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "BypassSecurityTrust usage can embed untrusted scripts or HTML",
        "fix-suggestion": "Remove calls to `bypassSecurityTrust` methods and rely on Angular's built-in sanitization. For dynamic content, implement server-side validation before sending to the client. Consider using Angular's safe binding syntax like `[innerText]` instead of unsafe alternatives."
      },
      "languages": [
        "typescript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ...({..., $X: string, ...}) { ... }\n"
                },
                {
                  "pattern-inside": "function ...(..., $X: string, ...) { ... }\n"
                }
              ]
            },
            {
              "focus-metavariable": "$X"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$X.$TRUST($Y)"
                }
              ]
            },
            {
              "focus-metavariable": "$Y"
            },
            {
              "pattern-not": "$X.$TRUST(`...`)\n"
            },
            {
              "pattern-not": "$X.$TRUST(\"...\")\n"
            },
            {
              "metavariable-regex": {
                "metavariable": "$TRUST",
                "regex": "(bypassSecurityTrustHtml|bypassSecurityTrustStyle|bypassSecurityTrustScript|bypassSecurityTrustUrl|bypassSecurityTrustResourceUrl)"
              }
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "import $S from \"underscore.string\"\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from \"underscore.string\"\n...\n"
                },
                {
                  "pattern-inside": "import $S from \"underscore.string\"\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"underscore.string\")\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$S.escapeHTML(...)"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "import $S from \"dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "import { ..., $S,... } from \"dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from \"dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"dompurify\")\n...\n"
                },
                {
                  "pattern-inside": "import $S from \"isomorphic-dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from \"isomorphic-dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"isomorphic-dompurify\")\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-inside": "$VALUE = $S(...)\n...\n"
                    },
                    {
                      "pattern": "$VALUE.sanitize(...)"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$VALUE = $S.sanitize\n...\n"
                    },
                    {
                      "pattern": "$S(...)"
                    }
                  ]
                },
                {
                  "pattern": "$S.sanitize(...)"
                },
                {
                  "pattern": "$S(...)"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "import $S from 'xss';\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from 'xss';\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"xss\")\n...\n"
                }
              ]
            },
            {
              "pattern": "$S(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "import $S from 'sanitize-html';\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from \"sanitize-html\";\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"sanitize-html\")\n...\n"
                }
              ]
            },
            {
              "pattern": "$S(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern": "sanitizer.sanitize(...)"
            },
            {
              "pattern-not": "sanitizer.sanitize(SecurityContext.NONE, ...);"
            }
          ]
        }
      ]
    },
    {
      "id": "typescript.aws-cdk.security.awscdk-bucket-grantpublicaccessmethod.awscdk-bucket-grantpublicaccessmethod",
      "message": "Using the grantPublicAccess method on S3 buckets in AWS CDK makes all objects publicly accessible to anyone on the internet. This can lead to data exposure, excessive costs from bandwidth usage, or potential legal/compliance violations. Only use this method when public access is explicitly required and confirm that no sensitive data will be stored in the bucket.",
      "metadata": {
        "cwe": [
          "CWE-306: Missing Authentication for Critical Function"
        ],
        "category": "security",
        "technology": [
          "AWS-CDK"
        ],
        "references": [
          "https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-control-overview.html"
        ],
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "GrantPublicAccess method publicly exposes S3 bucket contents",
        "fix-suggestion": "Remove calls to `grantPublicAccess()` method on S3 bucket objects containing sensitive data. Configure fine-grained access controls using IAM policies instead of public permissions. Implement a review process to validate that no sensitive buckets are publicly accessible."
      },
      "languages": [
        "ts"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern-inside": "import {Bucket} from '@aws-cdk/aws-s3'\n...\n"
            },
            {
              "pattern": "const $X = new Bucket(...)\n...\n$X.grantPublicAccess(...)\n"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "import * as $Y from '@aws-cdk/aws-s3'\n...\n"
            },
            {
              "pattern": "const $X = new $Y.Bucket(...)\n...\n$X.grantPublicAccess(...)\n"
            }
          ]
        }
      ]
    },
    {
      "id": "typescript.aws-cdk.security.awscdk-codebuild-project-public.awscdk-codebuild-project-public",
      "message": "Setting a CodeBuild project as public in AWS CDK exposes build logs, artifacts, and potentially sensitive information to anyone with the URL. This can lead to exposure of secrets, internal processes, or intellectual property that may appear in build outputs. Only enable public access for CodeBuild projects that contain no sensitive information and are intended for public consumption.",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-306: Missing Authentication for Critical Function"
        ],
        "technology": [
          "AWS-CDK"
        ],
        "references": [
          "https://docs.aws.amazon.com/codebuild/latest/userguide/public-builds.html"
        ],
        "owasp": [
          "A07:2021 - Identification and Authentication Failures"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Public CodeBuild project can leak build logs or artifacts",
        "fix-suggestion": "Set `projectVisibility: ProjectVisibility.PRIVATE` when creating CodeBuild projects. Remove any configuration that sets `badgeEnabled: true` on projects containing sensitive build information. Implement least-privilege IAM policies to control access to build artifacts and logs."
      },
      "languages": [
        "ts"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern-inside": "import {Project} from '@aws-cdk/aws-codebuild'\n...\n"
            },
            {
              "pattern": "const $X = new Project(..., {..., badge: true, ...})\n"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "import * as $Y from '@aws-cdk/aws-codebuild'\n...\n"
            },
            {
              "pattern": "const $X = new $Y.Project(..., {..., badge: true, ...})\n"
            }
          ]
        }
      ]
    },
    {
      "id": "typescript.aws-cdk.security.audit.awscdk-bucket-encryption.awscdk-bucket-encryption",
      "message": "Your AWS CDK S3 bucket is configured without encryption, leaving data stored in plain text. When a bucket lacks encryption, sensitive data can be exposed if access controls are compromised. Server-side encryption adds an important layer of protection for your data at rest.",
      "metadata": {
        "cwe": [
          "CWE-311: Missing Encryption of Sensitive Data"
        ],
        "category": "security",
        "technology": [
          "AWS-CDK"
        ],
        "references": [
          "https://docs.aws.amazon.com/AmazonS3/latest/userguide/security-best-practices.html"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A04:2021 - Insecure Design"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "AWS CDK S3 bucket without encryption enabled",
        "fix-suggestion": "Add encryption to your bucket props by specifying `encryption: BucketEncryption.KMS_MANAGED` or `encryption: BucketEncryption.S3_MANAGED` in your Bucket construct. For higher security, consider using your own KMS key with `encryptionKey: new kms.Key(this, 'MyKey')`. This ensures your data is encrypted at rest in S3."
      },
      "languages": [
        "typescript"
      ],
      "severity": "ERROR",
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern-inside": "import {Bucket} from '@aws-cdk/aws-s3'\n...\n"
            },
            {
              "pattern": "const $X = new Bucket(...)"
            },
            {
              "pattern-not": "const $X = new Bucket(..., {..., encryption: BucketEncryption.KMS_MANAGED, ...})\n"
            },
            {
              "pattern-not": "const $X = new Bucket(..., {..., encryption: BucketEncryption.KMS, ...})\n"
            },
            {
              "pattern-not": "const $X = new Bucket(..., {..., encryption: BucketEncryption.S3_MANAGED, ...})\n"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "import * as $Y from '@aws-cdk/aws-s3'\n...\n"
            },
            {
              "pattern": "const $X = new $Y.Bucket(...)"
            },
            {
              "pattern-not": "const $X = new $Y.Bucket(..., {..., encryption: $Y.BucketEncryption.KMS_MANAGED, ...})\n"
            },
            {
              "pattern-not": "const $X = new $Y.Bucket(..., {..., encryption: $Y.BucketEncryption.KMS, ...})\n"
            },
            {
              "pattern-not": "const $X = new $Y.Bucket(..., {..., encryption: $Y.BucketEncryption.S3_MANAGED, ...})\n"
            }
          ]
        }
      ]
    },
    {
      "id": "typescript.aws-cdk.security.audit.awscdk-sqs-unencryptedqueue.awscdk-sqs-unencryptedqueue",
      "message": "AWS CDK SQS queue is created without encryption at rest, potentially exposing sensitive message data. Unencrypted queues store message content in plain text, risking data exposure if storage media is compromised. Encryption is a key component of a defense-in-depth strategy for message queues.",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-311: Missing Encryption of Sensitive Data"
        ],
        "technology": [
          "AWS-CDK"
        ],
        "references": [
          "https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-data-protection.html"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A04:2021 - Insecure Design"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cryptographic Issues"
        ],
        "short-description": "AWS CDK SQS queue without encryption enabled",
        "fix-suggestion": "Enable encryption by adding `encryption: QueueEncryption.KMS_MANAGED` or `encryption: QueueEncryption.KMS` to the queue props in your Queue construct. For enhanced security, specify your own KMS key with `encryptionMasterKey: new kms.Key(this, 'QueueKey')`. This ensures your message data is protected at rest."
      },
      "languages": [
        "ts"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern-inside": "import {Queue} from '@aws-cdk/aws-sqs'\n...\n"
            },
            {
              "pattern": "const $X = new Queue(...)"
            },
            {
              "pattern-not": "const $X = new Queue(..., {..., encryption: QueueEncryption.KMS_MANAGED, ...})\n"
            },
            {
              "pattern-not": "const $X = new Queue(..., {..., encryption: QueueEncryption.KMS, ...})\n"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "import * as $Y from '@aws-cdk/aws-sqs'\n...\n"
            },
            {
              "pattern": "const $X = new $Y.Queue(...)"
            },
            {
              "pattern-not": "const $X = new $Y.Queue(..., {..., encryption: $Y.QueueEncryption.KMS_MANAGED, ...})\n"
            },
            {
              "pattern-not": "const $X = new $Y.Queue(..., {..., encryption: $Y.QueueEncryption.KMS, ...})\n"
            }
          ]
        }
      ]
    },
    {
      "id": "typescript.aws-cdk.security.audit.awscdk-bucket-enforcessl.aws-cdk-bucket-enforcessl",
      "message": "S3 bucket doesn't enforce encrypted connections (SSL/TLS) for data transmission. Without enforced encryption-in-transit, data transfers could occur over unencrypted connections, exposing sensitive information to interception. The enforceSSL property requires HTTPS for all access to the bucket.",
      "metadata": {
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "category": "security",
        "technology": [
          "AWS-CDK"
        ],
        "references": [
          "https://docs.aws.amazon.com/AmazonS3/latest/userguide/security-best-practices.html"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "S3 bucket doesn't enforce encrypted connections",
        "fix-suggestion": "Set `enforceSSL: true` in your bucket properties to ensure that requests using insecure connections are denied. Add this property to existing buckets via a bucket policy if not explicitly set. Consider implementing additional security measures like a VPC endpoint for S3 to further secure access patterns."
      },
      "languages": [
        "ts"
      ],
      "severity": "ERROR",
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern-inside": "import {Bucket} from '@aws-cdk/aws-s3';\n...\n"
            },
            {
              "pattern": "const $X = new Bucket(...)"
            },
            {
              "pattern-not": "const $X = new Bucket(..., {enforceSSL: true}, ...)\n"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "import * as $Y from '@aws-cdk/aws-s3';\n...\n"
            },
            {
              "pattern": "const $X = new $Y.Bucket(...)"
            },
            {
              "pattern-not": "const $X = new $Y.Bucket(..., {..., enforceSSL: true, ...})\n"
            }
          ]
        }
      ]
    },
    {
      "id": "typescript.lang.security.audit.cors-regex-wildcard.cors-regex-wildcard",
      "message": "Unescaped period character in CORS domain regex can match any character instead of a literal period. This overly permissive pattern may unintentionally allow requests from malicious domains that shouldn't be trusted. Regular expressions used for security controls must be precise.",
      "metadata": {
        "cwe": [
          "CWE-183: Permissive List of Allowed Inputs"
        ],
        "category": "security",
        "technology": [
          "cors"
        ],
        "owasp": [
          "A04:2021 - Insecure Design"
        ],
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "Unsafe period in CORS domain regex pattern",
        "fix-suggestion": "Escape the period in your CORS regex pattern by changing `.` to `\\.` in your domain pattern. Use precise regular expressions like `^https://example\\.com$` instead of overly permissive patterns. Consider using a whitelist of exact domains rather than complex regular expressions when possible."
      },
      "languages": [
        "ts"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern": "$CORS = [...,/$PATTERN/,...]"
            },
            {
              "pattern": "$CORS = /$PATTERN/"
            }
          ]
        },
        {
          "focus-metavariable": "$PATTERN"
        },
        {
          "metavariable-regex": {
            "metavariable": "$PATTERN",
            "regex": ".+?(?<!\\\\).\\..+(?<!\\\\)\\..+"
          }
        },
        {
          "metavariable-regex": {
            "metavariable": "$CORS",
            "regex": "(?i)cors"
          }
        }
      ]
    },
    {
      "id": "typescript.nestjs.security.audit.nestjs-header-cors-any.nestjs-header-cors-any",
      "message": "CORS policy allows requests from any origin with wildcard \"*\". This configuration bypasses Same Origin Policy restrictions designed to prevent cross-site attacks. Overly permissive CORS headers can expose your API to unauthorized access from any website.",
      "metadata": {
        "cwe": [
          "CWE-183: Permissive List of Allowed Inputs"
        ],
        "asvs": {
          "section": "V14: Configuration Verification Requirements",
          "control_id": "14.4.8 Permissive CORS",
          "control_url": "https://github.com/OWASP/ASVS/blob/master/4.0/en/0x22-V14-Config.md#v144-http-security-headers-requirements",
          "version": "4"
        },
        "category": "security",
        "technology": [
          "nestjs"
        ],
        "owasp": [
          "A04:2021 - Insecure Design"
        ],
        "references": [
          "https://owasp.org/Top10/A04_2021-Insecure_Design"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Validation"
        ],
        "short-description": "NestJS CORS allows requests from any origin",
        "fix-suggestion": "Replace wildcard `\"*\"` with a specific list of trusted domains in your CORS configuration. Use the NestJS `cors` option with an explicit `origin` array like `origin: ['https://trusted-site.com']`. Add validation logic to dynamically verify origins when more flexibility is needed."
      },
      "languages": [
        "typescript"
      ],
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern": "class $CN {\n    @Header(\"=~/[Aa][Cc][Cc][Ee][Ss][Ss]-[Cc][Oo][Nn][Tt][Rr][Oo][Ll]-[Aa][Ll][Ll][Oo][Ww]-[Oo][Rr][Ii][Gg][Ii][Nn]/\", '*')\n    $FN(...) {\n        ...\n    }\n}\n"
        },
        {
          "pattern": "NestFactory.create($MODULE, {cors: true})\n"
        },
        {
          "pattern": "NestFactory.create($MODULE, {cors: {origin: '*'}})\n"
        },
        {
          "pattern": "$APP.enableCors()\n"
        },
        {
          "pattern": "$APP.enableCors({origin: '*'})\n"
        }
      ]
    },
    {
      "id": "typescript.nestjs.security.audit.nestjs-header-xss-disabled.nestjs-header-xss-disabled",
      "message": "Setting the X-XSS-Protection header to 0 disables the browser's built-in XSS filter that can block some cross-site scripting attacks. Without this protection, malicious scripts injected into the application have a higher chance of executing successfully. Enable this header with appropriate values to add an additional layer of defense against XSS attacks.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "category": "security",
        "technology": [
          "nestjs"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://owasp.org/Top10/A03_2021-Injection"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "X-XSS-Protection disabled, increasing cross-site scripting risk",
        "fix-suggestion": "Configure the helmet middleware with `xssFilter: true` in your NestJS application. Set X-XSS-Protection header to `1; mode=block` to enable browser XSS protection. Implement content security policies alongside XSS protection for defense in depth."
      },
      "languages": [
        "typescript"
      ],
      "severity": "WARNING",
      "pattern": "class $CN {\n    ...\n    @Header(\"=~/[Xx]-[Xx][Ss][Ss]-[Pp][Rr][Oo][Tt][Ee][Cc][Tt][Ii][Oo][Nn]/\", '0')\n    $FN(...) {\n        ...\n    }\n    ...\n}\n"
    },
    {
      "id": "typescript.nestjs.security.audit.nestjs-open-redirect.nestjs-open-redirect",
      "message": "Untrusted user input is used in a URL redirect, creating an open redirect vulnerability. Attackers can craft malicious URLs that redirect users to phishing sites while appearing to come from your domain. This vulnerability can facilitate social engineering attacks against your users.",
      "metadata": {
        "cwe": [
          "CWE-601: URL Redirection to Untrusted Site ('Open Redirect')"
        ],
        "category": "security",
        "technology": [
          "nestjs"
        ],
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "references": [
          "https://owasp.org/Top10/A01_2021-Broken_Access_Control"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Open Redirect"
        ],
        "short-description": "NestJS open redirect using untrusted input",
        "fix-suggestion": "Validate redirect URLs by checking them against a whitelist of allowed destinations. Use a URL parser to extract and validate the domain before performing any redirect. Implement absolute URL validation with `isURL()` from class-validator or similar libraries, ensuring URLs are within your trusted domains."
      },
      "languages": [
        "typescript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern": "return {url: $URL}\n"
        },
        {
          "pattern-inside": "class $CN {\n    @Redirect(...)\n    $FN(...) {\n        ...\n    }\n}\n"
        },
        {
          "pattern-not": "return {url: \"...\"}\n"
        }
      ]
    },
    {
      "id": "typescript.react.security.react-insecure-request.react-insecure-request",
      "message": "Unencrypted HTTP request detected in React application, transmitting data without encryption. Plaintext HTTP connections can be intercepted, exposing sensitive information to eavesdroppers. All network requests should use HTTPS to ensure data confidentiality and integrity.",
      "metadata": {
        "vulnerability": "Insecure Transport",
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "references": [
          "https://www.npmjs.com/package/axios"
        ],
        "category": "security",
        "technology": [
          "react"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "React app makes insecure HTTP requests",
        "fix-suggestion": "Replace all `http://` URLs with `https://` in your API calls and resource references. Use environment variables to manage API endpoints and ensure they use HTTPS. Consider implementing HTTP Strict Transport Security (HSTS) headers on your server to enforce secure connections."
      },
      "languages": [
        "typescript",
        "javascript"
      ],
      "severity": "ERROR",
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "import $AXIOS from 'axios';\n...\n$AXIOS.$METHOD(...)\n"
                    },
                    {
                      "pattern-inside": "$AXIOS = require('axios');\n...\n$AXIOS.$METHOD(...)\n"
                    }
                  ]
                },
                {
                  "pattern": "$AXIOS.$VERB(\"$URL\",...)"
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$VERB",
                    "regex": "^(get|post|delete|head|patch|put|options)"
                  }
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-either": [
                    {
                      "pattern-inside": "import $AXIOS from 'axios';\n...\n$AXIOS(...)\n"
                    },
                    {
                      "pattern-inside": "$AXIOS = require('axios');\n...\n$AXIOS(...)\n"
                    }
                  ]
                },
                {
                  "pattern-either": [
                    {
                      "pattern": "$AXIOS({url: \"$URL\"}, ...)"
                    },
                    {
                      "pattern": "$OPTS = {url: \"$URL\"}\n...\n$AXIOS($OPTS, ...)\n"
                    }
                  ]
                }
              ]
            },
            {
              "pattern": "fetch(\"$URL\", ...)"
            }
          ]
        },
        {
          "metavariable-regex": {
            "metavariable": "$URL",
            "regex": "^([Hh][Tt][Tt][Pp]:\\/\\/(?!localhost).*)"
          }
        }
      ]
    },
    {
      "id": "typescript.react.security.react-markdown-insecure-html.react-markdown-insecure-html",
      "message": "Enabling allowDangerousHtml in React Markdown or disabling URI sanitization allows raw HTML and potentially harmful URLs to be rendered. Attackers can exploit this to inject JavaScript or redirect users to malicious sites through crafted markdown content. Always keep the default safety features enabled when processing untrusted markdown input.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://www.npmjs.com/package/react-markdown#security"
        ],
        "category": "security",
        "technology": [
          "react"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "allowDangerousHtml or transformLinkUri can lead to XSS",
        "fix-suggestion": "Remove `allowDangerousHtml` and `transformLinkUri={null}` props from React Markdown components. Maintain default sanitization features by not overriding security settings. For custom rendering, use the component override system instead of disabling security features."
      },
      "languages": [
        "typescript",
        "javascript"
      ],
      "severity": "WARNING",
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "$X = require('react-markdown/with-html');\n...\n"
            },
            {
              "pattern-inside": "$X = require('react-markdown');\n...\n"
            },
            {
              "pattern-inside": "import 'react-markdown/with-html';\n...\n"
            },
            {
              "pattern-inside": "import 'react-markdown';\n...\n"
            }
          ]
        },
        {
          "pattern-either": [
            {
              "pattern": "<$EL allowDangerousHtml />\n"
            },
            {
              "pattern": "<$EL escapeHtml={false} />\n"
            },
            {
              "pattern": "<$EL transformLinkUri=... />\n"
            },
            {
              "pattern": "<$EL transformImageUri=... />\n"
            }
          ]
        }
      ]
    },
    {
      "id": "typescript.react.security.audit.react-dangerouslysetinnerhtml.react-dangerouslysetinnerhtml",
      "message": "The dangerouslySetInnerHTML prop in React bypasses the framework's built-in XSS protections and renders HTML directly in the DOM. When user input flows into this prop, attackers can inject malicious scripts that execute in the context of your website. Always sanitize content with a library like DOMPurify before using this prop or avoid it entirely with safer alternatives.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://react.dev/reference/react-dom/components/common#dangerously-setting-the-inner-html"
        ],
        "category": "security",
        "confidence": "MEDIUM",
        "technology": [
          "react"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "dangerouslySetInnerHTML with user data leads to XSS",
        "fix-suggestion": "Replace `dangerouslySetInnerHTML` with safer alternatives like React components or text content. If HTML rendering is necessary, sanitize input with `DOMPurify.sanitize()` before passing to React. Consider implementing server-side rendering for complex HTML to avoid client-side security issues."
      },
      "languages": [
        "typescript",
        "javascript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ...({..., $X, ...}) { ... }\n"
                },
                {
                  "pattern-inside": "function ...(..., $X, ...) { ... }\n"
                }
              ]
            },
            {
              "focus-metavariable": "$X"
            },
            {
              "pattern-not-inside": "$F. ... .$SANITIZEUNC(...)\n"
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "focus-metavariable": "$X"
            },
            {
              "pattern-either": [
                {
                  "pattern": "{...,dangerouslySetInnerHTML: {__html: $X},...}\n"
                },
                {
                  "pattern": "<$Y ... dangerouslySetInnerHTML={{__html: $X}} />\n"
                }
              ]
            },
            {
              "pattern-not": "<$Y ... dangerouslySetInnerHTML={{__html: \"...\"}} />\n"
            },
            {
              "pattern-not": "{...,dangerouslySetInnerHTML:{__html: \"...\"},...}\n"
            },
            {
              "metavariable-pattern": {
                "patterns": [
                  {
                    "pattern-not": "{...}\n"
                  }
                ],
                "metavariable": "$X"
              }
            },
            {
              "pattern-not": "<... {__html: \"...\"} ...>\n"
            },
            {
              "pattern-not": "<... {__html: `...`} ...>\n"
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "import $S from \"underscore.string\"\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from \"underscore.string\"\n...\n"
                },
                {
                  "pattern-inside": "import $S from \"underscore.string\"\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"underscore.string\")\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$S.escapeHTML(...)"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "import $S from \"dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "import { ..., $S,... } from \"dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from \"dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"dompurify\")\n...\n"
                },
                {
                  "pattern-inside": "import $S from \"isomorphic-dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from \"isomorphic-dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"isomorphic-dompurify\")\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-inside": "$VALUE = $S(...)\n...\n"
                    },
                    {
                      "pattern": "$VALUE.sanitize(...)"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$VALUE = $S.sanitize\n...\n"
                    },
                    {
                      "pattern": "$S(...)"
                    }
                  ]
                },
                {
                  "pattern": "$S.sanitize(...)"
                },
                {
                  "pattern": "$S(...)"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "import $S from 'xss';\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from 'xss';\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"xss\")\n...\n"
                }
              ]
            },
            {
              "pattern": "$S(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "import $S from 'sanitize-html';\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from \"sanitize-html\";\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"sanitize-html\")\n...\n"
                }
              ]
            },
            {
              "pattern": "$S(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$S = new Remarkable()\n...\n"
                }
              ]
            },
            {
              "pattern": "$S.render(...)"
            }
          ]
        }
      ]
    },
    {
      "id": "typescript.react.security.audit.react-jwt-decoded-property.react-jwt-decoded-property",
      "message": "JWT token properties are being accessed without verifying the token's integrity first. Unverified JWT tokens should never be trusted as their contents could be manipulated or forged by attackers. Using data from an unverified token can lead to authentication bypasses and other security vulnerabilities.",
      "metadata": {
        "cwe": [
          "CWE-922: Insecure Storage of Sensitive Information"
        ],
        "references": [
          "https://pragmaticwebsecurity.com/articles/oauthoidc/localstorage-xss.html"
        ],
        "category": "security",
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "technology": [
          "react"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "JWT token used without verification in React",
        "fix-suggestion": "Verify JWT tokens before accessing their properties using `jwt.verify()` instead of just `jwt.decode()`. Implement proper error handling for token validation failures. Store verification status in your application state and only use token data after confirming its authenticity."
      },
      "languages": [
        "typescript",
        "javascript"
      ],
      "severity": "INFO",
      "patterns": [
        {
          "pattern-inside": "import jwt_decode from \"jwt-decode\";\n...\n"
        },
        {
          "pattern-inside": "$DECODED = jwt_decode($TOKEN,...);\n...\n"
        },
        {
          "pattern": "$DECODED.$PROPERTY"
        }
      ]
    },
    {
      "id": "typescript.react.security.audit.react-jwt-in-localstorage.react-jwt-in-localstorage",
      "message": "JWT tokens are being stored in localStorage, making them vulnerable to cross-site scripting (XSS) attacks. Unlike HTTP-only cookies, localStorage is accessible to any JavaScript running on the page, including malicious scripts. If an attacker can execute JavaScript in your application, they can steal tokens from localStorage.",
      "metadata": {
        "cwe": [
          "CWE-922: Insecure Storage of Sensitive Information"
        ],
        "references": [
          "https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies"
        ],
        "category": "security",
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "technology": [
          "react"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "JWT tokens stored in vulnerable localStorage",
        "fix-suggestion": "Store JWT tokens in HTTP-only cookies instead of `localStorage`. Set the `secure` and `SameSite=strict` flags on your cookies for additional protection. If cookies are not feasible, consider using more secure browser storage APIs like `IndexedDB` with additional security controls."
      },
      "languages": [
        "typescript",
        "javascript"
      ],
      "severity": "INFO",
      "patterns": [
        {
          "pattern-inside": "import jwt_decode from \"jwt-decode\";\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "$DECODED = jwt_decode($TOKEN,...);\n...\nlocalStorage.setItem($NAME, <... $TOKEN ...>);\n"
            },
            {
              "pattern": "$DECODED = jwt_decode(...);\n...\nlocalStorage.setItem($NAME, <... $DECODED ...>);\n"
            }
          ]
        }
      ]
    },
    {
      "id": "typescript.react.security.audit.react-unsanitized-method.react-unsanitized-method",
      "message": "Using DOM manipulation methods in React that insert HTML directly (like innerHTML or insertAdjacentHTML) circumvents React's built-in protections. These methods allow attackers to inject malicious scripts when the content contains unsanitized user input. Always sanitize dynamic HTML with a library like DOMPurify before inserting it into the DOM.",
      "metadata": {
        "cwe": [
          "CWE-79: Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')"
        ],
        "owasp": [
          "A07:2017 - Cross-Site Scripting (XSS)",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://developer.mozilla.org/en-US/docs/Web/API/Document/writeln",
          "https://developer.mozilla.org/en-US/docs/Web/API/Document/write",
          "https://developer.mozilla.org/en-US/docs/Web/API/Element/insertAdjacentHTML"
        ],
        "category": "security",
        "confidence": "MEDIUM",
        "technology": [
          "react"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Cross-Site-Scripting (XSS)"
        ],
        "short-description": "Inserting HTML in React without sanitizing fosters XSS",
        "fix-suggestion": "Replace DOM methods like `innerHTML`, `outerHTML`, or `insertAdjacentHTML` with React's virtual DOM rendering. Sanitize any dynamic HTML content with `DOMPurify.sanitize()` before insertion. Use React's component system to safely structure content rather than direct DOM manipulation."
      },
      "languages": [
        "typescript",
        "javascript"
      ],
      "severity": "WARNING",
      "mode": "taint",
      "pattern-sources": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "function ...({..., $X, ...}) { ... }\n"
                },
                {
                  "pattern-inside": "function ...(..., $X, ...) { ... }\n"
                }
              ]
            },
            {
              "focus-metavariable": "$X"
            },
            {
              "pattern-either": [
                {
                  "pattern": "$X.$Y"
                },
                {
                  "pattern": "$X[...]"
                }
              ]
            }
          ]
        }
      ],
      "pattern-sinks": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "this.window.document. ... .$HTML('...',$SINK) \n"
                },
                {
                  "pattern": "window.document. ... .$HTML('...',$SINK) \n"
                },
                {
                  "pattern": "document.$HTML($SINK)  \n"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$HTML",
                "regex": "(writeln|write)"
              }
            },
            {
              "focus-metavariable": "$SINK"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern": "$PROP. ... .$HTML('...',$SINK) \n"
                }
              ]
            },
            {
              "metavariable-regex": {
                "metavariable": "$HTML",
                "regex": "(insertAdjacentHTML)"
              }
            },
            {
              "focus-metavariable": "$SINK"
            }
          ]
        }
      ],
      "pattern-sanitizers": [
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "import $S from \"underscore.string\"\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from \"underscore.string\"\n...\n"
                },
                {
                  "pattern-inside": "import $S from \"underscore.string\"\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"underscore.string\")\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "pattern": "$S.escapeHTML(...)"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "import $S from \"dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "import { ..., $S,... } from \"dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from \"dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"dompurify\")\n...\n"
                },
                {
                  "pattern-inside": "import $S from \"isomorphic-dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from \"isomorphic-dompurify\"\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"isomorphic-dompurify\")\n...\n"
                }
              ]
            },
            {
              "pattern-either": [
                {
                  "patterns": [
                    {
                      "pattern-inside": "$VALUE = $S(...)\n...\n"
                    },
                    {
                      "pattern": "$VALUE.sanitize(...)"
                    }
                  ]
                },
                {
                  "patterns": [
                    {
                      "pattern-inside": "$VALUE = $S.sanitize\n...\n"
                    },
                    {
                      "pattern": "$S(...)"
                    }
                  ]
                },
                {
                  "pattern": "$S.sanitize(...)"
                },
                {
                  "pattern": "$S(...)"
                }
              ]
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "import $S from 'xss';\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from 'xss';\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"xss\")\n...\n"
                }
              ]
            },
            {
              "pattern": "$S(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "import $S from 'sanitize-html';\n...\n"
                },
                {
                  "pattern-inside": "import * as $S from \"sanitize-html\";\n...\n"
                },
                {
                  "pattern-inside": "$S = require(\"sanitize-html\")\n...\n"
                }
              ]
            },
            {
              "pattern": "$S(...)"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-either": [
                {
                  "pattern-inside": "$S = new Remarkable()\n...\n"
                }
              ]
            },
            {
              "pattern": "$S.render(...)"
            }
          ]
        }
      ]
    },
    {
      "id": "yaml.argo.security.argo-workflow-parameter-command-injection.argo-workflow-parameter-command-injection",
      "message": "Argo workflow uses input or workflow parameters directly in shell scripts, creating a command injection vulnerability. Attackers can craft malicious input containing shell commands that will be executed by the workflow. This could lead to unauthorized access, data exfiltration, or complete system compromise.",
      "languages": [
        "yaml"
      ],
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')",
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "owasp": [
          "A03:2021 \u2013 Injection"
        ],
        "confidence": "MEDIUM",
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "subcategory": [
          "vuln"
        ],
        "references": [
          "https://github.com/argoproj/argo-workflows/issues/5061",
          "https://github.com/argoproj/argo-workflows/issues/5114#issue-808865370"
        ],
        "technology": [
          "ci",
          "argo"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection",
          "Command Injection"
        ],
        "short-description": "Command injection in Argo workflow parameters",
        "fix-suggestion": "Convert parameters to environment variables instead of embedding them directly in shell scripts. Use the `env` field in your workflow template to pass parameters safely. Implement input validation and sanitization for all workflow parameters, especially those that might be user-controlled."
      },
      "severity": "ERROR",
      "patterns": [
        {
          "pattern-inside": "apiVersion: $VERSION\n...\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$VERSION",
            "regex": "(argoproj.io.*)"
          }
        },
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-inside": "command:\n  ...\n  - python\n  ...\n...\nsource: \n  $SCRIPT\n"
                },
                {
                  "focus-metavariable": "$SCRIPT"
                },
                {
                  "metavariable-pattern": {
                    "metavariable": "$SCRIPT",
                    "language": "python",
                    "patterns": [
                      {
                        "pattern": "$FUNC(..., $PARAM, ...)\n"
                      },
                      {
                        "metavariable-pattern": {
                          "metavariable": "$PARAM",
                          "pattern-either": [
                            {
                              "pattern-regex": "(.*{{.*inputs.parameters.*}}.*)"
                            },
                            {
                              "pattern-regex": "(.*{{.*workflow.parameters.*}}.*)"
                            }
                          ]
                        }
                      }
                    ]
                  }
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-inside": "command:\n  ...\n  - $LANG\n  ...\n...\nsource: \n  $SCRIPT\n"
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$LANG",
                    "regex": "(bash|sh)"
                  }
                },
                {
                  "focus-metavariable": "$SCRIPT"
                },
                {
                  "metavariable-pattern": {
                    "metavariable": "$SCRIPT",
                    "language": "bash",
                    "patterns": [
                      {
                        "pattern": "$CMD ... $PARAM  ...\n"
                      },
                      {
                        "metavariable-pattern": {
                          "metavariable": "$PARAM",
                          "pattern-either": [
                            {
                              "pattern-regex": "(.*{{.*inputs.parameters.*}}.*)"
                            },
                            {
                              "pattern-regex": "(.*{{.*workflow.parameters.*}}.*)"
                            }
                          ]
                        }
                      }
                    ]
                  }
                }
              ]
            },
            {
              "patterns": [
                {
                  "pattern-inside": "container:\n  ...\n  command: $LANG\n  ...\n  args: $PARAM\n"
                },
                {
                  "metavariable-regex": {
                    "metavariable": "$LANG",
                    "regex": ".*(sh|bash|ksh|csh|tcsh|zsh).*"
                  }
                },
                {
                  "metavariable-pattern": {
                    "metavariable": "$PARAM",
                    "pattern-either": [
                      {
                        "pattern-regex": "(.*{{.*inputs.parameters.*}}.*)"
                      },
                      {
                        "pattern-regex": "(.*{{.*workflow.parameters.*}}.*)"
                      }
                    ]
                  }
                },
                {
                  "focus-metavariable": "$PARAM"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "yaml.docker-compose.security.exposing-docker-socket-volume.exposing-docker-socket-volume",
      "patterns": [
        {
          "pattern-inside": "version: ...\n...\n"
        },
        {
          "pattern-either": [
            {
              "pattern": "volumes:\n  - ...\n  - /var/run/docker.sock:/var/run/docker.sock\n  - ...\n"
            },
            {
              "pattern": "volumes:\n  - ...\n  - /run/docker.sock:/run/docker.sock\n  - ...\n"
            },
            {
              "pattern": "volumes:\n  - ...\n  - /var/run/docker.sock:/run/docker.sock\n  - ...\n"
            },
            {
              "pattern": "volumes:\n  - ...\n  - /run/docker.sock:/var/run/docker.sock\n  - ...\n"
            },
            {
              "pattern": "volumes:\n  - ...\n  - /var/run/docker.sock\n  - ...\n"
            },
            {
              "pattern": "volumes:\n  - ...\n  - /run/docker.sock\n  - ...\n"
            },
            {
              "pattern": "volumes:\n  - ...\n  - ...\n    source: /var/run/docker.sock\n    ...\n  - ...\n"
            },
            {
              "pattern": "volumes:\n  - ...\n  - ...\n    source: /run/docker.sock\n    ...\n  - ...\n"
            }
          ]
        }
      ],
      "message": "Docker socket is exposed to containers through a volume mount, granting containers root-equivalent access to the host. The Docker socket allows complete control over the Docker daemon, including the ability to create privileged containers. This effectively bypasses all container isolation, giving containers full access to the host system.",
      "metadata": {
        "references": [
          "https://docs.docker.com/compose/compose-file/compose-file-v3/#volume-configuration-reference",
          "https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html#rule-1-do-not-expose-the-docker-daemon-socket-even-to-the-containers"
        ],
        "category": "security",
        "technology": [
          "docker-compose"
        ],
        "cwe": [
          "CWE-250: Execution with Unnecessary Privileges"
        ],
        "owasp": [
          "A06:2017 - Security Misconfiguration",
          "A05:2021 - Security Misconfiguration"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Docker socket exposed to containers via volume",
        "fix-suggestion": "Remove the `/var/run/docker.sock` volume mount from your Docker Compose file. Use dedicated tools like Docker-in-Docker if container orchestration is needed. Consider more secure alternatives like using Docker API proxies with limited permissions if container management is required."
      },
      "languages": [
        "yaml"
      ],
      "severity": "WARNING"
    },
    {
      "id": "yaml.docker-compose.security.no-new-privileges.no-new-privileges",
      "patterns": [
        {
          "pattern-inside": "version: ...\n...\nservices:\n  ...\n"
        },
        {
          "pattern": "$SERVICE:\n  ...\n  image: ...\n"
        },
        {
          "pattern-not": "$SERVICE:\n  ...\n  image: ...\n  ...\n  security_opt:\n    - ...\n    - no-new-privileges:true\n    - ...\n"
        },
        {
          "focus-metavariable": "$SERVICE"
        }
      ],
      "message": "Docker service allows privilege escalation through setuid or setgid binaries within the container. Setuid binaries can elevate privileges even within containers, potentially leading to container escapes. Without the no-new-privileges flag, attackers who compromise a container may gain higher privileges than intended.",
      "metadata": {
        "cwe": [
          "CWE-732: Incorrect Permission Assignment for Critical Resource"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration",
          "A06:2017 - Security Misconfiguration"
        ],
        "references": [
          "https://raesene.github.io/blog/2019/06/01/docker-capabilities-and-no-new-privs/",
          "https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt",
          "https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html#rule-4-add-no-new-privileges-flag"
        ],
        "category": "security",
        "technology": [
          "docker-compose"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Docker service allows privilege escalation",
        "fix-suggestion": "Add `security_opt: [\"no-new-privileges:true\"]` to your service configuration in the Docker Compose file. This prevents processes from gaining additional privileges through setuid binaries. Consider also adding other security measures like read-only filesystems and dropping capabilities."
      },
      "languages": [
        "yaml"
      ],
      "severity": "WARNING"
    },
    {
      "id": "yaml.docker-compose.security.privileged-service.privileged-service",
      "patterns": [
        {
          "pattern-inside": "version: ...\n...\nservices:\n  ...\n  $SERVICE:\n    ...\n    privileged: $TRUE\n"
        },
        {
          "focus-metavariable": "$TRUE"
        },
        {
          "metavariable-regex": {
            "metavariable": "$TRUE",
            "regex": "(true)"
          }
        }
      ],
      "fix": "false\n",
      "message": "Docker service is running in privileged mode, giving it full access to host devices and capabilities. Privileged containers effectively have the same level of access as processes running on the host itself. This completely bypasses container security boundaries and can lead to host system compromise if the container is breached.",
      "metadata": {
        "cwe": [
          "CWE-250: Execution with Unnecessary Privileges"
        ],
        "owasp": [
          "A06:2017 - Security Misconfiguration",
          "A05:2021 - Security Misconfiguration"
        ],
        "references": [
          "https://www.trendmicro.com/en_us/research/19/l/why-running-a-privileged-container-in-docker-is-a-bad-idea.html",
          "https://containerjournal.com/topics/container-security/why-running-a-privileged-container-is-not-a-good-idea/"
        ],
        "category": "security",
        "technology": [
          "docker-compose"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "HIGH",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Docker service running with privileged mode",
        "fix-suggestion": "Remove the `privileged: true` directive from your Docker Compose service definition. Instead, grant only the specific capabilities required using `cap_add` for minimal necessary permissions. Use volume mounts and device mounts with specific paths rather than privileged mode for accessing host resources."
      },
      "languages": [
        "yaml"
      ],
      "severity": "WARNING"
    },
    {
      "id": "yaml.docker-compose.security.seccomp-confinement-disabled.seccomp-confinement-disabled",
      "patterns": [
        {
          "pattern-inside": "version: ...\n...\nservices:\n  ...\n"
        },
        {
          "pattern": "$SERVICE:\n  ...\n  image: ...\n  ...\n  security_opt:\n    - ...\n    - seccomp:unconfined\n"
        }
      ],
      "message": "Docker service has seccomp confinement explicitly disabled, allowing containers to make any system call. Seccomp profiles limit which system calls a container can make, providing an important security boundary. Disabling this protection exposes the host to potential container escapes through kernel vulnerabilities.",
      "metadata": {
        "cwe": [
          "CWE-284: Improper Access Control"
        ],
        "references": [
          "https://docs.docker.com/engine/security/seccomp/"
        ],
        "category": "security",
        "technology": [
          "docker-compose"
        ],
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Docker seccomp confinement disabled",
        "fix-suggestion": "Remove `seccomp:unconfined` from the `security_opt` settings in your Docker Compose file. Use the default Docker seccomp profile which provides a good balance of security and functionality. If specific system calls are needed, create a custom seccomp profile that allows only the necessary calls rather than disabling protection entirely."
      },
      "languages": [
        "yaml"
      ],
      "severity": "WARNING"
    },
    {
      "id": "yaml.docker-compose.security.selinux-separation-disabled.selinux-separation-disabled",
      "patterns": [
        {
          "pattern-inside": "version: ...\n...\nservices:\n  ...\n"
        },
        {
          "pattern": "$SERVICE:\n  ...\n  image: ...\n  ...\n  security_opt:\n    - ...\n    - label:disable\n"
        }
      ],
      "message": "Docker service has SELinux separation explicitly disabled, weakening container isolation. SELinux adds an additional layer of mandatory access control to prevent containers from affecting each other or the host. By disabling this protection, containers become more vulnerable to privilege escalation and escape attempts.",
      "metadata": {
        "cwe": [
          "CWE-284: Improper Access Control"
        ],
        "references": [
          "https://www.projectatomic.io/blog/2016/03/dwalsh_selinux_containers/",
          "https://docs.docker.com/engine/reference/run/#security-configuration"
        ],
        "category": "security",
        "technology": [
          "docker-compose"
        ],
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Docker SELinux separation disabled",
        "fix-suggestion": "Remove `label:disable` from the `security_opt` settings in your Docker Compose file. Use SELinux's default container confinement for improved security isolation. If SELinux policies are causing issues, diagnose and address the specific problems rather than disabling protection entirely."
      },
      "languages": [
        "yaml"
      ],
      "severity": "WARNING"
    },
    {
      "id": "yaml.docker-compose.security.writable-filesystem-service.writable-filesystem-service",
      "patterns": [
        {
          "pattern-inside": "version: ...\n...\nservices:\n  ...\n"
        },
        {
          "pattern": "$SERVICE:\n  ...\n  image: ...\n  ...\n"
        },
        {
          "pattern-not": "$SERVICE:\n  ...\n  image: ...\n  ...\n  read_only: true\n"
        },
        {
          "focus-metavariable": "$SERVICE"
        }
      ],
      "message": "Docker service is running with a writable root filesystem, which creates unnecessary security risks. Writable filesystems allow attackers to modify files and download additional payloads if they gain access to the container. Using read-only filesystems is a key defense-in-depth measure for container security.",
      "metadata": {
        "cwe": [
          "CWE-732: Incorrect Permission Assignment for Critical Resource"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration",
          "A06:2017 - Security Misconfiguration"
        ],
        "references": [
          "https://docs.docker.com/compose/compose-file/compose-file-v3/#domainname-hostname-ipc-mac_address-privileged-read_only-shm_size-stdin_open-tty-user-working_dir",
          "https://blog.atomist.com/security-of-docker-kubernetes/",
          "https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html#rule-8-set-filesystem-and-volumes-to-read-only"
        ],
        "category": "security",
        "technology": [
          "docker-compose"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Docker container with writable root filesystem",
        "fix-suggestion": "Add `read_only: true` to your service definition in the Docker Compose file. For directories that must be writable, use specific volume mounts or `tmpfs` volumes for temporary files. Use docker volumes for persistent data storage instead of writing to the container filesystem."
      },
      "languages": [
        "yaml"
      ],
      "severity": "WARNING"
    },
    {
      "id": "yaml.github-actions.security.allowed-unsecure-commands.allowed-unsecure-commands",
      "languages": [
        "yaml"
      ],
      "severity": "WARNING",
      "message": "GitHub Actions workflow enables unsecure commands by setting ACTIONS_ALLOW_UNSECURE_COMMANDS. The deprecated set-env and add-path commands contain vulnerabilities that can allow attackers to execute arbitrary code. These commands were deprecated because they can be exploited through specially crafted input data.",
      "metadata": {
        "cwe": [
          "CWE-749: Exposed Dangerous Method or Function"
        ],
        "owasp": "A06:2017 - Security Misconfiguration",
        "references": [
          "https://github.blog/changelog/2020-10-01-github-actions-deprecating-set-env-and-add-path-commands/",
          "https://github.com/actions/toolkit/security/advisories/GHSA-mfwh-5m23-j46w",
          "https://github.com/actions/toolkit/blob/main/docs/commands.md#environment-files"
        ],
        "category": "security",
        "technology": [
          "github-actions"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Dangerous Method or Function"
        ],
        "short-description": "GitHub Actions enabling vulnerable commands",
        "fix-suggestion": "Remove the `ACTIONS_ALLOW_UNSECURE_COMMANDS` environment variable from your workflow. Use Environment Files with `echo \"name=value\" >> $GITHUB_ENV` instead of deprecated `set-env` commands. Use `echo \"path\" >> $GITHUB_PATH` instead of deprecated `add-path` commands."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "patterns": [
                {
                  "pattern-inside": "{env: ...}"
                },
                {
                  "pattern": "ACTIONS_ALLOW_UNSECURE_COMMANDS: true"
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "yaml.github-actions.security.curl-eval.curl-eval",
      "languages": [
        "yaml"
      ],
      "message": "Evaluating the output of curl commands with eval or similar constructs allows executing arbitrary code contained in the response. Attackers who control the remote server or can intercept the connection can inject malicious commands that execute with the workflow's permissions. Avoid using eval on downloaded content, or verify its integrity with cryptographic signatures before execution.",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.github.com/en/actions/learn-github-actions/security-hardening-for-github-actions#understanding-the-risk-of-script-injections"
        ],
        "technology": [
          "github-actions",
          "bash",
          "curl"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "Evaluating curl output can cause malicious code injection",
        "fix-suggestion": "Replace `eval $(curl ...)` patterns with direct script execution after downloading to a file. Implement checksum verification with `sha256sum` before executing downloaded content. Consider packaging required scripts with your repository instead of downloading during workflow execution."
      },
      "patterns": [
        {
          "pattern-inside": "steps: [...]"
        },
        {
          "pattern-inside": "- run: ...\n  ...\n"
        },
        {
          "pattern": "run: $SHELL"
        },
        {
          "metavariable-pattern": {
            "language": "bash",
            "metavariable": "$SHELL",
            "patterns": [
              {
                "pattern": "$DATA=<... curl ...>\n...\neval <... $DATA ...>\n"
              }
            ]
          }
        }
      ],
      "severity": "ERROR"
    },
    {
      "id": "yaml.github-actions.security.github-script-injection.github-script-injection",
      "languages": [
        "yaml"
      ],
      "message": "Directly interpolating github context data (like user input from issues or PRs) into JavaScript code in github-script actions enables attackers to break out of string contexts and inject malicious code. This code runs with the workflow's permissions, potentially allowing repository compromise. Store the data in environment variables and reference them properly within the script to maintain proper code/data separation.",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-94: Improper Control of Generation of Code ('Code Injection')"
        ],
        "owasp": [
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.github.com/en/actions/learn-github-actions/security-hardening-for-github-actions#understanding-the-risk-of-script-injections",
          "https://securitylab.github.com/research/github-actions-untrusted-input/",
          "https://github.com/actions/github-script"
        ],
        "technology": [
          "github-actions"
        ],
        "cwe2022-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "HIGH",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "GitHub Actions script interpolation can inject arbitrary code",
        "fix-suggestion": "Store dynamic data in environment variables using the `env:` section instead of directly interpolating into scripts. Reference context values with proper quoting like `\"${{ github.event.issue.title }}\"` in commands. Use the GitHub Script action's JavaScript context for complex operations instead of shell interpolation."
      },
      "patterns": [
        {
          "pattern-inside": "steps: [...]"
        },
        {
          "pattern-inside": "uses: $ACTION\n...\n"
        },
        {
          "pattern-inside": "with:\n  ...\n  script: ...\n  ...\n"
        },
        {
          "pattern": "script: $SHELL"
        },
        {
          "metavariable-regex": {
            "metavariable": "$ACTION",
            "regex": "actions/github-script@.*"
          }
        },
        {
          "metavariable-pattern": {
            "language": "generic",
            "metavariable": "$SHELL",
            "patterns": [
              {
                "pattern-either": [
                  {
                    "pattern": "${{ github.event.issue.title }}"
                  },
                  {
                    "pattern": "${{ github.event.issue.body }}"
                  },
                  {
                    "pattern": "${{ github.event.pull_request.title }}"
                  },
                  {
                    "pattern": "${{ github.event.pull_request.body }}"
                  },
                  {
                    "pattern": "${{ github.event.comment.body }}"
                  },
                  {
                    "pattern": "${{ github.event.review.body }}"
                  },
                  {
                    "pattern": "${{ github.event.review_comment.body }}"
                  },
                  {
                    "pattern": "${{ github.event.pages. ... .page_name}}"
                  },
                  {
                    "pattern": "${{ github.event.head_commit.message }}"
                  },
                  {
                    "pattern": "${{ github.event.head_commit.author.email }}"
                  },
                  {
                    "pattern": "${{ github.event.head_commit.author.name }}"
                  },
                  {
                    "pattern": "${{ github.event.commits ... .author.email }}"
                  },
                  {
                    "pattern": "${{ github.event.commits ... .author.name }}"
                  },
                  {
                    "pattern": "${{ github.event.pull_request.head.ref }}"
                  },
                  {
                    "pattern": "${{ github.event.pull_request.head.label }}"
                  },
                  {
                    "pattern": "${{ github.event.pull_request.head.repo.default_branch }}"
                  },
                  {
                    "pattern": "${{ github.head_ref }}"
                  },
                  {
                    "pattern": "${{ github.event.inputs ... }}"
                  },
                  {
                    "pattern": "${{ github.event.discussion.title }}"
                  },
                  {
                    "pattern": "${{ github.event.discussion.body }}"
                  }
                ]
              }
            ]
          }
        }
      ],
      "severity": "ERROR"
    },
    {
      "id": "yaml.github-actions.security.pull-request-target-code-checkout.pull-request-target-code-checkout",
      "languages": [
        "yaml"
      ],
      "message": "GitHub Actions workflow uses pull_request_target trigger while checking out code from the incoming PR, creating a security vulnerability. The pull_request_target event runs with repository secrets accessible, but executes code from untrusted pull requests. This combination allows attackers to steal secrets by submitting malicious code in a PR.",
      "metadata": {
        "category": "security",
        "owasp": [
          "A01:2021 - Broken Access Control"
        ],
        "cwe": [
          "CWE-913: Improper Control of Dynamically-Managed Code Resources"
        ],
        "references": [
          "https://securitylab.github.com/research/github-actions-preventing-pwn-requests/",
          "https://github.com/justinsteven/advisories/blob/master/2021_github_actions_checkspelling_token_leak_via_advice_symlink.md"
        ],
        "technology": [
          "github-actions"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "GitHub Actions workflow exposes secrets to PR code",
        "fix-suggestion": "Use `pull_request` instead of `pull_request_target` when checking out code from incoming PRs. If you need `pull_request_target`, only check out the target branch code with `ref: ${{ github.event.repository.default_branch }}`. Create separate jobs with explicit permission boundaries to isolate potentially untrusted code execution."
      },
      "patterns": [
        {
          "pattern-either": [
            {
              "pattern-inside": "on:\n  ...\n  pull_request_target: ...\n  ...\n...\n"
            },
            {
              "pattern-inside": "on: [..., pull_request_target, ...]\n...\n"
            },
            {
              "pattern-inside": "on: pull_request_target\n...\n"
            }
          ]
        },
        {
          "pattern-inside": "jobs:\n  ...\n  $JOBNAME:\n    ...\n    steps:\n      ...\n"
        },
        {
          "pattern": "...\nuses: \"$ACTION\"\nwith:\n  ...\n  ref: $EXPR\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$ACTION",
            "regex": "actions/checkout@.*"
          }
        },
        {
          "metavariable-pattern": {
            "language": "generic",
            "metavariable": "$EXPR",
            "patterns": [
              {
                "pattern": "${{ github.event.pull_request ... }}"
              }
            ]
          }
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "yaml.github-actions.security.run-shell-injection.run-shell-injection",
      "languages": [
        "yaml"
      ],
      "message": "Directly interpolating github context data into shell commands in workflow run steps allows attackers to inject additional commands through special shell characters. These injected commands execute with the workflow's permissions, potentially allowing repository compromise. Use environment variables with proper quoting to safely pass dynamic data to shell commands.",
      "metadata": {
        "category": "security",
        "cwe": [
          "CWE-78: Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')"
        ],
        "owasp": [
          "A01:2017 - Injection",
          "A03:2021 - Injection"
        ],
        "references": [
          "https://docs.github.com/en/actions/learn-github-actions/security-hardening-for-github-actions#understanding-the-risk-of-script-injections",
          "https://securitylab.github.com/research/github-actions-untrusted-input/"
        ],
        "technology": [
          "github-actions"
        ],
        "cwe2022-top25": true,
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "HIGH",
        "impact": "HIGH",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Command Injection"
        ],
        "short-description": "run step with unescaped interpolation may allow shell injection",
        "fix-suggestion": "Store dynamic values in environment variables using the `env:` section rather than directly interpolating them into commands. Use proper shell quoting like `\"$INPUT_VALUE\"` when referencing variables in commands. For complex data, write to temporary files and process with tools designed for structured data rather than shell commands."
      },
      "patterns": [
        {
          "pattern-inside": "steps: [...]"
        },
        {
          "pattern-inside": "- run: ...\n  ...\n"
        },
        {
          "pattern": "run: $SHELL"
        },
        {
          "metavariable-pattern": {
            "language": "generic",
            "metavariable": "$SHELL",
            "patterns": [
              {
                "pattern-either": [
                  {
                    "pattern": "${{ github.event.issue.title }}"
                  },
                  {
                    "pattern": "${{ github.event.issue.body }}"
                  },
                  {
                    "pattern": "${{ github.event.pull_request.title }}"
                  },
                  {
                    "pattern": "${{ github.event.pull_request.body }}"
                  },
                  {
                    "pattern": "${{ github.event.comment.body }}"
                  },
                  {
                    "pattern": "${{ github.event.review.body }}"
                  },
                  {
                    "pattern": "${{ github.event.review_comment.body }}"
                  },
                  {
                    "pattern": "${{ github.event.pages. ... .page_name}}"
                  },
                  {
                    "pattern": "${{ github.event.head_commit.message }}"
                  },
                  {
                    "pattern": "${{ github.event.head_commit.author.email }}"
                  },
                  {
                    "pattern": "${{ github.event.head_commit.author.name }}"
                  },
                  {
                    "pattern": "${{ github.event.commits ... .author.email }}"
                  },
                  {
                    "pattern": "${{ github.event.commits ... .author.name }}"
                  },
                  {
                    "pattern": "${{ github.event.pull_request.head.ref }}"
                  },
                  {
                    "pattern": "${{ github.event.pull_request.head.label }}"
                  },
                  {
                    "pattern": "${{ github.event.pull_request.head.repo.default_branch }}"
                  },
                  {
                    "pattern": "${{ github.head_ref }}"
                  },
                  {
                    "pattern": "${{ github.event.inputs ... }}"
                  },
                  {
                    "pattern": "${{ github.event.discussion.title }}"
                  },
                  {
                    "pattern": "${{ github.event.discussion.body }}"
                  },
                  {
                    "pattern": "${{ inputs ... }}"
                  },
                  {
                    "pattern": "${{ steps. ... .outputs ...}}"
                  }
                ]
              }
            ]
          }
        }
      ],
      "severity": "ERROR"
    },
    {
      "id": "yaml.github-actions.security.workflow-run-target-code-checkout.workflow-run-target-code-checkout",
      "languages": [
        "yaml"
      ],
      "message": "GitHub Actions workflow uses workflow_run trigger while checking out code from the incoming PR, creating a security vulnerability. The workflow_run event runs with repository secrets accessible, but can potentially run untrusted code from pull requests. This allows attackers to steal secrets through carefully crafted PRs.",
      "metadata": {
        "category": "security",
        "owasp": "A01:2017 - Injection",
        "cwe": "CWE-913: Improper Control of Dynamically-Managed Code Resources",
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "subcategory": [
          "vuln"
        ],
        "references": [
          "https://securitylab.github.com/research/github-actions-preventing-pwn-requests/",
          "https://github.com/justinsteven/advisories/blob/master/2021_github_actions_checkspelling_token_leak_via_advice_symlink.md",
          "https://www.legitsecurity.com/blog/github-privilege-escalation-vulnerability"
        ],
        "technology": [
          "github-actions"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Code Injection"
        ],
        "short-description": "GitHub Actions workflow_run exposes secrets to PR code",
        "fix-suggestion": "Avoid checking out code from incoming PRs in `workflow_run` triggered workflows. Only check out code from trusted branches with `ref: ${{ github.event.repository.default_branch }}`. Use artifact passing between workflows instead of directly using code from externally triggered workflows to maintain security boundaries."
      },
      "patterns": [
        {
          "pattern-inside": "on:\n  ...\n  workflow_run: ...\n  ...\n...\n"
        },
        {
          "pattern-inside": "jobs:\n  ...\n  $JOBNAME:\n    ...\n    steps:\n      ...\n"
        },
        {
          "pattern": "...\nuses: \"$ACTION\"\nwith:\n  ...\n  ref: $EXPR\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$ACTION",
            "regex": "actions/checkout@.*"
          }
        },
        {
          "metavariable-pattern": {
            "language": "generic",
            "metavariable": "$EXPR",
            "patterns": [
              {
                "pattern": "${{ github.event.workflow_run ... }}"
              }
            ]
          }
        }
      ],
      "severity": "WARNING"
    },
    {
      "id": "yaml.kubernetes.security.allow-privilege-escalation-no-securitycontext.allow-privilege-escalation-no-securitycontext",
      "patterns": [
        {
          "pattern-inside": "containers:\n  ...\n"
        },
        {
          "pattern-inside": "- $NAME: $CONTAINER\n  ...\n"
        },
        {
          "pattern": "image: ...\n...\n"
        },
        {
          "pattern-not": "image: ...\n...\nsecurityContext:\n  ...\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$NAME",
            "regex": "name"
          }
        },
        {
          "focus-metavariable": "$NAME"
        }
      ],
      "fix": "securityContext:\n  allowPrivilegeEscalation: false\n$NAME\n",
      "message": "Kubernetes pod lacks securityContext configuration, allowing privilege escalation through setuid binaries. Without explicitly preventing privilege escalation, containers may gain additional permissions beyond what was intended. This creates potential attack paths for container escape and privilege escalation.",
      "metadata": {
        "cwe": [
          "CWE-732: Incorrect Permission Assignment for Critical Resource"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration",
          "A06:2017 - Security Misconfiguration"
        ],
        "references": [
          "https://kubernetes.io/docs/concepts/policy/pod-security-policy/#privilege-escalation",
          "https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
          "https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt",
          "https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html#rule-4-add-no-new-privileges-flag"
        ],
        "category": "security",
        "technology": [
          "kubernetes"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Kubernetes pod missing privilege escalation protection",
        "fix-suggestion": "Add a `securityContext` section to your container definition with `allowPrivilegeEscalation: false`. Include additional security settings like `runAsNonRoot: true` and `readOnlyRootFilesystem: true`. Create a comprehensive Pod Security Policy (PSP) or use Kubernetes Pod Security Standards to enforce these settings across your cluster."
      },
      "languages": [
        "yaml"
      ],
      "severity": "WARNING"
    },
    {
      "id": "yaml.kubernetes.security.allow-privilege-escalation-true.allow-privilege-escalation-true",
      "patterns": [
        {
          "pattern-inside": "containers:\n  ...\n"
        },
        {
          "pattern-inside": "- name: $CONTAINER\n  ...\n"
        },
        {
          "pattern-inside": "image: ...\n...\n"
        },
        {
          "pattern-inside": "securityContext:\n  ...\n"
        },
        {
          "pattern": "allowPrivilegeEscalation: $TRUE\n"
        },
        {
          "metavariable-pattern": {
            "metavariable": "$TRUE",
            "pattern": "true\n"
          }
        },
        {
          "focus-metavariable": "$TRUE"
        }
      ],
      "fix": "false\n",
      "message": "Kubernetes container explicitly allows privilege escalation by setting allowPrivilegeEscalation to true. This permits the container to gain additional privileges through mechanisms like setuid binaries. Privileged containers pose a greater security risk as they can potentially escape their isolation and affect the host system.",
      "metadata": {
        "cwe": [
          "CWE-732: Incorrect Permission Assignment for Critical Resource"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration",
          "A06:2017 - Security Misconfiguration"
        ],
        "references": [
          "https://kubernetes.io/docs/concepts/policy/pod-security-policy/#privilege-escalation",
          "https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
          "https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt",
          "https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html#rule-4-add-no-new-privileges-flag"
        ],
        "category": "security",
        "technology": [
          "kubernetes"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Kubernetes container allows privilege escalation",
        "fix-suggestion": "Change `allowPrivilegeEscalation: true` to `allowPrivilegeEscalation: false` in the container's `securityContext`. Review why privilege escalation was enabled and find alternative solutions with least privilege. Consider implementing additional container security measures like dropping capabilities and using read-only filesystems."
      },
      "languages": [
        "yaml"
      ],
      "severity": "WARNING"
    },
    {
      "id": "yaml.kubernetes.security.allow-privilege-escalation.allow-privilege-escalation",
      "patterns": [
        {
          "pattern-inside": "containers:\n  ...\n"
        },
        {
          "pattern-inside": "- name: $CONTAINER\n  ...\n"
        },
        {
          "pattern": "image: ...\n...\n"
        },
        {
          "pattern-inside": "image: ...\n...\n$SC:\n  ...\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$SC",
            "regex": "^(securityContext)$"
          }
        },
        {
          "pattern-not-inside": "image: ...\n...\nsecurityContext:\n  ...\n  allowPrivilegeEscalation: $VAL\n"
        },
        {
          "focus-metavariable": "$SC"
        }
      ],
      "fix": "securityContext:\n  allowPrivilegeEscalation: false #\n",
      "message": "Kubernetes container's securityContext doesn't explicitly prevent privilege escalation. Without the allowPrivilegeEscalation: false setting, containers may be able to gain more privileges than initially granted. This omission creates an unnecessary security risk that could be exploited by attackers.",
      "metadata": {
        "cwe": [
          "CWE-732: Incorrect Permission Assignment for Critical Resource"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration",
          "A06:2017 - Security Misconfiguration"
        ],
        "references": [
          "https://kubernetes.io/docs/concepts/policy/pod-security-policy/#privilege-escalation",
          "https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
          "https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt",
          "https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html#rule-4-add-no-new-privileges-flag"
        ],
        "category": "security",
        "technology": [
          "kubernetes"
        ],
        "cwe2021-top25": true,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "SecurityContext missing privilege escalation prevention",
        "fix-suggestion": "Add `allowPrivilegeEscalation: false` to the container's `securityContext` configuration. Combine with other security settings like `runAsNonRoot: true` and appropriate capability restrictions. Implement Pod Security Standards to ensure consistent security posture across your Kubernetes workloads."
      },
      "languages": [
        "yaml"
      ],
      "severity": "WARNING"
    },
    {
      "id": "yaml.kubernetes.security.exposing-docker-socket-hostpath.exposing-docker-socket-hostpath",
      "patterns": [
        {
          "pattern-inside": "volumes:\n  ...\n"
        },
        {
          "pattern": "hostPath:\n  ...\n  path: /var/run/docker.sock\n"
        }
      ],
      "message": "Kubernetes pod mounts the Docker socket from the host, granting the pod full control over the Docker daemon. This effectively gives the pod root access to the host system, as it can create privileged containers. Mounting the Docker socket breaks the security isolation of Kubernetes.",
      "metadata": {
        "cwe": [
          "CWE-250: Execution with Unnecessary Privileges"
        ],
        "references": [
          "https://kubernetes.io/docs/concepts/storage/volumes/#hostpath",
          "https://kubernetes.io/docs/concepts/policy/pod-security-policy/#volumes-and-file-systems",
          "https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
          "https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html#rule-1-do-not-expose-the-docker-daemon-socket-even-to-the-containers"
        ],
        "category": "security",
        "technology": [
          "kubernetes"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "LOW",
        "impact": "HIGH",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Docker socket exposed to Kubernetes pod",
        "fix-suggestion": "Remove the hostPath volume mount that references `/var/run/docker.sock`. Consider using more secure alternatives like Kaniko or BuildKit for container building operations. If Docker socket access is absolutely necessary, use tightly scoped service accounts with minimal permissions and strict pod security contexts."
      },
      "languages": [
        "yaml"
      ],
      "severity": "WARNING"
    },
    {
      "id": "yaml.kubernetes.security.hostipc-pod.hostipc-pod",
      "patterns": [
        {
          "pattern-inside": "spec:\n  ...\n"
        },
        {
          "pattern": "hostIPC: true\n"
        }
      ],
      "message": "Kubernetes pod uses the host's IPC namespace, allowing container processes to communicate with host processes. This breaks isolation and allows pods to potentially access sensitive information through shared memory. Host IPC access also enables pod-to-host communication channels that bypass normal container boundaries.",
      "metadata": {
        "cwe": [
          "CWE-693: Protection Mechanism Failure"
        ],
        "references": [
          "https://kubernetes.io/docs/concepts/policy/pod-security-policy/#host-namespaces"
        ],
        "category": "security",
        "technology": [
          "kubernetes"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Kubernetes pod sharing host IPC namespace",
        "fix-suggestion": "Remove the `hostIPC: true` setting from your pod specification. Design your application to work without direct host IPC access using Kubernetes native communication mechanisms. If inter-process communication is needed, use service discovery, network communication, or Kubernetes-provided volumes rather than host IPC access."
      },
      "languages": [
        "yaml"
      ],
      "severity": "WARNING"
    },
    {
      "id": "yaml.kubernetes.security.hostnetwork-pod.hostnetwork-pod",
      "patterns": [
        {
          "pattern-inside": "spec:\n  ...\n"
        },
        {
          "pattern": "hostNetwork: true\n"
        }
      ],
      "message": "Kubernetes pod uses the host's network namespace, giving it access to localhost services and network interfaces. This allows pods to potentially snoop on network traffic from other pods on the same node. Host network access also bypasses network policies and other Kubernetes network security controls.",
      "metadata": {
        "cwe": [
          "CWE-406: Insufficient Control of Network Message Volume (Network Amplification)"
        ],
        "references": [
          "https://kubernetes.io/docs/concepts/policy/pod-security-policy/#host-namespaces"
        ],
        "category": "security",
        "technology": [
          "kubernetes"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Configuration"
        ],
        "short-description": "Kubernetes pod using host network namespace",
        "fix-suggestion": "Remove the `hostNetwork: true` setting from your pod specification. Use Kubernetes service abstractions and network policies to control pod communications. If specific host network capabilities are needed, consider using more targeted solutions like HostPort or NodePort services instead of full host network access."
      },
      "languages": [
        "yaml"
      ],
      "severity": "WARNING"
    },
    {
      "id": "yaml.kubernetes.security.hostpid-pod.hostpid-pod",
      "patterns": [
        {
          "pattern-inside": "spec:\n  ...\n"
        },
        {
          "pattern": "hostPID: true\n"
        }
      ],
      "message": "Kubernetes pod shares the host's process ID namespace, allowing containers to see and potentially interact with all processes on the node. When combined with debugging tools, this access could be used to escalate privileges outside the container. Host PID access breaks the process isolation that containers provide.",
      "metadata": {
        "cwe": [
          "CWE-269: Improper Privilege Management"
        ],
        "references": [
          "https://kubernetes.io/docs/concepts/policy/pod-security-policy/#host-namespaces"
        ],
        "category": "security",
        "technology": [
          "kubernetes"
        ],
        "owasp": [
          "A04:2021 - Insecure Design"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Kubernetes pod sharing host PID namespace",
        "fix-suggestion": "Remove the `hostPID: true` setting from your pod specification. Redesign your application to work within its own PID namespace using Kubernetes-native abstractions. If process monitoring is needed, consider using metrics collectors or log aggregation rather than direct host PID access."
      },
      "languages": [
        "yaml"
      ],
      "severity": "WARNING"
    },
    {
      "id": "yaml.kubernetes.security.legacy-api-clusterrole-excessive-permissions.legacy-api-clusterrole-excessive-permissions",
      "patterns": [
        {
          "pattern": "\"*\"\n"
        },
        {
          "pattern-inside": "resources: $A\n...\n"
        },
        {
          "pattern-inside": "verbs: $A\n...\n"
        },
        {
          "pattern-inside": "- apiGroups: [\"\"]\n  ...\n"
        },
        {
          "pattern-inside": "apiVersion: rbac.authorization.k8s.io/v1\n...\n"
        },
        {
          "pattern-inside": "kind: ClusterRole\n...\n"
        }
      ],
      "message": "Kubernetes ClusterRole for the core API group has excessive permissions, allowing for privilege escalation. Overly permissive roles in the core API group can grant access to sensitive resources across the entire cluster. Without proper restrictions, these roles could be used to gain administrative access to the Kubernetes environment.",
      "languages": [
        "yaml"
      ],
      "severity": "WARNING",
      "metadata": {
        "cwe": [
          "CWE-269: Improper Privilege Management"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration",
          "A06:2017 - Security Misconfiguration"
        ],
        "references": [
          "https://kubernetes.io/docs/reference/access-authn-authz/rbac/#role-and-clusterrole",
          "https://kubernetes.io/docs/concepts/security/rbac-good-practices/#general-good-practice",
          "https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.28/#api-groups"
        ],
        "category": "security",
        "technology": [
          "kubernetes"
        ],
        "cwe2021-top25": false,
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "HIGH",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Kubernetes ClusterRole with excessive core API permissions",
        "fix-suggestion": "Replace wildcard `*` permissions with explicit lists of required resources and verbs. Follow the principle of least privilege by granting only the specific permissions needed. Consider using multiple more granular roles instead of a single broadly scoped role to better isolate permissions."
      }
    },
    {
      "id": "yaml.kubernetes.security.privileged-container.privileged-container",
      "pattern-either": [
        {
          "patterns": [
            {
              "pattern-inside": "containers:\n  ...\n"
            },
            {
              "pattern": "image: ...\n...\nsecurityContext:\n  ...\n  privileged: true\n"
            }
          ]
        },
        {
          "patterns": [
            {
              "pattern-inside": "spec:\n  ...\n"
            },
            {
              "pattern-not-inside": "image: ...\n...\n"
            },
            {
              "pattern": "privileged: true\n"
            }
          ]
        }
      ],
      "message": "Kubernetes container runs in privileged mode, granting it full access to host resources and capabilities. Privileged containers essentially have the same access as processes running directly on the host. This completely bypasses container isolation and poses a significant security risk if compromised.",
      "metadata": {
        "cwe": [
          "CWE-250: Execution with Unnecessary Privileges"
        ],
        "references": [
          "https://kubernetes.io/docs/concepts/policy/pod-security-policy/#privileged",
          "https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
          "https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html"
        ],
        "category": "security",
        "technology": [
          "kubernetes"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Kubernetes container running in privileged mode",
        "fix-suggestion": "Remove the `privileged: true` setting from your container's `securityContext`. Grant only the specific capabilities needed using `capabilities.add` with minimum required permissions. Use alternative solutions like device plugins or init containers to handle operations that might have required privileged access."
      },
      "languages": [
        "yaml"
      ],
      "severity": "WARNING"
    },
    {
      "id": "yaml.kubernetes.security.run-as-non-root.run-as-non-root",
      "patterns": [
        {
          "pattern-inside": "$SPEC:\n  ...\n  containers:\n    ...\n  ...\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$SPEC",
            "regex": "^(spec)$"
          }
        },
        {
          "pattern-not-inside": "spec:\n  ...\n  securityContext:\n    ...\n  ...\n"
        },
        {
          "pattern-inside": "$SPEC:\n  ...\n  containers:\n    ...\n"
        },
        {
          "pattern-not-inside": "$SPEC:\n  ...\n  containers:\n    ...\n    - name: $NAME\n      image: ...\n      ...\n      securityContext:\n        ...\n        runAsNonRoot: $VALUE\n"
        },
        {
          "focus-metavariable": "$SPEC"
        }
      ],
      "fix": "$SPEC:\n  securityContext:\n    runAsNonRoot: true #\n",
      "message": "Kubernetes container is not explicitly configured to run as a non-root user. Containers running as root have unnecessary privileges that increase security risk if compromised. Running as root can lead to container escapes and host system access if combined with other vulnerabilities.",
      "metadata": {
        "references": [
          "https://kubernetes.io/blog/2016/08/security-best-practices-kubernetes-deployment/",
          "https://kubernetes.io/docs/concepts/policy/pod-security-policy/",
          "https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html#rule-2-set-a-user"
        ],
        "category": "security",
        "cwe": [
          "CWE-250: Execution with Unnecessary Privileges"
        ],
        "owasp": [
          "A05:2021 - Security Misconfiguration",
          "A06:2017 - Security Misconfiguration"
        ],
        "technology": [
          "kubernetes"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "LOW",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Kubernetes container missing non-root user enforcement",
        "fix-suggestion": "Add `runAsNonRoot: true` to the container's `securityContext` configuration. Set a specific non-zero user ID with `runAsUser: 1000` (or appropriate ID). Ensure your container image is designed to run as a non-root user by setting proper file permissions and avoiding privileged ports."
      },
      "languages": [
        "yaml"
      ],
      "severity": "INFO"
    },
    {
      "id": "yaml.kubernetes.security.seccomp-confinement-disabled.seccomp-confinement-disabled",
      "patterns": [
        {
          "pattern-inside": "containers:\n  ...\n"
        },
        {
          "pattern": "image: ...\n...\nsecurityContext:\n  ...\n  seccompProfile: unconfined\n"
        }
      ],
      "message": "Kubernetes container explicitly disables seccomp confinement with unconfined profile. Seccomp restricts the system calls that containers can make, providing an important security boundary. Disabling this protection exposes the host kernel to potential exploits through unrestricted system calls.",
      "metadata": {
        "cwe": [
          "CWE-284: Improper Access Control"
        ],
        "references": [
          "https://kubernetes.io/docs/concepts/policy/pod-security-policy/#seccomp",
          "https://kubernetes.io/docs/tasks/configure-pod-container/security-context/"
        ],
        "category": "security",
        "technology": [
          "kubernetes"
        ],
        "owasp": [
          "A05:2017 - Broken Access Control",
          "A01:2021 - Broken Access Control"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authorization"
        ],
        "short-description": "Kubernetes seccomp protection disabled",
        "fix-suggestion": "Remove `seccompProfile: type: Unconfined` from your security context configuration. Use the default seccomp profile or create a custom profile that allows only required system calls. Test your application with the default profile before considering custom profiles or disabling protection."
      },
      "languages": [
        "yaml"
      ],
      "severity": "WARNING"
    },
    {
      "id": "yaml.kubernetes.security.skip-tls-verify-cluster.skip-tls-verify-cluster",
      "pattern": "cluster:\n  ...\n  insecure-skip-tls-verify: true\n",
      "message": "Kubernetes cluster configuration disables TLS certificate verification with the server. This setting bypasses certificate validation, making HTTPS connections insecure and vulnerable to man-in-the-middle attacks. Skipping TLS verification removes an essential security layer that protects API server communications.",
      "metadata": {
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "references": [
          "https://kubernetes.io/docs/reference/config-api/client-authentication.v1beta1/#client-authentication-k8s-io-v1beta1-Cluster"
        ],
        "category": "security",
        "technology": [
          "kubernetes"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Kubernetes cluster skipping TLS verification",
        "fix-suggestion": "Remove `insecure-skip-tls-verify: true` from your cluster configuration. Properly configure trusted certificates for your Kubernetes API server. Use certificate authorities and proper certificate management instead of disabling verification to resolve certificate issues."
      },
      "languages": [
        "yaml"
      ],
      "severity": "WARNING"
    },
    {
      "id": "yaml.kubernetes.security.skip-tls-verify-service.skip-tls-verify-service",
      "pattern": "spec:\n  ...\n  insecureSkipTLSVerify: true\n",
      "message": "Kubernetes service configuration disables TLS certificate verification when communicating with external servers. This makes HTTPS connections vulnerable to eavesdropping and impersonation through man-in-the-middle attacks. Properly validated TLS is essential for secure communications with external services.",
      "metadata": {
        "cwe": [
          "CWE-319: Cleartext Transmission of Sensitive Information"
        ],
        "references": [
          "https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#apiservice-v1-apiregistration-k8s-io"
        ],
        "category": "security",
        "technology": [
          "kubernetes"
        ],
        "owasp": [
          "A03:2017 - Sensitive Data Exposure",
          "A02:2021 - Cryptographic Failures"
        ],
        "subcategory": [
          "vuln"
        ],
        "likelihood": "MEDIUM",
        "impact": "MEDIUM",
        "confidence": "MEDIUM",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Mishandled Sensitive Information"
        ],
        "short-description": "Kubernetes service skipping TLS verification",
        "fix-suggestion": "Remove `insecureSkipTLSVerify: true` from your service configuration. Properly configure trusted certificates and certificate authorities for external services. Implement proper certificate management instead of disabling verification to resolve certificate issues."
      },
      "languages": [
        "yaml"
      ],
      "severity": "WARNING"
    },
    {
      "id": "yaml.kubernetes.security.env.flask-debugging-enabled.flask-debugging-enabled",
      "languages": [
        "yaml"
      ],
      "severity": "WARNING",
      "message": "Flask application in Kubernetes has debugging enabled by setting FLASK_ENV to \"development\". Debug mode exposes sensitive information, allows code execution through the debugger, and reduces performance. Development environment settings should never be used in production deployments.",
      "metadata": {
        "owasp": "A06:2017 - Security Misconfiguration",
        "cwe": [
          "CWE-489: Active Debug Code"
        ],
        "references": [
          "https://flask.palletsprojects.com/en/2.0.x/debugging/",
          "https://flask.palletsprojects.com/en/2.0.x/config/#ENV"
        ],
        "category": "security",
        "technology": [
          "kubernetes",
          "flask"
        ],
        "subcategory": [
          "audit"
        ],
        "likelihood": "LOW",
        "impact": "MEDIUM",
        "confidence": "LOW",
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Active Debug Code"
        ],
        "short-description": "Flask debug mode enabled in Kubernetes",
        "fix-suggestion": "Change `FLASK_ENV` from `\"development\"` to `\"production\"` in your environment variables. Use `FLASK_DEBUG=0` to explicitly disable debugging. Create separate deployment configurations for development and production environments with appropriate settings for each context."
      },
      "patterns": [
        {
          "pattern-inside": "env: [...]\n"
        },
        {
          "pattern": "{name: FLASK_ENV, value: \"development\"}\n"
        }
      ],
      "fix-regex": {
        "regex": "development",
        "replacement": "dev"
      }
    },
    {
      "id": "yaml.openapi.security.openai-consequential-action-false.openai-consequential-action-false",
      "languages": [
        "yaml"
      ],
      "message": "OpenAPI specification marks state-changing methods as non-consequential, enabling 'Always Allow' option. This setting allows AI agents to perform these actions without user confirmation for each operation. State-changing operations like POST, PUT, PATCH, or DELETE could lead to unintended data modifications if automatically allowed.",
      "severity": "WARNING",
      "pattern-either": [
        {
          "pattern-inside": "post:\n  ...\n  x-openai-isConsequential: false\n"
        },
        {
          "pattern-inside": "put:\n  ...\n  x-openai-isConsequential: false\n"
        },
        {
          "pattern-inside": "patch:\n  ...\n  x-openai-isConsequential: false\n"
        },
        {
          "pattern-inside": "delete:\n  ...\n  x-openai-isConsequential: false\n"
        }
      ],
      "metadata": {
        "category": "security",
        "subcategory": [
          "audit"
        ],
        "technology": [
          "openapi",
          "openai"
        ],
        "likelihood": "HIGH",
        "impact": "HIGH",
        "confidence": "HIGH",
        "cwe": "CWE-441: Unintended Proxy or Intermediary ('Confused Deputy')",
        "owasp": [
          "A04:2021 Insecure Design",
          "LLM08:2023 - Excessive Agency"
        ],
        "references": [
          "https://platform.openai.com/docs/actions/consequential-flag",
          "https://owasp.org/Top10/A04_2021-Insecure_Design/",
          "https://owasp.org/www-project-top-10-for-large-language-model-applications/assets/PDF/OWASP-Top-10-for-LLMs-2023-v1_1.pdf"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Server-Side Request Forgery (SSRF)"
        ],
        "short-description": "State-changing API marked as non-consequential",
        "fix-suggestion": "Remove `x-openai-isConsequential: false` from state-changing HTTP methods in your OpenAPI specification. Set consequential status appropriately based on the risk of each operation. Consider implementing additional verification steps for sensitive operations that modify important data."
      }
    },
    {
      "id": "yaml.openapi.security.use-of-basic-authentication.use-of-basic-authentication",
      "languages": [
        "yaml"
      ],
      "message": "OpenAPI specification uses basic authentication, which has significant security weaknesses. Basic authentication transmits credentials in easily decoded base64 format with each request. Without additional transport security and proper credential management, this authentication method is vulnerable to credential theft.",
      "severity": "ERROR",
      "patterns": [
        {
          "pattern-inside": "openapi: $VERSION\n...\ncomponents:\n  ...\n  securitySchemes:\n    ...\n    $SCHEME:\n      ...\n"
        },
        {
          "metavariable-regex": {
            "metavariable": "$VERSION",
            "regex": "3.*"
          }
        },
        {
          "pattern": "type: http\n...\nscheme: basic\n"
        }
      ],
      "metadata": {
        "category": "security",
        "subcategory": [
          "vuln"
        ],
        "technology": [
          "openapi"
        ],
        "likelihood": "MEDIUM",
        "impact": "HIGH",
        "confidence": "HIGH",
        "cwe": "CWE-287: Improper Authentication",
        "owasp": [
          "A04:2021 Insecure Design",
          "A07:2021 Identification and Authentication Failures"
        ],
        "references": [
          "https://cwe.mitre.org/data/definitions/287.html",
          "https://owasp.org/Top10/A04_2021-Insecure_Design/",
          "https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/"
        ],
        "license": "Semgrep Rules License v1.0. For more details, visit semgrep.dev/legal/rules-license",
        "vulnerability_class": [
          "Improper Authentication"
        ],
        "short-description": "Weak basic authentication in API specification",
        "fix-suggestion": "Replace basic authentication with more secure alternatives like OAuth2 or OpenID Connect. Implement token-based authentication with proper expiration and refresh mechanisms. Consider mutual TLS (mTLS) for high-security scenarios requiring strong client authentication."
      }
    }
  ]
}