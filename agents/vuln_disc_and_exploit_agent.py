import sys
import os

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

from dotenv import load_dotenv

load_dotenv()


import json
import subprocess
import re
import logging
import requests
from bs4 import BeautifulSoup
from langgraph.prebuilt import create_react_agent
from langchain_core.prompts import PromptTemplate
from utils.print_utils import pretty_print_messages
from services.model_loader import load_model
from googlesearch import search
from langchain_community.tools import DuckDuckGoSearchRun


# --- Setup Logging ---
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# --- Constants ---
MAX_TOOL_RETRIES = 3
DEFAULT_NMAP_FLAGS = "-p- -v -T5"
PATH_TO_WORDLIST = "~/wordlists"
# --- Core Utilities ---


def run_cli_command(
    command: str, timeout: int = 180
) -> str:  # Increased timeout for Nmap
    """
    Executes a shell command and returns its output or an error message.
    """
    try:
        logger.info(f"Executing CLI: {command}")
        process = subprocess.run(
            command,
            shell=True,
            capture_output=True,
            text=True,
            timeout=timeout,
            check=False,  # Handle non-zero exit codes gracefully
        )
        if process.returncode == 0:
            # Some tools might print to stderr for informational messages,
            # but if returncode is 0, we primarily care about stdout.
            # However, nmap sometimes prints useful info to stderr even on success.
            # For simplicity now, we'll stick to stdout on success.
            # If a command specifically needs stderr too, this could be adjusted.
            return process.stdout.strip()
        else:
            # Combine stdout and stderr for more context on errors
            output = (process.stdout.strip() + "\n" + process.stderr.strip()).strip()
            # Nmap might return non-zero if e.g. host is down but -Pn is not used,
            # or other specific nmap errors.
            return f"Error (code {process.returncode}): {output}"
    except subprocess.TimeoutExpired:
        logger.error(f"Command timed out after {timeout}s: {command}")
        return f"Error: Command timed out after {timeout}s."
    except Exception as e:
        logger.error(f"Error executing command '{command}': {e}")
        return f"Error: Exception - {e}"


# --- Simplified Tool Functions ---
def searchsploit_tool(query: str) -> str:
    """
    Run searchsploit with a given query (e.g., CVE ID or keyword like 'Apache 2.4.50').
    This tool helps find known exploits from the Exploit-DB database.
    """
    logger.info(f"ðŸ” Running searchsploit for: {query}\n")
    try:
        # It's good practice to sanitize or validate the query if it's directly from user input,
        # but searchsploit itself is generally safe with varied string inputs.
        return run_cli_command(f"searchsploit {query}")
    except FileNotFoundError:
        return "âŒ Error: searchsploit not found. Make sure it's installed and in your PATH."
    except Exception as e:
        logger.error(f"Error in searchsploit_tool: {e}")
        return f"âŒ Error executing searchsploit: {e}"


def google_scrape(url):
    response = requests.get(url, timeout=10)
    response.raise_for_status()
    soup = BeautifulSoup(response.text, "html.parser")
    if soup is None or soup.title is None or soup.title.text is None:
        return "No title found"
    return soup.title.text


def web_exploit_search_tool(search_term: str) -> str:
    """
    Searches the web using Google for exploits and security information related to the search term.
    Input should be a specific search query, e.g., 'Grafana V11 CVE github poc' or 'WordPress File Upload Vulnerability CVE' if searching for CVE.
    Returns a list of page titles and urls from the search results.
    """
    print(f"Web searching for exploits: {search_term}")
    results = []
    for i, url in enumerate(search(search_term)):
        a = google_scrape(url)
        print(str(i) + ". " + a)
        print(url)
        print(" ")
        results.append(a)
    return results


def web_general_search_tool(search_term: str) -> str:
    """
    Searches the web using Google for general information related to the search term to gather more information about the vulnerability.
    """
    try:
        search = DuckDuckGoSearchRun()
        return search.invoke(search_term)
    except Exception as e:
        logger.error(f"Error in web_general_search_tool: {e}")
        return f"Error performing web search: {str(e)}"


use_openai = "OPENAI_API_KEY" in os.environ and bool(os.environ["OPENAI_API_KEY"])
model = load_model(use_openai=False)

vuln_disc_and_exploit_agent = create_react_agent(
    model=model,
    tools=[searchsploit_tool, web_exploit_search_tool, web_general_search_tool],
    prompt="""
You are a specialized AI Penetration Testing Assistant. Your role is to help users find and understand security vulnerabilities in their target systems.

**IMPORTANT:** Only test systems you have explicit written permission for.

**AVAILABLE TOOLS:**
- `searchsploit_tool`: Search Exploit-DB for known exploits
- `web_exploit_search_tool`: Search web for additional CVEs and PoCs. If searching for CVE you should include cve github poc in search query.
- `web_general_search_tool`: Search web for general information related to the search term to gather more information about the vulnerability.

**WORKFLOW:**
1. Get target information:
   - Target URL/IP
   - Technology stack
   - Permission confirmation

2. Search for vulnerabilities:
   - Use searchsploit_tool to find known exploits
   - Use web_exploit_search_tool to find related CVEs
   - Use web_general_search_tool to gather more information about the vulnerability if needed,
   - Analyze results and provide actionable advice.

3. Guide next steps:
   - Suggest specific recommendations based on findings
   - Provide commands and techniques to try
   - Help interpret results
""",
    name="Vulnerability Discovery and Exploit Agent",
)

# --- Example Usage ---
if __name__ == "__main__":
    # Example target (replace with your own)
    # target = "http://ffuf.me" # Initial target can be set or asked

    # Initialize message history
    message_history = []

    print("Vulnerability Discovery and Exploit Agent")
    print("Type 'exit' or 'quit' to end the session.")
    print("--------------------------------------------")

    initial_prompt = input(
        "Given the target and related information like technology stack, permission confirmation, etc. Please provide a detailed description of the target system and the vulnerability you are trying to exploit: "
    )
    if initial_prompt.lower() in ["exit", "quit"]:
        print("Exiting.")
        exit()

    message_history.append({"role": "user", "content": initial_prompt})

    while True:
        print("\n--- Agent Response ---")
        full_response = ""
        for chunk in vuln_disc_and_exploit_agent.stream({"messages": message_history}):
            pretty_print_messages(chunk)

        print()  # Newline after agent's full response

        if full_response:  # Add agent's full response to history
            message_history.append({"role": "assistant", "content": full_response})

        user_input = input("\nYour response: ")
        if user_input.lower() in ["exit", "quit"]:
            print("Exiting.")
            break

        message_history.append({"role": "user", "content": user_input})
